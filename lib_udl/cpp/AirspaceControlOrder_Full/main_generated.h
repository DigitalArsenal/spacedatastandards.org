// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AirspaceControlOrder_Full;
struct AirspaceControlOrder_FullBuilder;

enum AirspaceControlOrder_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  AirspaceControlOrder_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  AirspaceControlOrder_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  AirspaceControlOrder_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  AirspaceControlOrder_Full_dataMode_Enum_EXERCISE = 3,
  AirspaceControlOrder_Full_dataMode_Enum_MIN = AirspaceControlOrder_Full_dataMode_Enum_REAL,
  AirspaceControlOrder_Full_dataMode_Enum_MAX = AirspaceControlOrder_Full_dataMode_Enum_EXERCISE
};

inline const AirspaceControlOrder_Full_dataMode_Enum (&EnumValuesAirspaceControlOrder_Full_dataMode_Enum())[4] {
  static const AirspaceControlOrder_Full_dataMode_Enum values[] = {
    AirspaceControlOrder_Full_dataMode_Enum_REAL,
    AirspaceControlOrder_Full_dataMode_Enum_TEST,
    AirspaceControlOrder_Full_dataMode_Enum_SIMULATED,
    AirspaceControlOrder_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesAirspaceControlOrder_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAirspaceControlOrder_Full_dataMode_Enum(AirspaceControlOrder_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, AirspaceControlOrder_Full_dataMode_Enum_REAL, AirspaceControlOrder_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAirspaceControlOrder_Full_dataMode_Enum()[index];
}

/// /// Beta Version Airspace Control Order: Contains airspace coordination information and instructions that have been issued by an airspace control authority.
struct AirspaceControlOrder_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AirspaceControlOrder_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_RAWFILEURI = 8,
    VT_OPEXNAME = 10,
    VT_ORIGINATOR = 12,
    VT_STARTTIME = 14,
    VT_STOPTIME = 16,
    VT_STOPQUALIFIER = 18,
    VT_OPEXINFO = 20,
    VT_OPEXINFOALT = 22,
    VT_PLANORIGNUM = 24,
    VT_SERIALNUM = 26,
    VT_MONTH = 28,
    VT_QUALIFIER = 30,
    VT_QUALSN = 32,
    VT_AREAOFVALIDITY = 34,
    VT_ACOSERIALNUM = 36,
    VT_GEODATUM = 38,
    VT_ACOCOMMENTS = 40,
    VT_AIRSPACECONTROLORDERREFERENCES = 42,
    VT_AIRSPACECONTROLMEANSSTATUS = 44,
    VT_UNDLNKTRK = 46,
    VT_CLASSSOURCE = 48,
    VT_CLASSREASON = 50,
    VT_DOWNGRADEINSDATE = 52,
    VT_DECLASSEXEMPTIONCODE = 54,
    VT_CREATEDAT = 56,
    VT_CREATEDBY = 58,
    VT_SOURCEDL = 60,
    VT_SOURCE = 62,
    VT_ORIGIN = 64,
    VT_ORIGNETWORK = 66,
    VT_DATAMODE = 68
  };
  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: c44b0a80-9fef-63d9-6267-79037fb93e4c
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: EXAMPLE URI
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *rawFileURI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWFILEURI);
  }
  /// Specifies the code name or nickname assigned to a joint exercise or plan to designate message traffic.
  /// Example: /// Example: DESERT WIND
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *opExName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPEXNAME);
  }
  /// The originator of this reference.
  /// Example: /// Example: USCENTCOM
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *originator() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR);
  }
  /// The start of the effective time period of this airspace control order, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-07T13:55:43.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *startTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STARTTIME);
  }
  /// The end of the effective time period of this airspace control order, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-08T13:55:43.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *stopTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOPTIME);
  }
  /// A qualifier for the end of the effective time period of this airspace control order, such as AFTER, ASOF, NLT, etc. Used with field stopTime to indicate a relative time.
  /// Example: /// Example: AFTER
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *stopQualifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOPQUALIFIER);
  }
  /// Supplementary name that can be used to further identify exercise nicknames, or to provide the primary nickname of the option or the alternative of an operational plan.
  /// Example: /// Example: CONTROL
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *opExInfo() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPEXINFO);
  }
  /// The secondary supplementary nickname of the option or the alternative of the operational plan or order.
  /// Example: /// Example: ORANGE
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *opExInfoAlt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPEXINFOALT);
  }
  /// The official identifier of the military establishment responsible for the operation plan and the identification number assigned to this plan.
  /// Example: /// Example: SACEUR 106
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *planOrigNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLANORIGNUM);
  }
  /// The unique message identifier sequentially assigned by the originator.
  /// Example: /// Example: 1201003
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *serialNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SERIALNUM);
  }
  /// The month in which the message originated.
  /// Example: /// Example: OCT
  /// Constraints: Minimum length = 0, Maximum length = 12
  const ::flatbuffers::String *month() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MONTH);
  }
  /// The qualifier which caveats the message status.
  /// Example: /// Example: CHG
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *qualifier() const {
    return GetPointer<const ::flatbuffers::String *>(VT_QUALIFIER);
  }
  /// The serial number associated with the message qualifier.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t qualSN() const {
    return GetField<int32_t>(VT_QUALSN, 0);
  }
  /// Name of the area of the command for which the ACO is valid.
  /// Example: /// Example: FORT BRAGG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *areaOfValidity() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AREAOFVALIDITY);
  }
  /// The serial number of this airspace control order.
  /// Example: /// Example: 27B
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *acoSerialNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACOSERIALNUM);
  }
  /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated.
  /// Example: /// Example: EUR-T
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *geoDatum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEODATUM);
  }
  /// Free text information expressed in natural language.
  /// Example: /// Example: CHOKE POINTS
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *acoComments() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACOCOMMENTS);
  }
  /// The airspaceControlReferences set provides both USMTF and non-USMTF references for this airspace control order.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceControlOrderReferences() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AIRSPACECONTROLORDERREFERENCES);
  }
  /// Mandatory nested segment to report multiple airspace control means statuses within an ACOID.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceControlMeansStatus() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AIRSPACECONTROLMEANSSTATUS);
  }
  /// Collection of unique link 16 identifier that will be assigned to a future airspace control means.
  /// Example: /// Example: ['A2467', 'A3466', 'AA232']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *undLnkTrk() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_UNDLNKTRK);
  }
  /// Markings defining the source material or the original classification authority for the ACO message.
  /// Example: /// Example: ORIG:USJFCOM
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *classSource() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSSOURCE);
  }
  /// Mandatory if classSource uses the "IORIG" designator. Must be a REASON FOR CLASSIFICATION code.
  /// Example: /// Example: ['15C', '10C']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *classReason() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CLASSREASON);
  }
  /// Markings providing the literal guidance or date for downgrading or declassifying the airspace control order. Manditory if declassExemptionCode is nul.
  /// Example: /// Example: ['NST:AT EXERCISE ENDEX', 'DATE:25NOV1997']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *downgradeInsDate() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DOWNGRADEINSDATE);
  }
  /// Coded entries that provide justification for exemption from automatic downgrading or declassification of the airspace control order.
  /// Example: /// Example: ['X1', 'X2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *declassExemptionCode() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DECLASSEXEMPTIONCODE);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  AirspaceControlOrder_Full_dataMode_Enum dataMode() const {
    return static_cast<AirspaceControlOrder_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_RAWFILEURI) &&
           verifier.VerifyString(rawFileURI()) &&
           VerifyOffset(verifier, VT_OPEXNAME) &&
           verifier.VerifyString(opExName()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(originator()) &&
           VerifyOffset(verifier, VT_STARTTIME) &&
           verifier.VerifyString(startTime()) &&
           VerifyOffset(verifier, VT_STOPTIME) &&
           verifier.VerifyString(stopTime()) &&
           VerifyOffset(verifier, VT_STOPQUALIFIER) &&
           verifier.VerifyString(stopQualifier()) &&
           VerifyOffset(verifier, VT_OPEXINFO) &&
           verifier.VerifyString(opExInfo()) &&
           VerifyOffset(verifier, VT_OPEXINFOALT) &&
           verifier.VerifyString(opExInfoAlt()) &&
           VerifyOffset(verifier, VT_PLANORIGNUM) &&
           verifier.VerifyString(planOrigNum()) &&
           VerifyOffset(verifier, VT_SERIALNUM) &&
           verifier.VerifyString(serialNum()) &&
           VerifyOffset(verifier, VT_MONTH) &&
           verifier.VerifyString(month()) &&
           VerifyOffset(verifier, VT_QUALIFIER) &&
           verifier.VerifyString(qualifier()) &&
           VerifyField<int32_t>(verifier, VT_QUALSN, 4) &&
           VerifyOffset(verifier, VT_AREAOFVALIDITY) &&
           verifier.VerifyString(areaOfValidity()) &&
           VerifyOffset(verifier, VT_ACOSERIALNUM) &&
           verifier.VerifyString(acoSerialNum()) &&
           VerifyOffset(verifier, VT_GEODATUM) &&
           verifier.VerifyString(geoDatum()) &&
           VerifyOffset(verifier, VT_ACOCOMMENTS) &&
           verifier.VerifyString(acoComments()) &&
           VerifyOffset(verifier, VT_AIRSPACECONTROLORDERREFERENCES) &&
           verifier.VerifyVector(airspaceControlOrderReferences()) &&
           verifier.VerifyVectorOfStrings(airspaceControlOrderReferences()) &&
           VerifyOffset(verifier, VT_AIRSPACECONTROLMEANSSTATUS) &&
           verifier.VerifyVector(airspaceControlMeansStatus()) &&
           verifier.VerifyVectorOfStrings(airspaceControlMeansStatus()) &&
           VerifyOffset(verifier, VT_UNDLNKTRK) &&
           verifier.VerifyVector(undLnkTrk()) &&
           verifier.VerifyVectorOfStrings(undLnkTrk()) &&
           VerifyOffset(verifier, VT_CLASSSOURCE) &&
           verifier.VerifyString(classSource()) &&
           VerifyOffset(verifier, VT_CLASSREASON) &&
           verifier.VerifyVector(classReason()) &&
           verifier.VerifyVectorOfStrings(classReason()) &&
           VerifyOffset(verifier, VT_DOWNGRADEINSDATE) &&
           verifier.VerifyVector(downgradeInsDate()) &&
           verifier.VerifyVectorOfStrings(downgradeInsDate()) &&
           VerifyOffset(verifier, VT_DECLASSEXEMPTIONCODE) &&
           verifier.VerifyVector(declassExemptionCode()) &&
           verifier.VerifyVectorOfStrings(declassExemptionCode()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct AirspaceControlOrder_FullBuilder {
  typedef AirspaceControlOrder_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_rawFileURI(::flatbuffers::Offset<::flatbuffers::String> rawFileURI) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_RAWFILEURI, rawFileURI);
  }
  void add_opExName(::flatbuffers::Offset<::flatbuffers::String> opExName) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_OPEXNAME, opExName);
  }
  void add_originator(::flatbuffers::Offset<::flatbuffers::String> originator) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_ORIGINATOR, originator);
  }
  void add_startTime(::flatbuffers::Offset<::flatbuffers::String> startTime) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_STARTTIME, startTime);
  }
  void add_stopTime(::flatbuffers::Offset<::flatbuffers::String> stopTime) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_STOPTIME, stopTime);
  }
  void add_stopQualifier(::flatbuffers::Offset<::flatbuffers::String> stopQualifier) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_STOPQUALIFIER, stopQualifier);
  }
  void add_opExInfo(::flatbuffers::Offset<::flatbuffers::String> opExInfo) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_OPEXINFO, opExInfo);
  }
  void add_opExInfoAlt(::flatbuffers::Offset<::flatbuffers::String> opExInfoAlt) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_OPEXINFOALT, opExInfoAlt);
  }
  void add_planOrigNum(::flatbuffers::Offset<::flatbuffers::String> planOrigNum) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_PLANORIGNUM, planOrigNum);
  }
  void add_serialNum(::flatbuffers::Offset<::flatbuffers::String> serialNum) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_SERIALNUM, serialNum);
  }
  void add_month(::flatbuffers::Offset<::flatbuffers::String> month) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_MONTH, month);
  }
  void add_qualifier(::flatbuffers::Offset<::flatbuffers::String> qualifier) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_QUALIFIER, qualifier);
  }
  void add_qualSN(int32_t qualSN) {
    fbb_.AddElement<int32_t>(AirspaceControlOrder_Full::VT_QUALSN, qualSN, 0);
  }
  void add_areaOfValidity(::flatbuffers::Offset<::flatbuffers::String> areaOfValidity) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_AREAOFVALIDITY, areaOfValidity);
  }
  void add_acoSerialNum(::flatbuffers::Offset<::flatbuffers::String> acoSerialNum) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_ACOSERIALNUM, acoSerialNum);
  }
  void add_geoDatum(::flatbuffers::Offset<::flatbuffers::String> geoDatum) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_GEODATUM, geoDatum);
  }
  void add_acoComments(::flatbuffers::Offset<::flatbuffers::String> acoComments) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_ACOCOMMENTS, acoComments);
  }
  void add_airspaceControlOrderReferences(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceControlOrderReferences) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_AIRSPACECONTROLORDERREFERENCES, airspaceControlOrderReferences);
  }
  void add_airspaceControlMeansStatus(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceControlMeansStatus) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_AIRSPACECONTROLMEANSSTATUS, airspaceControlMeansStatus);
  }
  void add_undLnkTrk(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> undLnkTrk) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_UNDLNKTRK, undLnkTrk);
  }
  void add_classSource(::flatbuffers::Offset<::flatbuffers::String> classSource) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_CLASSSOURCE, classSource);
  }
  void add_classReason(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> classReason) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_CLASSREASON, classReason);
  }
  void add_downgradeInsDate(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> downgradeInsDate) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_DOWNGRADEINSDATE, downgradeInsDate);
  }
  void add_declassExemptionCode(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> declassExemptionCode) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_DECLASSEXEMPTIONCODE, declassExemptionCode);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_CREATEDBY, createdBy);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_SOURCEDL, sourceDL);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(AirspaceControlOrder_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(AirspaceControlOrder_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(AirspaceControlOrder_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit AirspaceControlOrder_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AirspaceControlOrder_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AirspaceControlOrder_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AirspaceControlOrder_Full> CreateAirspaceControlOrder_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rawFileURI = 0,
    ::flatbuffers::Offset<::flatbuffers::String> opExName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> originator = 0,
    ::flatbuffers::Offset<::flatbuffers::String> startTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stopTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stopQualifier = 0,
    ::flatbuffers::Offset<::flatbuffers::String> opExInfo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> opExInfoAlt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> planOrigNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> serialNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> month = 0,
    ::flatbuffers::Offset<::flatbuffers::String> qualifier = 0,
    int32_t qualSN = 0,
    ::flatbuffers::Offset<::flatbuffers::String> areaOfValidity = 0,
    ::flatbuffers::Offset<::flatbuffers::String> acoSerialNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> geoDatum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> acoComments = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceControlOrderReferences = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> airspaceControlMeansStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> undLnkTrk = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classSource = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> classReason = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> downgradeInsDate = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> declassExemptionCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    AirspaceControlOrder_Full_dataMode_Enum dataMode = AirspaceControlOrder_Full_dataMode_Enum_REAL) {
  AirspaceControlOrder_FullBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_sourceDL(sourceDL);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_declassExemptionCode(declassExemptionCode);
  builder_.add_downgradeInsDate(downgradeInsDate);
  builder_.add_classReason(classReason);
  builder_.add_classSource(classSource);
  builder_.add_undLnkTrk(undLnkTrk);
  builder_.add_airspaceControlMeansStatus(airspaceControlMeansStatus);
  builder_.add_airspaceControlOrderReferences(airspaceControlOrderReferences);
  builder_.add_acoComments(acoComments);
  builder_.add_geoDatum(geoDatum);
  builder_.add_acoSerialNum(acoSerialNum);
  builder_.add_areaOfValidity(areaOfValidity);
  builder_.add_qualSN(qualSN);
  builder_.add_qualifier(qualifier);
  builder_.add_month(month);
  builder_.add_serialNum(serialNum);
  builder_.add_planOrigNum(planOrigNum);
  builder_.add_opExInfoAlt(opExInfoAlt);
  builder_.add_opExInfo(opExInfo);
  builder_.add_stopQualifier(stopQualifier);
  builder_.add_stopTime(stopTime);
  builder_.add_startTime(startTime);
  builder_.add_originator(originator);
  builder_.add_opExName(opExName);
  builder_.add_rawFileURI(rawFileURI);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AirspaceControlOrder_Full> CreateAirspaceControlOrder_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *rawFileURI = nullptr,
    const char *opExName = nullptr,
    const char *originator = nullptr,
    const char *startTime = nullptr,
    const char *stopTime = nullptr,
    const char *stopQualifier = nullptr,
    const char *opExInfo = nullptr,
    const char *opExInfoAlt = nullptr,
    const char *planOrigNum = nullptr,
    const char *serialNum = nullptr,
    const char *month = nullptr,
    const char *qualifier = nullptr,
    int32_t qualSN = 0,
    const char *areaOfValidity = nullptr,
    const char *acoSerialNum = nullptr,
    const char *geoDatum = nullptr,
    const char *acoComments = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceControlOrderReferences = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *airspaceControlMeansStatus = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *undLnkTrk = nullptr,
    const char *classSource = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *classReason = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *downgradeInsDate = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *declassExemptionCode = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *sourceDL = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    AirspaceControlOrder_Full_dataMode_Enum dataMode = AirspaceControlOrder_Full_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto rawFileURI__ = rawFileURI ? _fbb.CreateString(rawFileURI) : 0;
  auto opExName__ = opExName ? _fbb.CreateString(opExName) : 0;
  auto originator__ = originator ? _fbb.CreateString(originator) : 0;
  auto startTime__ = startTime ? _fbb.CreateString(startTime) : 0;
  auto stopTime__ = stopTime ? _fbb.CreateString(stopTime) : 0;
  auto stopQualifier__ = stopQualifier ? _fbb.CreateString(stopQualifier) : 0;
  auto opExInfo__ = opExInfo ? _fbb.CreateString(opExInfo) : 0;
  auto opExInfoAlt__ = opExInfoAlt ? _fbb.CreateString(opExInfoAlt) : 0;
  auto planOrigNum__ = planOrigNum ? _fbb.CreateString(planOrigNum) : 0;
  auto serialNum__ = serialNum ? _fbb.CreateString(serialNum) : 0;
  auto month__ = month ? _fbb.CreateString(month) : 0;
  auto qualifier__ = qualifier ? _fbb.CreateString(qualifier) : 0;
  auto areaOfValidity__ = areaOfValidity ? _fbb.CreateString(areaOfValidity) : 0;
  auto acoSerialNum__ = acoSerialNum ? _fbb.CreateString(acoSerialNum) : 0;
  auto geoDatum__ = geoDatum ? _fbb.CreateString(geoDatum) : 0;
  auto acoComments__ = acoComments ? _fbb.CreateString(acoComments) : 0;
  auto airspaceControlOrderReferences__ = airspaceControlOrderReferences ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*airspaceControlOrderReferences) : 0;
  auto airspaceControlMeansStatus__ = airspaceControlMeansStatus ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*airspaceControlMeansStatus) : 0;
  auto undLnkTrk__ = undLnkTrk ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*undLnkTrk) : 0;
  auto classSource__ = classSource ? _fbb.CreateString(classSource) : 0;
  auto classReason__ = classReason ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*classReason) : 0;
  auto downgradeInsDate__ = downgradeInsDate ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*downgradeInsDate) : 0;
  auto declassExemptionCode__ = declassExemptionCode ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*declassExemptionCode) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateAirspaceControlOrder_Full(
      _fbb,
      id__,
      classificationMarking__,
      rawFileURI__,
      opExName__,
      originator__,
      startTime__,
      stopTime__,
      stopQualifier__,
      opExInfo__,
      opExInfoAlt__,
      planOrigNum__,
      serialNum__,
      month__,
      qualifier__,
      qualSN,
      areaOfValidity__,
      acoSerialNum__,
      geoDatum__,
      acoComments__,
      airspaceControlOrderReferences__,
      airspaceControlMeansStatus__,
      undLnkTrk__,
      classSource__,
      classReason__,
      downgradeInsDate__,
      declassExemptionCode__,
      createdAt__,
      createdBy__,
      sourceDL__,
      source__,
      origin__,
      origNetwork__,
      dataMode);
}

inline const AirspaceControlOrder_Full *GetAirspaceControlOrder_Full(const void *buf) {
  return ::flatbuffers::GetRoot<AirspaceControlOrder_Full>(buf);
}

inline const AirspaceControlOrder_Full *GetSizePrefixedAirspaceControlOrder_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AirspaceControlOrder_Full>(buf);
}

inline const char *AirspaceControlOrder_FullIdentifier() {
  return "AIRS";
}

inline bool AirspaceControlOrder_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirspaceControlOrder_FullIdentifier());
}

inline bool SizePrefixedAirspaceControlOrder_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirspaceControlOrder_FullIdentifier(), true);
}

inline bool VerifyAirspaceControlOrder_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AirspaceControlOrder_Full>(AirspaceControlOrder_FullIdentifier());
}

inline bool VerifySizePrefixedAirspaceControlOrder_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AirspaceControlOrder_Full>(AirspaceControlOrder_FullIdentifier());
}

inline void FinishAirspaceControlOrder_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirspaceControlOrder_Full> root) {
  fbb.Finish(root, AirspaceControlOrder_FullIdentifier());
}

inline void FinishSizePrefixedAirspaceControlOrder_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirspaceControlOrder_Full> root) {
  fbb.FinishSizePrefixed(root, AirspaceControlOrder_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
