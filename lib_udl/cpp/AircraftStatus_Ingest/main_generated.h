// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AircraftStatus_Ingest;
struct AircraftStatus_IngestBuilder;

enum AircraftStatus_Ingest_airToAirStatus_Enum : int8_t {
  /// No description available.
  AircraftStatus_Ingest_airToAirStatus_Enum_OPERATIONAL = 0,
  /// No description available.
  AircraftStatus_Ingest_airToAirStatus_Enum_NON_OPERATIONAL = 1,
  /// No description available.
  AircraftStatus_Ingest_airToAirStatus_Enum_OFF = 2,
  AircraftStatus_Ingest_airToAirStatus_Enum_MIN = AircraftStatus_Ingest_airToAirStatus_Enum_OPERATIONAL,
  AircraftStatus_Ingest_airToAirStatus_Enum_MAX = AircraftStatus_Ingest_airToAirStatus_Enum_OFF
};

inline const AircraftStatus_Ingest_airToAirStatus_Enum (&EnumValuesAircraftStatus_Ingest_airToAirStatus_Enum())[3] {
  static const AircraftStatus_Ingest_airToAirStatus_Enum values[] = {
    AircraftStatus_Ingest_airToAirStatus_Enum_OPERATIONAL,
    AircraftStatus_Ingest_airToAirStatus_Enum_NON_OPERATIONAL,
    AircraftStatus_Ingest_airToAirStatus_Enum_OFF
  };
  return values;
}

inline const char * const *EnumNamesAircraftStatus_Ingest_airToAirStatus_Enum() {
  static const char * const names[4] = {
    "OPERATIONAL",
    "NON_OPERATIONAL",
    "OFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameAircraftStatus_Ingest_airToAirStatus_Enum(AircraftStatus_Ingest_airToAirStatus_Enum e) {
  if (::flatbuffers::IsOutRange(e, AircraftStatus_Ingest_airToAirStatus_Enum_OPERATIONAL, AircraftStatus_Ingest_airToAirStatus_Enum_OFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAircraftStatus_Ingest_airToAirStatus_Enum()[index];
}

enum AircraftStatus_Ingest_airToGroundStatus_Enum : int8_t {
  /// No description available.
  AircraftStatus_Ingest_airToGroundStatus_Enum_OPERATIONAL = 0,
  /// No description available.
  AircraftStatus_Ingest_airToGroundStatus_Enum_NON_OPERATIONAL = 1,
  /// No description available.
  AircraftStatus_Ingest_airToGroundStatus_Enum_OFF = 2,
  AircraftStatus_Ingest_airToGroundStatus_Enum_MIN = AircraftStatus_Ingest_airToGroundStatus_Enum_OPERATIONAL,
  AircraftStatus_Ingest_airToGroundStatus_Enum_MAX = AircraftStatus_Ingest_airToGroundStatus_Enum_OFF
};

inline const AircraftStatus_Ingest_airToGroundStatus_Enum (&EnumValuesAircraftStatus_Ingest_airToGroundStatus_Enum())[3] {
  static const AircraftStatus_Ingest_airToGroundStatus_Enum values[] = {
    AircraftStatus_Ingest_airToGroundStatus_Enum_OPERATIONAL,
    AircraftStatus_Ingest_airToGroundStatus_Enum_NON_OPERATIONAL,
    AircraftStatus_Ingest_airToGroundStatus_Enum_OFF
  };
  return values;
}

inline const char * const *EnumNamesAircraftStatus_Ingest_airToGroundStatus_Enum() {
  static const char * const names[4] = {
    "OPERATIONAL",
    "NON_OPERATIONAL",
    "OFF",
    nullptr
  };
  return names;
}

inline const char *EnumNameAircraftStatus_Ingest_airToGroundStatus_Enum(AircraftStatus_Ingest_airToGroundStatus_Enum e) {
  if (::flatbuffers::IsOutRange(e, AircraftStatus_Ingest_airToGroundStatus_Enum_OPERATIONAL, AircraftStatus_Ingest_airToGroundStatus_Enum_OFF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAircraftStatus_Ingest_airToGroundStatus_Enum()[index];
}

enum AircraftStatus_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  AircraftStatus_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  AircraftStatus_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  AircraftStatus_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  AircraftStatus_Ingest_dataMode_Enum_EXERCISE = 3,
  AircraftStatus_Ingest_dataMode_Enum_MIN = AircraftStatus_Ingest_dataMode_Enum_REAL,
  AircraftStatus_Ingest_dataMode_Enum_MAX = AircraftStatus_Ingest_dataMode_Enum_EXERCISE
};

inline const AircraftStatus_Ingest_dataMode_Enum (&EnumValuesAircraftStatus_Ingest_dataMode_Enum())[4] {
  static const AircraftStatus_Ingest_dataMode_Enum values[] = {
    AircraftStatus_Ingest_dataMode_Enum_REAL,
    AircraftStatus_Ingest_dataMode_Enum_TEST,
    AircraftStatus_Ingest_dataMode_Enum_SIMULATED,
    AircraftStatus_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesAircraftStatus_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAircraftStatus_Ingest_dataMode_Enum(AircraftStatus_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, AircraftStatus_Ingest_dataMode_Enum_REAL, AircraftStatus_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAircraftStatus_Ingest_dataMode_Enum()[index];
}

/// /// Aircraft readiness and status data. Contains the dynamic data associated with the specific aircraft status, either in-flight or on-ground, including remaining fuel, mission readiness, and inventory, etc.
struct AircraftStatus_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AircraftStatus_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDAIRCRAFT = 8,
    VT_ALTAIRCRAFTID = 10,
    VT_CURRENTSTATE = 12,
    VT_IDAIRFIELD = 14,
    VT_GEOLOC = 16,
    VT_PREVIOUSICAO = 18,
    VT_CURRENTICAO = 20,
    VT_NEXTICAO = 22,
    VT_FLIGHTPHASE = 24,
    VT_TASTARTTIME = 26,
    VT_EARLIESTTAENDTIME = 28,
    VT_MISSIONREADINESS = 30,
    VT_FUEL = 32,
    VT_FUELFUNCTION = 34,
    VT_GUNCAPABLE = 36,
    VT_GUNRDSTYPE = 38,
    VT_GUNRDSMIN = 40,
    VT_GUNRDSMAX = 42,
    VT_AIRTOAIRSTATUS = 44,
    VT_AIRTOGROUNDSTATUS = 46,
    VT_INVENTORY = 48,
    VT_INVENTORYMIN = 50,
    VT_INVENTORYMAX = 52,
    VT_UNAVAILABLESYS = 54,
    VT_ADDITIONALSYS = 56,
    VT_NOTES = 58,
    VT_MXREMARK = 60,
    VT_MAINTSTATUS = 62,
    VT_MAINTSTATUSDRIVER = 64,
    VT_MAINTPRIORITY = 66,
    VT_ALPHASTATUSCODE = 68,
    VT_MAINTSTATUSUPDATE = 70,
    VT_LASTINSPECTIONDATE = 72,
    VT_MAINTPOC = 74,
    VT_GROUNDSTATUS = 76,
    VT_CONTAMINATIONSTATUS = 78,
    VT_FUELSTATUS = 80,
    VT_LASTUPDATEDBY = 82,
    VT_TROUBLESHOOTETIC = 84,
    VT_ETIC = 86,
    VT_PARKLOCATION = 88,
    VT_PARKLOCATIONSYSTEM = 90,
    VT_IDPOI = 92,
    VT_CREATEDAT = 94,
    VT_CREATEDBY = 96,
    VT_SOURCEDL = 98,
    VT_SOURCE = 100,
    VT_ORIGIN = 102,
    VT_DATAMODE = 104,
    VT_ORIGNETWORK = 106
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 0167f577-e06c-358e-85aa-0a07a730bdd0
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the aircraft.
  /// Example: /// Example: 29232269-e4c2-45c9-aa21-039a33209340
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idAircraft() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDAIRCRAFT);
  }
  /// Alternate Aircraft Identifier provided by source.
  /// Example: /// Example: ORIG-AIRCRAFT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *altAircraftId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALTAIRCRAFTID);
  }
  /// The current readiness state of the aircraft (e.g. AIRBORNE, ALERTCOCKED, AVAILABLE, BATTLESTATION, RUNWAY ALERT, SUITUP).
  /// Example: /// Example: AVAILABLE
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *currentState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENTSTATE);
  }
  /// If not airborne, the unique identifier of the installation currently hosting the aircraft.
  /// Example: /// Example: b89430e3-97d9-408c-9c89-fd3840c4b84d
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idAirfield() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDAIRFIELD);
  }
  /// US Air Force geographic location code of the airfield where the aircraft is located.
  /// Example: /// Example: AJJY
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *geoLoc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOLOC);
  }
  /// The International Civil Aviation Organization (ICAO) code at which this aircraft was previously located.
  /// Example: /// Example: EGLL
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *previousICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PREVIOUSICAO);
  }
  /// The International Civil Aviation Organization (ICAO) code at which this aircraft is currently located or has most recently departed, if airborne.
  /// Example: /// Example: KCHS
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *currentICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENTICAO);
  }
  /// The International Civil Aviation Organization (ICAO) code of the next destination of this aircraft.
  /// Example: /// Example: PHNL
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *nextICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEXTICAO);
  }
  /// Current flight phase (e.g. AIR REFUELING, GROUND, LANDING, etc.) of the aircraft.
  /// Example: /// Example: Landing
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *flightPhase() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FLIGHTPHASE);
  }
  /// The turnaround start time, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *taStartTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASTARTTIME);
  }
  /// The earliest time that turnaround of the aircraft may complete, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *earliestTAEndTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EARLIESTTAENDTIME);
  }
  /// The Operational Capability of the reported aircraft (ABLE, LOFUEL, UNABLE).
  /// Example: /// Example: ABLE
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *missionReadiness() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSIONREADINESS);
  }
  /// The mass of fuel remaining on the aircraft, in kilograms.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t fuel() const {
    return GetField<int32_t>(VT_FUEL, 0);
  }
  /// Used in conjunction with the fuel field to indicate either burnable or offload fuel.
  /// Example: /// Example: Burn
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *fuelFunction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUELFUNCTION);
  }
  /// Flag indicating that the aircraft is capable of making at least one gun pass.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool gunCapable() const {
    return GetField<uint8_t>(VT_GUNCAPABLE, 0) != 0;
  }
  /// The type of gun rounds available (e.g. 7.62 MM, 20 MM, 25 MM, etc.).
  /// Example: /// Example: 7.62 MM
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *gunRdsType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GUNRDSTYPE);
  }
  /// The lower bound of the estimated number of gun rounds available.
  /// Example: /// Example: 150
  /// Constraints: No constraints specified.
  int32_t gunRdsMin() const {
    return GetField<int32_t>(VT_GUNRDSMIN, 0);
  }
  /// The upper bound of the estimated number of gun rounds available.
  /// Example: /// Example: 550
  /// Constraints: No constraints specified.
  int32_t gunRdsMax() const {
    return GetField<int32_t>(VT_GUNRDSMAX, 0);
  }
  /// The status of the air-to-air weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF).
  /// Example: /// Example: OPERATIONAL
  /// Constraints: Minimum length = 0, Maximum length = 16
  AircraftStatus_Ingest_airToAirStatus_Enum airToAirStatus() const {
    return static_cast<AircraftStatus_Ingest_airToAirStatus_Enum>(GetField<int8_t>(VT_AIRTOAIRSTATUS, 0));
  }
  /// The status of the air-to-ground weapon release system (OPERATIONAL, NON-OPERATIONAL, OFF).
  /// Example: /// Example: OPERATIONAL
  /// Constraints: Minimum length = 0, Maximum length = 16
  AircraftStatus_Ingest_airToGroundStatus_Enum airToGroundStatus() const {
    return static_cast<AircraftStatus_Ingest_airToGroundStatus_Enum>(GetField<int8_t>(VT_AIRTOGROUNDSTATUS, 0));
  }
  /// Array of inventory item(s) for which estimate(s) are available (e.g. AIM-9 SIDEWINDER, AIM-120 AMRAAM, AIM-92 STINGER, CHAFF DECOY, FLARE TP 400, etc.).  Intended as, but not constrained to, MIL-STD-6016 environment dependent specific/store type designations.  This array must be the same length as inventoryMin and inventoryMax.
  /// Example: /// Example: ['AIM-9 SIDEWINDER', 'AIM-120 AMRAAM']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inventory() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INVENTORY);
  }
  /// Array of the lower bound quantity for each of the inventory items. The values in this array must correspond to position index in the inventory array. This array must be the same length as inventory and inventoryMax.
  /// Example: /// Example: [1, 2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inventoryMin() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INVENTORYMIN);
  }
  /// Array of the upper bound quantity for each of the inventory items. The values in this array must correspond to position index in the inventory array. This array must be the same length as inventory and inventoryMin.
  /// Example: /// Example: [2, 2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *inventoryMax() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_INVENTORYMAX);
  }
  /// List of unavailable systems that would normally be on this aircraft.
  /// Example: /// Example: ['CMDS', 'AOC']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *unavailableSys() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_UNAVAILABLESYS);
  }
  /// List of additional operational systems on this aircraft beyond what is normally available.
  /// Example: /// Example: ['ATOMS', 'TUDL', 'BLOS1']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *additionalSys() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ADDITIONALSYS);
  }
  /// Optional notes/comments concerning this aircraft status.
  /// Example: /// Example: Some notes for aircraft A
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *notes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  /// Maintenance pacing remarks assocociated with this aircraft.
  /// Example: /// Example: COM2 INOP
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *mxRemark() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MXREMARK);
  }
  /// The maintenance status of the aircraft.
  /// Example: /// Example: maintenance status
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *maintStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAINTSTATUS);
  }
  /// Indicates the maintenance discrepancy that drives the current maintenance status.
  /// Example: /// Example: SCREW STUCK IN LEFT NLG TIRE
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *maintStatusDriver() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAINTSTATUSDRIVER);
  }
  /// Indicates the priority of the maintenance effort.
  /// Example: /// Example: 1
  /// Constraints: Minimum length = 0, Maximum length = 1
  const ::flatbuffers::String *maintPriority() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAINTPRIORITY);
  }
  /// Aircraft alpha status code that indicates the aircraft maintenance status estimated by the pilot.
  /// Example: /// Example: A2
  /// Constraints: Minimum length = 0, Maximum length = 2
  const ::flatbuffers::String *alphaStatusCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALPHASTATUSCODE);
  }
  /// The time of the last maintenance status update, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *maintStatusUpdate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAINTSTATUSUPDATE);
  }
  /// Date when the military aircraft inspection was last performed, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-09-09T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastInspectionDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTINSPECTIONDATE);
  }
  /// Military aircraft maintenance point of contact for this aircraft.
  /// Example: /// Example: PSUP NIGHT SHIFT 800-555-4412
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *maintPoc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAINTPOC);
  }
  /// The ground status of the aircraft (e.g. ALERT, CREW READY, ENGINE START, HANGAR, etc.).
  /// Example: /// Example: ALERT
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *groundStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GROUNDSTATUS);
  }
  /// The contamination status of the aircraft (e.g. CLEAR, CONTAMINATED, DECONTAMINATED, UNKNOWN, etc.).
  /// Example: /// Example: CLEAR
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *contaminationStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTAMINATIONSTATUS);
  }
  /// The state of the aircraft fuel status (e.g. DELIVERED, DUMPED, EMPTY, FULL, OTHER, REQUESTED, etc.).
  /// Example: /// Example: DELIVERED
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *fuelStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FUELSTATUS);
  }
  /// The name or ID of the external user that updated this status.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *lastUpdatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTUPDATEDBY);
  }
  /// Estimated Time for Completion (ETIC) of an aircraft issue, in ISO 8601 UTC format with millisecond precision. This is the estimated time when the course of action to resolve the issue will be determined.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *troubleshootEtic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TROUBLESHOOTETIC);
  }
  /// The Expected Time in Commission (ETIC) for this aircraft, in ISO 8601 UTC format with millisecond precision. This is the estimated time when the issue will be resolved.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *etic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ETIC);
  }
  /// The parking location of this aircraft.
  /// Example: /// Example: B1
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *parkLocation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARKLOCATION);
  }
  /// The system that designated the parking location (e.g. EMOC, GDSS, PEX, etc.).
  /// Example: /// Example: GDSS
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *parkLocationSystem() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARKLOCATIONSYSTEM);
  }
  /// Unique identifier of the Point of Interest (POI) record related to this aircraft status. This will generally represent the location of an aircraft on the ground.
  /// Example: /// Example: 0e52f081-a2e3-4b73-b822-88b882232691
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idPOI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDPOI);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  AircraftStatus_Ingest_dataMode_Enum dataMode() const {
    return static_cast<AircraftStatus_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDAIRCRAFT) &&
           verifier.VerifyString(idAircraft()) &&
           VerifyOffset(verifier, VT_ALTAIRCRAFTID) &&
           verifier.VerifyString(altAircraftId()) &&
           VerifyOffset(verifier, VT_CURRENTSTATE) &&
           verifier.VerifyString(currentState()) &&
           VerifyOffset(verifier, VT_IDAIRFIELD) &&
           verifier.VerifyString(idAirfield()) &&
           VerifyOffset(verifier, VT_GEOLOC) &&
           verifier.VerifyString(geoLoc()) &&
           VerifyOffset(verifier, VT_PREVIOUSICAO) &&
           verifier.VerifyString(previousICAO()) &&
           VerifyOffset(verifier, VT_CURRENTICAO) &&
           verifier.VerifyString(currentICAO()) &&
           VerifyOffset(verifier, VT_NEXTICAO) &&
           verifier.VerifyString(nextICAO()) &&
           VerifyOffset(verifier, VT_FLIGHTPHASE) &&
           verifier.VerifyString(flightPhase()) &&
           VerifyOffset(verifier, VT_TASTARTTIME) &&
           verifier.VerifyString(taStartTime()) &&
           VerifyOffset(verifier, VT_EARLIESTTAENDTIME) &&
           verifier.VerifyString(earliestTAEndTime()) &&
           VerifyOffset(verifier, VT_MISSIONREADINESS) &&
           verifier.VerifyString(missionReadiness()) &&
           VerifyField<int32_t>(verifier, VT_FUEL, 4) &&
           VerifyOffset(verifier, VT_FUELFUNCTION) &&
           verifier.VerifyString(fuelFunction()) &&
           VerifyField<uint8_t>(verifier, VT_GUNCAPABLE, 1) &&
           VerifyOffset(verifier, VT_GUNRDSTYPE) &&
           verifier.VerifyString(gunRdsType()) &&
           VerifyField<int32_t>(verifier, VT_GUNRDSMIN, 4) &&
           VerifyField<int32_t>(verifier, VT_GUNRDSMAX, 4) &&
           VerifyField<int8_t>(verifier, VT_AIRTOAIRSTATUS, 1) &&
           VerifyField<int8_t>(verifier, VT_AIRTOGROUNDSTATUS, 1) &&
           VerifyOffset(verifier, VT_INVENTORY) &&
           verifier.VerifyVector(inventory()) &&
           verifier.VerifyVectorOfStrings(inventory()) &&
           VerifyOffset(verifier, VT_INVENTORYMIN) &&
           verifier.VerifyVector(inventoryMin()) &&
           verifier.VerifyVectorOfStrings(inventoryMin()) &&
           VerifyOffset(verifier, VT_INVENTORYMAX) &&
           verifier.VerifyVector(inventoryMax()) &&
           verifier.VerifyVectorOfStrings(inventoryMax()) &&
           VerifyOffset(verifier, VT_UNAVAILABLESYS) &&
           verifier.VerifyVector(unavailableSys()) &&
           verifier.VerifyVectorOfStrings(unavailableSys()) &&
           VerifyOffset(verifier, VT_ADDITIONALSYS) &&
           verifier.VerifyVector(additionalSys()) &&
           verifier.VerifyVectorOfStrings(additionalSys()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(notes()) &&
           VerifyOffset(verifier, VT_MXREMARK) &&
           verifier.VerifyString(mxRemark()) &&
           VerifyOffset(verifier, VT_MAINTSTATUS) &&
           verifier.VerifyString(maintStatus()) &&
           VerifyOffset(verifier, VT_MAINTSTATUSDRIVER) &&
           verifier.VerifyString(maintStatusDriver()) &&
           VerifyOffset(verifier, VT_MAINTPRIORITY) &&
           verifier.VerifyString(maintPriority()) &&
           VerifyOffset(verifier, VT_ALPHASTATUSCODE) &&
           verifier.VerifyString(alphaStatusCode()) &&
           VerifyOffset(verifier, VT_MAINTSTATUSUPDATE) &&
           verifier.VerifyString(maintStatusUpdate()) &&
           VerifyOffset(verifier, VT_LASTINSPECTIONDATE) &&
           verifier.VerifyString(lastInspectionDate()) &&
           VerifyOffset(verifier, VT_MAINTPOC) &&
           verifier.VerifyString(maintPoc()) &&
           VerifyOffset(verifier, VT_GROUNDSTATUS) &&
           verifier.VerifyString(groundStatus()) &&
           VerifyOffset(verifier, VT_CONTAMINATIONSTATUS) &&
           verifier.VerifyString(contaminationStatus()) &&
           VerifyOffset(verifier, VT_FUELSTATUS) &&
           verifier.VerifyString(fuelStatus()) &&
           VerifyOffset(verifier, VT_LASTUPDATEDBY) &&
           verifier.VerifyString(lastUpdatedBy()) &&
           VerifyOffset(verifier, VT_TROUBLESHOOTETIC) &&
           verifier.VerifyString(troubleshootEtic()) &&
           VerifyOffset(verifier, VT_ETIC) &&
           verifier.VerifyString(etic()) &&
           VerifyOffset(verifier, VT_PARKLOCATION) &&
           verifier.VerifyString(parkLocation()) &&
           VerifyOffset(verifier, VT_PARKLOCATIONSYSTEM) &&
           verifier.VerifyString(parkLocationSystem()) &&
           VerifyOffset(verifier, VT_IDPOI) &&
           verifier.VerifyString(idPOI()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct AircraftStatus_IngestBuilder {
  typedef AircraftStatus_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idAircraft(::flatbuffers::Offset<::flatbuffers::String> idAircraft) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_IDAIRCRAFT, idAircraft);
  }
  void add_altAircraftId(::flatbuffers::Offset<::flatbuffers::String> altAircraftId) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ALTAIRCRAFTID, altAircraftId);
  }
  void add_currentState(::flatbuffers::Offset<::flatbuffers::String> currentState) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_CURRENTSTATE, currentState);
  }
  void add_idAirfield(::flatbuffers::Offset<::flatbuffers::String> idAirfield) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_IDAIRFIELD, idAirfield);
  }
  void add_geoLoc(::flatbuffers::Offset<::flatbuffers::String> geoLoc) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_GEOLOC, geoLoc);
  }
  void add_previousICAO(::flatbuffers::Offset<::flatbuffers::String> previousICAO) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_PREVIOUSICAO, previousICAO);
  }
  void add_currentICAO(::flatbuffers::Offset<::flatbuffers::String> currentICAO) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_CURRENTICAO, currentICAO);
  }
  void add_nextICAO(::flatbuffers::Offset<::flatbuffers::String> nextICAO) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_NEXTICAO, nextICAO);
  }
  void add_flightPhase(::flatbuffers::Offset<::flatbuffers::String> flightPhase) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_FLIGHTPHASE, flightPhase);
  }
  void add_taStartTime(::flatbuffers::Offset<::flatbuffers::String> taStartTime) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_TASTARTTIME, taStartTime);
  }
  void add_earliestTAEndTime(::flatbuffers::Offset<::flatbuffers::String> earliestTAEndTime) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_EARLIESTTAENDTIME, earliestTAEndTime);
  }
  void add_missionReadiness(::flatbuffers::Offset<::flatbuffers::String> missionReadiness) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MISSIONREADINESS, missionReadiness);
  }
  void add_fuel(int32_t fuel) {
    fbb_.AddElement<int32_t>(AircraftStatus_Ingest::VT_FUEL, fuel, 0);
  }
  void add_fuelFunction(::flatbuffers::Offset<::flatbuffers::String> fuelFunction) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_FUELFUNCTION, fuelFunction);
  }
  void add_gunCapable(bool gunCapable) {
    fbb_.AddElement<uint8_t>(AircraftStatus_Ingest::VT_GUNCAPABLE, static_cast<uint8_t>(gunCapable), 0);
  }
  void add_gunRdsType(::flatbuffers::Offset<::flatbuffers::String> gunRdsType) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_GUNRDSTYPE, gunRdsType);
  }
  void add_gunRdsMin(int32_t gunRdsMin) {
    fbb_.AddElement<int32_t>(AircraftStatus_Ingest::VT_GUNRDSMIN, gunRdsMin, 0);
  }
  void add_gunRdsMax(int32_t gunRdsMax) {
    fbb_.AddElement<int32_t>(AircraftStatus_Ingest::VT_GUNRDSMAX, gunRdsMax, 0);
  }
  void add_airToAirStatus(AircraftStatus_Ingest_airToAirStatus_Enum airToAirStatus) {
    fbb_.AddElement<int8_t>(AircraftStatus_Ingest::VT_AIRTOAIRSTATUS, static_cast<int8_t>(airToAirStatus), 0);
  }
  void add_airToGroundStatus(AircraftStatus_Ingest_airToGroundStatus_Enum airToGroundStatus) {
    fbb_.AddElement<int8_t>(AircraftStatus_Ingest::VT_AIRTOGROUNDSTATUS, static_cast<int8_t>(airToGroundStatus), 0);
  }
  void add_inventory(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inventory) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_INVENTORY, inventory);
  }
  void add_inventoryMin(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inventoryMin) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_INVENTORYMIN, inventoryMin);
  }
  void add_inventoryMax(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inventoryMax) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_INVENTORYMAX, inventoryMax);
  }
  void add_unavailableSys(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> unavailableSys) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_UNAVAILABLESYS, unavailableSys);
  }
  void add_additionalSys(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> additionalSys) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ADDITIONALSYS, additionalSys);
  }
  void add_notes(::flatbuffers::Offset<::flatbuffers::String> notes) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_NOTES, notes);
  }
  void add_mxRemark(::flatbuffers::Offset<::flatbuffers::String> mxRemark) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MXREMARK, mxRemark);
  }
  void add_maintStatus(::flatbuffers::Offset<::flatbuffers::String> maintStatus) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MAINTSTATUS, maintStatus);
  }
  void add_maintStatusDriver(::flatbuffers::Offset<::flatbuffers::String> maintStatusDriver) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MAINTSTATUSDRIVER, maintStatusDriver);
  }
  void add_maintPriority(::flatbuffers::Offset<::flatbuffers::String> maintPriority) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MAINTPRIORITY, maintPriority);
  }
  void add_alphaStatusCode(::flatbuffers::Offset<::flatbuffers::String> alphaStatusCode) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ALPHASTATUSCODE, alphaStatusCode);
  }
  void add_maintStatusUpdate(::flatbuffers::Offset<::flatbuffers::String> maintStatusUpdate) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MAINTSTATUSUPDATE, maintStatusUpdate);
  }
  void add_lastInspectionDate(::flatbuffers::Offset<::flatbuffers::String> lastInspectionDate) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_LASTINSPECTIONDATE, lastInspectionDate);
  }
  void add_maintPoc(::flatbuffers::Offset<::flatbuffers::String> maintPoc) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_MAINTPOC, maintPoc);
  }
  void add_groundStatus(::flatbuffers::Offset<::flatbuffers::String> groundStatus) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_GROUNDSTATUS, groundStatus);
  }
  void add_contaminationStatus(::flatbuffers::Offset<::flatbuffers::String> contaminationStatus) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_CONTAMINATIONSTATUS, contaminationStatus);
  }
  void add_fuelStatus(::flatbuffers::Offset<::flatbuffers::String> fuelStatus) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_FUELSTATUS, fuelStatus);
  }
  void add_lastUpdatedBy(::flatbuffers::Offset<::flatbuffers::String> lastUpdatedBy) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_LASTUPDATEDBY, lastUpdatedBy);
  }
  void add_troubleshootEtic(::flatbuffers::Offset<::flatbuffers::String> troubleshootEtic) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_TROUBLESHOOTETIC, troubleshootEtic);
  }
  void add_etic(::flatbuffers::Offset<::flatbuffers::String> etic) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ETIC, etic);
  }
  void add_parkLocation(::flatbuffers::Offset<::flatbuffers::String> parkLocation) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_PARKLOCATION, parkLocation);
  }
  void add_parkLocationSystem(::flatbuffers::Offset<::flatbuffers::String> parkLocationSystem) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_PARKLOCATIONSYSTEM, parkLocationSystem);
  }
  void add_idPOI(::flatbuffers::Offset<::flatbuffers::String> idPOI) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_IDPOI, idPOI);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_SOURCEDL, sourceDL);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ORIGIN, origin);
  }
  void add_dataMode(AircraftStatus_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(AircraftStatus_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(AircraftStatus_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  explicit AircraftStatus_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AircraftStatus_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AircraftStatus_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AircraftStatus_Ingest> CreateAircraftStatus_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idAircraft = 0,
    ::flatbuffers::Offset<::flatbuffers::String> altAircraftId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currentState = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idAirfield = 0,
    ::flatbuffers::Offset<::flatbuffers::String> geoLoc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> previousICAO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currentICAO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nextICAO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> flightPhase = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taStartTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> earliestTAEndTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> missionReadiness = 0,
    int32_t fuel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fuelFunction = 0,
    bool gunCapable = false,
    ::flatbuffers::Offset<::flatbuffers::String> gunRdsType = 0,
    int32_t gunRdsMin = 0,
    int32_t gunRdsMax = 0,
    AircraftStatus_Ingest_airToAirStatus_Enum airToAirStatus = AircraftStatus_Ingest_airToAirStatus_Enum_OPERATIONAL,
    AircraftStatus_Ingest_airToGroundStatus_Enum airToGroundStatus = AircraftStatus_Ingest_airToGroundStatus_Enum_OPERATIONAL,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inventory = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inventoryMin = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> inventoryMax = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> unavailableSys = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> additionalSys = 0,
    ::flatbuffers::Offset<::flatbuffers::String> notes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mxRemark = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maintStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maintStatusDriver = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maintPriority = 0,
    ::flatbuffers::Offset<::flatbuffers::String> alphaStatusCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maintStatusUpdate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastInspectionDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> maintPoc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> groundStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> contaminationStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fuelStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastUpdatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> troubleshootEtic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> etic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parkLocation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parkLocationSystem = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idPOI = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    AircraftStatus_Ingest_dataMode_Enum dataMode = AircraftStatus_Ingest_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  AircraftStatus_IngestBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_sourceDL(sourceDL);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_idPOI(idPOI);
  builder_.add_parkLocationSystem(parkLocationSystem);
  builder_.add_parkLocation(parkLocation);
  builder_.add_etic(etic);
  builder_.add_troubleshootEtic(troubleshootEtic);
  builder_.add_lastUpdatedBy(lastUpdatedBy);
  builder_.add_fuelStatus(fuelStatus);
  builder_.add_contaminationStatus(contaminationStatus);
  builder_.add_groundStatus(groundStatus);
  builder_.add_maintPoc(maintPoc);
  builder_.add_lastInspectionDate(lastInspectionDate);
  builder_.add_maintStatusUpdate(maintStatusUpdate);
  builder_.add_alphaStatusCode(alphaStatusCode);
  builder_.add_maintPriority(maintPriority);
  builder_.add_maintStatusDriver(maintStatusDriver);
  builder_.add_maintStatus(maintStatus);
  builder_.add_mxRemark(mxRemark);
  builder_.add_notes(notes);
  builder_.add_additionalSys(additionalSys);
  builder_.add_unavailableSys(unavailableSys);
  builder_.add_inventoryMax(inventoryMax);
  builder_.add_inventoryMin(inventoryMin);
  builder_.add_inventory(inventory);
  builder_.add_gunRdsMax(gunRdsMax);
  builder_.add_gunRdsMin(gunRdsMin);
  builder_.add_gunRdsType(gunRdsType);
  builder_.add_fuelFunction(fuelFunction);
  builder_.add_fuel(fuel);
  builder_.add_missionReadiness(missionReadiness);
  builder_.add_earliestTAEndTime(earliestTAEndTime);
  builder_.add_taStartTime(taStartTime);
  builder_.add_flightPhase(flightPhase);
  builder_.add_nextICAO(nextICAO);
  builder_.add_currentICAO(currentICAO);
  builder_.add_previousICAO(previousICAO);
  builder_.add_geoLoc(geoLoc);
  builder_.add_idAirfield(idAirfield);
  builder_.add_currentState(currentState);
  builder_.add_altAircraftId(altAircraftId);
  builder_.add_idAircraft(idAircraft);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_airToGroundStatus(airToGroundStatus);
  builder_.add_airToAirStatus(airToAirStatus);
  builder_.add_gunCapable(gunCapable);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AircraftStatus_Ingest> CreateAircraftStatus_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idAircraft = nullptr,
    const char *altAircraftId = nullptr,
    const char *currentState = nullptr,
    const char *idAirfield = nullptr,
    const char *geoLoc = nullptr,
    const char *previousICAO = nullptr,
    const char *currentICAO = nullptr,
    const char *nextICAO = nullptr,
    const char *flightPhase = nullptr,
    const char *taStartTime = nullptr,
    const char *earliestTAEndTime = nullptr,
    const char *missionReadiness = nullptr,
    int32_t fuel = 0,
    const char *fuelFunction = nullptr,
    bool gunCapable = false,
    const char *gunRdsType = nullptr,
    int32_t gunRdsMin = 0,
    int32_t gunRdsMax = 0,
    AircraftStatus_Ingest_airToAirStatus_Enum airToAirStatus = AircraftStatus_Ingest_airToAirStatus_Enum_OPERATIONAL,
    AircraftStatus_Ingest_airToGroundStatus_Enum airToGroundStatus = AircraftStatus_Ingest_airToGroundStatus_Enum_OPERATIONAL,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inventory = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inventoryMin = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *inventoryMax = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *unavailableSys = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *additionalSys = nullptr,
    const char *notes = nullptr,
    const char *mxRemark = nullptr,
    const char *maintStatus = nullptr,
    const char *maintStatusDriver = nullptr,
    const char *maintPriority = nullptr,
    const char *alphaStatusCode = nullptr,
    const char *maintStatusUpdate = nullptr,
    const char *lastInspectionDate = nullptr,
    const char *maintPoc = nullptr,
    const char *groundStatus = nullptr,
    const char *contaminationStatus = nullptr,
    const char *fuelStatus = nullptr,
    const char *lastUpdatedBy = nullptr,
    const char *troubleshootEtic = nullptr,
    const char *etic = nullptr,
    const char *parkLocation = nullptr,
    const char *parkLocationSystem = nullptr,
    const char *idPOI = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *sourceDL = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    AircraftStatus_Ingest_dataMode_Enum dataMode = AircraftStatus_Ingest_dataMode_Enum_REAL,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idAircraft__ = idAircraft ? _fbb.CreateString(idAircraft) : 0;
  auto altAircraftId__ = altAircraftId ? _fbb.CreateString(altAircraftId) : 0;
  auto currentState__ = currentState ? _fbb.CreateString(currentState) : 0;
  auto idAirfield__ = idAirfield ? _fbb.CreateString(idAirfield) : 0;
  auto geoLoc__ = geoLoc ? _fbb.CreateString(geoLoc) : 0;
  auto previousICAO__ = previousICAO ? _fbb.CreateString(previousICAO) : 0;
  auto currentICAO__ = currentICAO ? _fbb.CreateString(currentICAO) : 0;
  auto nextICAO__ = nextICAO ? _fbb.CreateString(nextICAO) : 0;
  auto flightPhase__ = flightPhase ? _fbb.CreateString(flightPhase) : 0;
  auto taStartTime__ = taStartTime ? _fbb.CreateString(taStartTime) : 0;
  auto earliestTAEndTime__ = earliestTAEndTime ? _fbb.CreateString(earliestTAEndTime) : 0;
  auto missionReadiness__ = missionReadiness ? _fbb.CreateString(missionReadiness) : 0;
  auto fuelFunction__ = fuelFunction ? _fbb.CreateString(fuelFunction) : 0;
  auto gunRdsType__ = gunRdsType ? _fbb.CreateString(gunRdsType) : 0;
  auto inventory__ = inventory ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inventory) : 0;
  auto inventoryMin__ = inventoryMin ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inventoryMin) : 0;
  auto inventoryMax__ = inventoryMax ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*inventoryMax) : 0;
  auto unavailableSys__ = unavailableSys ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*unavailableSys) : 0;
  auto additionalSys__ = additionalSys ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*additionalSys) : 0;
  auto notes__ = notes ? _fbb.CreateString(notes) : 0;
  auto mxRemark__ = mxRemark ? _fbb.CreateString(mxRemark) : 0;
  auto maintStatus__ = maintStatus ? _fbb.CreateString(maintStatus) : 0;
  auto maintStatusDriver__ = maintStatusDriver ? _fbb.CreateString(maintStatusDriver) : 0;
  auto maintPriority__ = maintPriority ? _fbb.CreateString(maintPriority) : 0;
  auto alphaStatusCode__ = alphaStatusCode ? _fbb.CreateString(alphaStatusCode) : 0;
  auto maintStatusUpdate__ = maintStatusUpdate ? _fbb.CreateString(maintStatusUpdate) : 0;
  auto lastInspectionDate__ = lastInspectionDate ? _fbb.CreateString(lastInspectionDate) : 0;
  auto maintPoc__ = maintPoc ? _fbb.CreateString(maintPoc) : 0;
  auto groundStatus__ = groundStatus ? _fbb.CreateString(groundStatus) : 0;
  auto contaminationStatus__ = contaminationStatus ? _fbb.CreateString(contaminationStatus) : 0;
  auto fuelStatus__ = fuelStatus ? _fbb.CreateString(fuelStatus) : 0;
  auto lastUpdatedBy__ = lastUpdatedBy ? _fbb.CreateString(lastUpdatedBy) : 0;
  auto troubleshootEtic__ = troubleshootEtic ? _fbb.CreateString(troubleshootEtic) : 0;
  auto etic__ = etic ? _fbb.CreateString(etic) : 0;
  auto parkLocation__ = parkLocation ? _fbb.CreateString(parkLocation) : 0;
  auto parkLocationSystem__ = parkLocationSystem ? _fbb.CreateString(parkLocationSystem) : 0;
  auto idPOI__ = idPOI ? _fbb.CreateString(idPOI) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateAircraftStatus_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      idAircraft__,
      altAircraftId__,
      currentState__,
      idAirfield__,
      geoLoc__,
      previousICAO__,
      currentICAO__,
      nextICAO__,
      flightPhase__,
      taStartTime__,
      earliestTAEndTime__,
      missionReadiness__,
      fuel,
      fuelFunction__,
      gunCapable,
      gunRdsType__,
      gunRdsMin,
      gunRdsMax,
      airToAirStatus,
      airToGroundStatus,
      inventory__,
      inventoryMin__,
      inventoryMax__,
      unavailableSys__,
      additionalSys__,
      notes__,
      mxRemark__,
      maintStatus__,
      maintStatusDriver__,
      maintPriority__,
      alphaStatusCode__,
      maintStatusUpdate__,
      lastInspectionDate__,
      maintPoc__,
      groundStatus__,
      contaminationStatus__,
      fuelStatus__,
      lastUpdatedBy__,
      troubleshootEtic__,
      etic__,
      parkLocation__,
      parkLocationSystem__,
      idPOI__,
      createdAt__,
      createdBy__,
      sourceDL__,
      source__,
      origin__,
      dataMode,
      origNetwork__);
}

inline const AircraftStatus_Ingest *GetAircraftStatus_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<AircraftStatus_Ingest>(buf);
}

inline const AircraftStatus_Ingest *GetSizePrefixedAircraftStatus_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AircraftStatus_Ingest>(buf);
}

inline const char *AircraftStatus_IngestIdentifier() {
  return "AIRC";
}

inline bool AircraftStatus_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AircraftStatus_IngestIdentifier());
}

inline bool SizePrefixedAircraftStatus_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AircraftStatus_IngestIdentifier(), true);
}

inline bool VerifyAircraftStatus_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AircraftStatus_Ingest>(AircraftStatus_IngestIdentifier());
}

inline bool VerifySizePrefixedAircraftStatus_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AircraftStatus_Ingest>(AircraftStatus_IngestIdentifier());
}

inline void FinishAircraftStatus_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AircraftStatus_Ingest> root) {
  fbb.Finish(root, AircraftStatus_IngestIdentifier());
}

inline void FinishSizePrefixedAircraftStatus_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AircraftStatus_Ingest> root) {
  fbb.FinishSizePrefixed(root, AircraftStatus_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
