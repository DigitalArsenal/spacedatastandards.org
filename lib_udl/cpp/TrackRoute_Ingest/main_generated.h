// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct TrackRoute_Ingest;
struct TrackRoute_IngestBuilder;

enum TrackRoute_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  TrackRoute_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  TrackRoute_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  TrackRoute_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  TrackRoute_Ingest_dataMode_Enum_EXERCISE = 3,
  TrackRoute_Ingest_dataMode_Enum_MIN = TrackRoute_Ingest_dataMode_Enum_REAL,
  TrackRoute_Ingest_dataMode_Enum_MAX = TrackRoute_Ingest_dataMode_Enum_EXERCISE
};

inline const TrackRoute_Ingest_dataMode_Enum (&EnumValuesTrackRoute_Ingest_dataMode_Enum())[4] {
  static const TrackRoute_Ingest_dataMode_Enum values[] = {
    TrackRoute_Ingest_dataMode_Enum_REAL,
    TrackRoute_Ingest_dataMode_Enum_TEST,
    TrackRoute_Ingest_dataMode_Enum_SIMULATED,
    TrackRoute_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesTrackRoute_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackRoute_Ingest_dataMode_Enum(TrackRoute_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, TrackRoute_Ingest_dataMode_Enum_REAL, TrackRoute_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackRoute_Ingest_dataMode_Enum()[index];
}

/// /// A track route is a prescribed route for performing training events or operations such as air refueling.
struct TrackRoute_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrackRoute_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_TYPE = 8,
    VT_EXTERNALID = 10,
    VT_DIRECTION = 12,
    VT_CREATINGORG = 14,
    VT_LOCATIONTRACKID = 16,
    VT_TRACKID = 18,
    VT_TRACKNAME = 20,
    VT_SHORTNAME = 22,
    VT_TYPECODE = 24,
    VT_REGIONCODE = 26,
    VT_REGIONNAME = 28,
    VT_APXBEACONCODE = 30,
    VT_RECEIVERTANKERCHCODE = 32,
    VT_APNSETTING = 34,
    VT_SIC = 36,
    VT_REVIEWDATE = 38,
    VT_LASTUSEDDATE = 40,
    VT_LASTUPDATEDATE = 42,
    VT_PRIFREQ = 44,
    VT_SECFREQ = 46,
    VT_ARTCCMESSAGE = 48,
    VT_SCHEDULERORGNAME = 50,
    VT_SCHEDULERORGUNIT = 52,
    VT_EFFECTIVEDATE = 54,
    VT_ROUTEPOINTS = 56,
    VT_ALTITUDEBLOCKS = 58,
    VT_POC = 60,
    VT_CREATEDAT = 62,
    VT_CREATEDBY = 64,
    VT_UPDATEDAT = 66,
    VT_UPDATEDBY = 68,
    VT_SOURCEDL = 70,
    VT_SOURCE = 72,
    VT_ORIGIN = 74,
    VT_ORIGNETWORK = 76,
    VT_DATAMODE = 78
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The track route type represented by this record (ex. AIR REFUELING).
  /// Example: /// Example: AIR REFUELING
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Optional air refueling track ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: GDSSMH121004232315303094
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *externalId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALID);
  }
  /// The principal compass direction (cardinal or ordinal) of the track route.
  /// Example: /// Example: NE
  /// Constraints: Minimum length = 0, Maximum length = 2
  const ::flatbuffers::String *direction() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DIRECTION);
  }
  /// The name of the creating organization of the track route.
  /// Example: /// Example: HQPAC
  /// Constraints: Minimum length = 0, Maximum length = 250
  const ::flatbuffers::String *creatingOrg() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATINGORG);
  }
  /// Track location ID.
  /// Example: /// Example: POACHR
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *locationTrackId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOCATIONTRACKID);
  }
  /// Identifier of the track.
  /// Example: /// Example: CH61A
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *trackId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACKID);
  }
  /// Name of the track.
  /// Example: /// Example: CH61 POST
  /// Constraints: Minimum length = 0, Maximum length = 50
  const ::flatbuffers::String *trackName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACKNAME);
  }
  /// Abbreviated name of the track.
  /// Example: /// Example: CH61
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *shortName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHORTNAME);
  }
  /// Type of process used by AMC to schedule an air refueling event. Possible values are A (Matched Long Range), F (Matched AMC Short Notice), N (Unmatched Theater Operation Short Notice (Theater Assets)), R, Unmatched Long Range, S (Soft Air Refueling), T (Matched Theater Operation Short Notice (Theater Assets)), V (Unmatched AMC Short Notice), X (Unmatched Theater Operation Short Notice (AMC Assets)), Y (Matched Theater Operation Short Notice (AMC Assets)), Z (Other Air Refueling).
  /// Example: /// Example: V
  /// Constraints: Minimum length = 0, Maximum length = 2
  const ::flatbuffers::String *typeCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPECODE);
  }
  /// Region code indicating where the track resides as determined by the data source.
  /// Example: /// Example: 5
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *regionCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REGIONCODE);
  }
  /// Region where the track resides.
  /// Example: /// Example: North America
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *regionName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REGIONNAME);
  }
  /// The APX radar code sent and received by the aircraft for identification.
  /// Example: /// Example: 5/1
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *apxBeaconCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APXBEACONCODE);
  }
  /// The receiver tanker channel identifer for air refueling tracks.
  /// Example: /// Example: 31/094
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *receiverTankerCHCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECEIVERTANKERCHCODE);
  }
  /// The APN radar code sent and received by the aircraft for identification.
  /// Example: /// Example: 1-3-1
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *apnSetting() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APNSETTING);
  }
  /// Standard Indicator Code of the air refueling track.
  /// Example: /// Example: N
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *sic() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SIC);
  }
  /// Date the track needs to be reviewed for accuracy or deletion in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-09-16T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *reviewDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REVIEWDATE);
  }
  /// Used to show last time the track route was added to an itinerary in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-09-17T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastUsedDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTUSEDDATE);
  }
  /// The last updated date of the track route in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-09-17T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastUpdateDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTUPDATEDATE);
  }
  /// The primary UHF radio frequency used for the track route in megahertz.
  /// Example: /// Example: 357.5
  /// Constraints: No constraints specified.
  double priFreq() const {
    return GetField<double>(VT_PRIFREQ, 0.0);
  }
  /// The secondary UHF radio frequency used for the track route in megahertz.
  /// Example: /// Example: 319.7
  /// Constraints: No constraints specified.
  double secFreq() const {
    return GetField<double>(VT_SECFREQ, 0.0);
  }
  /// Air Refueling Track Control Center message.
  /// Example: /// Example: OAKLAND CTR/GUAM CERAP
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *artccMessage() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARTCCMESSAGE);
  }
  /// Point of contact for the air refueling track route scheduler.
  /// Example: /// Example: 97 OSS/OSOS DSN 866-5555
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *schedulerOrgName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCHEDULERORGNAME);
  }
  /// The unit responsible for scheduling the track route.
  /// Example: /// Example: 612 AOC
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *schedulerOrgUnit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCHEDULERORGUNIT);
  }
  /// The date which the DAFIF track was last updated/validated in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-09-17T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *effectiveDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EFFECTIVEDATE);
  }
  /// Points identified within the route.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *routePoints() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ROUTEPOINTS);
  }
  /// Minimum and maximum altitude bounds for the track.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *altitudeBlocks() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALTITUDEBLOCKS);
  }
  /// Point of contacts for scheduling or modifying the route.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *poc() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_POC);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was updated in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  TrackRoute_Ingest_dataMode_Enum dataMode() const {
    return static_cast<TrackRoute_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_EXTERNALID) &&
           verifier.VerifyString(externalId()) &&
           VerifyOffset(verifier, VT_DIRECTION) &&
           verifier.VerifyString(direction()) &&
           VerifyOffset(verifier, VT_CREATINGORG) &&
           verifier.VerifyString(creatingOrg()) &&
           VerifyOffset(verifier, VT_LOCATIONTRACKID) &&
           verifier.VerifyString(locationTrackId()) &&
           VerifyOffset(verifier, VT_TRACKID) &&
           verifier.VerifyString(trackId()) &&
           VerifyOffset(verifier, VT_TRACKNAME) &&
           verifier.VerifyString(trackName()) &&
           VerifyOffset(verifier, VT_SHORTNAME) &&
           verifier.VerifyString(shortName()) &&
           VerifyOffset(verifier, VT_TYPECODE) &&
           verifier.VerifyString(typeCode()) &&
           VerifyOffset(verifier, VT_REGIONCODE) &&
           verifier.VerifyString(regionCode()) &&
           VerifyOffset(verifier, VT_REGIONNAME) &&
           verifier.VerifyString(regionName()) &&
           VerifyOffset(verifier, VT_APXBEACONCODE) &&
           verifier.VerifyString(apxBeaconCode()) &&
           VerifyOffset(verifier, VT_RECEIVERTANKERCHCODE) &&
           verifier.VerifyString(receiverTankerCHCode()) &&
           VerifyOffset(verifier, VT_APNSETTING) &&
           verifier.VerifyString(apnSetting()) &&
           VerifyOffset(verifier, VT_SIC) &&
           verifier.VerifyString(sic()) &&
           VerifyOffset(verifier, VT_REVIEWDATE) &&
           verifier.VerifyString(reviewDate()) &&
           VerifyOffset(verifier, VT_LASTUSEDDATE) &&
           verifier.VerifyString(lastUsedDate()) &&
           VerifyOffset(verifier, VT_LASTUPDATEDATE) &&
           verifier.VerifyString(lastUpdateDate()) &&
           VerifyField<double>(verifier, VT_PRIFREQ, 8) &&
           VerifyField<double>(verifier, VT_SECFREQ, 8) &&
           VerifyOffset(verifier, VT_ARTCCMESSAGE) &&
           verifier.VerifyString(artccMessage()) &&
           VerifyOffset(verifier, VT_SCHEDULERORGNAME) &&
           verifier.VerifyString(schedulerOrgName()) &&
           VerifyOffset(verifier, VT_SCHEDULERORGUNIT) &&
           verifier.VerifyString(schedulerOrgUnit()) &&
           VerifyOffset(verifier, VT_EFFECTIVEDATE) &&
           verifier.VerifyString(effectiveDate()) &&
           VerifyOffset(verifier, VT_ROUTEPOINTS) &&
           verifier.VerifyVector(routePoints()) &&
           verifier.VerifyVectorOfStrings(routePoints()) &&
           VerifyOffset(verifier, VT_ALTITUDEBLOCKS) &&
           verifier.VerifyVector(altitudeBlocks()) &&
           verifier.VerifyVectorOfStrings(altitudeBlocks()) &&
           VerifyOffset(verifier, VT_POC) &&
           verifier.VerifyVector(poc()) &&
           verifier.VerifyVectorOfStrings(poc()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct TrackRoute_IngestBuilder {
  typedef TrackRoute_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_TYPE, type);
  }
  void add_externalId(::flatbuffers::Offset<::flatbuffers::String> externalId) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_EXTERNALID, externalId);
  }
  void add_direction(::flatbuffers::Offset<::flatbuffers::String> direction) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_DIRECTION, direction);
  }
  void add_creatingOrg(::flatbuffers::Offset<::flatbuffers::String> creatingOrg) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_CREATINGORG, creatingOrg);
  }
  void add_locationTrackId(::flatbuffers::Offset<::flatbuffers::String> locationTrackId) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_LOCATIONTRACKID, locationTrackId);
  }
  void add_trackId(::flatbuffers::Offset<::flatbuffers::String> trackId) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_TRACKID, trackId);
  }
  void add_trackName(::flatbuffers::Offset<::flatbuffers::String> trackName) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_TRACKNAME, trackName);
  }
  void add_shortName(::flatbuffers::Offset<::flatbuffers::String> shortName) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_SHORTNAME, shortName);
  }
  void add_typeCode(::flatbuffers::Offset<::flatbuffers::String> typeCode) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_TYPECODE, typeCode);
  }
  void add_regionCode(::flatbuffers::Offset<::flatbuffers::String> regionCode) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_REGIONCODE, regionCode);
  }
  void add_regionName(::flatbuffers::Offset<::flatbuffers::String> regionName) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_REGIONNAME, regionName);
  }
  void add_apxBeaconCode(::flatbuffers::Offset<::flatbuffers::String> apxBeaconCode) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_APXBEACONCODE, apxBeaconCode);
  }
  void add_receiverTankerCHCode(::flatbuffers::Offset<::flatbuffers::String> receiverTankerCHCode) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_RECEIVERTANKERCHCODE, receiverTankerCHCode);
  }
  void add_apnSetting(::flatbuffers::Offset<::flatbuffers::String> apnSetting) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_APNSETTING, apnSetting);
  }
  void add_sic(::flatbuffers::Offset<::flatbuffers::String> sic) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_SIC, sic);
  }
  void add_reviewDate(::flatbuffers::Offset<::flatbuffers::String> reviewDate) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_REVIEWDATE, reviewDate);
  }
  void add_lastUsedDate(::flatbuffers::Offset<::flatbuffers::String> lastUsedDate) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_LASTUSEDDATE, lastUsedDate);
  }
  void add_lastUpdateDate(::flatbuffers::Offset<::flatbuffers::String> lastUpdateDate) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_LASTUPDATEDATE, lastUpdateDate);
  }
  void add_priFreq(double priFreq) {
    fbb_.AddElement<double>(TrackRoute_Ingest::VT_PRIFREQ, priFreq, 0.0);
  }
  void add_secFreq(double secFreq) {
    fbb_.AddElement<double>(TrackRoute_Ingest::VT_SECFREQ, secFreq, 0.0);
  }
  void add_artccMessage(::flatbuffers::Offset<::flatbuffers::String> artccMessage) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_ARTCCMESSAGE, artccMessage);
  }
  void add_schedulerOrgName(::flatbuffers::Offset<::flatbuffers::String> schedulerOrgName) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_SCHEDULERORGNAME, schedulerOrgName);
  }
  void add_schedulerOrgUnit(::flatbuffers::Offset<::flatbuffers::String> schedulerOrgUnit) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_SCHEDULERORGUNIT, schedulerOrgUnit);
  }
  void add_effectiveDate(::flatbuffers::Offset<::flatbuffers::String> effectiveDate) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_EFFECTIVEDATE, effectiveDate);
  }
  void add_routePoints(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> routePoints) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_ROUTEPOINTS, routePoints);
  }
  void add_altitudeBlocks(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> altitudeBlocks) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_ALTITUDEBLOCKS, altitudeBlocks);
  }
  void add_poc(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> poc) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_POC, poc);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_UPDATEDBY, updatedBy);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_SOURCEDL, sourceDL);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(TrackRoute_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(TrackRoute_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(TrackRoute_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit TrackRoute_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrackRoute_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrackRoute_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrackRoute_Ingest> CreateTrackRoute_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> externalId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> direction = 0,
    ::flatbuffers::Offset<::flatbuffers::String> creatingOrg = 0,
    ::flatbuffers::Offset<::flatbuffers::String> locationTrackId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trackId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trackName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shortName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> typeCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> regionCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> regionName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> apxBeaconCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> receiverTankerCHCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> apnSetting = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reviewDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastUsedDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastUpdateDate = 0,
    double priFreq = 0.0,
    double secFreq = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> artccMessage = 0,
    ::flatbuffers::Offset<::flatbuffers::String> schedulerOrgName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> schedulerOrgUnit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> effectiveDate = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> routePoints = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> altitudeBlocks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> poc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    TrackRoute_Ingest_dataMode_Enum dataMode = TrackRoute_Ingest_dataMode_Enum_REAL) {
  TrackRoute_IngestBuilder builder_(_fbb);
  builder_.add_secFreq(secFreq);
  builder_.add_priFreq(priFreq);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_sourceDL(sourceDL);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_poc(poc);
  builder_.add_altitudeBlocks(altitudeBlocks);
  builder_.add_routePoints(routePoints);
  builder_.add_effectiveDate(effectiveDate);
  builder_.add_schedulerOrgUnit(schedulerOrgUnit);
  builder_.add_schedulerOrgName(schedulerOrgName);
  builder_.add_artccMessage(artccMessage);
  builder_.add_lastUpdateDate(lastUpdateDate);
  builder_.add_lastUsedDate(lastUsedDate);
  builder_.add_reviewDate(reviewDate);
  builder_.add_sic(sic);
  builder_.add_apnSetting(apnSetting);
  builder_.add_receiverTankerCHCode(receiverTankerCHCode);
  builder_.add_apxBeaconCode(apxBeaconCode);
  builder_.add_regionName(regionName);
  builder_.add_regionCode(regionCode);
  builder_.add_typeCode(typeCode);
  builder_.add_shortName(shortName);
  builder_.add_trackName(trackName);
  builder_.add_trackId(trackId);
  builder_.add_locationTrackId(locationTrackId);
  builder_.add_creatingOrg(creatingOrg);
  builder_.add_direction(direction);
  builder_.add_externalId(externalId);
  builder_.add_type(type);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TrackRoute_Ingest> CreateTrackRoute_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *type = nullptr,
    const char *externalId = nullptr,
    const char *direction = nullptr,
    const char *creatingOrg = nullptr,
    const char *locationTrackId = nullptr,
    const char *trackId = nullptr,
    const char *trackName = nullptr,
    const char *shortName = nullptr,
    const char *typeCode = nullptr,
    const char *regionCode = nullptr,
    const char *regionName = nullptr,
    const char *apxBeaconCode = nullptr,
    const char *receiverTankerCHCode = nullptr,
    const char *apnSetting = nullptr,
    const char *sic = nullptr,
    const char *reviewDate = nullptr,
    const char *lastUsedDate = nullptr,
    const char *lastUpdateDate = nullptr,
    double priFreq = 0.0,
    double secFreq = 0.0,
    const char *artccMessage = nullptr,
    const char *schedulerOrgName = nullptr,
    const char *schedulerOrgUnit = nullptr,
    const char *effectiveDate = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *routePoints = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *altitudeBlocks = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *poc = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *sourceDL = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    TrackRoute_Ingest_dataMode_Enum dataMode = TrackRoute_Ingest_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto externalId__ = externalId ? _fbb.CreateString(externalId) : 0;
  auto direction__ = direction ? _fbb.CreateString(direction) : 0;
  auto creatingOrg__ = creatingOrg ? _fbb.CreateString(creatingOrg) : 0;
  auto locationTrackId__ = locationTrackId ? _fbb.CreateString(locationTrackId) : 0;
  auto trackId__ = trackId ? _fbb.CreateString(trackId) : 0;
  auto trackName__ = trackName ? _fbb.CreateString(trackName) : 0;
  auto shortName__ = shortName ? _fbb.CreateString(shortName) : 0;
  auto typeCode__ = typeCode ? _fbb.CreateString(typeCode) : 0;
  auto regionCode__ = regionCode ? _fbb.CreateString(regionCode) : 0;
  auto regionName__ = regionName ? _fbb.CreateString(regionName) : 0;
  auto apxBeaconCode__ = apxBeaconCode ? _fbb.CreateString(apxBeaconCode) : 0;
  auto receiverTankerCHCode__ = receiverTankerCHCode ? _fbb.CreateString(receiverTankerCHCode) : 0;
  auto apnSetting__ = apnSetting ? _fbb.CreateString(apnSetting) : 0;
  auto sic__ = sic ? _fbb.CreateString(sic) : 0;
  auto reviewDate__ = reviewDate ? _fbb.CreateString(reviewDate) : 0;
  auto lastUsedDate__ = lastUsedDate ? _fbb.CreateString(lastUsedDate) : 0;
  auto lastUpdateDate__ = lastUpdateDate ? _fbb.CreateString(lastUpdateDate) : 0;
  auto artccMessage__ = artccMessage ? _fbb.CreateString(artccMessage) : 0;
  auto schedulerOrgName__ = schedulerOrgName ? _fbb.CreateString(schedulerOrgName) : 0;
  auto schedulerOrgUnit__ = schedulerOrgUnit ? _fbb.CreateString(schedulerOrgUnit) : 0;
  auto effectiveDate__ = effectiveDate ? _fbb.CreateString(effectiveDate) : 0;
  auto routePoints__ = routePoints ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*routePoints) : 0;
  auto altitudeBlocks__ = altitudeBlocks ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*altitudeBlocks) : 0;
  auto poc__ = poc ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*poc) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateTrackRoute_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      type__,
      externalId__,
      direction__,
      creatingOrg__,
      locationTrackId__,
      trackId__,
      trackName__,
      shortName__,
      typeCode__,
      regionCode__,
      regionName__,
      apxBeaconCode__,
      receiverTankerCHCode__,
      apnSetting__,
      sic__,
      reviewDate__,
      lastUsedDate__,
      lastUpdateDate__,
      priFreq,
      secFreq,
      artccMessage__,
      schedulerOrgName__,
      schedulerOrgUnit__,
      effectiveDate__,
      routePoints__,
      altitudeBlocks__,
      poc__,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      sourceDL__,
      source__,
      origin__,
      origNetwork__,
      dataMode);
}

inline const TrackRoute_Ingest *GetTrackRoute_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<TrackRoute_Ingest>(buf);
}

inline const TrackRoute_Ingest *GetSizePrefixedTrackRoute_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<TrackRoute_Ingest>(buf);
}

inline const char *TrackRoute_IngestIdentifier() {
  return "TRAC";
}

inline bool TrackRoute_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TrackRoute_IngestIdentifier());
}

inline bool SizePrefixedTrackRoute_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TrackRoute_IngestIdentifier(), true);
}

inline bool VerifyTrackRoute_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TrackRoute_Ingest>(TrackRoute_IngestIdentifier());
}

inline bool VerifySizePrefixedTrackRoute_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TrackRoute_Ingest>(TrackRoute_IngestIdentifier());
}

inline void FinishTrackRoute_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TrackRoute_Ingest> root) {
  fbb.Finish(root, TrackRoute_IngestIdentifier());
}

inline void FinishSizePrefixedTrackRoute_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TrackRoute_Ingest> root) {
  fbb.FinishSizePrefixed(root, TrackRoute_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
