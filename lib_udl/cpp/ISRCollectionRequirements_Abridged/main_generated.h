// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ISRCollectionRequirements_Abridged;
struct ISRCollectionRequirements_AbridgedBuilder;

/// /// Tasking desired collection requirements.
struct ISRCollectionRequirements_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ISRCollectionRequirements_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_HASH = 6,
    VT_TYPE = 8,
    VT_CRIDNUMBERS = 10,
    VT_PRIORITY = 12,
    VT_RECORDID = 14,
    VT_RECONSURVEY = 16,
    VT_INTELDISCIPLINE = 18,
    VT_SECONDARY = 20,
    VT_EMPHASIZED = 22,
    VT_ISPRISMCR = 24,
    VT_START = 26,
    VT_STOP = 28,
    VT_OPERATION = 30,
    VT_SUPPORTEDUNIT = 32,
    VT_COUNTRY = 34,
    VT_REGION = 36,
    VT_SUBREGION = 38,
    VT_SPECIALCOMGUIDANCE = 40,
    VT_CRITICALTIMES = 42,
    VT_EXPLOITATIONREQUIREMENT = 44,
    VT_TARGETLIST = 46
  };
  /// Collection Requirement Unique Identifier.
  /// Example: /// Example: ISCRCOLLECTIONREQUIREMENTS
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Encryption hashing algorithm.
  /// Example: /// Example: HASH
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *hash() const {
    return GetPointer<const ::flatbuffers::String *>(VT_HASH);
  }
  /// Type collection this requirement applies to.
  /// Example: /// Example: COLLECTION_TYPE
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Collection Requirement Unique Identifier.
  /// Example: /// Example: CRID
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *cridNumbers() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CRIDNUMBERS);
  }
  /// 1-n priority for this collection requirement.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double priority() const {
    return GetField<double>(VT_PRIORITY, 0.0);
  }
  /// Record id.
  /// Example: /// Example: RECORD-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *recordId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECORDID);
  }
  /// Reconnaissance Survey information the operator needs.
  /// Example: /// Example: SURVEY_INFO
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *reconSurvey() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECONSURVEY);
  }
  /// Primary type of intelligence to be collected for this requirement.
  /// Example: /// Example: Sig
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *intelDiscipline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTELDISCIPLINE);
  }
  /// Sub category of primary intelligence to be collected for this requirement.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool secondary() const {
    return GetField<uint8_t>(VT_SECONDARY, 0) != 0;
  }
  /// Is this collection requirement an emphasized/critical requirement.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool emphasized() const {
    return GetField<uint8_t>(VT_EMPHASIZED, 0) != 0;
  }
  /// Is this collection request for the Prism system?.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool isPrismCr() const {
    return GetField<uint8_t>(VT_ISPRISMCR, 0) != 0;
  }
  /// Start time for this requirement, should be within the mission time window.
  /// Example: /// Example: 2021-01-19T01:01:15.001Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *start() const {
    return GetPointer<const ::flatbuffers::String *>(VT_START);
  }
  /// Stop time for this requirement, should be within the mission time window.
  /// Example: /// Example: 2021-01-19T01:20:01.001Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *stop() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STOP);
  }
  /// Human readable name for this operation.
  /// Example: /// Example: NAME
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *operation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPERATION);
  }
  /// The name of the military unit that this assigned collection requirement will support.
  /// Example: /// Example: UNIT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *supportedUnit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUPPORTEDUNIT);
  }
  /// Country code of the collection requirement. A Country may represent countries, multi-national consortiums, and international organizations.
  /// Example: /// Example: COUNTRY_CODE
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *country() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRY);
  }
  /// Region of the collection requirement.
  /// Example: /// Example: REGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *region() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REGION);
  }
  /// Subregion of the collection requirement.
  /// Example: /// Example: SUBREGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *subregion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUBREGION);
  }
  /// Free text field for the user to specify special instructions needed for this collection.
  /// Example: /// Example: TEXT
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *specialComGuidance() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPECIALCOMGUIDANCE);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *criticalTimes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CRITICALTIMES);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *exploitationRequirement() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXPLOITATIONREQUIREMENT);
  }
  /// Array of POI Id's for the targets being tasked.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *targetList() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TARGETLIST);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_HASH) &&
           verifier.VerifyString(hash()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_CRIDNUMBERS) &&
           verifier.VerifyString(cridNumbers()) &&
           VerifyField<double>(verifier, VT_PRIORITY, 8) &&
           VerifyOffset(verifier, VT_RECORDID) &&
           verifier.VerifyString(recordId()) &&
           VerifyOffset(verifier, VT_RECONSURVEY) &&
           verifier.VerifyString(reconSurvey()) &&
           VerifyOffset(verifier, VT_INTELDISCIPLINE) &&
           verifier.VerifyString(intelDiscipline()) &&
           VerifyField<uint8_t>(verifier, VT_SECONDARY, 1) &&
           VerifyField<uint8_t>(verifier, VT_EMPHASIZED, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISPRISMCR, 1) &&
           VerifyOffset(verifier, VT_START) &&
           verifier.VerifyString(start()) &&
           VerifyOffset(verifier, VT_STOP) &&
           verifier.VerifyString(stop()) &&
           VerifyOffset(verifier, VT_OPERATION) &&
           verifier.VerifyString(operation()) &&
           VerifyOffset(verifier, VT_SUPPORTEDUNIT) &&
           verifier.VerifyString(supportedUnit()) &&
           VerifyOffset(verifier, VT_COUNTRY) &&
           verifier.VerifyString(country()) &&
           VerifyOffset(verifier, VT_REGION) &&
           verifier.VerifyString(region()) &&
           VerifyOffset(verifier, VT_SUBREGION) &&
           verifier.VerifyString(subregion()) &&
           VerifyOffset(verifier, VT_SPECIALCOMGUIDANCE) &&
           verifier.VerifyString(specialComGuidance()) &&
           VerifyOffset(verifier, VT_CRITICALTIMES) &&
           verifier.VerifyString(criticalTimes()) &&
           VerifyOffset(verifier, VT_EXPLOITATIONREQUIREMENT) &&
           verifier.VerifyString(exploitationRequirement()) &&
           VerifyOffset(verifier, VT_TARGETLIST) &&
           verifier.VerifyVector(targetList()) &&
           verifier.VerifyVectorOfStrings(targetList()) &&
           verifier.EndTable();
  }
};

struct ISRCollectionRequirements_AbridgedBuilder {
  typedef ISRCollectionRequirements_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_ID, id);
  }
  void add_hash(::flatbuffers::Offset<::flatbuffers::String> hash) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_HASH, hash);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_TYPE, type);
  }
  void add_cridNumbers(::flatbuffers::Offset<::flatbuffers::String> cridNumbers) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_CRIDNUMBERS, cridNumbers);
  }
  void add_priority(double priority) {
    fbb_.AddElement<double>(ISRCollectionRequirements_Abridged::VT_PRIORITY, priority, 0.0);
  }
  void add_recordId(::flatbuffers::Offset<::flatbuffers::String> recordId) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_RECORDID, recordId);
  }
  void add_reconSurvey(::flatbuffers::Offset<::flatbuffers::String> reconSurvey) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_RECONSURVEY, reconSurvey);
  }
  void add_intelDiscipline(::flatbuffers::Offset<::flatbuffers::String> intelDiscipline) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_INTELDISCIPLINE, intelDiscipline);
  }
  void add_secondary(bool secondary) {
    fbb_.AddElement<uint8_t>(ISRCollectionRequirements_Abridged::VT_SECONDARY, static_cast<uint8_t>(secondary), 0);
  }
  void add_emphasized(bool emphasized) {
    fbb_.AddElement<uint8_t>(ISRCollectionRequirements_Abridged::VT_EMPHASIZED, static_cast<uint8_t>(emphasized), 0);
  }
  void add_isPrismCr(bool isPrismCr) {
    fbb_.AddElement<uint8_t>(ISRCollectionRequirements_Abridged::VT_ISPRISMCR, static_cast<uint8_t>(isPrismCr), 0);
  }
  void add_start(::flatbuffers::Offset<::flatbuffers::String> start) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_START, start);
  }
  void add_stop(::flatbuffers::Offset<::flatbuffers::String> stop) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_STOP, stop);
  }
  void add_operation(::flatbuffers::Offset<::flatbuffers::String> operation) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_OPERATION, operation);
  }
  void add_supportedUnit(::flatbuffers::Offset<::flatbuffers::String> supportedUnit) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_SUPPORTEDUNIT, supportedUnit);
  }
  void add_country(::flatbuffers::Offset<::flatbuffers::String> country) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_COUNTRY, country);
  }
  void add_region(::flatbuffers::Offset<::flatbuffers::String> region) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_REGION, region);
  }
  void add_subregion(::flatbuffers::Offset<::flatbuffers::String> subregion) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_SUBREGION, subregion);
  }
  void add_specialComGuidance(::flatbuffers::Offset<::flatbuffers::String> specialComGuidance) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_SPECIALCOMGUIDANCE, specialComGuidance);
  }
  void add_criticalTimes(::flatbuffers::Offset<::flatbuffers::String> criticalTimes) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_CRITICALTIMES, criticalTimes);
  }
  void add_exploitationRequirement(::flatbuffers::Offset<::flatbuffers::String> exploitationRequirement) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_EXPLOITATIONREQUIREMENT, exploitationRequirement);
  }
  void add_targetList(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> targetList) {
    fbb_.AddOffset(ISRCollectionRequirements_Abridged::VT_TARGETLIST, targetList);
  }
  explicit ISRCollectionRequirements_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ISRCollectionRequirements_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ISRCollectionRequirements_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ISRCollectionRequirements_Abridged> CreateISRCollectionRequirements_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> hash = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cridNumbers = 0,
    double priority = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> recordId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> reconSurvey = 0,
    ::flatbuffers::Offset<::flatbuffers::String> intelDiscipline = 0,
    bool secondary = false,
    bool emphasized = false,
    bool isPrismCr = false,
    ::flatbuffers::Offset<::flatbuffers::String> start = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stop = 0,
    ::flatbuffers::Offset<::flatbuffers::String> operation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> supportedUnit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> country = 0,
    ::flatbuffers::Offset<::flatbuffers::String> region = 0,
    ::flatbuffers::Offset<::flatbuffers::String> subregion = 0,
    ::flatbuffers::Offset<::flatbuffers::String> specialComGuidance = 0,
    ::flatbuffers::Offset<::flatbuffers::String> criticalTimes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> exploitationRequirement = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> targetList = 0) {
  ISRCollectionRequirements_AbridgedBuilder builder_(_fbb);
  builder_.add_priority(priority);
  builder_.add_targetList(targetList);
  builder_.add_exploitationRequirement(exploitationRequirement);
  builder_.add_criticalTimes(criticalTimes);
  builder_.add_specialComGuidance(specialComGuidance);
  builder_.add_subregion(subregion);
  builder_.add_region(region);
  builder_.add_country(country);
  builder_.add_supportedUnit(supportedUnit);
  builder_.add_operation(operation);
  builder_.add_stop(stop);
  builder_.add_start(start);
  builder_.add_intelDiscipline(intelDiscipline);
  builder_.add_reconSurvey(reconSurvey);
  builder_.add_recordId(recordId);
  builder_.add_cridNumbers(cridNumbers);
  builder_.add_type(type);
  builder_.add_hash(hash);
  builder_.add_id(id);
  builder_.add_isPrismCr(isPrismCr);
  builder_.add_emphasized(emphasized);
  builder_.add_secondary(secondary);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ISRCollectionRequirements_Abridged> CreateISRCollectionRequirements_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *hash = nullptr,
    const char *type = nullptr,
    const char *cridNumbers = nullptr,
    double priority = 0.0,
    const char *recordId = nullptr,
    const char *reconSurvey = nullptr,
    const char *intelDiscipline = nullptr,
    bool secondary = false,
    bool emphasized = false,
    bool isPrismCr = false,
    const char *start = nullptr,
    const char *stop = nullptr,
    const char *operation = nullptr,
    const char *supportedUnit = nullptr,
    const char *country = nullptr,
    const char *region = nullptr,
    const char *subregion = nullptr,
    const char *specialComGuidance = nullptr,
    const char *criticalTimes = nullptr,
    const char *exploitationRequirement = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *targetList = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto hash__ = hash ? _fbb.CreateString(hash) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto cridNumbers__ = cridNumbers ? _fbb.CreateString(cridNumbers) : 0;
  auto recordId__ = recordId ? _fbb.CreateString(recordId) : 0;
  auto reconSurvey__ = reconSurvey ? _fbb.CreateString(reconSurvey) : 0;
  auto intelDiscipline__ = intelDiscipline ? _fbb.CreateString(intelDiscipline) : 0;
  auto start__ = start ? _fbb.CreateString(start) : 0;
  auto stop__ = stop ? _fbb.CreateString(stop) : 0;
  auto operation__ = operation ? _fbb.CreateString(operation) : 0;
  auto supportedUnit__ = supportedUnit ? _fbb.CreateString(supportedUnit) : 0;
  auto country__ = country ? _fbb.CreateString(country) : 0;
  auto region__ = region ? _fbb.CreateString(region) : 0;
  auto subregion__ = subregion ? _fbb.CreateString(subregion) : 0;
  auto specialComGuidance__ = specialComGuidance ? _fbb.CreateString(specialComGuidance) : 0;
  auto criticalTimes__ = criticalTimes ? _fbb.CreateString(criticalTimes) : 0;
  auto exploitationRequirement__ = exploitationRequirement ? _fbb.CreateString(exploitationRequirement) : 0;
  auto targetList__ = targetList ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*targetList) : 0;
  return CreateISRCollectionRequirements_Abridged(
      _fbb,
      id__,
      hash__,
      type__,
      cridNumbers__,
      priority,
      recordId__,
      reconSurvey__,
      intelDiscipline__,
      secondary,
      emphasized,
      isPrismCr,
      start__,
      stop__,
      operation__,
      supportedUnit__,
      country__,
      region__,
      subregion__,
      specialComGuidance__,
      criticalTimes__,
      exploitationRequirement__,
      targetList__);
}

inline const ISRCollectionRequirements_Abridged *GetISRCollectionRequirements_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<ISRCollectionRequirements_Abridged>(buf);
}

inline const ISRCollectionRequirements_Abridged *GetSizePrefixedISRCollectionRequirements_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ISRCollectionRequirements_Abridged>(buf);
}

inline const char *ISRCollectionRequirements_AbridgedIdentifier() {
  return "ISRC";
}

inline bool ISRCollectionRequirements_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ISRCollectionRequirements_AbridgedIdentifier());
}

inline bool SizePrefixedISRCollectionRequirements_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ISRCollectionRequirements_AbridgedIdentifier(), true);
}

inline bool VerifyISRCollectionRequirements_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ISRCollectionRequirements_Abridged>(ISRCollectionRequirements_AbridgedIdentifier());
}

inline bool VerifySizePrefixedISRCollectionRequirements_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ISRCollectionRequirements_Abridged>(ISRCollectionRequirements_AbridgedIdentifier());
}

inline void FinishISRCollectionRequirements_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ISRCollectionRequirements_Abridged> root) {
  fbb.Finish(root, ISRCollectionRequirements_AbridgedIdentifier());
}

inline void FinishSizePrefixedISRCollectionRequirements_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ISRCollectionRequirements_Abridged> root) {
  fbb.FinishSizePrefixed(root, ISRCollectionRequirements_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
