// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Sensorlimits_Abridged;
struct Sensorlimits_AbridgedBuilder;

enum Sensorlimits_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Sensorlimits_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Sensorlimits_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Sensorlimits_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Sensorlimits_Abridged_dataMode_Enum_EXERCISE = 3,
  Sensorlimits_Abridged_dataMode_Enum_MIN = Sensorlimits_Abridged_dataMode_Enum_REAL,
  Sensorlimits_Abridged_dataMode_Enum_MAX = Sensorlimits_Abridged_dataMode_Enum_EXERCISE
};

inline const Sensorlimits_Abridged_dataMode_Enum (&EnumValuesSensorlimits_Abridged_dataMode_Enum())[4] {
  static const Sensorlimits_Abridged_dataMode_Enum values[] = {
    Sensorlimits_Abridged_dataMode_Enum_REAL,
    Sensorlimits_Abridged_dataMode_Enum_TEST,
    Sensorlimits_Abridged_dataMode_Enum_SIMULATED,
    Sensorlimits_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSensorlimits_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorlimits_Abridged_dataMode_Enum(Sensorlimits_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Sensorlimits_Abridged_dataMode_Enum_REAL, Sensorlimits_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorlimits_Abridged_dataMode_Enum()[index];
}

/// /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
struct Sensorlimits_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Sensorlimits_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDSENSORLIMITS = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_ORIGNETWORK = 8,
    VT_UPPERLEFTAZIMUTHLIMIT = 10,
    VT_UPPERRIGHTAZIMUTHLIMIT = 12,
    VT_LOWERRIGHTAZIMUTHLIMIT = 14,
    VT_LOWERLEFTAZIMUTHLIMIT = 16,
    VT_LOWERLEFTELEVATIONLIMIT = 18,
    VT_UPPERLEFTELEVATIONLIMIT = 20,
    VT_LOWERRIGHTELEVATIONLIMIT = 22,
    VT_UPPERRIGHTELEVATIONLIMIT = 24,
    VT_SOURCE = 26,
    VT_DATAMODE = 28,
    VT_CREATEDAT = 30,
    VT_CREATEDBY = 32,
    VT_IDSENSOR = 34
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SENSORLIMITS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idSensorLimits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSORLIMITS);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperLeftAzimuthLimit() const {
    return GetField<double>(VT_UPPERLEFTAZIMUTHLIMIT, 0.0);
  }
  /// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperRightAzimuthLimit() const {
    return GetField<double>(VT_UPPERRIGHTAZIMUTHLIMIT, 0.0);
  }
  /// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerRightAzimuthLimit() const {
    return GetField<double>(VT_LOWERRIGHTAZIMUTHLIMIT, 0.0);
  }
  /// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerLeftAzimuthLimit() const {
    return GetField<double>(VT_LOWERLEFTAZIMUTHLIMIT, 0.0);
  }
  /// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerLeftElevationLimit() const {
    return GetField<double>(VT_LOWERLEFTELEVATIONLIMIT, 0.0);
  }
  /// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperLeftElevationLimit() const {
    return GetField<double>(VT_UPPERLEFTELEVATIONLIMIT, 0.0);
  }
  /// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerRightElevationLimit() const {
    return GetField<double>(VT_LOWERRIGHTELEVATIONLIMIT, 0.0);
  }
  /// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperRightElevationLimit() const {
    return GetField<double>(VT_UPPERRIGHTELEVATIONLIMIT, 0.0);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Sensorlimits_Abridged_dataMode_Enum dataMode() const {
    return static_cast<Sensorlimits_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Unique identifier of the target sensor object.
  /// Example: /// Example: SENSORLIMITS-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDSENSORLIMITS) &&
           verifier.VerifyString(idSensorLimits()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<double>(verifier, VT_UPPERLEFTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPERRIGHTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERRIGHTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERLEFTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERLEFTELEVATIONLIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPERLEFTELEVATIONLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERRIGHTELEVATIONLIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPERRIGHTELEVATIONLIMIT, 8) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           verifier.EndTable();
  }
};

struct Sensorlimits_AbridgedBuilder {
  typedef Sensorlimits_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idSensorLimits(::flatbuffers::Offset<::flatbuffers::String> idSensorLimits) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_IDSENSORLIMITS, idSensorLimits);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_upperLeftAzimuthLimit(double upperLeftAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_UPPERLEFTAZIMUTHLIMIT, upperLeftAzimuthLimit, 0.0);
  }
  void add_upperRightAzimuthLimit(double upperRightAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_UPPERRIGHTAZIMUTHLIMIT, upperRightAzimuthLimit, 0.0);
  }
  void add_lowerRightAzimuthLimit(double lowerRightAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_LOWERRIGHTAZIMUTHLIMIT, lowerRightAzimuthLimit, 0.0);
  }
  void add_lowerLeftAzimuthLimit(double lowerLeftAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_LOWERLEFTAZIMUTHLIMIT, lowerLeftAzimuthLimit, 0.0);
  }
  void add_lowerLeftElevationLimit(double lowerLeftElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_LOWERLEFTELEVATIONLIMIT, lowerLeftElevationLimit, 0.0);
  }
  void add_upperLeftElevationLimit(double upperLeftElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_UPPERLEFTELEVATIONLIMIT, upperLeftElevationLimit, 0.0);
  }
  void add_lowerRightElevationLimit(double lowerRightElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_LOWERRIGHTELEVATIONLIMIT, lowerRightElevationLimit, 0.0);
  }
  void add_upperRightElevationLimit(double upperRightElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Abridged::VT_UPPERRIGHTELEVATIONLIMIT, upperRightElevationLimit, 0.0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_SOURCE, source);
  }
  void add_dataMode(Sensorlimits_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Sensorlimits_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(Sensorlimits_Abridged::VT_IDSENSOR, idSensor);
  }
  explicit Sensorlimits_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sensorlimits_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sensorlimits_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sensorlimits_Abridged> CreateSensorlimits_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> idSensorLimits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    double upperLeftAzimuthLimit = 0.0,
    double upperRightAzimuthLimit = 0.0,
    double lowerRightAzimuthLimit = 0.0,
    double lowerLeftAzimuthLimit = 0.0,
    double lowerLeftElevationLimit = 0.0,
    double upperLeftElevationLimit = 0.0,
    double lowerRightElevationLimit = 0.0,
    double upperRightElevationLimit = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    Sensorlimits_Abridged_dataMode_Enum dataMode = Sensorlimits_Abridged_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0) {
  Sensorlimits_AbridgedBuilder builder_(_fbb);
  builder_.add_upperRightElevationLimit(upperRightElevationLimit);
  builder_.add_lowerRightElevationLimit(lowerRightElevationLimit);
  builder_.add_upperLeftElevationLimit(upperLeftElevationLimit);
  builder_.add_lowerLeftElevationLimit(lowerLeftElevationLimit);
  builder_.add_lowerLeftAzimuthLimit(lowerLeftAzimuthLimit);
  builder_.add_lowerRightAzimuthLimit(lowerRightAzimuthLimit);
  builder_.add_upperRightAzimuthLimit(upperRightAzimuthLimit);
  builder_.add_upperLeftAzimuthLimit(upperLeftAzimuthLimit);
  builder_.add_idSensor(idSensor);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_source(source);
  builder_.add_origNetwork(origNetwork);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idSensorLimits(idSensorLimits);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sensorlimits_Abridged> CreateSensorlimits_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *idSensorLimits = nullptr,
    const char *classificationMarking = nullptr,
    const char *origNetwork = nullptr,
    double upperLeftAzimuthLimit = 0.0,
    double upperRightAzimuthLimit = 0.0,
    double lowerRightAzimuthLimit = 0.0,
    double lowerLeftAzimuthLimit = 0.0,
    double lowerLeftElevationLimit = 0.0,
    double upperLeftElevationLimit = 0.0,
    double lowerRightElevationLimit = 0.0,
    double upperRightElevationLimit = 0.0,
    const char *source = nullptr,
    Sensorlimits_Abridged_dataMode_Enum dataMode = Sensorlimits_Abridged_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *idSensor = nullptr) {
  auto idSensorLimits__ = idSensorLimits ? _fbb.CreateString(idSensorLimits) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  return CreateSensorlimits_Abridged(
      _fbb,
      idSensorLimits__,
      classificationMarking__,
      origNetwork__,
      upperLeftAzimuthLimit,
      upperRightAzimuthLimit,
      lowerRightAzimuthLimit,
      lowerLeftAzimuthLimit,
      lowerLeftElevationLimit,
      upperLeftElevationLimit,
      lowerRightElevationLimit,
      upperRightElevationLimit,
      source__,
      dataMode,
      createdAt__,
      createdBy__,
      idSensor__);
}

inline const Sensorlimits_Abridged *GetSensorlimits_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<Sensorlimits_Abridged>(buf);
}

inline const Sensorlimits_Abridged *GetSizePrefixedSensorlimits_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Sensorlimits_Abridged>(buf);
}

inline const char *Sensorlimits_AbridgedIdentifier() {
  return "SENS";
}

inline bool Sensorlimits_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Sensorlimits_AbridgedIdentifier());
}

inline bool SizePrefixedSensorlimits_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Sensorlimits_AbridgedIdentifier(), true);
}

inline bool VerifySensorlimits_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Sensorlimits_Abridged>(Sensorlimits_AbridgedIdentifier());
}

inline bool VerifySizePrefixedSensorlimits_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Sensorlimits_Abridged>(Sensorlimits_AbridgedIdentifier());
}

inline void FinishSensorlimits_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Sensorlimits_Abridged> root) {
  fbb.Finish(root, Sensorlimits_AbridgedIdentifier());
}

inline void FinishSizePrefixedSensorlimits_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Sensorlimits_Abridged> root) {
  fbb.FinishSizePrefixed(root, Sensorlimits_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
