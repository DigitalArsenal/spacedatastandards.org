// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct MonoRadar_Full;
struct MonoRadar_FullBuilder;

enum MonoRadar_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  MonoRadar_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  MonoRadar_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  MonoRadar_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  MonoRadar_Full_dataMode_Enum_EXERCISE = 3,
  MonoRadar_Full_dataMode_Enum_MIN = MonoRadar_Full_dataMode_Enum_REAL,
  MonoRadar_Full_dataMode_Enum_MAX = MonoRadar_Full_dataMode_Enum_EXERCISE
};

inline const MonoRadar_Full_dataMode_Enum (&EnumValuesMonoRadar_Full_dataMode_Enum())[4] {
  static const MonoRadar_Full_dataMode_Enum values[] = {
    MonoRadar_Full_dataMode_Enum_REAL,
    MonoRadar_Full_dataMode_Enum_TEST,
    MonoRadar_Full_dataMode_Enum_SIMULATED,
    MonoRadar_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesMonoRadar_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameMonoRadar_Full_dataMode_Enum(MonoRadar_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, MonoRadar_Full_dataMode_Enum_REAL, MonoRadar_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMonoRadar_Full_dataMode_Enum()[index];
}

/// /// A monoradar record contains the raw, and in some cases, processed target reports from primary and secondary air surveillance radars.  All target positions for monoradar reports are recorded as range and azimuth from geographical North relative to the detecting radar site.  In the case of secondary surveillance radars, interrogation response codes are provided as well as quality and validation characteristics, when available in the particular record type used to generate the record.
struct MonoRadar_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MonoRadar_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_TTI = 8,
    VT_IDSENSOR = 10,
    VT_SENLAT = 12,
    VT_SENLON = 14,
    VT_SENALT = 16,
    VT_SAC = 18,
    VT_SIC = 20,
    VT_TGTID = 22,
    VT_ADDR = 24,
    VT_MSGFMT = 26,
    VT_MSGTYP = 28,
    VT_AF = 30,
    VT_FAA = 32,
    VT_SPI = 34,
    VT_AIMS = 36,
    VT_MTI = 38,
    VT_BCNHITS = 40,
    VT_TS = 42,
    VT_MSGTS = 44,
    VT_RNG = 46,
    VT_AZ = 48,
    VT_ACP = 50,
    VT_ALT3D = 52,
    VT_MC = 54,
    VT_MCV = 56,
    VT_MCG = 58,
    VT_M1 = 60,
    VT_M1V = 62,
    VT_M1G = 64,
    VT_M2 = 66,
    VT_M2V = 68,
    VT_M2XV = 70,
    VT_M2G = 72,
    VT_M3A = 74,
    VT_M3AV = 76,
    VT_M3AG = 78,
    VT_M3AXV = 80,
    VT_M4 = 82,
    VT_M4V = 84,
    VT_M4D1D2 = 86,
    VT_MSCOMMB = 88,
    VT_MILEMRGCY = 90,
    VT_CODE7500 = 92,
    VT_CODE7600 = 94,
    VT_CODE7700 = 96,
    VT_GRNDSPD = 98,
    VT_HDNG = 100,
    VT_TRKNUM = 102,
    VT_RAD = 104,
    VT_MAH = 106,
    VT_CDM = 108,
    VT_CARTPOS = 110,
    VT_PSRRL = 112,
    VT_SSRL = 114,
    VT_RNGDELT = 116,
    VT_AZDELT = 118,
    VT_WECTC = 120,
    VT_MRGRPT = 122,
    VT_ARTSQUAL = 124,
    VT_TRKELIG = 126,
    VT_TGTCONF = 128,
    VT_TGTCORR = 130,
    VT_TIS = 132,
    VT_TAGS = 134,
    VT_ORIGSENSORID = 136,
    VT_SOURCE = 138,
    VT_ORIGIN = 140,
    VT_DATAMODE = 142,
    VT_CREATEDAT = 144,
    VT_CREATEDBY = 146,
    VT_ORIGNETWORK = 148
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: MONORADAR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Test target indicator.
  /// Example: /// Example: TTI
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *tti() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TTI);
  }
  /// ID of the radar site or station providing the data.
  /// Example: /// Example: REF-SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Sensor WGS84 latitude, in degrees, at time of observation (ts). -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double senlat() const {
    return GetField<double>(VT_SENLAT, 0.0);
  }
  /// Sensor WGS84 longitude, in degrees, at time of observation (ts).  -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double senlon() const {
    return GetField<double>(VT_SENLON, 0.0);
  }
  /// Sensor altitude, in kilometers, at time of observation (ts).
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double senalt() const {
    return GetField<double>(VT_SENALT, 0.0);
  }
  /// System Area Code.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t sac() const {
    return GetField<int32_t>(VT_SAC, 0);
  }
  /// System Identification Code.
  /// Example: /// Example: 40
  /// Constraints: No constraints specified.
  int32_t sic() const {
    return GetField<int32_t>(VT_SIC, 0);
  }
  /// Aircraft identification from an aircraft equipped with a Mode S transponder.
  /// Example: /// Example: TGT-ID
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *tgtid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TGTID);
  }
  /// Aircraft address (24-bits Mode S address) assigned uniquely to each aircraft.
  /// Example: /// Example: ADDR-ID
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *addr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ADDR);
  }
  /// Message format received (i.e. 'ASR9', 'CAT48', 'TPS70', etc..).
  /// Example: /// Example: CAT48
  /// Constraints: Minimum length = 1, Maximum length = 16
  const ::flatbuffers::String *msgfmt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGFMT);
  }
  /// Message report type received (i.e. 'SRCH', 'BCN', 'REINF', 'BRTQC', 'PSR', etc..).
  /// Example: /// Example: BCN
  /// Constraints: Minimum length = 1, Maximum length = 16
  const ::flatbuffers::String *msgtyp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGTYP);
  }
  /// Flag indicating military message.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool af() const {
    return GetField<uint8_t>(VT_AF, 0) != 0;
  }
  /// Flag indicating FAA/Civ message.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool faa() const {
    return GetField<uint8_t>(VT_FAA, 0) != 0;
  }
  /// Flag indicating whether Special Position Indicator (SPI) present in interrogation response.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool spi() const {
    return GetField<uint8_t>(VT_SPI, 0) != 0;
  }
  /// Flag indicating whether AIMS present.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool aims() const {
    return GetField<uint8_t>(VT_AIMS, 0) != 0;
  }
  /// Flag indicating that target was detected using data from an MTI receiver.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool mti() const {
    return GetField<uint8_t>(VT_MTI, 0) != 0;
  }
  /// Number of beacon hits received on the target.
  /// Example: /// Example: 12
  /// Constraints: No constraints specified.
  int32_t bcnhits() const {
    return GetField<int32_t>(VT_BCNHITS, 0);
  }
  /// Target detection time, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *ts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  /// Message time, in ISO 8601 UTC format with microsecond precision. This is the time that the data message was released from the site.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *msgts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGTS);
  }
  /// Measured slant range to target from the observing site, in km.
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double rng() const {
    return GetField<double>(VT_RNG, 0.0);
  }
  /// Target azimuth, measured from the observing site, in degrees from true North.  If Azimuth Change Pulse (acp) count is provided, az represents the computed angle.
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double az() const {
    return GetField<double>(VT_AZ, 0.0);
  }
  /// Azimuth Change Pulse count at target detection.
  /// Example: /// Example: 100
  /// Constraints: No constraints specified.
  int32_t acp() const {
    return GetField<int32_t>(VT_ACP, 0);
  }
  /// Measured height of the target, in km. (for 3D radars).
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double alt3d() const {
    return GetField<double>(VT_ALT3D, 0.0);
  }
  /// Mode-C altitude (uncorrected pressure altitude), in km.
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double mc() const {
    return GetField<double>(VT_MC, 0.0);
  }
  /// Status of the mode-C validity bit.
  /// Example: /// Example: MCV
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *mcv() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MCV);
  }
  /// Indicator that the mode-C response was garbled.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool mcg() const {
    return GetField<uint8_t>(VT_MCG, 0) != 0;
  }
  /// Mode-1 interrogation response (mission code).
  /// Example: /// Example: MISSION_CODE
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *m1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M1);
  }
  /// Status of the mode-1 validity bit.
  /// Example: /// Example: M1V
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *m1v() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M1V);
  }
  /// Indicator that the mode-1 response was garbled.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool m1g() const {
    return GetField<uint8_t>(VT_M1G, 0) != 0;
  }
  /// Mode-2 interrogation response (military identification code).
  /// Example: /// Example: MILITARY_ID_CODE
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *m2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M2);
  }
  /// Status of the mode-2 validity bit.
  /// Example: /// Example: M2V
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *m2v() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M2V);
  }
  /// Status of the mode-2 X-Pulse response validation.
  /// Example: /// Example: M2XV
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *m2xv() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M2XV);
  }
  /// Indicator that the mode-2 response was garbled.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool m2g() const {
    return GetField<uint8_t>(VT_M2G, 0) != 0;
  }
  /// Mode-3/A interrogation response (aircraft identification).
  /// Example: /// Example: AIRCRAFT_ID
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *m3a() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M3A);
  }
  /// Status of the mode-3/A validity bit.
  /// Example: /// Example: M3AV
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *m3av() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M3AV);
  }
  /// Indicator that the mode-3/A response was garbled.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool m3ag() const {
    return GetField<uint8_t>(VT_M3AG, 0) != 0;
  }
  /// Status of the mode-3 X-Pulse response validation.
  /// Example: /// Example: M3AXV
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *m3axv() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M3AXV);
  }
  /// Mode-4 interrogation response (Identification Friend/Foe).
  /// Example: /// Example: ID_FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *m4() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M4);
  }
  /// Status of the mode-4 validity bit.
  /// Example: /// Example: M4V
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *m4v() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M4V);
  }
  /// Mode-4 D1 & D2 response status.
  /// Example: /// Example: STATUS
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *m4d1d2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_M4D1D2);
  }
  /// Mode-S Comm B message data.
  /// Example: /// Example: MSCOMMB
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *mscommb() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSCOMMB);
  }
  /// Flag indicating military emergency.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool milemrgcy() const {
    return GetField<uint8_t>(VT_MILEMRGCY, 0) != 0;
  }
  /// 7500 squawk present (hijack).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool code7500() const {
    return GetField<uint8_t>(VT_CODE7500, 0) != 0;
  }
  /// 7600 squawk present (loss of comm).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool code7600() const {
    return GetField<uint8_t>(VT_CODE7600, 0) != 0;
  }
  /// 7700 squawk present (general emergency).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool code7700() const {
    return GetField<uint8_t>(VT_CODE7700, 0) != 0;
  }
  /// Target ground speed, in meters/second.
  /// Example: /// Example: 30.23
  /// Constraints: No constraints specified.
  double grndspd() const {
    return GetField<double>(VT_GRNDSPD, 0.0);
  }
  /// Target heading, in degrees from true North at the target position.
  /// Example: /// Example: 30.23
  /// Constraints: No constraints specified.
  double hdng() const {
    return GetField<double>(VT_HDNG, 0.0);
  }
  /// Value representing a unique reference to a track record within a particular track file.  Included when the  radar station outputs tracks.
  /// Example: /// Example: 30
  /// Constraints: No constraints specified.
  int32_t trknum() const {
    return GetField<int32_t>(VT_TRKNUM, 0);
  }
  /// Type of sensor(s) maintaining track.
  /// Example: /// Example: RAD
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *rad() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAD);
  }
  /// Indication of Horizontal Maneuver detection.
  /// Example: /// Example: MAH
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *mah() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MAH);
  }
  /// Climbing/Descending mode indicator.
  /// Example: /// Example: CDM
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *cdm() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CDM);
  }
  /// Array of local 2d-cartesian [x, y] coordinates of target, in km.
  /// Example: /// Example: [1.2, 2.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *cartpos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_CARTPOS);
  }
  /// Runlength of the primary surveillance radar track, in degrees.
  /// Example: /// Example: 44.23
  /// Constraints: No constraints specified.
  double psrrl() const {
    return GetField<double>(VT_PSRRL, 0.0);
  }
  /// Runlength of the secondary surveillance radar track, in degrees.
  /// Example: /// Example: 44.23
  /// Constraints: No constraints specified.
  double ssrl() const {
    return GetField<double>(VT_SSRL, 0.0);
  }
  /// Target range delta between PSR and SSR (reference PSR-SSR), in km.
  /// Example: /// Example: 44.23
  /// Constraints: No constraints specified.
  double rngdelt() const {
    return GetField<double>(VT_RNGDELT, 0.0);
  }
  /// Target azimuth delta between PSR and SSR (reference PSR-SSR), in degrees.
  /// Example: /// Example: 44.23
  /// Constraints: No constraints specified.
  double azdelt() const {
    return GetField<double>(VT_AZDELT, 0.0);
  }
  /// Warning/Error Conditions and Target Classification.
  /// Example: /// Example: ['WARNING', 'WARNING']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *wectc() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_WECTC);
  }
  /// Flag indicating report separated from different responses at same range.  Azimuth may have larger than normal error when present.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool mrgrpt() const {
    return GetField<uint8_t>(VT_MRGRPT, 0) != 0;
  }
  /// ARTS quality.
  /// Example: /// Example: QUALITY
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *artsqual() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARTSQUAL);
  }
  /// Track eligibility flag.
  /// Example: /// Example: ELIGIBILITY
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *trkelig() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRKELIG);
  }
  /// Target confidence.
  /// Example: /// Example: CONFIDENCE
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *tgtconf() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TGTCONF);
  }
  /// Target correlation flag.
  /// Example: /// Example: CORRELATION
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *tgtcorr() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TGTCORR);
  }
  /// Data time-in-storage, in seconds. This is the amount of time elapsed between target detection and message transmission.
  /// Example: /// Example: 0.4
  /// Constraints: No constraints specified.
  double tis() const {
    return GetField<double>(VT_TIS, 0.0);
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// Optional identifier provided by observation source to indicate the sensor identifier which produced this observation.This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  MonoRadar_Full_dataMode_Enum dataMode() const {
    return static_cast<MonoRadar_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_TTI) &&
           verifier.VerifyString(tti()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyField<double>(verifier, VT_SENLAT, 8) &&
           VerifyField<double>(verifier, VT_SENLON, 8) &&
           VerifyField<double>(verifier, VT_SENALT, 8) &&
           VerifyField<int32_t>(verifier, VT_SAC, 4) &&
           VerifyField<int32_t>(verifier, VT_SIC, 4) &&
           VerifyOffset(verifier, VT_TGTID) &&
           verifier.VerifyString(tgtid()) &&
           VerifyOffset(verifier, VT_ADDR) &&
           verifier.VerifyString(addr()) &&
           VerifyOffset(verifier, VT_MSGFMT) &&
           verifier.VerifyString(msgfmt()) &&
           VerifyOffset(verifier, VT_MSGTYP) &&
           verifier.VerifyString(msgtyp()) &&
           VerifyField<uint8_t>(verifier, VT_AF, 1) &&
           VerifyField<uint8_t>(verifier, VT_FAA, 1) &&
           VerifyField<uint8_t>(verifier, VT_SPI, 1) &&
           VerifyField<uint8_t>(verifier, VT_AIMS, 1) &&
           VerifyField<uint8_t>(verifier, VT_MTI, 1) &&
           VerifyField<int32_t>(verifier, VT_BCNHITS, 4) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(ts()) &&
           VerifyOffset(verifier, VT_MSGTS) &&
           verifier.VerifyString(msgts()) &&
           VerifyField<double>(verifier, VT_RNG, 8) &&
           VerifyField<double>(verifier, VT_AZ, 8) &&
           VerifyField<int32_t>(verifier, VT_ACP, 4) &&
           VerifyField<double>(verifier, VT_ALT3D, 8) &&
           VerifyField<double>(verifier, VT_MC, 8) &&
           VerifyOffset(verifier, VT_MCV) &&
           verifier.VerifyString(mcv()) &&
           VerifyField<uint8_t>(verifier, VT_MCG, 1) &&
           VerifyOffset(verifier, VT_M1) &&
           verifier.VerifyString(m1()) &&
           VerifyOffset(verifier, VT_M1V) &&
           verifier.VerifyString(m1v()) &&
           VerifyField<uint8_t>(verifier, VT_M1G, 1) &&
           VerifyOffset(verifier, VT_M2) &&
           verifier.VerifyString(m2()) &&
           VerifyOffset(verifier, VT_M2V) &&
           verifier.VerifyString(m2v()) &&
           VerifyOffset(verifier, VT_M2XV) &&
           verifier.VerifyString(m2xv()) &&
           VerifyField<uint8_t>(verifier, VT_M2G, 1) &&
           VerifyOffset(verifier, VT_M3A) &&
           verifier.VerifyString(m3a()) &&
           VerifyOffset(verifier, VT_M3AV) &&
           verifier.VerifyString(m3av()) &&
           VerifyField<uint8_t>(verifier, VT_M3AG, 1) &&
           VerifyOffset(verifier, VT_M3AXV) &&
           verifier.VerifyString(m3axv()) &&
           VerifyOffset(verifier, VT_M4) &&
           verifier.VerifyString(m4()) &&
           VerifyOffset(verifier, VT_M4V) &&
           verifier.VerifyString(m4v()) &&
           VerifyOffset(verifier, VT_M4D1D2) &&
           verifier.VerifyString(m4d1d2()) &&
           VerifyOffset(verifier, VT_MSCOMMB) &&
           verifier.VerifyString(mscommb()) &&
           VerifyField<uint8_t>(verifier, VT_MILEMRGCY, 1) &&
           VerifyField<uint8_t>(verifier, VT_CODE7500, 1) &&
           VerifyField<uint8_t>(verifier, VT_CODE7600, 1) &&
           VerifyField<uint8_t>(verifier, VT_CODE7700, 1) &&
           VerifyField<double>(verifier, VT_GRNDSPD, 8) &&
           VerifyField<double>(verifier, VT_HDNG, 8) &&
           VerifyField<int32_t>(verifier, VT_TRKNUM, 4) &&
           VerifyOffset(verifier, VT_RAD) &&
           verifier.VerifyString(rad()) &&
           VerifyOffset(verifier, VT_MAH) &&
           verifier.VerifyString(mah()) &&
           VerifyOffset(verifier, VT_CDM) &&
           verifier.VerifyString(cdm()) &&
           VerifyOffset(verifier, VT_CARTPOS) &&
           verifier.VerifyVector(cartpos()) &&
           verifier.VerifyVectorOfStrings(cartpos()) &&
           VerifyField<double>(verifier, VT_PSRRL, 8) &&
           VerifyField<double>(verifier, VT_SSRL, 8) &&
           VerifyField<double>(verifier, VT_RNGDELT, 8) &&
           VerifyField<double>(verifier, VT_AZDELT, 8) &&
           VerifyOffset(verifier, VT_WECTC) &&
           verifier.VerifyVector(wectc()) &&
           verifier.VerifyVectorOfStrings(wectc()) &&
           VerifyField<uint8_t>(verifier, VT_MRGRPT, 1) &&
           VerifyOffset(verifier, VT_ARTSQUAL) &&
           verifier.VerifyString(artsqual()) &&
           VerifyOffset(verifier, VT_TRKELIG) &&
           verifier.VerifyString(trkelig()) &&
           VerifyOffset(verifier, VT_TGTCONF) &&
           verifier.VerifyString(tgtconf()) &&
           VerifyOffset(verifier, VT_TGTCORR) &&
           verifier.VerifyString(tgtcorr()) &&
           VerifyField<double>(verifier, VT_TIS, 8) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct MonoRadar_FullBuilder {
  typedef MonoRadar_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(MonoRadar_Full::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(MonoRadar_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_tti(::flatbuffers::Offset<::flatbuffers::String> tti) {
    fbb_.AddOffset(MonoRadar_Full::VT_TTI, tti);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(MonoRadar_Full::VT_IDSENSOR, idSensor);
  }
  void add_senlat(double senlat) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_SENLAT, senlat, 0.0);
  }
  void add_senlon(double senlon) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_SENLON, senlon, 0.0);
  }
  void add_senalt(double senalt) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_SENALT, senalt, 0.0);
  }
  void add_sac(int32_t sac) {
    fbb_.AddElement<int32_t>(MonoRadar_Full::VT_SAC, sac, 0);
  }
  void add_sic(int32_t sic) {
    fbb_.AddElement<int32_t>(MonoRadar_Full::VT_SIC, sic, 0);
  }
  void add_tgtid(::flatbuffers::Offset<::flatbuffers::String> tgtid) {
    fbb_.AddOffset(MonoRadar_Full::VT_TGTID, tgtid);
  }
  void add_addr(::flatbuffers::Offset<::flatbuffers::String> addr) {
    fbb_.AddOffset(MonoRadar_Full::VT_ADDR, addr);
  }
  void add_msgfmt(::flatbuffers::Offset<::flatbuffers::String> msgfmt) {
    fbb_.AddOffset(MonoRadar_Full::VT_MSGFMT, msgfmt);
  }
  void add_msgtyp(::flatbuffers::Offset<::flatbuffers::String> msgtyp) {
    fbb_.AddOffset(MonoRadar_Full::VT_MSGTYP, msgtyp);
  }
  void add_af(bool af) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_AF, static_cast<uint8_t>(af), 0);
  }
  void add_faa(bool faa) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_FAA, static_cast<uint8_t>(faa), 0);
  }
  void add_spi(bool spi) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_SPI, static_cast<uint8_t>(spi), 0);
  }
  void add_aims(bool aims) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_AIMS, static_cast<uint8_t>(aims), 0);
  }
  void add_mti(bool mti) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_MTI, static_cast<uint8_t>(mti), 0);
  }
  void add_bcnhits(int32_t bcnhits) {
    fbb_.AddElement<int32_t>(MonoRadar_Full::VT_BCNHITS, bcnhits, 0);
  }
  void add_ts(::flatbuffers::Offset<::flatbuffers::String> ts) {
    fbb_.AddOffset(MonoRadar_Full::VT_TS, ts);
  }
  void add_msgts(::flatbuffers::Offset<::flatbuffers::String> msgts) {
    fbb_.AddOffset(MonoRadar_Full::VT_MSGTS, msgts);
  }
  void add_rng(double rng) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_RNG, rng, 0.0);
  }
  void add_az(double az) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_AZ, az, 0.0);
  }
  void add_acp(int32_t acp) {
    fbb_.AddElement<int32_t>(MonoRadar_Full::VT_ACP, acp, 0);
  }
  void add_alt3d(double alt3d) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_ALT3D, alt3d, 0.0);
  }
  void add_mc(double mc) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_MC, mc, 0.0);
  }
  void add_mcv(::flatbuffers::Offset<::flatbuffers::String> mcv) {
    fbb_.AddOffset(MonoRadar_Full::VT_MCV, mcv);
  }
  void add_mcg(bool mcg) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_MCG, static_cast<uint8_t>(mcg), 0);
  }
  void add_m1(::flatbuffers::Offset<::flatbuffers::String> m1) {
    fbb_.AddOffset(MonoRadar_Full::VT_M1, m1);
  }
  void add_m1v(::flatbuffers::Offset<::flatbuffers::String> m1v) {
    fbb_.AddOffset(MonoRadar_Full::VT_M1V, m1v);
  }
  void add_m1g(bool m1g) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_M1G, static_cast<uint8_t>(m1g), 0);
  }
  void add_m2(::flatbuffers::Offset<::flatbuffers::String> m2) {
    fbb_.AddOffset(MonoRadar_Full::VT_M2, m2);
  }
  void add_m2v(::flatbuffers::Offset<::flatbuffers::String> m2v) {
    fbb_.AddOffset(MonoRadar_Full::VT_M2V, m2v);
  }
  void add_m2xv(::flatbuffers::Offset<::flatbuffers::String> m2xv) {
    fbb_.AddOffset(MonoRadar_Full::VT_M2XV, m2xv);
  }
  void add_m2g(bool m2g) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_M2G, static_cast<uint8_t>(m2g), 0);
  }
  void add_m3a(::flatbuffers::Offset<::flatbuffers::String> m3a) {
    fbb_.AddOffset(MonoRadar_Full::VT_M3A, m3a);
  }
  void add_m3av(::flatbuffers::Offset<::flatbuffers::String> m3av) {
    fbb_.AddOffset(MonoRadar_Full::VT_M3AV, m3av);
  }
  void add_m3ag(bool m3ag) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_M3AG, static_cast<uint8_t>(m3ag), 0);
  }
  void add_m3axv(::flatbuffers::Offset<::flatbuffers::String> m3axv) {
    fbb_.AddOffset(MonoRadar_Full::VT_M3AXV, m3axv);
  }
  void add_m4(::flatbuffers::Offset<::flatbuffers::String> m4) {
    fbb_.AddOffset(MonoRadar_Full::VT_M4, m4);
  }
  void add_m4v(::flatbuffers::Offset<::flatbuffers::String> m4v) {
    fbb_.AddOffset(MonoRadar_Full::VT_M4V, m4v);
  }
  void add_m4d1d2(::flatbuffers::Offset<::flatbuffers::String> m4d1d2) {
    fbb_.AddOffset(MonoRadar_Full::VT_M4D1D2, m4d1d2);
  }
  void add_mscommb(::flatbuffers::Offset<::flatbuffers::String> mscommb) {
    fbb_.AddOffset(MonoRadar_Full::VT_MSCOMMB, mscommb);
  }
  void add_milemrgcy(bool milemrgcy) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_MILEMRGCY, static_cast<uint8_t>(milemrgcy), 0);
  }
  void add_code7500(bool code7500) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_CODE7500, static_cast<uint8_t>(code7500), 0);
  }
  void add_code7600(bool code7600) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_CODE7600, static_cast<uint8_t>(code7600), 0);
  }
  void add_code7700(bool code7700) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_CODE7700, static_cast<uint8_t>(code7700), 0);
  }
  void add_grndspd(double grndspd) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_GRNDSPD, grndspd, 0.0);
  }
  void add_hdng(double hdng) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_HDNG, hdng, 0.0);
  }
  void add_trknum(int32_t trknum) {
    fbb_.AddElement<int32_t>(MonoRadar_Full::VT_TRKNUM, trknum, 0);
  }
  void add_rad(::flatbuffers::Offset<::flatbuffers::String> rad) {
    fbb_.AddOffset(MonoRadar_Full::VT_RAD, rad);
  }
  void add_mah(::flatbuffers::Offset<::flatbuffers::String> mah) {
    fbb_.AddOffset(MonoRadar_Full::VT_MAH, mah);
  }
  void add_cdm(::flatbuffers::Offset<::flatbuffers::String> cdm) {
    fbb_.AddOffset(MonoRadar_Full::VT_CDM, cdm);
  }
  void add_cartpos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cartpos) {
    fbb_.AddOffset(MonoRadar_Full::VT_CARTPOS, cartpos);
  }
  void add_psrrl(double psrrl) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_PSRRL, psrrl, 0.0);
  }
  void add_ssrl(double ssrl) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_SSRL, ssrl, 0.0);
  }
  void add_rngdelt(double rngdelt) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_RNGDELT, rngdelt, 0.0);
  }
  void add_azdelt(double azdelt) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_AZDELT, azdelt, 0.0);
  }
  void add_wectc(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> wectc) {
    fbb_.AddOffset(MonoRadar_Full::VT_WECTC, wectc);
  }
  void add_mrgrpt(bool mrgrpt) {
    fbb_.AddElement<uint8_t>(MonoRadar_Full::VT_MRGRPT, static_cast<uint8_t>(mrgrpt), 0);
  }
  void add_artsqual(::flatbuffers::Offset<::flatbuffers::String> artsqual) {
    fbb_.AddOffset(MonoRadar_Full::VT_ARTSQUAL, artsqual);
  }
  void add_trkelig(::flatbuffers::Offset<::flatbuffers::String> trkelig) {
    fbb_.AddOffset(MonoRadar_Full::VT_TRKELIG, trkelig);
  }
  void add_tgtconf(::flatbuffers::Offset<::flatbuffers::String> tgtconf) {
    fbb_.AddOffset(MonoRadar_Full::VT_TGTCONF, tgtconf);
  }
  void add_tgtcorr(::flatbuffers::Offset<::flatbuffers::String> tgtcorr) {
    fbb_.AddOffset(MonoRadar_Full::VT_TGTCORR, tgtcorr);
  }
  void add_tis(double tis) {
    fbb_.AddElement<double>(MonoRadar_Full::VT_TIS, tis, 0.0);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(MonoRadar_Full::VT_TAGS, tags);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(MonoRadar_Full::VT_ORIGSENSORID, origSensorId);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(MonoRadar_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(MonoRadar_Full::VT_ORIGIN, origin);
  }
  void add_dataMode(MonoRadar_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(MonoRadar_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(MonoRadar_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(MonoRadar_Full::VT_CREATEDBY, createdBy);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(MonoRadar_Full::VT_ORIGNETWORK, origNetwork);
  }
  explicit MonoRadar_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MonoRadar_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MonoRadar_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MonoRadar_Full> CreateMonoRadar_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tti = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    int32_t sac = 0,
    int32_t sic = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tgtid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> addr = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgfmt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgtyp = 0,
    bool af = false,
    bool faa = false,
    bool spi = false,
    bool aims = false,
    bool mti = false,
    int32_t bcnhits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgts = 0,
    double rng = 0.0,
    double az = 0.0,
    int32_t acp = 0,
    double alt3d = 0.0,
    double mc = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> mcv = 0,
    bool mcg = false,
    ::flatbuffers::Offset<::flatbuffers::String> m1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m1v = 0,
    bool m1g = false,
    ::flatbuffers::Offset<::flatbuffers::String> m2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m2v = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m2xv = 0,
    bool m2g = false,
    ::flatbuffers::Offset<::flatbuffers::String> m3a = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m3av = 0,
    bool m3ag = false,
    ::flatbuffers::Offset<::flatbuffers::String> m3axv = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m4 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m4v = 0,
    ::flatbuffers::Offset<::flatbuffers::String> m4d1d2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mscommb = 0,
    bool milemrgcy = false,
    bool code7500 = false,
    bool code7600 = false,
    bool code7700 = false,
    double grndspd = 0.0,
    double hdng = 0.0,
    int32_t trknum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rad = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mah = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cdm = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> cartpos = 0,
    double psrrl = 0.0,
    double ssrl = 0.0,
    double rngdelt = 0.0,
    double azdelt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> wectc = 0,
    bool mrgrpt = false,
    ::flatbuffers::Offset<::flatbuffers::String> artsqual = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trkelig = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tgtconf = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tgtcorr = 0,
    double tis = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    MonoRadar_Full_dataMode_Enum dataMode = MonoRadar_Full_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  MonoRadar_FullBuilder builder_(_fbb);
  builder_.add_tis(tis);
  builder_.add_azdelt(azdelt);
  builder_.add_rngdelt(rngdelt);
  builder_.add_ssrl(ssrl);
  builder_.add_psrrl(psrrl);
  builder_.add_hdng(hdng);
  builder_.add_grndspd(grndspd);
  builder_.add_mc(mc);
  builder_.add_alt3d(alt3d);
  builder_.add_az(az);
  builder_.add_rng(rng);
  builder_.add_senalt(senalt);
  builder_.add_senlon(senlon);
  builder_.add_senlat(senlat);
  builder_.add_origNetwork(origNetwork);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_origSensorId(origSensorId);
  builder_.add_tags(tags);
  builder_.add_tgtcorr(tgtcorr);
  builder_.add_tgtconf(tgtconf);
  builder_.add_trkelig(trkelig);
  builder_.add_artsqual(artsqual);
  builder_.add_wectc(wectc);
  builder_.add_cartpos(cartpos);
  builder_.add_cdm(cdm);
  builder_.add_mah(mah);
  builder_.add_rad(rad);
  builder_.add_trknum(trknum);
  builder_.add_mscommb(mscommb);
  builder_.add_m4d1d2(m4d1d2);
  builder_.add_m4v(m4v);
  builder_.add_m4(m4);
  builder_.add_m3axv(m3axv);
  builder_.add_m3av(m3av);
  builder_.add_m3a(m3a);
  builder_.add_m2xv(m2xv);
  builder_.add_m2v(m2v);
  builder_.add_m2(m2);
  builder_.add_m1v(m1v);
  builder_.add_m1(m1);
  builder_.add_mcv(mcv);
  builder_.add_acp(acp);
  builder_.add_msgts(msgts);
  builder_.add_ts(ts);
  builder_.add_bcnhits(bcnhits);
  builder_.add_msgtyp(msgtyp);
  builder_.add_msgfmt(msgfmt);
  builder_.add_addr(addr);
  builder_.add_tgtid(tgtid);
  builder_.add_sic(sic);
  builder_.add_sac(sac);
  builder_.add_idSensor(idSensor);
  builder_.add_tti(tti);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_mrgrpt(mrgrpt);
  builder_.add_code7700(code7700);
  builder_.add_code7600(code7600);
  builder_.add_code7500(code7500);
  builder_.add_milemrgcy(milemrgcy);
  builder_.add_m3ag(m3ag);
  builder_.add_m2g(m2g);
  builder_.add_m1g(m1g);
  builder_.add_mcg(mcg);
  builder_.add_mti(mti);
  builder_.add_aims(aims);
  builder_.add_spi(spi);
  builder_.add_faa(faa);
  builder_.add_af(af);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MonoRadar_Full> CreateMonoRadar_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *tti = nullptr,
    const char *idSensor = nullptr,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    int32_t sac = 0,
    int32_t sic = 0,
    const char *tgtid = nullptr,
    const char *addr = nullptr,
    const char *msgfmt = nullptr,
    const char *msgtyp = nullptr,
    bool af = false,
    bool faa = false,
    bool spi = false,
    bool aims = false,
    bool mti = false,
    int32_t bcnhits = 0,
    const char *ts = nullptr,
    const char *msgts = nullptr,
    double rng = 0.0,
    double az = 0.0,
    int32_t acp = 0,
    double alt3d = 0.0,
    double mc = 0.0,
    const char *mcv = nullptr,
    bool mcg = false,
    const char *m1 = nullptr,
    const char *m1v = nullptr,
    bool m1g = false,
    const char *m2 = nullptr,
    const char *m2v = nullptr,
    const char *m2xv = nullptr,
    bool m2g = false,
    const char *m3a = nullptr,
    const char *m3av = nullptr,
    bool m3ag = false,
    const char *m3axv = nullptr,
    const char *m4 = nullptr,
    const char *m4v = nullptr,
    const char *m4d1d2 = nullptr,
    const char *mscommb = nullptr,
    bool milemrgcy = false,
    bool code7500 = false,
    bool code7600 = false,
    bool code7700 = false,
    double grndspd = 0.0,
    double hdng = 0.0,
    int32_t trknum = 0,
    const char *rad = nullptr,
    const char *mah = nullptr,
    const char *cdm = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *cartpos = nullptr,
    double psrrl = 0.0,
    double ssrl = 0.0,
    double rngdelt = 0.0,
    double azdelt = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *wectc = nullptr,
    bool mrgrpt = false,
    const char *artsqual = nullptr,
    const char *trkelig = nullptr,
    const char *tgtconf = nullptr,
    const char *tgtcorr = nullptr,
    double tis = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    const char *origSensorId = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    MonoRadar_Full_dataMode_Enum dataMode = MonoRadar_Full_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto tti__ = tti ? _fbb.CreateString(tti) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto tgtid__ = tgtid ? _fbb.CreateString(tgtid) : 0;
  auto addr__ = addr ? _fbb.CreateString(addr) : 0;
  auto msgfmt__ = msgfmt ? _fbb.CreateString(msgfmt) : 0;
  auto msgtyp__ = msgtyp ? _fbb.CreateString(msgtyp) : 0;
  auto ts__ = ts ? _fbb.CreateString(ts) : 0;
  auto msgts__ = msgts ? _fbb.CreateString(msgts) : 0;
  auto mcv__ = mcv ? _fbb.CreateString(mcv) : 0;
  auto m1__ = m1 ? _fbb.CreateString(m1) : 0;
  auto m1v__ = m1v ? _fbb.CreateString(m1v) : 0;
  auto m2__ = m2 ? _fbb.CreateString(m2) : 0;
  auto m2v__ = m2v ? _fbb.CreateString(m2v) : 0;
  auto m2xv__ = m2xv ? _fbb.CreateString(m2xv) : 0;
  auto m3a__ = m3a ? _fbb.CreateString(m3a) : 0;
  auto m3av__ = m3av ? _fbb.CreateString(m3av) : 0;
  auto m3axv__ = m3axv ? _fbb.CreateString(m3axv) : 0;
  auto m4__ = m4 ? _fbb.CreateString(m4) : 0;
  auto m4v__ = m4v ? _fbb.CreateString(m4v) : 0;
  auto m4d1d2__ = m4d1d2 ? _fbb.CreateString(m4d1d2) : 0;
  auto mscommb__ = mscommb ? _fbb.CreateString(mscommb) : 0;
  auto rad__ = rad ? _fbb.CreateString(rad) : 0;
  auto mah__ = mah ? _fbb.CreateString(mah) : 0;
  auto cdm__ = cdm ? _fbb.CreateString(cdm) : 0;
  auto cartpos__ = cartpos ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*cartpos) : 0;
  auto wectc__ = wectc ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*wectc) : 0;
  auto artsqual__ = artsqual ? _fbb.CreateString(artsqual) : 0;
  auto trkelig__ = trkelig ? _fbb.CreateString(trkelig) : 0;
  auto tgtconf__ = tgtconf ? _fbb.CreateString(tgtconf) : 0;
  auto tgtcorr__ = tgtcorr ? _fbb.CreateString(tgtcorr) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateMonoRadar_Full(
      _fbb,
      id__,
      classificationMarking__,
      tti__,
      idSensor__,
      senlat,
      senlon,
      senalt,
      sac,
      sic,
      tgtid__,
      addr__,
      msgfmt__,
      msgtyp__,
      af,
      faa,
      spi,
      aims,
      mti,
      bcnhits,
      ts__,
      msgts__,
      rng,
      az,
      acp,
      alt3d,
      mc,
      mcv__,
      mcg,
      m1__,
      m1v__,
      m1g,
      m2__,
      m2v__,
      m2xv__,
      m2g,
      m3a__,
      m3av__,
      m3ag,
      m3axv__,
      m4__,
      m4v__,
      m4d1d2__,
      mscommb__,
      milemrgcy,
      code7500,
      code7600,
      code7700,
      grndspd,
      hdng,
      trknum,
      rad__,
      mah__,
      cdm__,
      cartpos__,
      psrrl,
      ssrl,
      rngdelt,
      azdelt,
      wectc__,
      mrgrpt,
      artsqual__,
      trkelig__,
      tgtconf__,
      tgtcorr__,
      tis,
      tags__,
      origSensorId__,
      source__,
      origin__,
      dataMode,
      createdAt__,
      createdBy__,
      origNetwork__);
}

inline const MonoRadar_Full *GetMonoRadar_Full(const void *buf) {
  return ::flatbuffers::GetRoot<MonoRadar_Full>(buf);
}

inline const MonoRadar_Full *GetSizePrefixedMonoRadar_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MonoRadar_Full>(buf);
}

inline const char *MonoRadar_FullIdentifier() {
  return "MONO";
}

inline bool MonoRadar_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MonoRadar_FullIdentifier());
}

inline bool SizePrefixedMonoRadar_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, MonoRadar_FullIdentifier(), true);
}

inline bool VerifyMonoRadar_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MonoRadar_Full>(MonoRadar_FullIdentifier());
}

inline bool VerifySizePrefixedMonoRadar_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MonoRadar_Full>(MonoRadar_FullIdentifier());
}

inline void FinishMonoRadar_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MonoRadar_Full> root) {
  fbb.Finish(root, MonoRadar_FullIdentifier());
}

inline void FinishSizePrefixedMonoRadar_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MonoRadar_Full> root) {
  fbb.FinishSizePrefixed(root, MonoRadar_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
