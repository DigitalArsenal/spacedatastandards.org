// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Status;
struct StatusBuilder;

enum Status_state_Enum : int8_t {
  /// No description available.
  Status_state_Enum_UNKNOWN = 0,
  /// No description available.
  Status_state_Enum_DEAD = 1,
  /// No description available.
  Status_state_Enum_ACTIVE = 2,
  /// No description available.
  Status_state_Enum_RF_ACTIVE = 3,
  /// No description available.
  Status_state_Enum_STANDBY = 4,
  Status_state_Enum_MIN = Status_state_Enum_UNKNOWN,
  Status_state_Enum_MAX = Status_state_Enum_STANDBY
};

inline const Status_state_Enum (&EnumValuesStatus_state_Enum())[5] {
  static const Status_state_Enum values[] = {
    Status_state_Enum_UNKNOWN,
    Status_state_Enum_DEAD,
    Status_state_Enum_ACTIVE,
    Status_state_Enum_RF_ACTIVE,
    Status_state_Enum_STANDBY
  };
  return values;
}

inline const char * const *EnumNamesStatus_state_Enum() {
  static const char * const names[6] = {
    "UNKNOWN",
    "DEAD",
    "ACTIVE",
    "RF_ACTIVE",
    "STANDBY",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus_state_Enum(Status_state_Enum e) {
  if (::flatbuffers::IsOutRange(e, Status_state_Enum_UNKNOWN, Status_state_Enum_STANDBY)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus_state_Enum()[index];
}

enum Status_sysCap_Enum : int8_t {
  /// No description available.
  Status_sysCap_Enum_FMC = 0,
  /// No description available.
  Status_sysCap_Enum_NMC = 1,
  /// No description available.
  Status_sysCap_Enum_PMC = 2,
  /// No description available.
  Status_sysCap_Enum_UNK = 3,
  Status_sysCap_Enum_MIN = Status_sysCap_Enum_FMC,
  Status_sysCap_Enum_MAX = Status_sysCap_Enum_UNK
};

inline const Status_sysCap_Enum (&EnumValuesStatus_sysCap_Enum())[4] {
  static const Status_sysCap_Enum values[] = {
    Status_sysCap_Enum_FMC,
    Status_sysCap_Enum_NMC,
    Status_sysCap_Enum_PMC,
    Status_sysCap_Enum_UNK
  };
  return values;
}

inline const char * const *EnumNamesStatus_sysCap_Enum() {
  static const char * const names[5] = {
    "FMC",
    "NMC",
    "PMC",
    "UNK",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus_sysCap_Enum(Status_sysCap_Enum e) {
  if (::flatbuffers::IsOutRange(e, Status_sysCap_Enum_FMC, Status_sysCap_Enum_UNK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus_sysCap_Enum()[index];
}

enum Status_opsCap_Enum : int8_t {
  /// No description available.
  Status_opsCap_Enum_FMC = 0,
  /// No description available.
  Status_opsCap_Enum_NMC = 1,
  /// No description available.
  Status_opsCap_Enum_PMC = 2,
  /// No description available.
  Status_opsCap_Enum_UNK = 3,
  Status_opsCap_Enum_MIN = Status_opsCap_Enum_FMC,
  Status_opsCap_Enum_MAX = Status_opsCap_Enum_UNK
};

inline const Status_opsCap_Enum (&EnumValuesStatus_opsCap_Enum())[4] {
  static const Status_opsCap_Enum values[] = {
    Status_opsCap_Enum_FMC,
    Status_opsCap_Enum_NMC,
    Status_opsCap_Enum_PMC,
    Status_opsCap_Enum_UNK
  };
  return values;
}

inline const char * const *EnumNamesStatus_opsCap_Enum() {
  static const char * const names[5] = {
    "FMC",
    "NMC",
    "PMC",
    "UNK",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus_opsCap_Enum(Status_opsCap_Enum e) {
  if (::flatbuffers::IsOutRange(e, Status_opsCap_Enum_FMC, Status_opsCap_Enum_UNK)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus_opsCap_Enum()[index];
}

enum Status_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Status_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Status_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Status_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Status_dataMode_Enum_EXERCISE = 3,
  Status_dataMode_Enum_MIN = Status_dataMode_Enum_REAL,
  Status_dataMode_Enum_MAX = Status_dataMode_Enum_EXERCISE
};

inline const Status_dataMode_Enum (&EnumValuesStatus_dataMode_Enum())[4] {
  static const Status_dataMode_Enum values[] = {
    Status_dataMode_Enum_REAL,
    Status_dataMode_Enum_TEST,
    Status_dataMode_Enum_SIMULATED,
    Status_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesStatus_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatus_dataMode_Enum(Status_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Status_dataMode_Enum_REAL, Status_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatus_dataMode_Enum()[index];
}

/// /// Status for a particular Entity. An entity may have multiple status records collected by various sources.
struct Status FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_DERIVEDFROM = 8,
    VT_DECLASSIFICATIONDATE = 10,
    VT_DECLASSIFICATIONSTRING = 12,
    VT_IDENTITY = 14,
    VT_STATE = 16,
    VT_SYSCAP = 18,
    VT_OPSCAP = 20,
    VT_SOURCE = 22,
    VT_SUBSTATUSCOLLECTION = 24,
    VT_DATAMODE = 26,
    VT_NOTES = 28,
    VT_CREATEDAT = 30,
    VT_CREATEDBY = 32,
    VT_UPDATEDAT = 34,
    VT_UPDATEDBY = 36,
    VT_ORIGIN = 38,
    VT_ORIGNETWORK = 40
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: STATUS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The sources or SCG references from which the classification of this data is derived.
  /// Example: /// Example: SOME_SOURCE
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *derivedFrom() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DERIVEDFROM);
  }
  /// The declassification date of this data, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-01-01T01:02:02.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *declassificationDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECLASSIFICATIONDATE);
  }
  /// Declassification string of this data.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *declassificationString() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECLASSIFICATIONSTRING);
  }
  /// Unique identifier of the parent entity.
  /// Example: /// Example: ENTITY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idEntity() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTITY);
  }
  /// Overall state of the entity, if applicable (e.g. UNKNOWN, DEAD, ACTIVE, RF ACTIVE, STANDBY).
  /// Example: /// Example: ACTIVE
  /// Constraints: Minimum length = 0, Maximum length = 16
  Status_state_Enum state() const {
    return static_cast<Status_state_Enum>(GetField<int8_t>(VT_STATE, 0));
  }
  /// System capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK).
  /// Example: /// Example: FMC
  /// Constraints: Minimum length = 0, Maximum length = 3
  Status_sysCap_Enum sysCap() const {
    return static_cast<Status_sysCap_Enum>(GetField<int8_t>(VT_SYSCAP, 0));
  }
  /// Operation capability of the entity, if applicable (e.g. FMC, NMC, PMC, UNK).
  /// Example: /// Example: FMC
  /// Constraints: Minimum length = 0, Maximum length = 3
  Status_opsCap_Enum opsCap() const {
    return static_cast<Status_opsCap_Enum>(GetField<int8_t>(VT_OPSCAP, 0));
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *subStatusCollection() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SUBSTATUSCOLLECTION);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Status_dataMode_Enum dataMode() const {
    return static_cast<Status_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Comments describing the status creation and or updates to an entity.
  /// Example: /// Example: Example Notes
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *notes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: TST1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_DERIVEDFROM) &&
           verifier.VerifyString(derivedFrom()) &&
           VerifyOffset(verifier, VT_DECLASSIFICATIONDATE) &&
           verifier.VerifyString(declassificationDate()) &&
           VerifyOffset(verifier, VT_DECLASSIFICATIONSTRING) &&
           verifier.VerifyString(declassificationString()) &&
           VerifyOffset(verifier, VT_IDENTITY) &&
           verifier.VerifyString(idEntity()) &&
           VerifyField<int8_t>(verifier, VT_STATE, 1) &&
           VerifyField<int8_t>(verifier, VT_SYSCAP, 1) &&
           VerifyField<int8_t>(verifier, VT_OPSCAP, 1) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_SUBSTATUSCOLLECTION) &&
           verifier.VerifyVector(subStatusCollection()) &&
           verifier.VerifyVectorOfStrings(subStatusCollection()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(notes()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct StatusBuilder {
  typedef Status Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Status::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Status::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_derivedFrom(::flatbuffers::Offset<::flatbuffers::String> derivedFrom) {
    fbb_.AddOffset(Status::VT_DERIVEDFROM, derivedFrom);
  }
  void add_declassificationDate(::flatbuffers::Offset<::flatbuffers::String> declassificationDate) {
    fbb_.AddOffset(Status::VT_DECLASSIFICATIONDATE, declassificationDate);
  }
  void add_declassificationString(::flatbuffers::Offset<::flatbuffers::String> declassificationString) {
    fbb_.AddOffset(Status::VT_DECLASSIFICATIONSTRING, declassificationString);
  }
  void add_idEntity(::flatbuffers::Offset<::flatbuffers::String> idEntity) {
    fbb_.AddOffset(Status::VT_IDENTITY, idEntity);
  }
  void add_state(Status_state_Enum state) {
    fbb_.AddElement<int8_t>(Status::VT_STATE, static_cast<int8_t>(state), 0);
  }
  void add_sysCap(Status_sysCap_Enum sysCap) {
    fbb_.AddElement<int8_t>(Status::VT_SYSCAP, static_cast<int8_t>(sysCap), 0);
  }
  void add_opsCap(Status_opsCap_Enum opsCap) {
    fbb_.AddElement<int8_t>(Status::VT_OPSCAP, static_cast<int8_t>(opsCap), 0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Status::VT_SOURCE, source);
  }
  void add_subStatusCollection(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> subStatusCollection) {
    fbb_.AddOffset(Status::VT_SUBSTATUSCOLLECTION, subStatusCollection);
  }
  void add_dataMode(Status_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Status::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_notes(::flatbuffers::Offset<::flatbuffers::String> notes) {
    fbb_.AddOffset(Status::VT_NOTES, notes);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Status::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Status::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(Status::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(Status::VT_UPDATEDBY, updatedBy);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Status::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Status::VT_ORIGNETWORK, origNetwork);
  }
  explicit StatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Status> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Status>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Status> CreateStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> derivedFrom = 0,
    ::flatbuffers::Offset<::flatbuffers::String> declassificationDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> declassificationString = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idEntity = 0,
    Status_state_Enum state = Status_state_Enum_UNKNOWN,
    Status_sysCap_Enum sysCap = Status_sysCap_Enum_FMC,
    Status_opsCap_Enum opsCap = Status_opsCap_Enum_FMC,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> subStatusCollection = 0,
    Status_dataMode_Enum dataMode = Status_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> notes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  StatusBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_notes(notes);
  builder_.add_subStatusCollection(subStatusCollection);
  builder_.add_source(source);
  builder_.add_idEntity(idEntity);
  builder_.add_declassificationString(declassificationString);
  builder_.add_declassificationDate(declassificationDate);
  builder_.add_derivedFrom(derivedFrom);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_opsCap(opsCap);
  builder_.add_sysCap(sysCap);
  builder_.add_state(state);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Status> CreateStatusDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *derivedFrom = nullptr,
    const char *declassificationDate = nullptr,
    const char *declassificationString = nullptr,
    const char *idEntity = nullptr,
    Status_state_Enum state = Status_state_Enum_UNKNOWN,
    Status_sysCap_Enum sysCap = Status_sysCap_Enum_FMC,
    Status_opsCap_Enum opsCap = Status_opsCap_Enum_FMC,
    const char *source = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *subStatusCollection = nullptr,
    Status_dataMode_Enum dataMode = Status_dataMode_Enum_REAL,
    const char *notes = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto derivedFrom__ = derivedFrom ? _fbb.CreateString(derivedFrom) : 0;
  auto declassificationDate__ = declassificationDate ? _fbb.CreateString(declassificationDate) : 0;
  auto declassificationString__ = declassificationString ? _fbb.CreateString(declassificationString) : 0;
  auto idEntity__ = idEntity ? _fbb.CreateString(idEntity) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto subStatusCollection__ = subStatusCollection ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*subStatusCollection) : 0;
  auto notes__ = notes ? _fbb.CreateString(notes) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateStatus(
      _fbb,
      id__,
      classificationMarking__,
      derivedFrom__,
      declassificationDate__,
      declassificationString__,
      idEntity__,
      state,
      sysCap,
      opsCap,
      source__,
      subStatusCollection__,
      dataMode,
      notes__,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      origin__,
      origNetwork__);
}

inline const Status *GetStatus(const void *buf) {
  return ::flatbuffers::GetRoot<Status>(buf);
}

inline const Status *GetSizePrefixedStatus(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Status>(buf);
}

inline const char *StatusIdentifier() {
  return "STAT";
}

inline bool StatusBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StatusIdentifier());
}

inline bool SizePrefixedStatusBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, StatusIdentifier(), true);
}

inline bool VerifyStatusBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Status>(StatusIdentifier());
}

inline bool VerifySizePrefixedStatusBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Status>(StatusIdentifier());
}

inline void FinishStatusBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Status> root) {
  fbb.Finish(root, StatusIdentifier());
}

inline void FinishSizePrefixedStatusBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Status> root) {
  fbb.FinishSizePrefixed(root, StatusIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
