// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct DiplomaticClearanceDetails_Full;
struct DiplomaticClearanceDetails_FullBuilder;

/// /// Collection of diplomatic clearance details.
struct DiplomaticClearanceDetails_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DiplomaticClearanceDetails_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDSORTIE = 4,
    VT_LEGNUM = 6,
    VT_ROUTESTRING = 8,
    VT_VALIDSTARTTIME = 10,
    VT_VALIDENDTIME = 12,
    VT_CLEARANCEID = 14,
    VT_EXTERNALCLEARANCEID = 16,
    VT_CLEAREDCALLSIGN = 18,
    VT_SEQUENCENUM = 20,
    VT_COUNTRYCODE = 22,
    VT_ALTCOUNTRYCODE = 24,
    VT_COUNTRYNAME = 26,
    VT_VALIDDESC = 28,
    VT_WINDOWREMARK = 30,
    VT_ENTRYPOINT = 32,
    VT_ENTRYNET = 34,
    VT_EXITPOINT = 36,
    VT_EXITNLT = 38,
    VT_REQICAO = 40,
    VT_ACTION = 42,
    VT_STATUS = 44,
    VT_PROFILE = 46,
    VT_REQPOINT = 48,
    VT_CLEARANCEREMARK = 50
  };
  /// Unique identifier of the Aircraft Sortie associated with this diplomatic clearance record.
  /// Example: /// Example: 207010e0-f97d-431c-8c00-7e46acfef0f5
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSortie() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSORTIE);
  }
  /// Identifies the Itinerary point of a sortie where an air event occurs.
  /// Example: /// Example: 825
  /// Constraints: No constraints specified.
  int32_t legNum() const {
    return GetField<int32_t>(VT_LEGNUM, 0);
  }
  /// The 1801 fileable route of flight string associated with this diplomatic clearance. The route of flight string contains route designators, significant points, change of speed/altitude, change of flight rules, and cruise climbs.
  /// Example: /// Example: DCT DOH P430 BAYAN/M062F150 P430 RAMKI
  /// Constraints: Minimum length = 0, Maximum length = 4000
  const ::flatbuffers::String *routeString() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROUTESTRING);
  }
  /// The start time of the validity of this diplomatic clearance, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *validStartTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALIDSTARTTIME);
  }
  /// The end time of the validity of this diplomatic clearance, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *validEndTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALIDENDTIME);
  }
  /// Identifier of this diplomatic clearance issued by the host country.
  /// Example: /// Example: MFMW225662GHQ
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *clearanceId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLEARANCEID);
  }
  /// Optional clearance ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: aa714f4d52a37ab1a00b21af9566e379
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *externalClearanceId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALCLEARANCEID);
  }
  /// The call sign of the sortie cleared with this diplomatic clearance.
  /// Example: /// Example: FALCN09
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *clearedCallSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLEAREDCALLSIGN);
  }
  /// The placement of this diplomatic clearance within a sequence of clearances used on a sortie. For example, a sequence value of 3 means that it is the third diplomatic clearance the aircraft will use.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t sequenceNum() const {
    return GetField<int32_t>(VT_SEQUENCENUM, 0);
  }
  /// The DoD Standard Country Code designator for the country issuing the diplomatic clearance. This field will be set to "OTHR" if the source value does not match a UDL Country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: NL
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *countryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  /// Specifies an alternate country code if the data provider code is not part of an official Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
  /// Example: /// Example: IZ
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *altCountryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALTCOUNTRYCODE);
  }
  /// Name of the country issuing this diplomatic clearance.
  /// Example: /// Example: NETHERLANDS
  /// Constraints: Minimum length = 0, Maximum length = 50
  const ::flatbuffers::String *countryName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYNAME);
  }
  /// Description of when this diplomatic clearance is valid.
  /// Example: /// Example: CY2023
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *validDesc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALIDDESC);
  }
  /// Remarks concerning the valid diplomatic clearance window.
  /// Example: /// Example: Period remarks
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *windowRemark() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WINDOWREMARK);
  }
  /// The navigation point name where the aircraft must enter the country.
  /// Example: /// Example: LOMOS
  /// Constraints: Minimum length = 0, Maximum length = 38
  const ::flatbuffers::String *entryPoint() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENTRYPOINT);
  }
  /// Earliest time the aircraft may enter the country, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *entryNET() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENTRYNET);
  }
  /// The navigation point name where the aircraft must exit the country.
  /// Example: /// Example: BUDOP
  /// Constraints: Minimum length = 0, Maximum length = 38
  const ::flatbuffers::String *exitPoint() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXITPOINT);
  }
  /// Latest time the aircraft may exit the country, in ISO 8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-01-01T01:01:01.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *exitNLT() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXITNLT);
  }
  /// Flag indicating whether the clearance request requires ICAO specific information.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool reqICAO() const {
    return GetField<uint8_t>(VT_REQICAO, 0) != 0;
  }
  /// The type of action the aircraft can take with this diplomatic clearance (e.g. O for Overfly, L for Land, etc.).
  /// Example: /// Example: O
  /// Constraints: Minimum length = 0, Maximum length = 1
  const ::flatbuffers::String *action() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTION);
  }
  /// Indicates the current status of the diplomatic clearance request.
  /// Example: /// Example: IN WORK
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *status() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATUS);
  }
  /// The diplomatic clearance profile name used within clearance management systems.
  /// Example: /// Example: T LAND/OFLY IATA COMPLIANT CARGO 23
  /// Constraints: Minimum length = 0, Maximum length = 100
  const ::flatbuffers::String *profile() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROFILE);
  }
  /// Flag indicating whether entry/exit points are required for clearances.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool reqPoint() const {
    return GetField<uint8_t>(VT_REQPOINT, 0) != 0;
  }
  /// Remarks concerning this diplomatic clearance.
  /// Example: /// Example: Clearance remarks
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *clearanceRemark() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLEARANCEREMARK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDSORTIE) &&
           verifier.VerifyString(idSortie()) &&
           VerifyField<int32_t>(verifier, VT_LEGNUM, 4) &&
           VerifyOffset(verifier, VT_ROUTESTRING) &&
           verifier.VerifyString(routeString()) &&
           VerifyOffset(verifier, VT_VALIDSTARTTIME) &&
           verifier.VerifyString(validStartTime()) &&
           VerifyOffset(verifier, VT_VALIDENDTIME) &&
           verifier.VerifyString(validEndTime()) &&
           VerifyOffset(verifier, VT_CLEARANCEID) &&
           verifier.VerifyString(clearanceId()) &&
           VerifyOffset(verifier, VT_EXTERNALCLEARANCEID) &&
           verifier.VerifyString(externalClearanceId()) &&
           VerifyOffset(verifier, VT_CLEAREDCALLSIGN) &&
           verifier.VerifyString(clearedCallSign()) &&
           VerifyField<int32_t>(verifier, VT_SEQUENCENUM, 4) &&
           VerifyOffset(verifier, VT_COUNTRYCODE) &&
           verifier.VerifyString(countryCode()) &&
           VerifyOffset(verifier, VT_ALTCOUNTRYCODE) &&
           verifier.VerifyString(altCountryCode()) &&
           VerifyOffset(verifier, VT_COUNTRYNAME) &&
           verifier.VerifyString(countryName()) &&
           VerifyOffset(verifier, VT_VALIDDESC) &&
           verifier.VerifyString(validDesc()) &&
           VerifyOffset(verifier, VT_WINDOWREMARK) &&
           verifier.VerifyString(windowRemark()) &&
           VerifyOffset(verifier, VT_ENTRYPOINT) &&
           verifier.VerifyString(entryPoint()) &&
           VerifyOffset(verifier, VT_ENTRYNET) &&
           verifier.VerifyString(entryNET()) &&
           VerifyOffset(verifier, VT_EXITPOINT) &&
           verifier.VerifyString(exitPoint()) &&
           VerifyOffset(verifier, VT_EXITNLT) &&
           verifier.VerifyString(exitNLT()) &&
           VerifyField<uint8_t>(verifier, VT_REQICAO, 1) &&
           VerifyOffset(verifier, VT_ACTION) &&
           verifier.VerifyString(action()) &&
           VerifyOffset(verifier, VT_STATUS) &&
           verifier.VerifyString(status()) &&
           VerifyOffset(verifier, VT_PROFILE) &&
           verifier.VerifyString(profile()) &&
           VerifyField<uint8_t>(verifier, VT_REQPOINT, 1) &&
           VerifyOffset(verifier, VT_CLEARANCEREMARK) &&
           verifier.VerifyString(clearanceRemark()) &&
           verifier.EndTable();
  }
};

struct DiplomaticClearanceDetails_FullBuilder {
  typedef DiplomaticClearanceDetails_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idSortie(::flatbuffers::Offset<::flatbuffers::String> idSortie) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_IDSORTIE, idSortie);
  }
  void add_legNum(int32_t legNum) {
    fbb_.AddElement<int32_t>(DiplomaticClearanceDetails_Full::VT_LEGNUM, legNum, 0);
  }
  void add_routeString(::flatbuffers::Offset<::flatbuffers::String> routeString) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_ROUTESTRING, routeString);
  }
  void add_validStartTime(::flatbuffers::Offset<::flatbuffers::String> validStartTime) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_VALIDSTARTTIME, validStartTime);
  }
  void add_validEndTime(::flatbuffers::Offset<::flatbuffers::String> validEndTime) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_VALIDENDTIME, validEndTime);
  }
  void add_clearanceId(::flatbuffers::Offset<::flatbuffers::String> clearanceId) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_CLEARANCEID, clearanceId);
  }
  void add_externalClearanceId(::flatbuffers::Offset<::flatbuffers::String> externalClearanceId) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_EXTERNALCLEARANCEID, externalClearanceId);
  }
  void add_clearedCallSign(::flatbuffers::Offset<::flatbuffers::String> clearedCallSign) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_CLEAREDCALLSIGN, clearedCallSign);
  }
  void add_sequenceNum(int32_t sequenceNum) {
    fbb_.AddElement<int32_t>(DiplomaticClearanceDetails_Full::VT_SEQUENCENUM, sequenceNum, 0);
  }
  void add_countryCode(::flatbuffers::Offset<::flatbuffers::String> countryCode) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_COUNTRYCODE, countryCode);
  }
  void add_altCountryCode(::flatbuffers::Offset<::flatbuffers::String> altCountryCode) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_ALTCOUNTRYCODE, altCountryCode);
  }
  void add_countryName(::flatbuffers::Offset<::flatbuffers::String> countryName) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_COUNTRYNAME, countryName);
  }
  void add_validDesc(::flatbuffers::Offset<::flatbuffers::String> validDesc) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_VALIDDESC, validDesc);
  }
  void add_windowRemark(::flatbuffers::Offset<::flatbuffers::String> windowRemark) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_WINDOWREMARK, windowRemark);
  }
  void add_entryPoint(::flatbuffers::Offset<::flatbuffers::String> entryPoint) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_ENTRYPOINT, entryPoint);
  }
  void add_entryNET(::flatbuffers::Offset<::flatbuffers::String> entryNET) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_ENTRYNET, entryNET);
  }
  void add_exitPoint(::flatbuffers::Offset<::flatbuffers::String> exitPoint) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_EXITPOINT, exitPoint);
  }
  void add_exitNLT(::flatbuffers::Offset<::flatbuffers::String> exitNLT) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_EXITNLT, exitNLT);
  }
  void add_reqICAO(bool reqICAO) {
    fbb_.AddElement<uint8_t>(DiplomaticClearanceDetails_Full::VT_REQICAO, static_cast<uint8_t>(reqICAO), 0);
  }
  void add_action(::flatbuffers::Offset<::flatbuffers::String> action) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_ACTION, action);
  }
  void add_status(::flatbuffers::Offset<::flatbuffers::String> status) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_STATUS, status);
  }
  void add_profile(::flatbuffers::Offset<::flatbuffers::String> profile) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_PROFILE, profile);
  }
  void add_reqPoint(bool reqPoint) {
    fbb_.AddElement<uint8_t>(DiplomaticClearanceDetails_Full::VT_REQPOINT, static_cast<uint8_t>(reqPoint), 0);
  }
  void add_clearanceRemark(::flatbuffers::Offset<::flatbuffers::String> clearanceRemark) {
    fbb_.AddOffset(DiplomaticClearanceDetails_Full::VT_CLEARANCEREMARK, clearanceRemark);
  }
  explicit DiplomaticClearanceDetails_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DiplomaticClearanceDetails_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DiplomaticClearanceDetails_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DiplomaticClearanceDetails_Full> CreateDiplomaticClearanceDetails_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> idSortie = 0,
    int32_t legNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> routeString = 0,
    ::flatbuffers::Offset<::flatbuffers::String> validStartTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> validEndTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> clearanceId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> externalClearanceId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> clearedCallSign = 0,
    int32_t sequenceNum = 0,
    ::flatbuffers::Offset<::flatbuffers::String> countryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> altCountryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> countryName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> validDesc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> windowRemark = 0,
    ::flatbuffers::Offset<::flatbuffers::String> entryPoint = 0,
    ::flatbuffers::Offset<::flatbuffers::String> entryNET = 0,
    ::flatbuffers::Offset<::flatbuffers::String> exitPoint = 0,
    ::flatbuffers::Offset<::flatbuffers::String> exitNLT = 0,
    bool reqICAO = false,
    ::flatbuffers::Offset<::flatbuffers::String> action = 0,
    ::flatbuffers::Offset<::flatbuffers::String> status = 0,
    ::flatbuffers::Offset<::flatbuffers::String> profile = 0,
    bool reqPoint = false,
    ::flatbuffers::Offset<::flatbuffers::String> clearanceRemark = 0) {
  DiplomaticClearanceDetails_FullBuilder builder_(_fbb);
  builder_.add_clearanceRemark(clearanceRemark);
  builder_.add_profile(profile);
  builder_.add_status(status);
  builder_.add_action(action);
  builder_.add_exitNLT(exitNLT);
  builder_.add_exitPoint(exitPoint);
  builder_.add_entryNET(entryNET);
  builder_.add_entryPoint(entryPoint);
  builder_.add_windowRemark(windowRemark);
  builder_.add_validDesc(validDesc);
  builder_.add_countryName(countryName);
  builder_.add_altCountryCode(altCountryCode);
  builder_.add_countryCode(countryCode);
  builder_.add_sequenceNum(sequenceNum);
  builder_.add_clearedCallSign(clearedCallSign);
  builder_.add_externalClearanceId(externalClearanceId);
  builder_.add_clearanceId(clearanceId);
  builder_.add_validEndTime(validEndTime);
  builder_.add_validStartTime(validStartTime);
  builder_.add_routeString(routeString);
  builder_.add_legNum(legNum);
  builder_.add_idSortie(idSortie);
  builder_.add_reqPoint(reqPoint);
  builder_.add_reqICAO(reqICAO);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DiplomaticClearanceDetails_Full> CreateDiplomaticClearanceDetails_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *idSortie = nullptr,
    int32_t legNum = 0,
    const char *routeString = nullptr,
    const char *validStartTime = nullptr,
    const char *validEndTime = nullptr,
    const char *clearanceId = nullptr,
    const char *externalClearanceId = nullptr,
    const char *clearedCallSign = nullptr,
    int32_t sequenceNum = 0,
    const char *countryCode = nullptr,
    const char *altCountryCode = nullptr,
    const char *countryName = nullptr,
    const char *validDesc = nullptr,
    const char *windowRemark = nullptr,
    const char *entryPoint = nullptr,
    const char *entryNET = nullptr,
    const char *exitPoint = nullptr,
    const char *exitNLT = nullptr,
    bool reqICAO = false,
    const char *action = nullptr,
    const char *status = nullptr,
    const char *profile = nullptr,
    bool reqPoint = false,
    const char *clearanceRemark = nullptr) {
  auto idSortie__ = idSortie ? _fbb.CreateString(idSortie) : 0;
  auto routeString__ = routeString ? _fbb.CreateString(routeString) : 0;
  auto validStartTime__ = validStartTime ? _fbb.CreateString(validStartTime) : 0;
  auto validEndTime__ = validEndTime ? _fbb.CreateString(validEndTime) : 0;
  auto clearanceId__ = clearanceId ? _fbb.CreateString(clearanceId) : 0;
  auto externalClearanceId__ = externalClearanceId ? _fbb.CreateString(externalClearanceId) : 0;
  auto clearedCallSign__ = clearedCallSign ? _fbb.CreateString(clearedCallSign) : 0;
  auto countryCode__ = countryCode ? _fbb.CreateString(countryCode) : 0;
  auto altCountryCode__ = altCountryCode ? _fbb.CreateString(altCountryCode) : 0;
  auto countryName__ = countryName ? _fbb.CreateString(countryName) : 0;
  auto validDesc__ = validDesc ? _fbb.CreateString(validDesc) : 0;
  auto windowRemark__ = windowRemark ? _fbb.CreateString(windowRemark) : 0;
  auto entryPoint__ = entryPoint ? _fbb.CreateString(entryPoint) : 0;
  auto entryNET__ = entryNET ? _fbb.CreateString(entryNET) : 0;
  auto exitPoint__ = exitPoint ? _fbb.CreateString(exitPoint) : 0;
  auto exitNLT__ = exitNLT ? _fbb.CreateString(exitNLT) : 0;
  auto action__ = action ? _fbb.CreateString(action) : 0;
  auto status__ = status ? _fbb.CreateString(status) : 0;
  auto profile__ = profile ? _fbb.CreateString(profile) : 0;
  auto clearanceRemark__ = clearanceRemark ? _fbb.CreateString(clearanceRemark) : 0;
  return CreateDiplomaticClearanceDetails_Full(
      _fbb,
      idSortie__,
      legNum,
      routeString__,
      validStartTime__,
      validEndTime__,
      clearanceId__,
      externalClearanceId__,
      clearedCallSign__,
      sequenceNum,
      countryCode__,
      altCountryCode__,
      countryName__,
      validDesc__,
      windowRemark__,
      entryPoint__,
      entryNET__,
      exitPoint__,
      exitNLT__,
      reqICAO,
      action__,
      status__,
      profile__,
      reqPoint,
      clearanceRemark__);
}

inline const DiplomaticClearanceDetails_Full *GetDiplomaticClearanceDetails_Full(const void *buf) {
  return ::flatbuffers::GetRoot<DiplomaticClearanceDetails_Full>(buf);
}

inline const DiplomaticClearanceDetails_Full *GetSizePrefixedDiplomaticClearanceDetails_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DiplomaticClearanceDetails_Full>(buf);
}

inline const char *DiplomaticClearanceDetails_FullIdentifier() {
  return "DIPL";
}

inline bool DiplomaticClearanceDetails_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DiplomaticClearanceDetails_FullIdentifier());
}

inline bool SizePrefixedDiplomaticClearanceDetails_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DiplomaticClearanceDetails_FullIdentifier(), true);
}

inline bool VerifyDiplomaticClearanceDetails_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DiplomaticClearanceDetails_Full>(DiplomaticClearanceDetails_FullIdentifier());
}

inline bool VerifySizePrefixedDiplomaticClearanceDetails_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DiplomaticClearanceDetails_Full>(DiplomaticClearanceDetails_FullIdentifier());
}

inline void FinishDiplomaticClearanceDetails_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DiplomaticClearanceDetails_Full> root) {
  fbb.Finish(root, DiplomaticClearanceDetails_FullIdentifier());
}

inline void FinishSizePrefixedDiplomaticClearanceDetails_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DiplomaticClearanceDetails_Full> root) {
  fbb.FinishSizePrefixed(root, DiplomaticClearanceDetails_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
