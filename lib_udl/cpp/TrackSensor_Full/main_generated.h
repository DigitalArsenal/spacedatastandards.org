// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct TrackSensor_Full;
struct TrackSensor_FullBuilder;

enum TrackSensor_Full_sensorFOVType_Enum : int8_t {
  /// No description available.
  TrackSensor_Full_sensorFOVType_Enum_BUTTERFLY = 0,
  /// No description available.
  TrackSensor_Full_sensorFOVType_Enum_CONE_ANGULAR = 1,
  /// No description available.
  TrackSensor_Full_sensorFOVType_Enum_CONE_DISTANCE = 2,
  /// No description available.
  TrackSensor_Full_sensorFOVType_Enum_HORIZON_TO_HORIZON = 3,
  /// No description available.
  TrackSensor_Full_sensorFOVType_Enum_UNKNOWN = 4,
  TrackSensor_Full_sensorFOVType_Enum_MIN = TrackSensor_Full_sensorFOVType_Enum_BUTTERFLY,
  TrackSensor_Full_sensorFOVType_Enum_MAX = TrackSensor_Full_sensorFOVType_Enum_UNKNOWN
};

inline const TrackSensor_Full_sensorFOVType_Enum (&EnumValuesTrackSensor_Full_sensorFOVType_Enum())[5] {
  static const TrackSensor_Full_sensorFOVType_Enum values[] = {
    TrackSensor_Full_sensorFOVType_Enum_BUTTERFLY,
    TrackSensor_Full_sensorFOVType_Enum_CONE_ANGULAR,
    TrackSensor_Full_sensorFOVType_Enum_CONE_DISTANCE,
    TrackSensor_Full_sensorFOVType_Enum_HORIZON_TO_HORIZON,
    TrackSensor_Full_sensorFOVType_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesTrackSensor_Full_sensorFOVType_Enum() {
  static const char * const names[6] = {
    "BUTTERFLY",
    "CONE_ANGULAR",
    "CONE_DISTANCE",
    "HORIZON_TO_HORIZON",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameTrackSensor_Full_sensorFOVType_Enum(TrackSensor_Full_sensorFOVType_Enum e) {
  if (::flatbuffers::IsOutRange(e, TrackSensor_Full_sensorFOVType_Enum_BUTTERFLY, TrackSensor_Full_sensorFOVType_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTrackSensor_Full_sensorFOVType_Enum()[index];
}

/// /// Schema for Track Sensor data.
struct TrackSensor_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrackSensor_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RANGE = 4,
    VT_AZ = 6,
    VT_SENSORNUMBER = 8,
    VT_SENSORNAME = 10,
    VT_MISSIONNUMBER = 12,
    VT_MINRANGELIMIT = 14,
    VT_SENSORFOVTYPE = 16
  };
  /// The track object range from the observing sensor, in kilometers.
  /// Example: /// Example: 4023.95
  /// Constraints: No constraints specified.
  double range() const {
    return GetField<double>(VT_RANGE, 0.0);
  }
  /// The observing sensor azimuth angle, in degrees and topocentric frame.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  double az() const {
    return GetField<double>(VT_AZ, 0.0);
  }
  /// Number assigned to this sensor. Since there is no authoritative numbering scheme, these numbers sometimes collide across sensors (especially commercial sensors). It is therefore not a unique identifier.
  /// Example: /// Example: 1234
  /// Constraints: No constraints specified.
  int32_t sensorNumber() const {
    return GetField<int32_t>(VT_SENSORNUMBER, 0);
  }
  /// Unique name of this sensor.
  /// Example: /// Example: SENSOR_NAME
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *sensorName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SENSORNAME);
  }
  /// The mission number which produced this track observation.
  /// Example: /// Example: Example Mission
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *missionNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSIONNUMBER);
  }
  /// Minimum range measurement capability of the sensor, in kilometers.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double minRangeLimit() const {
    return GetField<double>(VT_MINRANGELIMIT, 0.0);
  }
  /// The field of view (FOV) type (Butterfly, Cone Angular, Cone Distance, Horizon to Horizon, Unknown) employed by the sensor observing this object.
  /// Example: /// Example: UNKNOWN
  /// Constraints: Minimum length = 0, Maximum length = 24
  TrackSensor_Full_sensorFOVType_Enum sensorFOVType() const {
    return static_cast<TrackSensor_Full_sensorFOVType_Enum>(GetField<int8_t>(VT_SENSORFOVTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_RANGE, 8) &&
           VerifyField<double>(verifier, VT_AZ, 8) &&
           VerifyField<int32_t>(verifier, VT_SENSORNUMBER, 4) &&
           VerifyOffset(verifier, VT_SENSORNAME) &&
           verifier.VerifyString(sensorName()) &&
           VerifyOffset(verifier, VT_MISSIONNUMBER) &&
           verifier.VerifyString(missionNumber()) &&
           VerifyField<double>(verifier, VT_MINRANGELIMIT, 8) &&
           VerifyField<int8_t>(verifier, VT_SENSORFOVTYPE, 1) &&
           verifier.EndTable();
  }
};

struct TrackSensor_FullBuilder {
  typedef TrackSensor_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_range(double range) {
    fbb_.AddElement<double>(TrackSensor_Full::VT_RANGE, range, 0.0);
  }
  void add_az(double az) {
    fbb_.AddElement<double>(TrackSensor_Full::VT_AZ, az, 0.0);
  }
  void add_sensorNumber(int32_t sensorNumber) {
    fbb_.AddElement<int32_t>(TrackSensor_Full::VT_SENSORNUMBER, sensorNumber, 0);
  }
  void add_sensorName(::flatbuffers::Offset<::flatbuffers::String> sensorName) {
    fbb_.AddOffset(TrackSensor_Full::VT_SENSORNAME, sensorName);
  }
  void add_missionNumber(::flatbuffers::Offset<::flatbuffers::String> missionNumber) {
    fbb_.AddOffset(TrackSensor_Full::VT_MISSIONNUMBER, missionNumber);
  }
  void add_minRangeLimit(double minRangeLimit) {
    fbb_.AddElement<double>(TrackSensor_Full::VT_MINRANGELIMIT, minRangeLimit, 0.0);
  }
  void add_sensorFOVType(TrackSensor_Full_sensorFOVType_Enum sensorFOVType) {
    fbb_.AddElement<int8_t>(TrackSensor_Full::VT_SENSORFOVTYPE, static_cast<int8_t>(sensorFOVType), 0);
  }
  explicit TrackSensor_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrackSensor_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrackSensor_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrackSensor_Full> CreateTrackSensor_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double range = 0.0,
    double az = 0.0,
    int32_t sensorNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sensorName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> missionNumber = 0,
    double minRangeLimit = 0.0,
    TrackSensor_Full_sensorFOVType_Enum sensorFOVType = TrackSensor_Full_sensorFOVType_Enum_BUTTERFLY) {
  TrackSensor_FullBuilder builder_(_fbb);
  builder_.add_minRangeLimit(minRangeLimit);
  builder_.add_az(az);
  builder_.add_range(range);
  builder_.add_missionNumber(missionNumber);
  builder_.add_sensorName(sensorName);
  builder_.add_sensorNumber(sensorNumber);
  builder_.add_sensorFOVType(sensorFOVType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TrackSensor_Full> CreateTrackSensor_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    double range = 0.0,
    double az = 0.0,
    int32_t sensorNumber = 0,
    const char *sensorName = nullptr,
    const char *missionNumber = nullptr,
    double minRangeLimit = 0.0,
    TrackSensor_Full_sensorFOVType_Enum sensorFOVType = TrackSensor_Full_sensorFOVType_Enum_BUTTERFLY) {
  auto sensorName__ = sensorName ? _fbb.CreateString(sensorName) : 0;
  auto missionNumber__ = missionNumber ? _fbb.CreateString(missionNumber) : 0;
  return CreateTrackSensor_Full(
      _fbb,
      range,
      az,
      sensorNumber,
      sensorName__,
      missionNumber__,
      minRangeLimit,
      sensorFOVType);
}

inline const TrackSensor_Full *GetTrackSensor_Full(const void *buf) {
  return ::flatbuffers::GetRoot<TrackSensor_Full>(buf);
}

inline const TrackSensor_Full *GetSizePrefixedTrackSensor_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<TrackSensor_Full>(buf);
}

inline const char *TrackSensor_FullIdentifier() {
  return "TRAC";
}

inline bool TrackSensor_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TrackSensor_FullIdentifier());
}

inline bool SizePrefixedTrackSensor_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, TrackSensor_FullIdentifier(), true);
}

inline bool VerifyTrackSensor_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<TrackSensor_Full>(TrackSensor_FullIdentifier());
}

inline bool VerifySizePrefixedTrackSensor_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<TrackSensor_Full>(TrackSensor_FullIdentifier());
}

inline void FinishTrackSensor_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TrackSensor_Full> root) {
  fbb.Finish(root, TrackSensor_FullIdentifier());
}

inline void FinishSizePrefixedTrackSensor_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<TrackSensor_Full> root) {
  fbb.FinishSizePrefixed(root, TrackSensor_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
