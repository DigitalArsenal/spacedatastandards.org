// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct CollectRequest_Abridged;
struct CollectRequest_AbridgedBuilder;

enum CollectRequest_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  CollectRequest_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  CollectRequest_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  CollectRequest_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  CollectRequest_Abridged_dataMode_Enum_EXERCISE = 3,
  CollectRequest_Abridged_dataMode_Enum_MIN = CollectRequest_Abridged_dataMode_Enum_REAL,
  CollectRequest_Abridged_dataMode_Enum_MAX = CollectRequest_Abridged_dataMode_Enum_EXERCISE
};

inline const CollectRequest_Abridged_dataMode_Enum (&EnumValuesCollectRequest_Abridged_dataMode_Enum())[4] {
  static const CollectRequest_Abridged_dataMode_Enum values[] = {
    CollectRequest_Abridged_dataMode_Enum_REAL,
    CollectRequest_Abridged_dataMode_Enum_TEST,
    CollectRequest_Abridged_dataMode_Enum_SIMULATED,
    CollectRequest_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesCollectRequest_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameCollectRequest_Abridged_dataMode_Enum(CollectRequest_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, CollectRequest_Abridged_dataMode_Enum_REAL, CollectRequest_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCollectRequest_Abridged_dataMode_Enum()[index];
}

/// /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
struct CollectRequest_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CollectRequest_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDPARENTREQ = 8,
    VT_MSGTYPE = 10,
    VT_MSGCREATEDATE = 12,
    VT_TYPE = 14,
    VT_IDPLAN = 16,
    VT_PLANINDEX = 18,
    VT_TASKID = 20,
    VT_DWELLID = 22,
    VT_EXTERNALID = 24,
    VT_IDSENSOR = 26,
    VT_ORIGSENSORID = 28,
    VT_OBTYPE = 30,
    VT_PRIORITY = 32,
    VT_TASKCATEGORY = 34,
    VT_SUFFIX = 36,
    VT_UCTFOLLOWUP = 38,
    VT_STARTTIME = 40,
    VT_ENDTIME = 42,
    VT_IDONORBIT = 44,
    VT_SATNO = 46,
    VT_ORIGOBJECTID = 48,
    VT_TASKGROUP = 50,
    VT_IRON = 52,
    VT_ORBITREGIME = 54,
    VT_TARGETSIZE = 56,
    VT_RCSMIN = 58,
    VT_RCS = 60,
    VT_RCSMAX = 62,
    VT_FREQMIN = 64,
    VT_FREQ = 66,
    VT_FREQMAX = 68,
    VT_POLARIZATION = 70,
    VT_VISMAGMIN = 72,
    VT_VISMAG = 74,
    VT_VISMAGMAX = 76,
    VT_SPECTRALMODEL = 78,
    VT_REFLECTANCE = 80,
    VT_IRRADIANCE = 82,
    VT_NUMFRAMES = 84,
    VT_FRAMERATE = 86,
    VT_INTEGRATIONTIME = 88,
    VT_NUMTRACKS = 90,
    VT_NUMOBS = 92,
    VT_DURATION = 94,
    VT_SRCHPATTERN = 96,
    VT_SCENARIO = 98,
    VT_IDELSET = 100,
    VT_IDMANIFOLD = 102,
    VT_IDSTATEVECTOR = 104,
    VT_ESID = 106,
    VT_EPOCH = 108,
    VT_SEMIMAJORAXIS = 110,
    VT_ECCENTRICITY = 112,
    VT_INCLINATION = 114,
    VT_RAAN = 116,
    VT_ARGOFPERIGEE = 118,
    VT_TRUEANOMOLY = 120,
    VT_RA = 122,
    VT_DEC = 124,
    VT_AZ = 126,
    VT_EL = 128,
    VT_RANGE = 130,
    VT_EXTENTAZ = 132,
    VT_EXTENTEL = 134,
    VT_EXTENTRANGE = 136,
    VT_LAT = 138,
    VT_LON = 140,
    VT_ALT = 142,
    VT_STOPLAT = 144,
    VT_STOPLON = 146,
    VT_STOPALT = 148,
    VT_SRCHINC = 150,
    VT_XANGLE = 152,
    VT_YANGLE = 154,
    VT_ORIENTANGLE = 156,
    VT_CUSTOMER = 158,
    VT_NOTES = 160,
    VT_CREATEDAT = 162,
    VT_CREATEDBY = 164,
    VT_SOURCE = 166,
    VT_ORIGIN = 168,
    VT_ORIGNETWORK = 170,
    VT_DATAMODE = 172,
    VT_STATEVECTOR = 174,
    VT_ELSET = 176
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: COLLECTREQUEST-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
  /// Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idParentReq() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDPARENTREQ);
  }
  /// The type of external message from which this request originated.
  /// Example: /// Example: SU67
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *msgType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGTYPE);
  }
  /// The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
  /// Example: /// Example: 2024-04-25T08:17:01.346Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *msgCreateDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MSGCREATEDATE);
  }
  /// The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
  /// Example: /// Example: DWELL
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
  /// Example: /// Example: REF-PLAN-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idPlan() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDPLAN);
  }
  /// Index number (integer) for records within a collection plan or schedule.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  int32_t planIndex() const {
    return GetField<int32_t>(VT_PLANINDEX, 0);
  }
  /// Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
  /// Example: /// Example: TASK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *taskId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKID);
  }
  /// The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
  /// Example: /// Example: DWELL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *dwellId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DWELLID);
  }
  /// Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: EXTERNAL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *externalId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALID);
  }
  /// Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
  /// Example: /// Example: REF-SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
  /// Example: /// Example: RADAR
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *obType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBTYPE);
  }
  /// The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
  /// Example: /// Example: EMERGENCY
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *priority() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIORITY);
  }
  /// The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t taskCategory() const {
    return GetField<int32_t>(VT_TASKCATEGORY, 0);
  }
  /// The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
  /// Example: /// Example: T
  /// Constraints: Minimum length = 0, Maximum length = 1
  const ::flatbuffers::String *suffix() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SUFFIX);
  }
  /// Boolean indicating that this collect request is UCT follow-up.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool uctFollowUp() const {
    return GetField<uint8_t>(VT_UCTFOLLOWUP, 0) != 0;
  }
  /// The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *startTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STARTTIME);
  }
  /// The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
  /// Example: /// Example: 2018-01-01T18:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *endTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENDTIME);
  }
  /// Unique identifier of the target on-orbit object for this request.
  /// Example: /// Example: REF-ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Satellite/catalog number of the target on-orbit object for this request.
  /// Example: /// Example: 101
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// The tasking group to which the target object is assigned.
  /// Example: /// Example: 729
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *taskGroup() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKGROUP);
  }
  /// Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t iron() const {
    return GetField<int32_t>(VT_IRON, 0);
  }
  /// The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
  /// Example: /// Example: GEO
  /// Constraints: Minimum length = 0, Maximum length = 12
  const ::flatbuffers::String *orbitRegime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBITREGIME);
  }
  /// The minimum object (diameter) size, in meters, to be reported.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double targetSize() const {
    return GetField<double>(VT_TARGETSIZE, 0.0);
  }
  /// The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rcsMin() const {
    return GetField<double>(VT_RCSMIN, 0.0);
  }
  /// The Radar Cross-Section of the target, in m^2.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rcs() const {
    return GetField<double>(VT_RCS, 0.0);
  }
  /// The maximum Radar Cross-Section of the target, in m^2.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rcsMax() const {
    return GetField<double>(VT_RCSMAX, 0.0);
  }
  /// The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double freqMin() const {
    return GetField<double>(VT_FREQMIN, 0.0);
  }
  /// The estimated or expected emission frequency of the target, in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double freq() const {
    return GetField<double>(VT_FREQ, 0.0);
  }
  /// The maximum frequency of interest, in MHz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double freqMax() const {
    return GetField<double>(VT_FREQMAX, 0.0);
  }
  /// The RF polarization (H, LHC, RHC, V).
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *polarization() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POLARIZATION);
  }
  /// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double visMagMin() const {
    return GetField<double>(VT_VISMAGMIN, 0.0);
  }
  /// The estimated or expected visual magnitude of the target, in Magnitudes (M).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double visMag() const {
    return GetField<double>(VT_VISMAG, 0.0);
  }
  /// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double visMagMax() const {
    return GetField<double>(VT_VISMAGMAX, 0.0);
  }
  /// The spectral model used for the irradiance calculation.
  /// Example: /// Example: Example Model
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *spectralModel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPECTRALMODEL);
  }
  /// The fraction of solar energy reflected from target.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double reflectance() const {
    return GetField<double>(VT_REFLECTANCE, 0.0);
  }
  /// The target object irradiance value.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double irradiance() const {
    return GetField<double>(VT_IRRADIANCE, 0.0);
  }
  /// For optical sensors, the requested number of frames to capture at each sensor step.
  /// Example: /// Example: 6
  /// Constraints: No constraints specified.
  int32_t numFrames() const {
    return GetField<int32_t>(VT_NUMFRAMES, 0);
  }
  /// For optical sensors, the frame rate of the camera, in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double frameRate() const {
    return GetField<double>(VT_FRAMERATE, 0.0);
  }
  /// For optical sensors, the integration time per camera frame, in milliseconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double integrationTime() const {
    return GetField<double>(VT_INTEGRATIONTIME, 0.0);
  }
  /// The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t numTracks() const {
    return GetField<int32_t>(VT_NUMTRACKS, 0);
  }
  /// The number of requested observations on the target.
  /// Example: /// Example: 9
  /// Constraints: No constraints specified.
  int32_t numObs() const {
    return GetField<int32_t>(VT_NUMOBS, 0);
  }
  /// The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
  /// Example: /// Example: 11
  /// Constraints: No constraints specified.
  int32_t duration() const {
    return GetField<int32_t>(VT_DURATION, 0);
  }
  /// The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
  /// Example: /// Example: SCAN
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *srchPattern() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SRCHPATTERN);
  }
  /// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
  /// Example: /// Example: Example direction
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *scenario() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCENARIO);
  }
  /// ID of the UDL Elset of the object associated with this request.
  /// Example: /// Example: REF-ELSET-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idElset() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDELSET);
  }
  /// ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
  /// Example: /// Example: REF-MANIFOLD-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idManifold() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDMANIFOLD);
  }
  /// ID of the UDL State Vector of the object or central vector associated with this request.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idStateVector() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSTATEVECTOR);
  }
  /// ID of the UDL Ephemeris Set of the object associated with this request.
  /// Example: /// Example: ES-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *esId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ESID);
  }
  /// Epoch time, in ISO 8601 UTC format, of the orbital elements.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *epoch() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPOCH);
  }
  /// The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double semiMajorAxis() const {
    return GetField<double>(VT_SEMIMAJORAXIS, 0.0);
  }
  /// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double eccentricity() const {
    return GetField<double>(VT_ECCENTRICITY, 0.0);
  }
  /// The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double inclination() const {
    return GetField<double>(VT_INCLINATION, 0.0);
  }
  /// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double raan() const {
    return GetField<double>(VT_RAAN, 0.0);
  }
  /// The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double argOfPerigee() const {
    return GetField<double>(VT_ARGOFPERIGEE, 0.0);
  }
  /// The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double trueAnomoly() const {
    return GetField<double>(VT_TRUEANOMOLY, 0.0);
  }
  /// The expected or directed right ascension angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double ra() const {
    return GetField<double>(VT_RA, 0.0);
  }
  /// The expected or directed declination angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double dec() const {
    return GetField<double>(VT_DEC, 0.0);
  }
  /// The expected or directed azimuth angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double az() const {
    return GetField<double>(VT_AZ, 0.0);
  }
  /// The expected or directed elevation angle, in degrees, for search or target acquisition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double el() const {
    return GetField<double>(VT_EL, 0.0);
  }
  /// The expected acquisition range or defined center range, in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double range() const {
    return GetField<double>(VT_RANGE, 0.0);
  }
  /// The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double extentAz() const {
    return GetField<double>(VT_EXTENTAZ, 0.0);
  }
  /// The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double extentEl() const {
    return GetField<double>(VT_EXTENTEL, 0.0);
  }
  /// The extent of the range, in km, from center range to define a spatial volume.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double extentRange() const {
    return GetField<double>(VT_EXTENTRANGE, 0.0);
  }
  /// WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  /// WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  /// Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double alt() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  /// The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double stopLat() const {
    return GetField<double>(VT_STOPLAT, 0.0);
  }
  /// The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double stopLon() const {
    return GetField<double>(VT_STOPLON, 0.0);
  }
  /// The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double stopAlt() const {
    return GetField<double>(VT_STOPALT, 0.0);
  }
  /// The maximum inclination, in degrees, to be used in search operations.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double srchInc() const {
    return GetField<double>(VT_SRCHINC, 0.0);
  }
  /// The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double xAngle() const {
    return GetField<double>(VT_XANGLE, 0.0);
  }
  /// The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double yAngle() const {
    return GetField<double>(VT_YANGLE, 0.0);
  }
  /// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double orientAngle() const {
    return GetField<double>(VT_ORIENTANGLE, 0.0);
  }
  /// The customer for this request.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *customer() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CUSTOMER);
  }
  /// Notes or comments associated with this request.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  const ::flatbuffers::String *notes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NOTES);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: Example source
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  CollectRequest_Abridged_dataMode_Enum dataMode() const {
    return static_cast<CollectRequest_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *stateVector() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATEVECTOR);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *elset() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELSET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDPARENTREQ) &&
           verifier.VerifyString(idParentReq()) &&
           VerifyOffset(verifier, VT_MSGTYPE) &&
           verifier.VerifyString(msgType()) &&
           VerifyOffset(verifier, VT_MSGCREATEDATE) &&
           verifier.VerifyString(msgCreateDate()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_IDPLAN) &&
           verifier.VerifyString(idPlan()) &&
           VerifyField<int32_t>(verifier, VT_PLANINDEX, 4) &&
           VerifyOffset(verifier, VT_TASKID) &&
           verifier.VerifyString(taskId()) &&
           VerifyOffset(verifier, VT_DWELLID) &&
           verifier.VerifyString(dwellId()) &&
           VerifyOffset(verifier, VT_EXTERNALID) &&
           verifier.VerifyString(externalId()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyOffset(verifier, VT_OBTYPE) &&
           verifier.VerifyString(obType()) &&
           VerifyOffset(verifier, VT_PRIORITY) &&
           verifier.VerifyString(priority()) &&
           VerifyField<int32_t>(verifier, VT_TASKCATEGORY, 4) &&
           VerifyOffset(verifier, VT_SUFFIX) &&
           verifier.VerifyString(suffix()) &&
           VerifyField<uint8_t>(verifier, VT_UCTFOLLOWUP, 1) &&
           VerifyOffset(verifier, VT_STARTTIME) &&
           verifier.VerifyString(startTime()) &&
           VerifyOffset(verifier, VT_ENDTIME) &&
           verifier.VerifyString(endTime()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_TASKGROUP) &&
           verifier.VerifyString(taskGroup()) &&
           VerifyField<int32_t>(verifier, VT_IRON, 4) &&
           VerifyOffset(verifier, VT_ORBITREGIME) &&
           verifier.VerifyString(orbitRegime()) &&
           VerifyField<double>(verifier, VT_TARGETSIZE, 8) &&
           VerifyField<double>(verifier, VT_RCSMIN, 8) &&
           VerifyField<double>(verifier, VT_RCS, 8) &&
           VerifyField<double>(verifier, VT_RCSMAX, 8) &&
           VerifyField<double>(verifier, VT_FREQMIN, 8) &&
           VerifyField<double>(verifier, VT_FREQ, 8) &&
           VerifyField<double>(verifier, VT_FREQMAX, 8) &&
           VerifyOffset(verifier, VT_POLARIZATION) &&
           verifier.VerifyString(polarization()) &&
           VerifyField<double>(verifier, VT_VISMAGMIN, 8) &&
           VerifyField<double>(verifier, VT_VISMAG, 8) &&
           VerifyField<double>(verifier, VT_VISMAGMAX, 8) &&
           VerifyOffset(verifier, VT_SPECTRALMODEL) &&
           verifier.VerifyString(spectralModel()) &&
           VerifyField<double>(verifier, VT_REFLECTANCE, 8) &&
           VerifyField<double>(verifier, VT_IRRADIANCE, 8) &&
           VerifyField<int32_t>(verifier, VT_NUMFRAMES, 4) &&
           VerifyField<double>(verifier, VT_FRAMERATE, 8) &&
           VerifyField<double>(verifier, VT_INTEGRATIONTIME, 8) &&
           VerifyField<int32_t>(verifier, VT_NUMTRACKS, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMOBS, 4) &&
           VerifyField<int32_t>(verifier, VT_DURATION, 4) &&
           VerifyOffset(verifier, VT_SRCHPATTERN) &&
           verifier.VerifyString(srchPattern()) &&
           VerifyOffset(verifier, VT_SCENARIO) &&
           verifier.VerifyString(scenario()) &&
           VerifyOffset(verifier, VT_IDELSET) &&
           verifier.VerifyString(idElset()) &&
           VerifyOffset(verifier, VT_IDMANIFOLD) &&
           verifier.VerifyString(idManifold()) &&
           VerifyOffset(verifier, VT_IDSTATEVECTOR) &&
           verifier.VerifyString(idStateVector()) &&
           VerifyOffset(verifier, VT_ESID) &&
           verifier.VerifyString(esId()) &&
           VerifyOffset(verifier, VT_EPOCH) &&
           verifier.VerifyString(epoch()) &&
           VerifyField<double>(verifier, VT_SEMIMAJORAXIS, 8) &&
           VerifyField<double>(verifier, VT_ECCENTRICITY, 8) &&
           VerifyField<double>(verifier, VT_INCLINATION, 8) &&
           VerifyField<double>(verifier, VT_RAAN, 8) &&
           VerifyField<double>(verifier, VT_ARGOFPERIGEE, 8) &&
           VerifyField<double>(verifier, VT_TRUEANOMOLY, 8) &&
           VerifyField<double>(verifier, VT_RA, 8) &&
           VerifyField<double>(verifier, VT_DEC, 8) &&
           VerifyField<double>(verifier, VT_AZ, 8) &&
           VerifyField<double>(verifier, VT_EL, 8) &&
           VerifyField<double>(verifier, VT_RANGE, 8) &&
           VerifyField<double>(verifier, VT_EXTENTAZ, 8) &&
           VerifyField<double>(verifier, VT_EXTENTEL, 8) &&
           VerifyField<double>(verifier, VT_EXTENTRANGE, 8) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<double>(verifier, VT_ALT, 8) &&
           VerifyField<double>(verifier, VT_STOPLAT, 8) &&
           VerifyField<double>(verifier, VT_STOPLON, 8) &&
           VerifyField<double>(verifier, VT_STOPALT, 8) &&
           VerifyField<double>(verifier, VT_SRCHINC, 8) &&
           VerifyField<double>(verifier, VT_XANGLE, 8) &&
           VerifyField<double>(verifier, VT_YANGLE, 8) &&
           VerifyField<double>(verifier, VT_ORIENTANGLE, 8) &&
           VerifyOffset(verifier, VT_CUSTOMER) &&
           verifier.VerifyString(customer()) &&
           VerifyOffset(verifier, VT_NOTES) &&
           verifier.VerifyString(notes()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_STATEVECTOR) &&
           verifier.VerifyString(stateVector()) &&
           VerifyOffset(verifier, VT_ELSET) &&
           verifier.VerifyString(elset()) &&
           verifier.EndTable();
  }
};

struct CollectRequest_AbridgedBuilder {
  typedef CollectRequest_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idParentReq(::flatbuffers::Offset<::flatbuffers::String> idParentReq) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDPARENTREQ, idParentReq);
  }
  void add_msgType(::flatbuffers::Offset<::flatbuffers::String> msgType) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_MSGTYPE, msgType);
  }
  void add_msgCreateDate(::flatbuffers::Offset<::flatbuffers::String> msgCreateDate) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_MSGCREATEDATE, msgCreateDate);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_TYPE, type);
  }
  void add_idPlan(::flatbuffers::Offset<::flatbuffers::String> idPlan) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDPLAN, idPlan);
  }
  void add_planIndex(int32_t planIndex) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_PLANINDEX, planIndex, 0);
  }
  void add_taskId(::flatbuffers::Offset<::flatbuffers::String> taskId) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_TASKID, taskId);
  }
  void add_dwellId(::flatbuffers::Offset<::flatbuffers::String> dwellId) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_DWELLID, dwellId);
  }
  void add_externalId(::flatbuffers::Offset<::flatbuffers::String> externalId) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_EXTERNALID, externalId);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDSENSOR, idSensor);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ORIGSENSORID, origSensorId);
  }
  void add_obType(::flatbuffers::Offset<::flatbuffers::String> obType) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_OBTYPE, obType);
  }
  void add_priority(::flatbuffers::Offset<::flatbuffers::String> priority) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_PRIORITY, priority);
  }
  void add_taskCategory(int32_t taskCategory) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_TASKCATEGORY, taskCategory, 0);
  }
  void add_suffix(::flatbuffers::Offset<::flatbuffers::String> suffix) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_SUFFIX, suffix);
  }
  void add_uctFollowUp(bool uctFollowUp) {
    fbb_.AddElement<uint8_t>(CollectRequest_Abridged::VT_UCTFOLLOWUP, static_cast<uint8_t>(uctFollowUp), 0);
  }
  void add_startTime(::flatbuffers::Offset<::flatbuffers::String> startTime) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_STARTTIME, startTime);
  }
  void add_endTime(::flatbuffers::Offset<::flatbuffers::String> endTime) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ENDTIME, endTime);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_SATNO, satNo, 0);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  void add_taskGroup(::flatbuffers::Offset<::flatbuffers::String> taskGroup) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_TASKGROUP, taskGroup);
  }
  void add_iron(int32_t iron) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_IRON, iron, 0);
  }
  void add_orbitRegime(::flatbuffers::Offset<::flatbuffers::String> orbitRegime) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ORBITREGIME, orbitRegime);
  }
  void add_targetSize(double targetSize) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_TARGETSIZE, targetSize, 0.0);
  }
  void add_rcsMin(double rcsMin) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_RCSMIN, rcsMin, 0.0);
  }
  void add_rcs(double rcs) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_RCS, rcs, 0.0);
  }
  void add_rcsMax(double rcsMax) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_RCSMAX, rcsMax, 0.0);
  }
  void add_freqMin(double freqMin) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_FREQMIN, freqMin, 0.0);
  }
  void add_freq(double freq) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_FREQ, freq, 0.0);
  }
  void add_freqMax(double freqMax) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_FREQMAX, freqMax, 0.0);
  }
  void add_polarization(::flatbuffers::Offset<::flatbuffers::String> polarization) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_POLARIZATION, polarization);
  }
  void add_visMagMin(double visMagMin) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_VISMAGMIN, visMagMin, 0.0);
  }
  void add_visMag(double visMag) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_VISMAG, visMag, 0.0);
  }
  void add_visMagMax(double visMagMax) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_VISMAGMAX, visMagMax, 0.0);
  }
  void add_spectralModel(::flatbuffers::Offset<::flatbuffers::String> spectralModel) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_SPECTRALMODEL, spectralModel);
  }
  void add_reflectance(double reflectance) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_REFLECTANCE, reflectance, 0.0);
  }
  void add_irradiance(double irradiance) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_IRRADIANCE, irradiance, 0.0);
  }
  void add_numFrames(int32_t numFrames) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_NUMFRAMES, numFrames, 0);
  }
  void add_frameRate(double frameRate) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_FRAMERATE, frameRate, 0.0);
  }
  void add_integrationTime(double integrationTime) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_INTEGRATIONTIME, integrationTime, 0.0);
  }
  void add_numTracks(int32_t numTracks) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_NUMTRACKS, numTracks, 0);
  }
  void add_numObs(int32_t numObs) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_NUMOBS, numObs, 0);
  }
  void add_duration(int32_t duration) {
    fbb_.AddElement<int32_t>(CollectRequest_Abridged::VT_DURATION, duration, 0);
  }
  void add_srchPattern(::flatbuffers::Offset<::flatbuffers::String> srchPattern) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_SRCHPATTERN, srchPattern);
  }
  void add_scenario(::flatbuffers::Offset<::flatbuffers::String> scenario) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_SCENARIO, scenario);
  }
  void add_idElset(::flatbuffers::Offset<::flatbuffers::String> idElset) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDELSET, idElset);
  }
  void add_idManifold(::flatbuffers::Offset<::flatbuffers::String> idManifold) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDMANIFOLD, idManifold);
  }
  void add_idStateVector(::flatbuffers::Offset<::flatbuffers::String> idStateVector) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_IDSTATEVECTOR, idStateVector);
  }
  void add_esId(::flatbuffers::Offset<::flatbuffers::String> esId) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ESID, esId);
  }
  void add_epoch(::flatbuffers::Offset<::flatbuffers::String> epoch) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_EPOCH, epoch);
  }
  void add_semiMajorAxis(double semiMajorAxis) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_SEMIMAJORAXIS, semiMajorAxis, 0.0);
  }
  void add_eccentricity(double eccentricity) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_ECCENTRICITY, eccentricity, 0.0);
  }
  void add_inclination(double inclination) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_INCLINATION, inclination, 0.0);
  }
  void add_raan(double raan) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_RAAN, raan, 0.0);
  }
  void add_argOfPerigee(double argOfPerigee) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_ARGOFPERIGEE, argOfPerigee, 0.0);
  }
  void add_trueAnomoly(double trueAnomoly) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_TRUEANOMOLY, trueAnomoly, 0.0);
  }
  void add_ra(double ra) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_RA, ra, 0.0);
  }
  void add_dec(double dec) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_DEC, dec, 0.0);
  }
  void add_az(double az) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_AZ, az, 0.0);
  }
  void add_el(double el) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_EL, el, 0.0);
  }
  void add_range(double range) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_RANGE, range, 0.0);
  }
  void add_extentAz(double extentAz) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_EXTENTAZ, extentAz, 0.0);
  }
  void add_extentEl(double extentEl) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_EXTENTEL, extentEl, 0.0);
  }
  void add_extentRange(double extentRange) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_EXTENTRANGE, extentRange, 0.0);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_LON, lon, 0.0);
  }
  void add_alt(double alt) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_ALT, alt, 0.0);
  }
  void add_stopLat(double stopLat) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_STOPLAT, stopLat, 0.0);
  }
  void add_stopLon(double stopLon) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_STOPLON, stopLon, 0.0);
  }
  void add_stopAlt(double stopAlt) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_STOPALT, stopAlt, 0.0);
  }
  void add_srchInc(double srchInc) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_SRCHINC, srchInc, 0.0);
  }
  void add_xAngle(double xAngle) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_XANGLE, xAngle, 0.0);
  }
  void add_yAngle(double yAngle) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_YANGLE, yAngle, 0.0);
  }
  void add_orientAngle(double orientAngle) {
    fbb_.AddElement<double>(CollectRequest_Abridged::VT_ORIENTANGLE, orientAngle, 0.0);
  }
  void add_customer(::flatbuffers::Offset<::flatbuffers::String> customer) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_CUSTOMER, customer);
  }
  void add_notes(::flatbuffers::Offset<::flatbuffers::String> notes) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_NOTES, notes);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(CollectRequest_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(CollectRequest_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_stateVector(::flatbuffers::Offset<::flatbuffers::String> stateVector) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_STATEVECTOR, stateVector);
  }
  void add_elset(::flatbuffers::Offset<::flatbuffers::String> elset) {
    fbb_.AddOffset(CollectRequest_Abridged::VT_ELSET, elset);
  }
  explicit CollectRequest_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CollectRequest_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CollectRequest_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CollectRequest_Abridged> CreateCollectRequest_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idParentReq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> msgCreateDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idPlan = 0,
    int32_t planIndex = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dwellId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> externalId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> priority = 0,
    int32_t taskCategory = 0,
    ::flatbuffers::Offset<::flatbuffers::String> suffix = 0,
    bool uctFollowUp = false,
    ::flatbuffers::Offset<::flatbuffers::String> startTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> endTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskGroup = 0,
    int32_t iron = 0,
    ::flatbuffers::Offset<::flatbuffers::String> orbitRegime = 0,
    double targetSize = 0.0,
    double rcsMin = 0.0,
    double rcs = 0.0,
    double rcsMax = 0.0,
    double freqMin = 0.0,
    double freq = 0.0,
    double freqMax = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> polarization = 0,
    double visMagMin = 0.0,
    double visMag = 0.0,
    double visMagMax = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> spectralModel = 0,
    double reflectance = 0.0,
    double irradiance = 0.0,
    int32_t numFrames = 0,
    double frameRate = 0.0,
    double integrationTime = 0.0,
    int32_t numTracks = 0,
    int32_t numObs = 0,
    int32_t duration = 0,
    ::flatbuffers::Offset<::flatbuffers::String> srchPattern = 0,
    ::flatbuffers::Offset<::flatbuffers::String> scenario = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idElset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idManifold = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idStateVector = 0,
    ::flatbuffers::Offset<::flatbuffers::String> esId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> epoch = 0,
    double semiMajorAxis = 0.0,
    double eccentricity = 0.0,
    double inclination = 0.0,
    double raan = 0.0,
    double argOfPerigee = 0.0,
    double trueAnomoly = 0.0,
    double ra = 0.0,
    double dec = 0.0,
    double az = 0.0,
    double el = 0.0,
    double range = 0.0,
    double extentAz = 0.0,
    double extentEl = 0.0,
    double extentRange = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0,
    double stopLat = 0.0,
    double stopLon = 0.0,
    double stopAlt = 0.0,
    double srchInc = 0.0,
    double xAngle = 0.0,
    double yAngle = 0.0,
    double orientAngle = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> customer = 0,
    ::flatbuffers::Offset<::flatbuffers::String> notes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    CollectRequest_Abridged_dataMode_Enum dataMode = CollectRequest_Abridged_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> stateVector = 0,
    ::flatbuffers::Offset<::flatbuffers::String> elset = 0) {
  CollectRequest_AbridgedBuilder builder_(_fbb);
  builder_.add_orientAngle(orientAngle);
  builder_.add_yAngle(yAngle);
  builder_.add_xAngle(xAngle);
  builder_.add_srchInc(srchInc);
  builder_.add_stopAlt(stopAlt);
  builder_.add_stopLon(stopLon);
  builder_.add_stopLat(stopLat);
  builder_.add_alt(alt);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_extentRange(extentRange);
  builder_.add_extentEl(extentEl);
  builder_.add_extentAz(extentAz);
  builder_.add_range(range);
  builder_.add_el(el);
  builder_.add_az(az);
  builder_.add_dec(dec);
  builder_.add_ra(ra);
  builder_.add_trueAnomoly(trueAnomoly);
  builder_.add_argOfPerigee(argOfPerigee);
  builder_.add_raan(raan);
  builder_.add_inclination(inclination);
  builder_.add_eccentricity(eccentricity);
  builder_.add_semiMajorAxis(semiMajorAxis);
  builder_.add_integrationTime(integrationTime);
  builder_.add_frameRate(frameRate);
  builder_.add_irradiance(irradiance);
  builder_.add_reflectance(reflectance);
  builder_.add_visMagMax(visMagMax);
  builder_.add_visMag(visMag);
  builder_.add_visMagMin(visMagMin);
  builder_.add_freqMax(freqMax);
  builder_.add_freq(freq);
  builder_.add_freqMin(freqMin);
  builder_.add_rcsMax(rcsMax);
  builder_.add_rcs(rcs);
  builder_.add_rcsMin(rcsMin);
  builder_.add_targetSize(targetSize);
  builder_.add_elset(elset);
  builder_.add_stateVector(stateVector);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_notes(notes);
  builder_.add_customer(customer);
  builder_.add_epoch(epoch);
  builder_.add_esId(esId);
  builder_.add_idStateVector(idStateVector);
  builder_.add_idManifold(idManifold);
  builder_.add_idElset(idElset);
  builder_.add_scenario(scenario);
  builder_.add_srchPattern(srchPattern);
  builder_.add_duration(duration);
  builder_.add_numObs(numObs);
  builder_.add_numTracks(numTracks);
  builder_.add_numFrames(numFrames);
  builder_.add_spectralModel(spectralModel);
  builder_.add_polarization(polarization);
  builder_.add_orbitRegime(orbitRegime);
  builder_.add_iron(iron);
  builder_.add_taskGroup(taskGroup);
  builder_.add_origObjectId(origObjectId);
  builder_.add_satNo(satNo);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_endTime(endTime);
  builder_.add_startTime(startTime);
  builder_.add_suffix(suffix);
  builder_.add_taskCategory(taskCategory);
  builder_.add_priority(priority);
  builder_.add_obType(obType);
  builder_.add_origSensorId(origSensorId);
  builder_.add_idSensor(idSensor);
  builder_.add_externalId(externalId);
  builder_.add_dwellId(dwellId);
  builder_.add_taskId(taskId);
  builder_.add_planIndex(planIndex);
  builder_.add_idPlan(idPlan);
  builder_.add_type(type);
  builder_.add_msgCreateDate(msgCreateDate);
  builder_.add_msgType(msgType);
  builder_.add_idParentReq(idParentReq);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_uctFollowUp(uctFollowUp);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CollectRequest_Abridged> CreateCollectRequest_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idParentReq = nullptr,
    const char *msgType = nullptr,
    const char *msgCreateDate = nullptr,
    const char *type = nullptr,
    const char *idPlan = nullptr,
    int32_t planIndex = 0,
    const char *taskId = nullptr,
    const char *dwellId = nullptr,
    const char *externalId = nullptr,
    const char *idSensor = nullptr,
    const char *origSensorId = nullptr,
    const char *obType = nullptr,
    const char *priority = nullptr,
    int32_t taskCategory = 0,
    const char *suffix = nullptr,
    bool uctFollowUp = false,
    const char *startTime = nullptr,
    const char *endTime = nullptr,
    const char *idOnOrbit = nullptr,
    int32_t satNo = 0,
    const char *origObjectId = nullptr,
    const char *taskGroup = nullptr,
    int32_t iron = 0,
    const char *orbitRegime = nullptr,
    double targetSize = 0.0,
    double rcsMin = 0.0,
    double rcs = 0.0,
    double rcsMax = 0.0,
    double freqMin = 0.0,
    double freq = 0.0,
    double freqMax = 0.0,
    const char *polarization = nullptr,
    double visMagMin = 0.0,
    double visMag = 0.0,
    double visMagMax = 0.0,
    const char *spectralModel = nullptr,
    double reflectance = 0.0,
    double irradiance = 0.0,
    int32_t numFrames = 0,
    double frameRate = 0.0,
    double integrationTime = 0.0,
    int32_t numTracks = 0,
    int32_t numObs = 0,
    int32_t duration = 0,
    const char *srchPattern = nullptr,
    const char *scenario = nullptr,
    const char *idElset = nullptr,
    const char *idManifold = nullptr,
    const char *idStateVector = nullptr,
    const char *esId = nullptr,
    const char *epoch = nullptr,
    double semiMajorAxis = 0.0,
    double eccentricity = 0.0,
    double inclination = 0.0,
    double raan = 0.0,
    double argOfPerigee = 0.0,
    double trueAnomoly = 0.0,
    double ra = 0.0,
    double dec = 0.0,
    double az = 0.0,
    double el = 0.0,
    double range = 0.0,
    double extentAz = 0.0,
    double extentEl = 0.0,
    double extentRange = 0.0,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0,
    double stopLat = 0.0,
    double stopLon = 0.0,
    double stopAlt = 0.0,
    double srchInc = 0.0,
    double xAngle = 0.0,
    double yAngle = 0.0,
    double orientAngle = 0.0,
    const char *customer = nullptr,
    const char *notes = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    CollectRequest_Abridged_dataMode_Enum dataMode = CollectRequest_Abridged_dataMode_Enum_REAL,
    const char *stateVector = nullptr,
    const char *elset = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idParentReq__ = idParentReq ? _fbb.CreateString(idParentReq) : 0;
  auto msgType__ = msgType ? _fbb.CreateString(msgType) : 0;
  auto msgCreateDate__ = msgCreateDate ? _fbb.CreateString(msgCreateDate) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto idPlan__ = idPlan ? _fbb.CreateString(idPlan) : 0;
  auto taskId__ = taskId ? _fbb.CreateString(taskId) : 0;
  auto dwellId__ = dwellId ? _fbb.CreateString(dwellId) : 0;
  auto externalId__ = externalId ? _fbb.CreateString(externalId) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto obType__ = obType ? _fbb.CreateString(obType) : 0;
  auto priority__ = priority ? _fbb.CreateString(priority) : 0;
  auto suffix__ = suffix ? _fbb.CreateString(suffix) : 0;
  auto startTime__ = startTime ? _fbb.CreateString(startTime) : 0;
  auto endTime__ = endTime ? _fbb.CreateString(endTime) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto taskGroup__ = taskGroup ? _fbb.CreateString(taskGroup) : 0;
  auto orbitRegime__ = orbitRegime ? _fbb.CreateString(orbitRegime) : 0;
  auto polarization__ = polarization ? _fbb.CreateString(polarization) : 0;
  auto spectralModel__ = spectralModel ? _fbb.CreateString(spectralModel) : 0;
  auto srchPattern__ = srchPattern ? _fbb.CreateString(srchPattern) : 0;
  auto scenario__ = scenario ? _fbb.CreateString(scenario) : 0;
  auto idElset__ = idElset ? _fbb.CreateString(idElset) : 0;
  auto idManifold__ = idManifold ? _fbb.CreateString(idManifold) : 0;
  auto idStateVector__ = idStateVector ? _fbb.CreateString(idStateVector) : 0;
  auto esId__ = esId ? _fbb.CreateString(esId) : 0;
  auto epoch__ = epoch ? _fbb.CreateString(epoch) : 0;
  auto customer__ = customer ? _fbb.CreateString(customer) : 0;
  auto notes__ = notes ? _fbb.CreateString(notes) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto stateVector__ = stateVector ? _fbb.CreateString(stateVector) : 0;
  auto elset__ = elset ? _fbb.CreateString(elset) : 0;
  return CreateCollectRequest_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      idParentReq__,
      msgType__,
      msgCreateDate__,
      type__,
      idPlan__,
      planIndex,
      taskId__,
      dwellId__,
      externalId__,
      idSensor__,
      origSensorId__,
      obType__,
      priority__,
      taskCategory,
      suffix__,
      uctFollowUp,
      startTime__,
      endTime__,
      idOnOrbit__,
      satNo,
      origObjectId__,
      taskGroup__,
      iron,
      orbitRegime__,
      targetSize,
      rcsMin,
      rcs,
      rcsMax,
      freqMin,
      freq,
      freqMax,
      polarization__,
      visMagMin,
      visMag,
      visMagMax,
      spectralModel__,
      reflectance,
      irradiance,
      numFrames,
      frameRate,
      integrationTime,
      numTracks,
      numObs,
      duration,
      srchPattern__,
      scenario__,
      idElset__,
      idManifold__,
      idStateVector__,
      esId__,
      epoch__,
      semiMajorAxis,
      eccentricity,
      inclination,
      raan,
      argOfPerigee,
      trueAnomoly,
      ra,
      dec,
      az,
      el,
      range,
      extentAz,
      extentEl,
      extentRange,
      lat,
      lon,
      alt,
      stopLat,
      stopLon,
      stopAlt,
      srchInc,
      xAngle,
      yAngle,
      orientAngle,
      customer__,
      notes__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      origNetwork__,
      dataMode,
      stateVector__,
      elset__);
}

inline const CollectRequest_Abridged *GetCollectRequest_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<CollectRequest_Abridged>(buf);
}

inline const CollectRequest_Abridged *GetSizePrefixedCollectRequest_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<CollectRequest_Abridged>(buf);
}

inline const char *CollectRequest_AbridgedIdentifier() {
  return "COLL";
}

inline bool CollectRequest_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CollectRequest_AbridgedIdentifier());
}

inline bool SizePrefixedCollectRequest_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, CollectRequest_AbridgedIdentifier(), true);
}

inline bool VerifyCollectRequest_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<CollectRequest_Abridged>(CollectRequest_AbridgedIdentifier());
}

inline bool VerifySizePrefixedCollectRequest_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<CollectRequest_Abridged>(CollectRequest_AbridgedIdentifier());
}

inline void FinishCollectRequest_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CollectRequest_Abridged> root) {
  fbb.Finish(root, CollectRequest_AbridgedIdentifier());
}

inline void FinishSizePrefixedCollectRequest_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<CollectRequest_Abridged> root) {
  fbb.FinishSizePrefixed(root, CollectRequest_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
