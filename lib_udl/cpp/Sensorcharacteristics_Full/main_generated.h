// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Sensorcharacteristics_Full;
struct Sensorcharacteristics_FullBuilder;

enum Sensorcharacteristics_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Sensorcharacteristics_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Sensorcharacteristics_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Sensorcharacteristics_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Sensorcharacteristics_Full_dataMode_Enum_EXERCISE = 3,
  Sensorcharacteristics_Full_dataMode_Enum_MIN = Sensorcharacteristics_Full_dataMode_Enum_REAL,
  Sensorcharacteristics_Full_dataMode_Enum_MAX = Sensorcharacteristics_Full_dataMode_Enum_EXERCISE
};

inline const Sensorcharacteristics_Full_dataMode_Enum (&EnumValuesSensorcharacteristics_Full_dataMode_Enum())[4] {
  static const Sensorcharacteristics_Full_dataMode_Enum values[] = {
    Sensorcharacteristics_Full_dataMode_Enum_REAL,
    Sensorcharacteristics_Full_dataMode_Enum_TEST,
    Sensorcharacteristics_Full_dataMode_Enum_SIMULATED,
    Sensorcharacteristics_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSensorcharacteristics_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorcharacteristics_Full_dataMode_Enum(Sensorcharacteristics_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Sensorcharacteristics_Full_dataMode_Enum_REAL, Sensorcharacteristics_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorcharacteristics_Full_dataMode_Enum()[index];
}

/// /// Model representation of characteristics and capabilities of a sensor.
struct Sensorcharacteristics_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Sensorcharacteristics_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_IDSENSOR = 6,
    VT_CLASSIFICATIONMARKING = 8,
    VT_ORIGNETWORK = 10,
    VT_AZIMUTHRATE = 12,
    VT_ELEVATIONRATEGEOLM = 14,
    VT_MINRANGELIMIT = 16,
    VT_MAXRANGELIMIT = 18,
    VT_LEFTCLOCKANGLE = 20,
    VT_RIGHTCLOCKANGLE = 22,
    VT_BORESIGHT = 24,
    VT_BORESIGHTOFFANGLE = 26,
    VT_NEGATIVERANGERATELIMIT = 28,
    VT_POSITIVERANGERATELIMIT = 30,
    VT_MAGNITUDELIMIT = 32,
    VT_TRACKANGLE = 34,
    VT_MINSIGNALNOISERATIO = 36,
    VT_FANBEAMWIDTH = 38,
    VT_TASKABLERANGE = 40,
    VT_MAXOBSERVABLERANGE = 42,
    VT_RADIOFREQUENCY = 44,
    VT_RADARFREQUENCY = 46,
    VT_TRANSMITPOWER = 48,
    VT_HFOV = 50,
    VT_VFOV = 52,
    VT_HRESPIXELS = 54,
    VT_VRESPIXELS = 56,
    VT_BAND = 58,
    VT_MAXDEVIATIONANGLE = 60,
    VT_APERTURE = 62,
    VT_LEFTGEOBELTLIMIT = 64,
    VT_RIGHTGEOBELTLIMIT = 66,
    VT_ASRSCANRATE = 68,
    VT_K = 70,
    VT_FOCALPOINT = 72,
    VT_TOWERHEIGHT = 74,
    VT_TRUENORTHCORRECTOR = 76,
    VT_MAGDEC = 78,
    VT_Z1MINRANGE = 80,
    VT_Z2MINRANGE = 82,
    VT_Z1MAXRANGE = 84,
    VT_Z2MAXRANGE = 86,
    VT_RADARMUR = 88,
    VT_PROBFALSEALARM = 90,
    VT_PRF = 92,
    VT_RADARPULSEWIDTH = 94,
    VT_NUMINTEGRATEDPULSES = 96,
    VT_TRUETILT = 98,
    VT_RADARMESSAGEFORMAT = 100,
    VT_SYSTEMNOISETEMPERATURE = 102,
    VT_SOURCE = 104,
    VT_DATAMODE = 106,
    VT_CREATEDAT = 108,
    VT_CREATEDBY = 110,
    VT_UPDATEDAT = 112,
    VT_UPDATEDBY = 114
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SENSORCHARACTERISTICS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Unique identifier of the parent sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Azimuth rate acquisition limit (rad/min).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  double azimuthRate() const {
    return GetField<double>(VT_AZIMUTHRATE, 0.0);
  }
  /// Elevation rate acquisition limit (rad/min).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  double elevationRateGeolm() const {
    return GetField<double>(VT_ELEVATIONRATEGEOLM, 0.0);
  }
  /// Minimum range measurement capability of the sensor (km).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double minRangeLimit() const {
    return GetField<double>(VT_MINRANGELIMIT, 0.0);
  }
  /// Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double maxRangeLimit() const {
    return GetField<double>(VT_MAXRANGELIMIT, 0.0);
  }
  /// For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double leftClockAngle() const {
    return GetField<double>(VT_LEFTCLOCKANGLE, 0.0);
  }
  /// For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double rightClockAngle() const {
    return GetField<double>(VT_RIGHTCLOCKANGLE, 0.0);
  }
  /// The angle of the center of a phased array sensor.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double boresight() const {
    return GetField<double>(VT_BORESIGHT, 0.0);
  }
  /// The number of degrees off of the boresight for the sensor (degrees).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double boresightOffAngle() const {
    return GetField<double>(VT_BORESIGHTOFFANGLE, 0.0);
  }
  /// Negative Range-rate/relative velocity limit (km/sec).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double negativeRangeRateLimit() const {
    return GetField<double>(VT_NEGATIVERANGERATELIMIT, 0.0);
  }
  /// Positive Range-rate/relative velocity limit (km/sec).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double positiveRangeRateLimit() const {
    return GetField<double>(VT_POSITIVERANGERATELIMIT, 0.0);
  }
  /// Absolute magnitude acquisition limit for optical sensors.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double magnitudeLimit() const {
    return GetField<double>(VT_MAGNITUDELIMIT, 0.0);
  }
  /// Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double trackAngle() const {
    return GetField<double>(VT_TRACKANGLE, 0.0);
  }
  /// Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double minSignalNoiseRatio() const {
    return GetField<double>(VT_MINSIGNALNOISERATIO, 0.0);
  }
  /// The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
  /// Example: /// Example: 3.1
  /// Constraints: No constraints specified.
  double fanBeamWidth() const {
    return GetField<double>(VT_FANBEAMWIDTH, 0.0);
  }
  /// Maximum taskable range of the sensor (km).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double taskableRange() const {
    return GetField<double>(VT_TASKABLERANGE, 0.0);
  }
  /// Maximum observable sensor range (km).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double maxObservableRange() const {
    return GetField<double>(VT_MAXOBSERVABLERANGE, 0.0);
  }
  /// Radio frequency (if sensor is RF).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double radioFrequency() const {
    return GetField<double>(VT_RADIOFREQUENCY, 0.0);
  }
  /// Radar frequency of the sensor (if a radar sensor).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double radarFrequency() const {
    return GetField<double>(VT_RADARFREQUENCY, 0.0);
  }
  /// Radar transmit power in Watts.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double transmitPower() const {
    return GetField<double>(VT_TRANSMITPOWER, 0.0);
  }
  /// Horizontal field of view.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double hFOV() const {
    return GetField<double>(VT_HFOV, 0.0);
  }
  /// Vertical field of view.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double vFOV() const {
    return GetField<double>(VT_VFOV, 0.0);
  }
  /// Horizontal pixel resolution.
  /// Example: /// Example: 1000
  /// Constraints: No constraints specified.
  int32_t hResPixels() const {
    return GetField<int32_t>(VT_HRESPIXELS, 0);
  }
  /// Vertical pixel resolution.
  /// Example: /// Example: 1000
  /// Constraints: No constraints specified.
  int32_t vResPixels() const {
    return GetField<int32_t>(VT_VRESPIXELS, 0);
  }
  /// Sensor band.
  /// Example: /// Example: BAND
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *band() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BAND);
  }
  /// Max deviation angle of the sensor in degrees.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double maxDeviationAngle() const {
    return GetField<double>(VT_MAXDEVIATIONANGLE, 0.0);
  }
  /// Optical sensor camera aperture.
  /// Example: /// Example: 2.23
  /// Constraints: No constraints specified.
  double aperture() const {
    return GetField<double>(VT_APERTURE, 0.0);
  }
  /// Leftmost GEO belt longitude limit for this sensor (if applicable).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double leftGeoBeltLimit() const {
    return GetField<double>(VT_LEFTGEOBELTLIMIT, 0.0);
  }
  /// Rightmost GEO belt longitude limit for this sensor (if applicable).
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double rightGeoBeltLimit() const {
    return GetField<double>(VT_RIGHTGEOBELTLIMIT, 0.0);
  }
  /// For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double asrScanRate() const {
    return GetField<double>(VT_ASRSCANRATE, 0.0);
  }
  /// For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2).
  /// Example: /// Example: 1.4
  /// Constraints: No constraints specified.
  double k() const {
    return GetField<double>(VT_K, 0.0);
  }
  /// For radar based sensors, the focal point elevation of the radar at the site, in meters.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double focalPoint() const {
    return GetField<double>(VT_FOCALPOINT, 0.0);
  }
  /// For tower sensors, the physical height of the sensor tower, in meters.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double towerHeight() const {
    return GetField<double>(VT_TOWERHEIGHT, 0.0);
  }
  /// True North correction for the sensor, in ACP (Azimunth Change Pulse) count.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t trueNorthCorrector() const {
    return GetField<int32_t>(VT_TRUENORTHCORRECTOR, 0);
  }
  /// Angle between magnetic north and true north at the sensor site, in degrees.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double magDec() const {
    return GetField<double>(VT_MAGDEC, 0.0);
  }
  /// Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double z1MinRange() const {
    return GetField<double>(VT_Z1MINRANGE, 0.0);
  }
  /// Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double z2MinRange() const {
    return GetField<double>(VT_Z2MINRANGE, 0.0);
  }
  /// Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  double z1MaxRange() const {
    return GetField<double>(VT_Z1MAXRANGE, 0.0);
  }
  /// Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  double z2MaxRange() const {
    return GetField<double>(VT_Z2MAXRANGE, 0.0);
  }
  /// For radar based sensors, radar maximum unambiguous range, in km.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double radarMUR() const {
    return GetField<double>(VT_RADARMUR, 0.0);
  }
  /// For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference.
  /// Example: /// Example: 0.5
  /// Constraints: No constraints specified.
  double probFalseAlarm() const {
    return GetField<double>(VT_PROBFALSEALARM, 0.0);
  }
  /// For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double prf() const {
    return GetField<double>(VT_PRF, 0.0);
  }
  /// For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double radarPulseWidth() const {
    return GetField<double>(VT_RADARPULSEWIDTH, 0.0);
  }
  /// For radar based sensors, number of integrated pulses in a transmit cycle.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t numIntegratedPulses() const {
    return GetField<int32_t>(VT_NUMINTEGRATEDPULSES, 0);
  }
  /// Antenna true tilt, in degrees.
  /// Example: /// Example: 20.23
  /// Constraints: No constraints specified.
  double trueTilt() const {
    return GetField<double>(VT_TRUETILT, 0.0);
  }
  /// Message data format transmitted by the sensor digitizer.
  /// Example: /// Example: DATA_FORMAT
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *radarMessageFormat() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RADARMESSAGEFORMAT);
  }
  /// For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin.
  /// Example: /// Example: 3.5
  /// Constraints: No constraints specified.
  double systemNoiseTemperature() const {
    return GetField<double>(VT_SYSTEMNOISETEMPERATURE, 0.0);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Sensorcharacteristics_Full_dataMode_Enum dataMode() const {
    return static_cast<Sensorcharacteristics_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<double>(verifier, VT_AZIMUTHRATE, 8) &&
           VerifyField<double>(verifier, VT_ELEVATIONRATEGEOLM, 8) &&
           VerifyField<double>(verifier, VT_MINRANGELIMIT, 8) &&
           VerifyField<double>(verifier, VT_MAXRANGELIMIT, 8) &&
           VerifyField<double>(verifier, VT_LEFTCLOCKANGLE, 8) &&
           VerifyField<double>(verifier, VT_RIGHTCLOCKANGLE, 8) &&
           VerifyField<double>(verifier, VT_BORESIGHT, 8) &&
           VerifyField<double>(verifier, VT_BORESIGHTOFFANGLE, 8) &&
           VerifyField<double>(verifier, VT_NEGATIVERANGERATELIMIT, 8) &&
           VerifyField<double>(verifier, VT_POSITIVERANGERATELIMIT, 8) &&
           VerifyField<double>(verifier, VT_MAGNITUDELIMIT, 8) &&
           VerifyField<double>(verifier, VT_TRACKANGLE, 8) &&
           VerifyField<double>(verifier, VT_MINSIGNALNOISERATIO, 8) &&
           VerifyField<double>(verifier, VT_FANBEAMWIDTH, 8) &&
           VerifyField<double>(verifier, VT_TASKABLERANGE, 8) &&
           VerifyField<double>(verifier, VT_MAXOBSERVABLERANGE, 8) &&
           VerifyField<double>(verifier, VT_RADIOFREQUENCY, 8) &&
           VerifyField<double>(verifier, VT_RADARFREQUENCY, 8) &&
           VerifyField<double>(verifier, VT_TRANSMITPOWER, 8) &&
           VerifyField<double>(verifier, VT_HFOV, 8) &&
           VerifyField<double>(verifier, VT_VFOV, 8) &&
           VerifyField<int32_t>(verifier, VT_HRESPIXELS, 4) &&
           VerifyField<int32_t>(verifier, VT_VRESPIXELS, 4) &&
           VerifyOffset(verifier, VT_BAND) &&
           verifier.VerifyString(band()) &&
           VerifyField<double>(verifier, VT_MAXDEVIATIONANGLE, 8) &&
           VerifyField<double>(verifier, VT_APERTURE, 8) &&
           VerifyField<double>(verifier, VT_LEFTGEOBELTLIMIT, 8) &&
           VerifyField<double>(verifier, VT_RIGHTGEOBELTLIMIT, 8) &&
           VerifyField<double>(verifier, VT_ASRSCANRATE, 8) &&
           VerifyField<double>(verifier, VT_K, 8) &&
           VerifyField<double>(verifier, VT_FOCALPOINT, 8) &&
           VerifyField<double>(verifier, VT_TOWERHEIGHT, 8) &&
           VerifyField<int32_t>(verifier, VT_TRUENORTHCORRECTOR, 4) &&
           VerifyField<double>(verifier, VT_MAGDEC, 8) &&
           VerifyField<double>(verifier, VT_Z1MINRANGE, 8) &&
           VerifyField<double>(verifier, VT_Z2MINRANGE, 8) &&
           VerifyField<double>(verifier, VT_Z1MAXRANGE, 8) &&
           VerifyField<double>(verifier, VT_Z2MAXRANGE, 8) &&
           VerifyField<double>(verifier, VT_RADARMUR, 8) &&
           VerifyField<double>(verifier, VT_PROBFALSEALARM, 8) &&
           VerifyField<double>(verifier, VT_PRF, 8) &&
           VerifyField<double>(verifier, VT_RADARPULSEWIDTH, 8) &&
           VerifyField<int32_t>(verifier, VT_NUMINTEGRATEDPULSES, 4) &&
           VerifyField<double>(verifier, VT_TRUETILT, 8) &&
           VerifyOffset(verifier, VT_RADARMESSAGEFORMAT) &&
           verifier.VerifyString(radarMessageFormat()) &&
           VerifyField<double>(verifier, VT_SYSTEMNOISETEMPERATURE, 8) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           verifier.EndTable();
  }
};

struct Sensorcharacteristics_FullBuilder {
  typedef Sensorcharacteristics_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_ID, id);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_IDSENSOR, idSensor);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_azimuthRate(double azimuthRate) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_AZIMUTHRATE, azimuthRate, 0.0);
  }
  void add_elevationRateGeolm(double elevationRateGeolm) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_ELEVATIONRATEGEOLM, elevationRateGeolm, 0.0);
  }
  void add_minRangeLimit(double minRangeLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MINRANGELIMIT, minRangeLimit, 0.0);
  }
  void add_maxRangeLimit(double maxRangeLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MAXRANGELIMIT, maxRangeLimit, 0.0);
  }
  void add_leftClockAngle(double leftClockAngle) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_LEFTCLOCKANGLE, leftClockAngle, 0.0);
  }
  void add_rightClockAngle(double rightClockAngle) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_RIGHTCLOCKANGLE, rightClockAngle, 0.0);
  }
  void add_boresight(double boresight) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_BORESIGHT, boresight, 0.0);
  }
  void add_boresightOffAngle(double boresightOffAngle) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_BORESIGHTOFFANGLE, boresightOffAngle, 0.0);
  }
  void add_negativeRangeRateLimit(double negativeRangeRateLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_NEGATIVERANGERATELIMIT, negativeRangeRateLimit, 0.0);
  }
  void add_positiveRangeRateLimit(double positiveRangeRateLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_POSITIVERANGERATELIMIT, positiveRangeRateLimit, 0.0);
  }
  void add_magnitudeLimit(double magnitudeLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MAGNITUDELIMIT, magnitudeLimit, 0.0);
  }
  void add_trackAngle(double trackAngle) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_TRACKANGLE, trackAngle, 0.0);
  }
  void add_minSignalNoiseRatio(double minSignalNoiseRatio) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MINSIGNALNOISERATIO, minSignalNoiseRatio, 0.0);
  }
  void add_fanBeamWidth(double fanBeamWidth) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_FANBEAMWIDTH, fanBeamWidth, 0.0);
  }
  void add_taskableRange(double taskableRange) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_TASKABLERANGE, taskableRange, 0.0);
  }
  void add_maxObservableRange(double maxObservableRange) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MAXOBSERVABLERANGE, maxObservableRange, 0.0);
  }
  void add_radioFrequency(double radioFrequency) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_RADIOFREQUENCY, radioFrequency, 0.0);
  }
  void add_radarFrequency(double radarFrequency) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_RADARFREQUENCY, radarFrequency, 0.0);
  }
  void add_transmitPower(double transmitPower) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_TRANSMITPOWER, transmitPower, 0.0);
  }
  void add_hFOV(double hFOV) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_HFOV, hFOV, 0.0);
  }
  void add_vFOV(double vFOV) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_VFOV, vFOV, 0.0);
  }
  void add_hResPixels(int32_t hResPixels) {
    fbb_.AddElement<int32_t>(Sensorcharacteristics_Full::VT_HRESPIXELS, hResPixels, 0);
  }
  void add_vResPixels(int32_t vResPixels) {
    fbb_.AddElement<int32_t>(Sensorcharacteristics_Full::VT_VRESPIXELS, vResPixels, 0);
  }
  void add_band(::flatbuffers::Offset<::flatbuffers::String> band) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_BAND, band);
  }
  void add_maxDeviationAngle(double maxDeviationAngle) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MAXDEVIATIONANGLE, maxDeviationAngle, 0.0);
  }
  void add_aperture(double aperture) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_APERTURE, aperture, 0.0);
  }
  void add_leftGeoBeltLimit(double leftGeoBeltLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_LEFTGEOBELTLIMIT, leftGeoBeltLimit, 0.0);
  }
  void add_rightGeoBeltLimit(double rightGeoBeltLimit) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_RIGHTGEOBELTLIMIT, rightGeoBeltLimit, 0.0);
  }
  void add_asrScanRate(double asrScanRate) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_ASRSCANRATE, asrScanRate, 0.0);
  }
  void add_k(double k) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_K, k, 0.0);
  }
  void add_focalPoint(double focalPoint) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_FOCALPOINT, focalPoint, 0.0);
  }
  void add_towerHeight(double towerHeight) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_TOWERHEIGHT, towerHeight, 0.0);
  }
  void add_trueNorthCorrector(int32_t trueNorthCorrector) {
    fbb_.AddElement<int32_t>(Sensorcharacteristics_Full::VT_TRUENORTHCORRECTOR, trueNorthCorrector, 0);
  }
  void add_magDec(double magDec) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_MAGDEC, magDec, 0.0);
  }
  void add_z1MinRange(double z1MinRange) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_Z1MINRANGE, z1MinRange, 0.0);
  }
  void add_z2MinRange(double z2MinRange) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_Z2MINRANGE, z2MinRange, 0.0);
  }
  void add_z1MaxRange(double z1MaxRange) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_Z1MAXRANGE, z1MaxRange, 0.0);
  }
  void add_z2MaxRange(double z2MaxRange) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_Z2MAXRANGE, z2MaxRange, 0.0);
  }
  void add_radarMUR(double radarMUR) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_RADARMUR, radarMUR, 0.0);
  }
  void add_probFalseAlarm(double probFalseAlarm) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_PROBFALSEALARM, probFalseAlarm, 0.0);
  }
  void add_prf(double prf) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_PRF, prf, 0.0);
  }
  void add_radarPulseWidth(double radarPulseWidth) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_RADARPULSEWIDTH, radarPulseWidth, 0.0);
  }
  void add_numIntegratedPulses(int32_t numIntegratedPulses) {
    fbb_.AddElement<int32_t>(Sensorcharacteristics_Full::VT_NUMINTEGRATEDPULSES, numIntegratedPulses, 0);
  }
  void add_trueTilt(double trueTilt) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_TRUETILT, trueTilt, 0.0);
  }
  void add_radarMessageFormat(::flatbuffers::Offset<::flatbuffers::String> radarMessageFormat) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_RADARMESSAGEFORMAT, radarMessageFormat);
  }
  void add_systemNoiseTemperature(double systemNoiseTemperature) {
    fbb_.AddElement<double>(Sensorcharacteristics_Full::VT_SYSTEMNOISETEMPERATURE, systemNoiseTemperature, 0.0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_SOURCE, source);
  }
  void add_dataMode(Sensorcharacteristics_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Sensorcharacteristics_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(Sensorcharacteristics_Full::VT_UPDATEDBY, updatedBy);
  }
  explicit Sensorcharacteristics_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sensorcharacteristics_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sensorcharacteristics_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sensorcharacteristics_Full> CreateSensorcharacteristics_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    double azimuthRate = 0.0,
    double elevationRateGeolm = 0.0,
    double minRangeLimit = 0.0,
    double maxRangeLimit = 0.0,
    double leftClockAngle = 0.0,
    double rightClockAngle = 0.0,
    double boresight = 0.0,
    double boresightOffAngle = 0.0,
    double negativeRangeRateLimit = 0.0,
    double positiveRangeRateLimit = 0.0,
    double magnitudeLimit = 0.0,
    double trackAngle = 0.0,
    double minSignalNoiseRatio = 0.0,
    double fanBeamWidth = 0.0,
    double taskableRange = 0.0,
    double maxObservableRange = 0.0,
    double radioFrequency = 0.0,
    double radarFrequency = 0.0,
    double transmitPower = 0.0,
    double hFOV = 0.0,
    double vFOV = 0.0,
    int32_t hResPixels = 0,
    int32_t vResPixels = 0,
    ::flatbuffers::Offset<::flatbuffers::String> band = 0,
    double maxDeviationAngle = 0.0,
    double aperture = 0.0,
    double leftGeoBeltLimit = 0.0,
    double rightGeoBeltLimit = 0.0,
    double asrScanRate = 0.0,
    double k = 0.0,
    double focalPoint = 0.0,
    double towerHeight = 0.0,
    int32_t trueNorthCorrector = 0,
    double magDec = 0.0,
    double z1MinRange = 0.0,
    double z2MinRange = 0.0,
    double z1MaxRange = 0.0,
    double z2MaxRange = 0.0,
    double radarMUR = 0.0,
    double probFalseAlarm = 0.0,
    double prf = 0.0,
    double radarPulseWidth = 0.0,
    int32_t numIntegratedPulses = 0,
    double trueTilt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> radarMessageFormat = 0,
    double systemNoiseTemperature = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    Sensorcharacteristics_Full_dataMode_Enum dataMode = Sensorcharacteristics_Full_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0) {
  Sensorcharacteristics_FullBuilder builder_(_fbb);
  builder_.add_systemNoiseTemperature(systemNoiseTemperature);
  builder_.add_trueTilt(trueTilt);
  builder_.add_radarPulseWidth(radarPulseWidth);
  builder_.add_prf(prf);
  builder_.add_probFalseAlarm(probFalseAlarm);
  builder_.add_radarMUR(radarMUR);
  builder_.add_z2MaxRange(z2MaxRange);
  builder_.add_z1MaxRange(z1MaxRange);
  builder_.add_z2MinRange(z2MinRange);
  builder_.add_z1MinRange(z1MinRange);
  builder_.add_magDec(magDec);
  builder_.add_towerHeight(towerHeight);
  builder_.add_focalPoint(focalPoint);
  builder_.add_k(k);
  builder_.add_asrScanRate(asrScanRate);
  builder_.add_rightGeoBeltLimit(rightGeoBeltLimit);
  builder_.add_leftGeoBeltLimit(leftGeoBeltLimit);
  builder_.add_aperture(aperture);
  builder_.add_maxDeviationAngle(maxDeviationAngle);
  builder_.add_vFOV(vFOV);
  builder_.add_hFOV(hFOV);
  builder_.add_transmitPower(transmitPower);
  builder_.add_radarFrequency(radarFrequency);
  builder_.add_radioFrequency(radioFrequency);
  builder_.add_maxObservableRange(maxObservableRange);
  builder_.add_taskableRange(taskableRange);
  builder_.add_fanBeamWidth(fanBeamWidth);
  builder_.add_minSignalNoiseRatio(minSignalNoiseRatio);
  builder_.add_trackAngle(trackAngle);
  builder_.add_magnitudeLimit(magnitudeLimit);
  builder_.add_positiveRangeRateLimit(positiveRangeRateLimit);
  builder_.add_negativeRangeRateLimit(negativeRangeRateLimit);
  builder_.add_boresightOffAngle(boresightOffAngle);
  builder_.add_boresight(boresight);
  builder_.add_rightClockAngle(rightClockAngle);
  builder_.add_leftClockAngle(leftClockAngle);
  builder_.add_maxRangeLimit(maxRangeLimit);
  builder_.add_minRangeLimit(minRangeLimit);
  builder_.add_elevationRateGeolm(elevationRateGeolm);
  builder_.add_azimuthRate(azimuthRate);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_source(source);
  builder_.add_radarMessageFormat(radarMessageFormat);
  builder_.add_numIntegratedPulses(numIntegratedPulses);
  builder_.add_trueNorthCorrector(trueNorthCorrector);
  builder_.add_band(band);
  builder_.add_vResPixels(vResPixels);
  builder_.add_hResPixels(hResPixels);
  builder_.add_origNetwork(origNetwork);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idSensor(idSensor);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sensorcharacteristics_Full> CreateSensorcharacteristics_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *idSensor = nullptr,
    const char *classificationMarking = nullptr,
    const char *origNetwork = nullptr,
    double azimuthRate = 0.0,
    double elevationRateGeolm = 0.0,
    double minRangeLimit = 0.0,
    double maxRangeLimit = 0.0,
    double leftClockAngle = 0.0,
    double rightClockAngle = 0.0,
    double boresight = 0.0,
    double boresightOffAngle = 0.0,
    double negativeRangeRateLimit = 0.0,
    double positiveRangeRateLimit = 0.0,
    double magnitudeLimit = 0.0,
    double trackAngle = 0.0,
    double minSignalNoiseRatio = 0.0,
    double fanBeamWidth = 0.0,
    double taskableRange = 0.0,
    double maxObservableRange = 0.0,
    double radioFrequency = 0.0,
    double radarFrequency = 0.0,
    double transmitPower = 0.0,
    double hFOV = 0.0,
    double vFOV = 0.0,
    int32_t hResPixels = 0,
    int32_t vResPixels = 0,
    const char *band = nullptr,
    double maxDeviationAngle = 0.0,
    double aperture = 0.0,
    double leftGeoBeltLimit = 0.0,
    double rightGeoBeltLimit = 0.0,
    double asrScanRate = 0.0,
    double k = 0.0,
    double focalPoint = 0.0,
    double towerHeight = 0.0,
    int32_t trueNorthCorrector = 0,
    double magDec = 0.0,
    double z1MinRange = 0.0,
    double z2MinRange = 0.0,
    double z1MaxRange = 0.0,
    double z2MaxRange = 0.0,
    double radarMUR = 0.0,
    double probFalseAlarm = 0.0,
    double prf = 0.0,
    double radarPulseWidth = 0.0,
    int32_t numIntegratedPulses = 0,
    double trueTilt = 0.0,
    const char *radarMessageFormat = nullptr,
    double systemNoiseTemperature = 0.0,
    const char *source = nullptr,
    Sensorcharacteristics_Full_dataMode_Enum dataMode = Sensorcharacteristics_Full_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto band__ = band ? _fbb.CreateString(band) : 0;
  auto radarMessageFormat__ = radarMessageFormat ? _fbb.CreateString(radarMessageFormat) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  return CreateSensorcharacteristics_Full(
      _fbb,
      id__,
      idSensor__,
      classificationMarking__,
      origNetwork__,
      azimuthRate,
      elevationRateGeolm,
      minRangeLimit,
      maxRangeLimit,
      leftClockAngle,
      rightClockAngle,
      boresight,
      boresightOffAngle,
      negativeRangeRateLimit,
      positiveRangeRateLimit,
      magnitudeLimit,
      trackAngle,
      minSignalNoiseRatio,
      fanBeamWidth,
      taskableRange,
      maxObservableRange,
      radioFrequency,
      radarFrequency,
      transmitPower,
      hFOV,
      vFOV,
      hResPixels,
      vResPixels,
      band__,
      maxDeviationAngle,
      aperture,
      leftGeoBeltLimit,
      rightGeoBeltLimit,
      asrScanRate,
      k,
      focalPoint,
      towerHeight,
      trueNorthCorrector,
      magDec,
      z1MinRange,
      z2MinRange,
      z1MaxRange,
      z2MaxRange,
      radarMUR,
      probFalseAlarm,
      prf,
      radarPulseWidth,
      numIntegratedPulses,
      trueTilt,
      radarMessageFormat__,
      systemNoiseTemperature,
      source__,
      dataMode,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__);
}

inline const Sensorcharacteristics_Full *GetSensorcharacteristics_Full(const void *buf) {
  return ::flatbuffers::GetRoot<Sensorcharacteristics_Full>(buf);
}

inline const Sensorcharacteristics_Full *GetSizePrefixedSensorcharacteristics_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Sensorcharacteristics_Full>(buf);
}

inline const char *Sensorcharacteristics_FullIdentifier() {
  return "SENS";
}

inline bool Sensorcharacteristics_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Sensorcharacteristics_FullIdentifier());
}

inline bool SizePrefixedSensorcharacteristics_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Sensorcharacteristics_FullIdentifier(), true);
}

inline bool VerifySensorcharacteristics_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Sensorcharacteristics_Full>(Sensorcharacteristics_FullIdentifier());
}

inline bool VerifySizePrefixedSensorcharacteristics_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Sensorcharacteristics_Full>(Sensorcharacteristics_FullIdentifier());
}

inline void FinishSensorcharacteristics_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Sensorcharacteristics_Full> root) {
  fbb.Finish(root, Sensorcharacteristics_FullIdentifier());
}

inline void FinishSizePrefixedSensorcharacteristics_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Sensorcharacteristics_Full> root) {
  fbb.FinishSizePrefixed(root, Sensorcharacteristics_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
