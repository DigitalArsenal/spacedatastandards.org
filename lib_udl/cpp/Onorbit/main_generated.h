// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Onorbit;
struct OnorbitBuilder;

enum Onorbit_objectType_Enum : int8_t {
  /// No description available.
  Onorbit_objectType_Enum_ROCKET_BODY = 0,
  /// No description available.
  Onorbit_objectType_Enum_DEBRIS = 1,
  /// No description available.
  Onorbit_objectType_Enum_PAYLOAD = 2,
  /// No description available.
  Onorbit_objectType_Enum_PLATFORM = 3,
  /// No description available.
  Onorbit_objectType_Enum_MANNED = 4,
  /// No description available.
  Onorbit_objectType_Enum_UNKNOWN = 5,
  Onorbit_objectType_Enum_MIN = Onorbit_objectType_Enum_ROCKET_BODY,
  Onorbit_objectType_Enum_MAX = Onorbit_objectType_Enum_UNKNOWN
};

inline const Onorbit_objectType_Enum (&EnumValuesOnorbit_objectType_Enum())[6] {
  static const Onorbit_objectType_Enum values[] = {
    Onorbit_objectType_Enum_ROCKET_BODY,
    Onorbit_objectType_Enum_DEBRIS,
    Onorbit_objectType_Enum_PAYLOAD,
    Onorbit_objectType_Enum_PLATFORM,
    Onorbit_objectType_Enum_MANNED,
    Onorbit_objectType_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesOnorbit_objectType_Enum() {
  static const char * const names[7] = {
    "ROCKET_BODY",
    "DEBRIS",
    "PAYLOAD",
    "PLATFORM",
    "MANNED",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameOnorbit_objectType_Enum(Onorbit_objectType_Enum e) {
  if (::flatbuffers::IsOutRange(e, Onorbit_objectType_Enum_ROCKET_BODY, Onorbit_objectType_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOnorbit_objectType_Enum()[index];
}

enum Onorbit_category_Enum : int8_t {
  /// No description available.
  Onorbit_category_Enum_UNKNOWN = 0,
  /// No description available.
  Onorbit_category_Enum_ON_ORBIT = 1,
  /// No description available.
  Onorbit_category_Enum_DECAYED = 2,
  /// No description available.
  Onorbit_category_Enum_CATALOGED_WITHOUT_STATE = 3,
  /// No description available.
  Onorbit_category_Enum_LAUNCH_NOMINAL = 4,
  /// No description available.
  Onorbit_category_Enum_ANALYST_SATELLITE = 5,
  /// No description available.
  Onorbit_category_Enum_CISLUNAR = 6,
  /// No description available.
  Onorbit_category_Enum_LUNAR = 7,
  /// No description available.
  Onorbit_category_Enum_HYPERBOLIC = 8,
  /// No description available.
  Onorbit_category_Enum_HELIOCENTRIC = 9,
  /// No description available.
  Onorbit_category_Enum_INTERPLANETARY = 10,
  /// No description available.
  Onorbit_category_Enum_LAGRANGIAN = 11,
  /// No description available.
  Onorbit_category_Enum_DOCKED = 12,
  Onorbit_category_Enum_MIN = Onorbit_category_Enum_UNKNOWN,
  Onorbit_category_Enum_MAX = Onorbit_category_Enum_DOCKED
};

inline const Onorbit_category_Enum (&EnumValuesOnorbit_category_Enum())[13] {
  static const Onorbit_category_Enum values[] = {
    Onorbit_category_Enum_UNKNOWN,
    Onorbit_category_Enum_ON_ORBIT,
    Onorbit_category_Enum_DECAYED,
    Onorbit_category_Enum_CATALOGED_WITHOUT_STATE,
    Onorbit_category_Enum_LAUNCH_NOMINAL,
    Onorbit_category_Enum_ANALYST_SATELLITE,
    Onorbit_category_Enum_CISLUNAR,
    Onorbit_category_Enum_LUNAR,
    Onorbit_category_Enum_HYPERBOLIC,
    Onorbit_category_Enum_HELIOCENTRIC,
    Onorbit_category_Enum_INTERPLANETARY,
    Onorbit_category_Enum_LAGRANGIAN,
    Onorbit_category_Enum_DOCKED
  };
  return values;
}

inline const char * const *EnumNamesOnorbit_category_Enum() {
  static const char * const names[14] = {
    "UNKNOWN",
    "ON_ORBIT",
    "DECAYED",
    "CATALOGED_WITHOUT_STATE",
    "LAUNCH_NOMINAL",
    "ANALYST_SATELLITE",
    "CISLUNAR",
    "LUNAR",
    "HYPERBOLIC",
    "HELIOCENTRIC",
    "INTERPLANETARY",
    "LAGRANGIAN",
    "DOCKED",
    nullptr
  };
  return names;
}

inline const char *EnumNameOnorbit_category_Enum(Onorbit_category_Enum e) {
  if (::flatbuffers::IsOutRange(e, Onorbit_category_Enum_UNKNOWN, Onorbit_category_Enum_DOCKED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOnorbit_category_Enum()[index];
}

enum Onorbit_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Onorbit_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Onorbit_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Onorbit_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Onorbit_dataMode_Enum_EXERCISE = 3,
  Onorbit_dataMode_Enum_MIN = Onorbit_dataMode_Enum_REAL,
  Onorbit_dataMode_Enum_MAX = Onorbit_dataMode_Enum_EXERCISE
};

inline const Onorbit_dataMode_Enum (&EnumValuesOnorbit_dataMode_Enum())[4] {
  static const Onorbit_dataMode_Enum values[] = {
    Onorbit_dataMode_Enum_REAL,
    Onorbit_dataMode_Enum_TEST,
    Onorbit_dataMode_Enum_SIMULATED,
    Onorbit_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesOnorbit_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOnorbit_dataMode_Enum(Onorbit_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Onorbit_dataMode_Enum_REAL, Onorbit_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOnorbit_dataMode_Enum()[index];
}

/// /// Model object representing on-orbit objects or satellites in the system.
struct Onorbit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OnorbitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDONORBIT = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_SATNO = 8,
    VT_COMMONNAME = 10,
    VT_CONSTELLATION = 12,
    VT_INTLDES = 14,
    VT_LAUNCHDATE = 16,
    VT_DECAYDATE = 18,
    VT_OBJECTTYPE = 20,
    VT_ORIGIN = 22,
    VT_MISSIONNUMBER = 24,
    VT_CATEGORY = 26,
    VT_LIFETIMEYEARS = 28,
    VT_ALTNAME = 30,
    VT_CREATEDAT = 32,
    VT_CREATEDBY = 34,
    VT_UPDATEDAT = 36,
    VT_UPDATEDBY = 38,
    VT_SOURCE = 40,
    VT_DATAMODE = 42,
    VT_LAUNCHSITEID = 44,
    VT_ANTENNAS = 46,
    VT_BATTERIES = 48,
    VT_SOLARARRAYS = 50,
    VT_THRUSTERS = 52,
    VT_ONORBITDETAILS = 54,
    VT_COUNTRYCODE = 56,
    VT_ORIGNETWORK = 58
  };
  /// For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites, auto-generated by the system.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Satellite/Catalog number of the target on-orbit object.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Common name of the on-orbit object.
  /// Example: /// Example: Example common name
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *commonName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMONNAME);
  }
  /// Constellation to which this satellite belongs.
  /// Example: /// Example: Big Dipper
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *constellation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSTELLATION);
  }
  /// International Designator, typically of the format YYYYLLLAAA, where YYYY is the launch year, LLL is the sequential launch number of that year, and AAA is an optional launch piece designator for the launch.
  /// Example: /// Example: 2021123ABC
  /// Constraints: Minimum length = 0, Maximum length = 45
  const ::flatbuffers::String *intlDes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTLDES);
  }
  /// Date of launch.
  /// Example: /// Example: 2018-01-01
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *launchDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCHDATE);
  }
  /// Date of decay.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *decayDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DECAYDATE);
  }
  /// Type of on-orbit object: ROCKET BODY, DEBRIS, PAYLOAD, PLATFORM, MANNED, UNKNOWN.
  /// Example: /// Example: PAYLOAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  Onorbit_objectType_Enum objectType() const {
    return static_cast<Onorbit_objectType_Enum>(GetField<int8_t>(VT_OBJECTTYPE, 0));
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Mission number of the on-orbit object.
  /// Example: /// Example: Expedition 1
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *missionNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MISSIONNUMBER);
  }
  /// Category of the on-orbit object. (Unknown, On-Orbit, Decayed, Cataloged Without State, Launch Nominal, Analyst Satellite, Cislunar, Lunar, Hyperbolic, Heliocentric, Interplanetary, Lagrangian, Docked).
  /// Example: /// Example: Lunar
  /// Constraints: Minimum length = 0, Maximum length = 45
  Onorbit_category_Enum category() const {
    return static_cast<Onorbit_category_Enum>(GetField<int8_t>(VT_CATEGORY, 0));
  }
  /// Estimated lifetime of the on-orbit payload, if known.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t lifetimeYears() const {
    return GetField<int32_t>(VT_LIFETIMEYEARS, 0);
  }
  /// Alternate name of the on-orbit object.
  /// Example: /// Example: Alternate Name
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *altName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALTNAME);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Onorbit_dataMode_Enum dataMode() const {
    return static_cast<Onorbit_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Id of the associated launchSite entity.
  /// Example: /// Example: LAUNCHSITE-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *launchSiteId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LAUNCHSITEID);
  }
  /// Read-only collection of antennas on this on-orbit object.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *antennas() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ANTENNAS);
  }
  /// Read-only collection of batteries on this on-orbit object.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *batteries() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_BATTERIES);
  }
  /// Read-only collection of solar arrays on this on-orbit object.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *solarArrays() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SOLARARRAYS);
  }
  /// Read-only collection of thrusters (engines) on this on-orbit object.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *thrusters() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_THRUSTERS);
  }
  /// Read-only collection of details for this on-orbit object.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *onorbitDetails() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ONORBITDETAILS);
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDLâ€™s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *countryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_COMMONNAME) &&
           verifier.VerifyString(commonName()) &&
           VerifyOffset(verifier, VT_CONSTELLATION) &&
           verifier.VerifyString(constellation()) &&
           VerifyOffset(verifier, VT_INTLDES) &&
           verifier.VerifyString(intlDes()) &&
           VerifyOffset(verifier, VT_LAUNCHDATE) &&
           verifier.VerifyString(launchDate()) &&
           VerifyOffset(verifier, VT_DECAYDATE) &&
           verifier.VerifyString(decayDate()) &&
           VerifyField<int8_t>(verifier, VT_OBJECTTYPE, 1) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_MISSIONNUMBER) &&
           verifier.VerifyString(missionNumber()) &&
           VerifyField<int8_t>(verifier, VT_CATEGORY, 1) &&
           VerifyField<int32_t>(verifier, VT_LIFETIMEYEARS, 4) &&
           VerifyOffset(verifier, VT_ALTNAME) &&
           verifier.VerifyString(altName()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_LAUNCHSITEID) &&
           verifier.VerifyString(launchSiteId()) &&
           VerifyOffset(verifier, VT_ANTENNAS) &&
           verifier.VerifyVector(antennas()) &&
           verifier.VerifyVectorOfStrings(antennas()) &&
           VerifyOffset(verifier, VT_BATTERIES) &&
           verifier.VerifyVector(batteries()) &&
           verifier.VerifyVectorOfStrings(batteries()) &&
           VerifyOffset(verifier, VT_SOLARARRAYS) &&
           verifier.VerifyVector(solarArrays()) &&
           verifier.VerifyVectorOfStrings(solarArrays()) &&
           VerifyOffset(verifier, VT_THRUSTERS) &&
           verifier.VerifyVector(thrusters()) &&
           verifier.VerifyVectorOfStrings(thrusters()) &&
           VerifyOffset(verifier, VT_ONORBITDETAILS) &&
           verifier.VerifyVector(onorbitDetails()) &&
           verifier.VerifyVectorOfStrings(onorbitDetails()) &&
           VerifyOffset(verifier, VT_COUNTRYCODE) &&
           verifier.VerifyString(countryCode()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct OnorbitBuilder {
  typedef Onorbit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(Onorbit::VT_IDONORBIT, idOnOrbit);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Onorbit::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(Onorbit::VT_SATNO, satNo, 0);
  }
  void add_commonName(::flatbuffers::Offset<::flatbuffers::String> commonName) {
    fbb_.AddOffset(Onorbit::VT_COMMONNAME, commonName);
  }
  void add_constellation(::flatbuffers::Offset<::flatbuffers::String> constellation) {
    fbb_.AddOffset(Onorbit::VT_CONSTELLATION, constellation);
  }
  void add_intlDes(::flatbuffers::Offset<::flatbuffers::String> intlDes) {
    fbb_.AddOffset(Onorbit::VT_INTLDES, intlDes);
  }
  void add_launchDate(::flatbuffers::Offset<::flatbuffers::String> launchDate) {
    fbb_.AddOffset(Onorbit::VT_LAUNCHDATE, launchDate);
  }
  void add_decayDate(::flatbuffers::Offset<::flatbuffers::String> decayDate) {
    fbb_.AddOffset(Onorbit::VT_DECAYDATE, decayDate);
  }
  void add_objectType(Onorbit_objectType_Enum objectType) {
    fbb_.AddElement<int8_t>(Onorbit::VT_OBJECTTYPE, static_cast<int8_t>(objectType), 0);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Onorbit::VT_ORIGIN, origin);
  }
  void add_missionNumber(::flatbuffers::Offset<::flatbuffers::String> missionNumber) {
    fbb_.AddOffset(Onorbit::VT_MISSIONNUMBER, missionNumber);
  }
  void add_category(Onorbit_category_Enum category) {
    fbb_.AddElement<int8_t>(Onorbit::VT_CATEGORY, static_cast<int8_t>(category), 0);
  }
  void add_lifetimeYears(int32_t lifetimeYears) {
    fbb_.AddElement<int32_t>(Onorbit::VT_LIFETIMEYEARS, lifetimeYears, 0);
  }
  void add_altName(::flatbuffers::Offset<::flatbuffers::String> altName) {
    fbb_.AddOffset(Onorbit::VT_ALTNAME, altName);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Onorbit::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Onorbit::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(Onorbit::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(Onorbit::VT_UPDATEDBY, updatedBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Onorbit::VT_SOURCE, source);
  }
  void add_dataMode(Onorbit_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Onorbit::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_launchSiteId(::flatbuffers::Offset<::flatbuffers::String> launchSiteId) {
    fbb_.AddOffset(Onorbit::VT_LAUNCHSITEID, launchSiteId);
  }
  void add_antennas(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> antennas) {
    fbb_.AddOffset(Onorbit::VT_ANTENNAS, antennas);
  }
  void add_batteries(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> batteries) {
    fbb_.AddOffset(Onorbit::VT_BATTERIES, batteries);
  }
  void add_solarArrays(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> solarArrays) {
    fbb_.AddOffset(Onorbit::VT_SOLARARRAYS, solarArrays);
  }
  void add_thrusters(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> thrusters) {
    fbb_.AddOffset(Onorbit::VT_THRUSTERS, thrusters);
  }
  void add_onorbitDetails(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> onorbitDetails) {
    fbb_.AddOffset(Onorbit::VT_ONORBITDETAILS, onorbitDetails);
  }
  void add_countryCode(::flatbuffers::Offset<::flatbuffers::String> countryCode) {
    fbb_.AddOffset(Onorbit::VT_COUNTRYCODE, countryCode);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Onorbit::VT_ORIGNETWORK, origNetwork);
  }
  explicit OnorbitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Onorbit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Onorbit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Onorbit> CreateOnorbit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> commonName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> constellation = 0,
    ::flatbuffers::Offset<::flatbuffers::String> intlDes = 0,
    ::flatbuffers::Offset<::flatbuffers::String> launchDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> decayDate = 0,
    Onorbit_objectType_Enum objectType = Onorbit_objectType_Enum_ROCKET_BODY,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> missionNumber = 0,
    Onorbit_category_Enum category = Onorbit_category_Enum_UNKNOWN,
    int32_t lifetimeYears = 0,
    ::flatbuffers::Offset<::flatbuffers::String> altName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    Onorbit_dataMode_Enum dataMode = Onorbit_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> launchSiteId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> antennas = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> batteries = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> solarArrays = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> thrusters = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> onorbitDetails = 0,
    ::flatbuffers::Offset<::flatbuffers::String> countryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  OnorbitBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_countryCode(countryCode);
  builder_.add_onorbitDetails(onorbitDetails);
  builder_.add_thrusters(thrusters);
  builder_.add_solarArrays(solarArrays);
  builder_.add_batteries(batteries);
  builder_.add_antennas(antennas);
  builder_.add_launchSiteId(launchSiteId);
  builder_.add_source(source);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_altName(altName);
  builder_.add_lifetimeYears(lifetimeYears);
  builder_.add_missionNumber(missionNumber);
  builder_.add_origin(origin);
  builder_.add_decayDate(decayDate);
  builder_.add_launchDate(launchDate);
  builder_.add_intlDes(intlDes);
  builder_.add_constellation(constellation);
  builder_.add_commonName(commonName);
  builder_.add_satNo(satNo);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_dataMode(dataMode);
  builder_.add_category(category);
  builder_.add_objectType(objectType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Onorbit> CreateOnorbitDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *idOnOrbit = nullptr,
    const char *classificationMarking = nullptr,
    int32_t satNo = 0,
    const char *commonName = nullptr,
    const char *constellation = nullptr,
    const char *intlDes = nullptr,
    const char *launchDate = nullptr,
    const char *decayDate = nullptr,
    Onorbit_objectType_Enum objectType = Onorbit_objectType_Enum_ROCKET_BODY,
    const char *origin = nullptr,
    const char *missionNumber = nullptr,
    Onorbit_category_Enum category = Onorbit_category_Enum_UNKNOWN,
    int32_t lifetimeYears = 0,
    const char *altName = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *source = nullptr,
    Onorbit_dataMode_Enum dataMode = Onorbit_dataMode_Enum_REAL,
    const char *launchSiteId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *antennas = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *batteries = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *solarArrays = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *thrusters = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *onorbitDetails = nullptr,
    const char *countryCode = nullptr,
    const char *origNetwork = nullptr) {
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto commonName__ = commonName ? _fbb.CreateString(commonName) : 0;
  auto constellation__ = constellation ? _fbb.CreateString(constellation) : 0;
  auto intlDes__ = intlDes ? _fbb.CreateString(intlDes) : 0;
  auto launchDate__ = launchDate ? _fbb.CreateString(launchDate) : 0;
  auto decayDate__ = decayDate ? _fbb.CreateString(decayDate) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto missionNumber__ = missionNumber ? _fbb.CreateString(missionNumber) : 0;
  auto altName__ = altName ? _fbb.CreateString(altName) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto launchSiteId__ = launchSiteId ? _fbb.CreateString(launchSiteId) : 0;
  auto antennas__ = antennas ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*antennas) : 0;
  auto batteries__ = batteries ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*batteries) : 0;
  auto solarArrays__ = solarArrays ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*solarArrays) : 0;
  auto thrusters__ = thrusters ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*thrusters) : 0;
  auto onorbitDetails__ = onorbitDetails ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*onorbitDetails) : 0;
  auto countryCode__ = countryCode ? _fbb.CreateString(countryCode) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateOnorbit(
      _fbb,
      idOnOrbit__,
      classificationMarking__,
      satNo,
      commonName__,
      constellation__,
      intlDes__,
      launchDate__,
      decayDate__,
      objectType,
      origin__,
      missionNumber__,
      category,
      lifetimeYears,
      altName__,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      source__,
      dataMode,
      launchSiteId__,
      antennas__,
      batteries__,
      solarArrays__,
      thrusters__,
      onorbitDetails__,
      countryCode__,
      origNetwork__);
}

inline const Onorbit *GetOnorbit(const void *buf) {
  return ::flatbuffers::GetRoot<Onorbit>(buf);
}

inline const Onorbit *GetSizePrefixedOnorbit(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Onorbit>(buf);
}

inline const char *OnorbitIdentifier() {
  return "ONOR";
}

inline bool OnorbitBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OnorbitIdentifier());
}

inline bool SizePrefixedOnorbitBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OnorbitIdentifier(), true);
}

inline bool VerifyOnorbitBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Onorbit>(OnorbitIdentifier());
}

inline bool VerifySizePrefixedOnorbitBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Onorbit>(OnorbitIdentifier());
}

inline void FinishOnorbitBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Onorbit> root) {
  fbb.Finish(root, OnorbitIdentifier());
}

inline void FinishSizePrefixedOnorbitBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Onorbit> root) {
  fbb.FinishSizePrefixed(root, OnorbitIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
