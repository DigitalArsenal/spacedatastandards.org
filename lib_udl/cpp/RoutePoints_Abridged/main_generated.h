// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct RoutePoints_Abridged;
struct RoutePoints_AbridgedBuilder;

/// /// Points identified within the route.
struct RoutePoints_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoutePoints_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PTSEQUENCEID = 4,
    VT_PTTYPECODE = 6,
    VT_PTTYPENAME = 8,
    VT_WAYPOINTNAME = 10,
    VT_DAFIFPT = 12,
    VT_PTLAT = 14,
    VT_PTLON = 16,
    VT_MAGDEC = 18,
    VT_NAVAIDLENGTH = 20,
    VT_NAVAID = 22,
    VT_COUNTRYCODE = 24,
    VT_ALTCOUNTRYCODE = 26,
    VT_NAVAIDTYPE = 28
  };
  /// Sequencing field for the track route. This is the identifier representing the sequence of waypoints associated to the track route.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t ptSequenceId() const {
    return GetField<int32_t>(VT_PTSEQUENCEID, 0);
  }
  /// Code representation of the point within the track route (ex. EP, EX, CP, IP, etc.).
  /// Example: /// Example: EP
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *ptTypeCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PTTYPECODE);
  }
  /// The name that represents the point within the track route (ex. ENTRY POINT, EXIT POINT, CONTROL POINT, INITIAL POINT, etc.).
  /// Example: /// Example: ENTRY POINT
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *ptTypeName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PTTYPENAME);
  }
  /// Name of a waypoint which identifies the location of the point.
  /// Example: /// Example: KCHS
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *waypointName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WAYPOINTNAME);
  }
  /// Flag indicating this is a Digital Aeronautical Flight Information File (DAFIF) point.
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool dafifPt() const {
    return GetField<uint8_t>(VT_DAFIFPT, 0) != 0;
  }
  /// WGS84 latitude of the point location, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double ptLat() const {
    return GetField<double>(VT_PTLAT, 0.0);
  }
  /// WGS84 longitude of the point location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  double ptLon() const {
    return GetField<double>(VT_PTLON, 0.0);
  }
  /// The magnetic declination/variation of the route point location from true north, in degrees. Positive values east of true north and negative values west of true north.
  /// Example: /// Example: 7.35
  /// Constraints: No constraints specified.
  double magDec() const {
    return GetField<double>(VT_MAGDEC, 0.0);
  }
  /// The length of the course from the Navigational Aid (NAVAID) in nautical miles.
  /// Example: /// Example: 100.2
  /// Constraints: No constraints specified.
  double navaidLength() const {
    return GetField<double>(VT_NAVAIDLENGTH, 0.0);
  }
  /// Navigational Aid (NAVAID) identification code.
  /// Example: /// Example: HTO
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *navaid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAVAID);
  }
  /// The DoD Standard Country Code designator for the country where the route point resides. This field should be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
  /// Example: /// Example: NL
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *countryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  /// Specifies an alternate country code if the data provider code is not part of an official NAVAID Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
  /// Example: /// Example: IZ
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *altCountryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALTCOUNTRYCODE);
  }
  /// The NAVAID type of this route point (ex. VOR, VORTAC, TACAN, etc.).
  /// Example: /// Example: VORTAC
  /// Constraints: Minimum length = 0, Maximum length = 12
  const ::flatbuffers::String *navaidType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAVAIDTYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PTSEQUENCEID, 4) &&
           VerifyOffset(verifier, VT_PTTYPECODE) &&
           verifier.VerifyString(ptTypeCode()) &&
           VerifyOffset(verifier, VT_PTTYPENAME) &&
           verifier.VerifyString(ptTypeName()) &&
           VerifyOffset(verifier, VT_WAYPOINTNAME) &&
           verifier.VerifyString(waypointName()) &&
           VerifyField<uint8_t>(verifier, VT_DAFIFPT, 1) &&
           VerifyField<double>(verifier, VT_PTLAT, 8) &&
           VerifyField<double>(verifier, VT_PTLON, 8) &&
           VerifyField<double>(verifier, VT_MAGDEC, 8) &&
           VerifyField<double>(verifier, VT_NAVAIDLENGTH, 8) &&
           VerifyOffset(verifier, VT_NAVAID) &&
           verifier.VerifyString(navaid()) &&
           VerifyOffset(verifier, VT_COUNTRYCODE) &&
           verifier.VerifyString(countryCode()) &&
           VerifyOffset(verifier, VT_ALTCOUNTRYCODE) &&
           verifier.VerifyString(altCountryCode()) &&
           VerifyOffset(verifier, VT_NAVAIDTYPE) &&
           verifier.VerifyString(navaidType()) &&
           verifier.EndTable();
  }
};

struct RoutePoints_AbridgedBuilder {
  typedef RoutePoints_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ptSequenceId(int32_t ptSequenceId) {
    fbb_.AddElement<int32_t>(RoutePoints_Abridged::VT_PTSEQUENCEID, ptSequenceId, 0);
  }
  void add_ptTypeCode(::flatbuffers::Offset<::flatbuffers::String> ptTypeCode) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_PTTYPECODE, ptTypeCode);
  }
  void add_ptTypeName(::flatbuffers::Offset<::flatbuffers::String> ptTypeName) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_PTTYPENAME, ptTypeName);
  }
  void add_waypointName(::flatbuffers::Offset<::flatbuffers::String> waypointName) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_WAYPOINTNAME, waypointName);
  }
  void add_dafifPt(bool dafifPt) {
    fbb_.AddElement<uint8_t>(RoutePoints_Abridged::VT_DAFIFPT, static_cast<uint8_t>(dafifPt), 0);
  }
  void add_ptLat(double ptLat) {
    fbb_.AddElement<double>(RoutePoints_Abridged::VT_PTLAT, ptLat, 0.0);
  }
  void add_ptLon(double ptLon) {
    fbb_.AddElement<double>(RoutePoints_Abridged::VT_PTLON, ptLon, 0.0);
  }
  void add_magDec(double magDec) {
    fbb_.AddElement<double>(RoutePoints_Abridged::VT_MAGDEC, magDec, 0.0);
  }
  void add_navaidLength(double navaidLength) {
    fbb_.AddElement<double>(RoutePoints_Abridged::VT_NAVAIDLENGTH, navaidLength, 0.0);
  }
  void add_navaid(::flatbuffers::Offset<::flatbuffers::String> navaid) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_NAVAID, navaid);
  }
  void add_countryCode(::flatbuffers::Offset<::flatbuffers::String> countryCode) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_COUNTRYCODE, countryCode);
  }
  void add_altCountryCode(::flatbuffers::Offset<::flatbuffers::String> altCountryCode) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_ALTCOUNTRYCODE, altCountryCode);
  }
  void add_navaidType(::flatbuffers::Offset<::flatbuffers::String> navaidType) {
    fbb_.AddOffset(RoutePoints_Abridged::VT_NAVAIDTYPE, navaidType);
  }
  explicit RoutePoints_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoutePoints_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoutePoints_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoutePoints_Abridged> CreateRoutePoints_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ptSequenceId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ptTypeCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ptTypeName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> waypointName = 0,
    bool dafifPt = false,
    double ptLat = 0.0,
    double ptLon = 0.0,
    double magDec = 0.0,
    double navaidLength = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> navaid = 0,
    ::flatbuffers::Offset<::flatbuffers::String> countryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> altCountryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> navaidType = 0) {
  RoutePoints_AbridgedBuilder builder_(_fbb);
  builder_.add_navaidLength(navaidLength);
  builder_.add_magDec(magDec);
  builder_.add_ptLon(ptLon);
  builder_.add_ptLat(ptLat);
  builder_.add_navaidType(navaidType);
  builder_.add_altCountryCode(altCountryCode);
  builder_.add_countryCode(countryCode);
  builder_.add_navaid(navaid);
  builder_.add_waypointName(waypointName);
  builder_.add_ptTypeName(ptTypeName);
  builder_.add_ptTypeCode(ptTypeCode);
  builder_.add_ptSequenceId(ptSequenceId);
  builder_.add_dafifPt(dafifPt);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RoutePoints_Abridged> CreateRoutePoints_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ptSequenceId = 0,
    const char *ptTypeCode = nullptr,
    const char *ptTypeName = nullptr,
    const char *waypointName = nullptr,
    bool dafifPt = false,
    double ptLat = 0.0,
    double ptLon = 0.0,
    double magDec = 0.0,
    double navaidLength = 0.0,
    const char *navaid = nullptr,
    const char *countryCode = nullptr,
    const char *altCountryCode = nullptr,
    const char *navaidType = nullptr) {
  auto ptTypeCode__ = ptTypeCode ? _fbb.CreateString(ptTypeCode) : 0;
  auto ptTypeName__ = ptTypeName ? _fbb.CreateString(ptTypeName) : 0;
  auto waypointName__ = waypointName ? _fbb.CreateString(waypointName) : 0;
  auto navaid__ = navaid ? _fbb.CreateString(navaid) : 0;
  auto countryCode__ = countryCode ? _fbb.CreateString(countryCode) : 0;
  auto altCountryCode__ = altCountryCode ? _fbb.CreateString(altCountryCode) : 0;
  auto navaidType__ = navaidType ? _fbb.CreateString(navaidType) : 0;
  return CreateRoutePoints_Abridged(
      _fbb,
      ptSequenceId,
      ptTypeCode__,
      ptTypeName__,
      waypointName__,
      dafifPt,
      ptLat,
      ptLon,
      magDec,
      navaidLength,
      navaid__,
      countryCode__,
      altCountryCode__,
      navaidType__);
}

inline const RoutePoints_Abridged *GetRoutePoints_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<RoutePoints_Abridged>(buf);
}

inline const RoutePoints_Abridged *GetSizePrefixedRoutePoints_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RoutePoints_Abridged>(buf);
}

inline const char *RoutePoints_AbridgedIdentifier() {
  return "ROUT";
}

inline bool RoutePoints_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RoutePoints_AbridgedIdentifier());
}

inline bool SizePrefixedRoutePoints_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RoutePoints_AbridgedIdentifier(), true);
}

inline bool VerifyRoutePoints_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RoutePoints_Abridged>(RoutePoints_AbridgedIdentifier());
}

inline bool VerifySizePrefixedRoutePoints_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RoutePoints_Abridged>(RoutePoints_AbridgedIdentifier());
}

inline void FinishRoutePoints_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RoutePoints_Abridged> root) {
  fbb.Finish(root, RoutePoints_AbridgedIdentifier());
}

inline void FinishSizePrefixedRoutePoints_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RoutePoints_Abridged> root) {
  fbb.FinishSizePrefixed(root, RoutePoints_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
