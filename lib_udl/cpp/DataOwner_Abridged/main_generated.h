// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct DataOwner_Abridged;
struct DataOwner_AbridgedBuilder;

/// /// Information pertaining to UDL data owners.
struct DataOwner_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DataOwner_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DONAME = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_OWNERTYPE = 8,
    VT_DATATYPE = 10,
    VT_PROVIDER = 12,
    VT_COUNTRYCODE = 14,
    VT_IDCONTACT = 16,
    VT_DESCRIPTION = 18,
    VT_CONTROL = 20,
    VT_ENABLED = 22,
    VT_COMINGSOON = 24,
    VT_SOURCE = 26
  };
  /// The name of the data owner.
  /// Example: /// Example: Data owner name
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *doName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DONAME);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Type of organization which this data owner belongs to (e.g. Commercial, Government, Academic, Consortium, etc.).
  /// Example: /// Example: Commercial
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *ownerType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OWNERTYPE);
  }
  /// Type of data this data owner owns (e.g. EPHEMERIS, IMAGERY, MANEUVER, etc.).
  /// Example: /// Example: ELSET
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *dataType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DATATYPE);
  }
  /// Organization name for the data provider.
  /// Example: /// Example: ACME
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *provider() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PROVIDER);
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDLâ€™s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 1, Maximum length = 4
  const ::flatbuffers::String *countryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  /// Unique identifier of the contact for this data owner.
  /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idContact() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDCONTACT);
  }
  /// Description of this data owner.
  /// Example: /// Example: Description of this data owner.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Optional control required to access this data type from this owner.
  /// Example: /// Example: PR-ACME-ELSETS
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *control() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONTROL);
  }
  /// Boolean indicating if the data owner is enabled (if not enabled, they should not appear on the data products screen on the storefront).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool enabled() const {
    return GetField<uint8_t>(VT_ENABLED, 0) != 0;
  }
  /// Boolean indicating if the data owner is coming soon or not yet available.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool comingSoon() const {
    return GetField<uint8_t>(VT_COMINGSOON, 0) != 0;
  }
  /// Source of the data.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DONAME) &&
           verifier.VerifyString(doName()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_OWNERTYPE) &&
           verifier.VerifyString(ownerType()) &&
           VerifyOffset(verifier, VT_DATATYPE) &&
           verifier.VerifyString(dataType()) &&
           VerifyOffset(verifier, VT_PROVIDER) &&
           verifier.VerifyString(provider()) &&
           VerifyOffset(verifier, VT_COUNTRYCODE) &&
           verifier.VerifyString(countryCode()) &&
           VerifyOffset(verifier, VT_IDCONTACT) &&
           verifier.VerifyString(idContact()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_CONTROL) &&
           verifier.VerifyString(control()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED, 1) &&
           VerifyField<uint8_t>(verifier, VT_COMINGSOON, 1) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           verifier.EndTable();
  }
};

struct DataOwner_AbridgedBuilder {
  typedef DataOwner_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_doName(::flatbuffers::Offset<::flatbuffers::String> doName) {
    fbb_.AddOffset(DataOwner_Abridged::VT_DONAME, doName);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(DataOwner_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_ownerType(::flatbuffers::Offset<::flatbuffers::String> ownerType) {
    fbb_.AddOffset(DataOwner_Abridged::VT_OWNERTYPE, ownerType);
  }
  void add_dataType(::flatbuffers::Offset<::flatbuffers::String> dataType) {
    fbb_.AddOffset(DataOwner_Abridged::VT_DATATYPE, dataType);
  }
  void add_provider(::flatbuffers::Offset<::flatbuffers::String> provider) {
    fbb_.AddOffset(DataOwner_Abridged::VT_PROVIDER, provider);
  }
  void add_countryCode(::flatbuffers::Offset<::flatbuffers::String> countryCode) {
    fbb_.AddOffset(DataOwner_Abridged::VT_COUNTRYCODE, countryCode);
  }
  void add_idContact(::flatbuffers::Offset<::flatbuffers::String> idContact) {
    fbb_.AddOffset(DataOwner_Abridged::VT_IDCONTACT, idContact);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(DataOwner_Abridged::VT_DESCRIPTION, description);
  }
  void add_control(::flatbuffers::Offset<::flatbuffers::String> control) {
    fbb_.AddOffset(DataOwner_Abridged::VT_CONTROL, control);
  }
  void add_enabled(bool enabled) {
    fbb_.AddElement<uint8_t>(DataOwner_Abridged::VT_ENABLED, static_cast<uint8_t>(enabled), 0);
  }
  void add_comingSoon(bool comingSoon) {
    fbb_.AddElement<uint8_t>(DataOwner_Abridged::VT_COMINGSOON, static_cast<uint8_t>(comingSoon), 0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(DataOwner_Abridged::VT_SOURCE, source);
  }
  explicit DataOwner_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DataOwner_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DataOwner_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DataOwner_Abridged> CreateDataOwner_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> doName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ownerType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dataType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> provider = 0,
    ::flatbuffers::Offset<::flatbuffers::String> countryCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idContact = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> control = 0,
    bool enabled = false,
    bool comingSoon = false,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0) {
  DataOwner_AbridgedBuilder builder_(_fbb);
  builder_.add_source(source);
  builder_.add_control(control);
  builder_.add_description(description);
  builder_.add_idContact(idContact);
  builder_.add_countryCode(countryCode);
  builder_.add_provider(provider);
  builder_.add_dataType(dataType);
  builder_.add_ownerType(ownerType);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_doName(doName);
  builder_.add_comingSoon(comingSoon);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DataOwner_Abridged> CreateDataOwner_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *doName = nullptr,
    const char *classificationMarking = nullptr,
    const char *ownerType = nullptr,
    const char *dataType = nullptr,
    const char *provider = nullptr,
    const char *countryCode = nullptr,
    const char *idContact = nullptr,
    const char *description = nullptr,
    const char *control = nullptr,
    bool enabled = false,
    bool comingSoon = false,
    const char *source = nullptr) {
  auto doName__ = doName ? _fbb.CreateString(doName) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto ownerType__ = ownerType ? _fbb.CreateString(ownerType) : 0;
  auto dataType__ = dataType ? _fbb.CreateString(dataType) : 0;
  auto provider__ = provider ? _fbb.CreateString(provider) : 0;
  auto countryCode__ = countryCode ? _fbb.CreateString(countryCode) : 0;
  auto idContact__ = idContact ? _fbb.CreateString(idContact) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto control__ = control ? _fbb.CreateString(control) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  return CreateDataOwner_Abridged(
      _fbb,
      doName__,
      classificationMarking__,
      ownerType__,
      dataType__,
      provider__,
      countryCode__,
      idContact__,
      description__,
      control__,
      enabled,
      comingSoon,
      source__);
}

inline const DataOwner_Abridged *GetDataOwner_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<DataOwner_Abridged>(buf);
}

inline const DataOwner_Abridged *GetSizePrefixedDataOwner_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DataOwner_Abridged>(buf);
}

inline const char *DataOwner_AbridgedIdentifier() {
  return "DATA";
}

inline bool DataOwner_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DataOwner_AbridgedIdentifier());
}

inline bool SizePrefixedDataOwner_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DataOwner_AbridgedIdentifier(), true);
}

inline bool VerifyDataOwner_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DataOwner_Abridged>(DataOwner_AbridgedIdentifier());
}

inline bool VerifySizePrefixedDataOwner_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DataOwner_Abridged>(DataOwner_AbridgedIdentifier());
}

inline void FinishDataOwner_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DataOwner_Abridged> root) {
  fbb.Finish(root, DataOwner_AbridgedIdentifier());
}

inline void FinishSizePrefixedDataOwner_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DataOwner_Abridged> root) {
  fbb.FinishSizePrefixed(root, DataOwner_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
