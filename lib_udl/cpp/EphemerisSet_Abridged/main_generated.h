// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct EphemerisSet_Abridged;
struct EphemerisSet_AbridgedBuilder;

enum EphemerisSet_Abridged_referenceFrame_Enum : int8_t {
  /// No description available.
  EphemerisSet_Abridged_referenceFrame_Enum_J2000 = 0,
  /// No description available.
  EphemerisSet_Abridged_referenceFrame_Enum_EFG_TDR = 1,
  /// No description available.
  EphemerisSet_Abridged_referenceFrame_Enum_ECR_ECEF = 2,
  /// No description available.
  EphemerisSet_Abridged_referenceFrame_Enum_TEME = 3,
  /// No description available.
  EphemerisSet_Abridged_referenceFrame_Enum_ITRF = 4,
  /// No description available.
  EphemerisSet_Abridged_referenceFrame_Enum_GCRF = 5,
  EphemerisSet_Abridged_referenceFrame_Enum_MIN = EphemerisSet_Abridged_referenceFrame_Enum_J2000,
  EphemerisSet_Abridged_referenceFrame_Enum_MAX = EphemerisSet_Abridged_referenceFrame_Enum_GCRF
};

inline const EphemerisSet_Abridged_referenceFrame_Enum (&EnumValuesEphemerisSet_Abridged_referenceFrame_Enum())[6] {
  static const EphemerisSet_Abridged_referenceFrame_Enum values[] = {
    EphemerisSet_Abridged_referenceFrame_Enum_J2000,
    EphemerisSet_Abridged_referenceFrame_Enum_EFG_TDR,
    EphemerisSet_Abridged_referenceFrame_Enum_ECR_ECEF,
    EphemerisSet_Abridged_referenceFrame_Enum_TEME,
    EphemerisSet_Abridged_referenceFrame_Enum_ITRF,
    EphemerisSet_Abridged_referenceFrame_Enum_GCRF
  };
  return values;
}

inline const char * const *EnumNamesEphemerisSet_Abridged_referenceFrame_Enum() {
  static const char * const names[7] = {
    "J2000",
    "EFG_TDR",
    "ECR_ECEF",
    "TEME",
    "ITRF",
    "GCRF",
    nullptr
  };
  return names;
}

inline const char *EnumNameEphemerisSet_Abridged_referenceFrame_Enum(EphemerisSet_Abridged_referenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, EphemerisSet_Abridged_referenceFrame_Enum_J2000, EphemerisSet_Abridged_referenceFrame_Enum_GCRF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEphemerisSet_Abridged_referenceFrame_Enum()[index];
}

enum EphemerisSet_Abridged_covReferenceFrame_Enum : int8_t {
  /// No description available.
  EphemerisSet_Abridged_covReferenceFrame_Enum_J2000 = 0,
  /// No description available.
  EphemerisSet_Abridged_covReferenceFrame_Enum_UVW = 1,
  EphemerisSet_Abridged_covReferenceFrame_Enum_MIN = EphemerisSet_Abridged_covReferenceFrame_Enum_J2000,
  EphemerisSet_Abridged_covReferenceFrame_Enum_MAX = EphemerisSet_Abridged_covReferenceFrame_Enum_UVW
};

inline const EphemerisSet_Abridged_covReferenceFrame_Enum (&EnumValuesEphemerisSet_Abridged_covReferenceFrame_Enum())[2] {
  static const EphemerisSet_Abridged_covReferenceFrame_Enum values[] = {
    EphemerisSet_Abridged_covReferenceFrame_Enum_J2000,
    EphemerisSet_Abridged_covReferenceFrame_Enum_UVW
  };
  return values;
}

inline const char * const *EnumNamesEphemerisSet_Abridged_covReferenceFrame_Enum() {
  static const char * const names[3] = {
    "J2000",
    "UVW",
    nullptr
  };
  return names;
}

inline const char *EnumNameEphemerisSet_Abridged_covReferenceFrame_Enum(EphemerisSet_Abridged_covReferenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, EphemerisSet_Abridged_covReferenceFrame_Enum_J2000, EphemerisSet_Abridged_covReferenceFrame_Enum_UVW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEphemerisSet_Abridged_covReferenceFrame_Enum()[index];
}

enum EphemerisSet_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  EphemerisSet_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  EphemerisSet_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  EphemerisSet_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  EphemerisSet_Abridged_dataMode_Enum_EXERCISE = 3,
  EphemerisSet_Abridged_dataMode_Enum_MIN = EphemerisSet_Abridged_dataMode_Enum_REAL,
  EphemerisSet_Abridged_dataMode_Enum_MAX = EphemerisSet_Abridged_dataMode_Enum_EXERCISE
};

inline const EphemerisSet_Abridged_dataMode_Enum (&EnumValuesEphemerisSet_Abridged_dataMode_Enum())[4] {
  static const EphemerisSet_Abridged_dataMode_Enum values[] = {
    EphemerisSet_Abridged_dataMode_Enum_REAL,
    EphemerisSet_Abridged_dataMode_Enum_TEST,
    EphemerisSet_Abridged_dataMode_Enum_SIMULATED,
    EphemerisSet_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesEphemerisSet_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEphemerisSet_Abridged_dataMode_Enum(EphemerisSet_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, EphemerisSet_Abridged_dataMode_Enum_REAL, EphemerisSet_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEphemerisSet_Abridged_dataMode_Enum()[index];
}

/// /// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
struct EphemerisSet_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EphemerisSet_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDONORBIT = 8,
    VT_ORIGOBJECTID = 10,
    VT_POINTSTARTTIME = 12,
    VT_USABLESTARTTIME = 14,
    VT_POINTENDTIME = 16,
    VT_USABLEENDTIME = 18,
    VT_STEPSIZE = 20,
    VT_NUMPOINTS = 22,
    VT_TYPE = 24,
    VT_PEDIGREE = 26,
    VT_CATEGORY = 28,
    VT_IDSTATEVECTOR = 30,
    VT_HASMNVR = 32,
    VT_IDMANEUVERS = 34,
    VT_HASCOV = 36,
    VT_HASACCEL = 38,
    VT_CENTBODY = 40,
    VT_INTEGRATOR = 42,
    VT_GEOPOTENTIALMODEL = 44,
    VT_DRAGMODEL = 46,
    VT_LUNARSOLAR = 48,
    VT_SOLIDEARTHTIDES = 50,
    VT_BDOT = 52,
    VT_EDR = 54,
    VT_INTERPOLATION = 56,
    VT_INTERPOLATIONDEGREE = 58,
    VT_FILENAME = 60,
    VT_COMMENTS = 62,
    VT_DESCRIPTION = 64,
    VT_DESCRIPTOR = 66,
    VT_REFERENCEFRAME = 68,
    VT_COVREFERENCEFRAME = 70,
    VT_CREATEDAT = 72,
    VT_CREATEDBY = 74,
    VT_SOURCE = 76,
    VT_ORIGIN = 78,
    VT_DATAMODE = 80,
    VT_SATNO = 82,
    VT_TRANSACTIONID = 84,
    VT_ORIGNETWORK = 86
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: EPHEMERISSET-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the primary satellite on-orbit object.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Start time/first time point of the ephemeris, in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *pointStartTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POINTSTARTTIME);
  }
  /// Optional start time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:10:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *usableStartTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USABLESTARTTIME);
  }
  /// End time/last time point of the ephemeris, in ISO 8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *pointEndTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POINTENDTIME);
  }
  /// Optional end time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2018-01-01T20:50:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *usableEndTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_USABLEENDTIME);
  }
  /// Ephemeris step size, in seconds.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t stepSize() const {
    return GetField<int32_t>(VT_STEPSIZE, 0);
  }
  /// Number of points contained in the ephemeris.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t numPoints() const {
    return GetField<int32_t>(VT_NUMPOINTS, 0);
  }
  /// The type/purpose of the ephemeris (e.g., CALIBRATION, LAUNCH, MNVR_PLAN, ROUTINE, SCREENING).
  /// Example: /// Example: LAUNCH
  /// Constraints: Minimum length = 1, Maximum length = 24
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID).
  /// Example: /// Example: PROPAGATED
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *pedigree() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PEDIGREE);
  }
  /// The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL).
  /// Example: /// Example: ANALYST
  /// Constraints: Minimum length = 1, Maximum length = 24
  const ::flatbuffers::String *category() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CATEGORY);
  }
  /// ID of the State Vector used to generate the ephemeris.
  /// Example: /// Example: STATEVECTOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idStateVector() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSTATEVECTOR);
  }
  /// Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool hasMnvr() const {
    return GetField<uint8_t>(VT_HASMNVR, 0) != 0;
  }
  /// Array of the maneuver IDs of all maneuvers incorporated in the ephemeris.
  /// Example: /// Example: ['EXAMPLE_ID1', 'EXAMPLE_ID2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *idManeuvers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_IDMANEUVERS);
  }
  /// Boolean indicating whether covariance data is provided with the ephemeris.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool hasCov() const {
    return GetField<uint8_t>(VT_HASCOV, 0) != 0;
  }
  /// Boolean indicating whether acceleration data is provided with the ephemeris.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool hasAccel() const {
    return GetField<uint8_t>(VT_HASACCEL, 0) != 0;
  }
  /// The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated.
  /// Example: /// Example: Earth
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *centBody() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CENTBODY);
  }
  /// Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY).
  /// Example: /// Example: COWELL
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *integrator() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTEGRATOR);
  }
  /// Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T).
  /// Example: /// Example: GEM-T3
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *geopotentialModel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_GEOPOTENTIALMODEL);
  }
  /// Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.).
  /// Example: /// Example: JAC70
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *dragModel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DRAGMODEL);
  }
  /// Boolean indicating use of lunar/solar data in ephemeris generation.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool lunarSolar() const {
    return GetField<uint8_t>(VT_LUNARSOLAR, 0) != 0;
  }
  /// Boolean indicating use of solid earth tide data in ephemeris generation.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool solidEarthTides() const {
    return GetField<uint8_t>(VT_SOLIDEARTHTIDES, 0) != 0;
  }
  /// First derivative of ballistic coefficient (m^2/kg-s).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double bDot() const {
    return GetField<double>(VT_BDOT, 0.0);
  }
  /// Model parameter value for energy dissipation rate (EDR), expressed in w/kg.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double edr() const {
    return GetField<double>(VT_EDR, 0.0);
  }
  /// The recommended interpolation method for the ephemeris data.
  /// Example: /// Example: LINEAR
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *interpolation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INTERPOLATION);
  }
  /// The recommended interpolation degree for the ephemeris data.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  int32_t interpolationDegree() const {
    return GetField<int32_t>(VT_INTERPOLATIONDEGREE, 0);
  }
  /// Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the 'EphemerisSet' OpenAPI docs.
  /// Example: /// Example: Example file name
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *filename() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILENAME);
  }
  /// Additional source provided comments associated with the ephemeris.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  const ::flatbuffers::String *comments() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENTS);
  }
  /// Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 512
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: Example descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  EphemerisSet_Abridged_referenceFrame_Enum referenceFrame() const {
    return static_cast<EphemerisSet_Abridged_referenceFrame_Enum>(GetField<int8_t>(VT_REFERENCEFRAME, 0));
  }
  /// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  EphemerisSet_Abridged_covReferenceFrame_Enum covReferenceFrame() const {
    return static_cast<EphemerisSet_Abridged_covReferenceFrame_Enum>(GetField<int8_t>(VT_COVREFERENCEFRAME, 0));
  }
  /// Time the row was created in the database, in UTC.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  EphemerisSet_Abridged_dataMode_Enum dataMode() const {
    return static_cast<EphemerisSet_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_POINTSTARTTIME) &&
           verifier.VerifyString(pointStartTime()) &&
           VerifyOffset(verifier, VT_USABLESTARTTIME) &&
           verifier.VerifyString(usableStartTime()) &&
           VerifyOffset(verifier, VT_POINTENDTIME) &&
           verifier.VerifyString(pointEndTime()) &&
           VerifyOffset(verifier, VT_USABLEENDTIME) &&
           verifier.VerifyString(usableEndTime()) &&
           VerifyField<int32_t>(verifier, VT_STEPSIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMPOINTS, 4) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_PEDIGREE) &&
           verifier.VerifyString(pedigree()) &&
           VerifyOffset(verifier, VT_CATEGORY) &&
           verifier.VerifyString(category()) &&
           VerifyOffset(verifier, VT_IDSTATEVECTOR) &&
           verifier.VerifyString(idStateVector()) &&
           VerifyField<uint8_t>(verifier, VT_HASMNVR, 1) &&
           VerifyOffset(verifier, VT_IDMANEUVERS) &&
           verifier.VerifyVector(idManeuvers()) &&
           verifier.VerifyVectorOfStrings(idManeuvers()) &&
           VerifyField<uint8_t>(verifier, VT_HASCOV, 1) &&
           VerifyField<uint8_t>(verifier, VT_HASACCEL, 1) &&
           VerifyOffset(verifier, VT_CENTBODY) &&
           verifier.VerifyString(centBody()) &&
           VerifyOffset(verifier, VT_INTEGRATOR) &&
           verifier.VerifyString(integrator()) &&
           VerifyOffset(verifier, VT_GEOPOTENTIALMODEL) &&
           verifier.VerifyString(geopotentialModel()) &&
           VerifyOffset(verifier, VT_DRAGMODEL) &&
           verifier.VerifyString(dragModel()) &&
           VerifyField<uint8_t>(verifier, VT_LUNARSOLAR, 1) &&
           VerifyField<uint8_t>(verifier, VT_SOLIDEARTHTIDES, 1) &&
           VerifyField<double>(verifier, VT_BDOT, 8) &&
           VerifyField<double>(verifier, VT_EDR, 8) &&
           VerifyOffset(verifier, VT_INTERPOLATION) &&
           verifier.VerifyString(interpolation()) &&
           VerifyField<int32_t>(verifier, VT_INTERPOLATIONDEGREE, 4) &&
           VerifyOffset(verifier, VT_FILENAME) &&
           verifier.VerifyString(filename()) &&
           VerifyOffset(verifier, VT_COMMENTS) &&
           verifier.VerifyString(comments()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(descriptor()) &&
           VerifyField<int8_t>(verifier, VT_REFERENCEFRAME, 1) &&
           VerifyField<int8_t>(verifier, VT_COVREFERENCEFRAME, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct EphemerisSet_AbridgedBuilder {
  typedef EphemerisSet_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  void add_pointStartTime(::flatbuffers::Offset<::flatbuffers::String> pointStartTime) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_POINTSTARTTIME, pointStartTime);
  }
  void add_usableStartTime(::flatbuffers::Offset<::flatbuffers::String> usableStartTime) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_USABLESTARTTIME, usableStartTime);
  }
  void add_pointEndTime(::flatbuffers::Offset<::flatbuffers::String> pointEndTime) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_POINTENDTIME, pointEndTime);
  }
  void add_usableEndTime(::flatbuffers::Offset<::flatbuffers::String> usableEndTime) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_USABLEENDTIME, usableEndTime);
  }
  void add_stepSize(int32_t stepSize) {
    fbb_.AddElement<int32_t>(EphemerisSet_Abridged::VT_STEPSIZE, stepSize, 0);
  }
  void add_numPoints(int32_t numPoints) {
    fbb_.AddElement<int32_t>(EphemerisSet_Abridged::VT_NUMPOINTS, numPoints, 0);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_TYPE, type);
  }
  void add_pedigree(::flatbuffers::Offset<::flatbuffers::String> pedigree) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_PEDIGREE, pedigree);
  }
  void add_category(::flatbuffers::Offset<::flatbuffers::String> category) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_CATEGORY, category);
  }
  void add_idStateVector(::flatbuffers::Offset<::flatbuffers::String> idStateVector) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_IDSTATEVECTOR, idStateVector);
  }
  void add_hasMnvr(bool hasMnvr) {
    fbb_.AddElement<uint8_t>(EphemerisSet_Abridged::VT_HASMNVR, static_cast<uint8_t>(hasMnvr), 0);
  }
  void add_idManeuvers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> idManeuvers) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_IDMANEUVERS, idManeuvers);
  }
  void add_hasCov(bool hasCov) {
    fbb_.AddElement<uint8_t>(EphemerisSet_Abridged::VT_HASCOV, static_cast<uint8_t>(hasCov), 0);
  }
  void add_hasAccel(bool hasAccel) {
    fbb_.AddElement<uint8_t>(EphemerisSet_Abridged::VT_HASACCEL, static_cast<uint8_t>(hasAccel), 0);
  }
  void add_centBody(::flatbuffers::Offset<::flatbuffers::String> centBody) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_CENTBODY, centBody);
  }
  void add_integrator(::flatbuffers::Offset<::flatbuffers::String> integrator) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_INTEGRATOR, integrator);
  }
  void add_geopotentialModel(::flatbuffers::Offset<::flatbuffers::String> geopotentialModel) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_GEOPOTENTIALMODEL, geopotentialModel);
  }
  void add_dragModel(::flatbuffers::Offset<::flatbuffers::String> dragModel) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_DRAGMODEL, dragModel);
  }
  void add_lunarSolar(bool lunarSolar) {
    fbb_.AddElement<uint8_t>(EphemerisSet_Abridged::VT_LUNARSOLAR, static_cast<uint8_t>(lunarSolar), 0);
  }
  void add_solidEarthTides(bool solidEarthTides) {
    fbb_.AddElement<uint8_t>(EphemerisSet_Abridged::VT_SOLIDEARTHTIDES, static_cast<uint8_t>(solidEarthTides), 0);
  }
  void add_bDot(double bDot) {
    fbb_.AddElement<double>(EphemerisSet_Abridged::VT_BDOT, bDot, 0.0);
  }
  void add_edr(double edr) {
    fbb_.AddElement<double>(EphemerisSet_Abridged::VT_EDR, edr, 0.0);
  }
  void add_interpolation(::flatbuffers::Offset<::flatbuffers::String> interpolation) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_INTERPOLATION, interpolation);
  }
  void add_interpolationDegree(int32_t interpolationDegree) {
    fbb_.AddElement<int32_t>(EphemerisSet_Abridged::VT_INTERPOLATIONDEGREE, interpolationDegree, 0);
  }
  void add_filename(::flatbuffers::Offset<::flatbuffers::String> filename) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_FILENAME, filename);
  }
  void add_comments(::flatbuffers::Offset<::flatbuffers::String> comments) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_COMMENTS, comments);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_DESCRIPTION, description);
  }
  void add_descriptor(::flatbuffers::Offset<::flatbuffers::String> descriptor) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_DESCRIPTOR, descriptor);
  }
  void add_referenceFrame(EphemerisSet_Abridged_referenceFrame_Enum referenceFrame) {
    fbb_.AddElement<int8_t>(EphemerisSet_Abridged::VT_REFERENCEFRAME, static_cast<int8_t>(referenceFrame), 0);
  }
  void add_covReferenceFrame(EphemerisSet_Abridged_covReferenceFrame_Enum covReferenceFrame) {
    fbb_.AddElement<int8_t>(EphemerisSet_Abridged::VT_COVREFERENCEFRAME, static_cast<int8_t>(covReferenceFrame), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_ORIGIN, origin);
  }
  void add_dataMode(EphemerisSet_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(EphemerisSet_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(EphemerisSet_Abridged::VT_SATNO, satNo, 0);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_TRANSACTIONID, transactionId);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(EphemerisSet_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  explicit EphemerisSet_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EphemerisSet_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EphemerisSet_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EphemerisSet_Abridged> CreateEphemerisSet_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pointStartTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> usableStartTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pointEndTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> usableEndTime = 0,
    int32_t stepSize = 0,
    int32_t numPoints = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pedigree = 0,
    ::flatbuffers::Offset<::flatbuffers::String> category = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idStateVector = 0,
    bool hasMnvr = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> idManeuvers = 0,
    bool hasCov = false,
    bool hasAccel = false,
    ::flatbuffers::Offset<::flatbuffers::String> centBody = 0,
    ::flatbuffers::Offset<::flatbuffers::String> integrator = 0,
    ::flatbuffers::Offset<::flatbuffers::String> geopotentialModel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> dragModel = 0,
    bool lunarSolar = false,
    bool solidEarthTides = false,
    double bDot = 0.0,
    double edr = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> interpolation = 0,
    int32_t interpolationDegree = 0,
    ::flatbuffers::Offset<::flatbuffers::String> filename = 0,
    ::flatbuffers::Offset<::flatbuffers::String> comments = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> descriptor = 0,
    EphemerisSet_Abridged_referenceFrame_Enum referenceFrame = EphemerisSet_Abridged_referenceFrame_Enum_J2000,
    EphemerisSet_Abridged_covReferenceFrame_Enum covReferenceFrame = EphemerisSet_Abridged_covReferenceFrame_Enum_J2000,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    EphemerisSet_Abridged_dataMode_Enum dataMode = EphemerisSet_Abridged_dataMode_Enum_REAL,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  EphemerisSet_AbridgedBuilder builder_(_fbb);
  builder_.add_edr(edr);
  builder_.add_bDot(bDot);
  builder_.add_origNetwork(origNetwork);
  builder_.add_transactionId(transactionId);
  builder_.add_satNo(satNo);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_descriptor(descriptor);
  builder_.add_description(description);
  builder_.add_comments(comments);
  builder_.add_filename(filename);
  builder_.add_interpolationDegree(interpolationDegree);
  builder_.add_interpolation(interpolation);
  builder_.add_dragModel(dragModel);
  builder_.add_geopotentialModel(geopotentialModel);
  builder_.add_integrator(integrator);
  builder_.add_centBody(centBody);
  builder_.add_idManeuvers(idManeuvers);
  builder_.add_idStateVector(idStateVector);
  builder_.add_category(category);
  builder_.add_pedigree(pedigree);
  builder_.add_type(type);
  builder_.add_numPoints(numPoints);
  builder_.add_stepSize(stepSize);
  builder_.add_usableEndTime(usableEndTime);
  builder_.add_pointEndTime(pointEndTime);
  builder_.add_usableStartTime(usableStartTime);
  builder_.add_pointStartTime(pointStartTime);
  builder_.add_origObjectId(origObjectId);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_covReferenceFrame(covReferenceFrame);
  builder_.add_referenceFrame(referenceFrame);
  builder_.add_solidEarthTides(solidEarthTides);
  builder_.add_lunarSolar(lunarSolar);
  builder_.add_hasAccel(hasAccel);
  builder_.add_hasCov(hasCov);
  builder_.add_hasMnvr(hasMnvr);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EphemerisSet_Abridged> CreateEphemerisSet_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idOnOrbit = nullptr,
    const char *origObjectId = nullptr,
    const char *pointStartTime = nullptr,
    const char *usableStartTime = nullptr,
    const char *pointEndTime = nullptr,
    const char *usableEndTime = nullptr,
    int32_t stepSize = 0,
    int32_t numPoints = 0,
    const char *type = nullptr,
    const char *pedigree = nullptr,
    const char *category = nullptr,
    const char *idStateVector = nullptr,
    bool hasMnvr = false,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *idManeuvers = nullptr,
    bool hasCov = false,
    bool hasAccel = false,
    const char *centBody = nullptr,
    const char *integrator = nullptr,
    const char *geopotentialModel = nullptr,
    const char *dragModel = nullptr,
    bool lunarSolar = false,
    bool solidEarthTides = false,
    double bDot = 0.0,
    double edr = 0.0,
    const char *interpolation = nullptr,
    int32_t interpolationDegree = 0,
    const char *filename = nullptr,
    const char *comments = nullptr,
    const char *description = nullptr,
    const char *descriptor = nullptr,
    EphemerisSet_Abridged_referenceFrame_Enum referenceFrame = EphemerisSet_Abridged_referenceFrame_Enum_J2000,
    EphemerisSet_Abridged_covReferenceFrame_Enum covReferenceFrame = EphemerisSet_Abridged_covReferenceFrame_Enum_J2000,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    EphemerisSet_Abridged_dataMode_Enum dataMode = EphemerisSet_Abridged_dataMode_Enum_REAL,
    int32_t satNo = 0,
    const char *transactionId = nullptr,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto pointStartTime__ = pointStartTime ? _fbb.CreateString(pointStartTime) : 0;
  auto usableStartTime__ = usableStartTime ? _fbb.CreateString(usableStartTime) : 0;
  auto pointEndTime__ = pointEndTime ? _fbb.CreateString(pointEndTime) : 0;
  auto usableEndTime__ = usableEndTime ? _fbb.CreateString(usableEndTime) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto pedigree__ = pedigree ? _fbb.CreateString(pedigree) : 0;
  auto category__ = category ? _fbb.CreateString(category) : 0;
  auto idStateVector__ = idStateVector ? _fbb.CreateString(idStateVector) : 0;
  auto idManeuvers__ = idManeuvers ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*idManeuvers) : 0;
  auto centBody__ = centBody ? _fbb.CreateString(centBody) : 0;
  auto integrator__ = integrator ? _fbb.CreateString(integrator) : 0;
  auto geopotentialModel__ = geopotentialModel ? _fbb.CreateString(geopotentialModel) : 0;
  auto dragModel__ = dragModel ? _fbb.CreateString(dragModel) : 0;
  auto interpolation__ = interpolation ? _fbb.CreateString(interpolation) : 0;
  auto filename__ = filename ? _fbb.CreateString(filename) : 0;
  auto comments__ = comments ? _fbb.CreateString(comments) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto descriptor__ = descriptor ? _fbb.CreateString(descriptor) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateEphemerisSet_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      idOnOrbit__,
      origObjectId__,
      pointStartTime__,
      usableStartTime__,
      pointEndTime__,
      usableEndTime__,
      stepSize,
      numPoints,
      type__,
      pedigree__,
      category__,
      idStateVector__,
      hasMnvr,
      idManeuvers__,
      hasCov,
      hasAccel,
      centBody__,
      integrator__,
      geopotentialModel__,
      dragModel__,
      lunarSolar,
      solidEarthTides,
      bDot,
      edr,
      interpolation__,
      interpolationDegree,
      filename__,
      comments__,
      description__,
      descriptor__,
      referenceFrame,
      covReferenceFrame,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode,
      satNo,
      transactionId__,
      origNetwork__);
}

inline const EphemerisSet_Abridged *GetEphemerisSet_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<EphemerisSet_Abridged>(buf);
}

inline const EphemerisSet_Abridged *GetSizePrefixedEphemerisSet_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EphemerisSet_Abridged>(buf);
}

inline const char *EphemerisSet_AbridgedIdentifier() {
  return "EPHE";
}

inline bool EphemerisSet_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EphemerisSet_AbridgedIdentifier());
}

inline bool SizePrefixedEphemerisSet_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EphemerisSet_AbridgedIdentifier(), true);
}

inline bool VerifyEphemerisSet_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EphemerisSet_Abridged>(EphemerisSet_AbridgedIdentifier());
}

inline bool VerifySizePrefixedEphemerisSet_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EphemerisSet_Abridged>(EphemerisSet_AbridgedIdentifier());
}

inline void FinishEphemerisSet_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EphemerisSet_Abridged> root) {
  fbb.Finish(root, EphemerisSet_AbridgedIdentifier());
}

inline void FinishSizePrefixedEphemerisSet_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EphemerisSet_Abridged> root) {
  fbb.FinishSizePrefixed(root, EphemerisSet_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
