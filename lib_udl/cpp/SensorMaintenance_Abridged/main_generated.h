// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SensorMaintenance_Abridged;
struct SensorMaintenance_AbridgedBuilder;

enum SensorMaintenance_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  SensorMaintenance_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  SensorMaintenance_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  SensorMaintenance_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  SensorMaintenance_Abridged_dataMode_Enum_EXERCISE = 3,
  SensorMaintenance_Abridged_dataMode_Enum_MIN = SensorMaintenance_Abridged_dataMode_Enum_REAL,
  SensorMaintenance_Abridged_dataMode_Enum_MAX = SensorMaintenance_Abridged_dataMode_Enum_EXERCISE
};

inline const SensorMaintenance_Abridged_dataMode_Enum (&EnumValuesSensorMaintenance_Abridged_dataMode_Enum())[4] {
  static const SensorMaintenance_Abridged_dataMode_Enum values[] = {
    SensorMaintenance_Abridged_dataMode_Enum_REAL,
    SensorMaintenance_Abridged_dataMode_Enum_TEST,
    SensorMaintenance_Abridged_dataMode_Enum_SIMULATED,
    SensorMaintenance_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSensorMaintenance_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorMaintenance_Abridged_dataMode_Enum(SensorMaintenance_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, SensorMaintenance_Abridged_dataMode_Enum_REAL, SensorMaintenance_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorMaintenance_Abridged_dataMode_Enum()[index];
}

/// /// Maintenance schedule and operational status of Sensor.
struct SensorMaintenance_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SensorMaintenance_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_SITECODE = 8,
    VT_IDSENSOR = 10,
    VT_STARTTIME = 12,
    VT_ENDTIME = 14,
    VT_RECALL = 16,
    VT_DURATION = 18,
    VT_MWOPSCAP = 20,
    VT_SSOPSCAP = 22,
    VT_MDOPSCAP = 24,
    VT_IMPACTEDFACES = 26,
    VT_EQUIPSTATUS = 28,
    VT_ACTIVITY = 30,
    VT_REMARK = 32,
    VT_REQUESTOR = 34,
    VT_CHANGER = 36,
    VT_APPROVER = 38,
    VT_EOWID = 40,
    VT_REV = 42,
    VT_PRIORITY = 44,
    VT_REL = 46,
    VT_LINENUMBER = 48,
    VT_RESOURCE = 50,
    VT_INACTIVEDATE = 52,
    VT_CREATEDAT = 54,
    VT_CREATEDBY = 56,
    VT_SOURCE = 58,
    VT_ORIGIN = 60,
    VT_DATAMODE = 62,
    VT_ORIGNETWORK = 64
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SENSORMAINTENANCE-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The site to which this item applies.  NOTE - this site code is COLT specific and may not identically correspond to other UDL site IDs.
  /// Example: /// Example: site01
  /// Constraints: Minimum length = 1, Maximum length = 6
  const ::flatbuffers::String *siteCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SITECODE);
  }
  /// UUID of the sensor.
  /// Example: /// Example: idSensor
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// The planned outage start time in ISO8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *startTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STARTTIME);
  }
  /// The planned outage end time in ISO8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *endTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENDTIME);
  }
  /// The minimum time required to recall this activity, expressed as ddd:hh:mm.
  /// Example: /// Example: 128:16:52
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *recall() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RECALL);
  }
  /// The duration of the planned outage, expressed as ddd:hh:mm.
  /// Example: /// Example: 128:16:52
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *duration() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DURATION);
  }
  /// The Missile Warning operational capability of this maintenance item.  Typical values are G, Y, R, and - for non-applicable sites.
  /// Example: /// Example: G
  /// Constraints: Minimum length = 0, Maximum length = 3
  const ::flatbuffers::String *mwOpsCap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MWOPSCAP);
  }
  /// The Space Surveillance operational capability of this maintenance item.  Typical values are G, Y, R, and - for non-applicable sites.
  /// Example: /// Example: Y
  /// Constraints: Minimum length = 0, Maximum length = 3
  const ::flatbuffers::String *ssOpsCap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SSOPSCAP);
  }
  /// The Missile Defense operational capability of this maintenance item.  Typical values are G, Y, R, and - for non-applicable sites.
  /// Example: /// Example: R
  /// Constraints: Minimum length = 0, Maximum length = 3
  const ::flatbuffers::String *mdOpsCap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MDOPSCAP);
  }
  /// The sensor face(s) to which this COLT maintenance item applies, if applicable.
  /// Example: /// Example: impactedFaces
  /// Constraints: Minimum length = 0, Maximum length = 50
  const ::flatbuffers::String *impactedFaces() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMPACTEDFACES);
  }
  /// The mission capability status of the equipment (e.g. FMC, NMC, PMC, UNK, etc.).
  /// Example: /// Example: FMC
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *equipStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EQUIPSTATUS);
  }
  /// Description of the activity taking place during this outage.
  /// Example: /// Example: Activity Description
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *activity() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTIVITY);
  }
  /// Remarks concerning this outage.
  /// Example: /// Example: Remarks
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *remark() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REMARK);
  }
  /// The name of the requestor.
  /// Example: /// Example: requestor
  /// Constraints: Minimum length = 0, Maximum length = 50
  const ::flatbuffers::String *requestor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REQUESTOR);
  }
  /// The name of the changer, if applicable.
  /// Example: /// Example: changer
  /// Constraints: Minimum length = 0, Maximum length = 50
  const ::flatbuffers::String *changer() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHANGER);
  }
  /// The name of the approver.
  /// Example: /// Example: approver
  /// Constraints: Minimum length = 0, Maximum length = 50
  const ::flatbuffers::String *approver() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPROVER);
  }
  /// COLT EOWID.
  /// Example: /// Example: eowId
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *eowId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EOWID);
  }
  /// The revision number for this maintenance item.
  /// Example: /// Example: rev
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *rev() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REV);
  }
  /// The priority of this maintenance item.
  /// Example: /// Example: low
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *priority() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIORITY);
  }
  /// Release.
  /// Example: /// Example: rel
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *rel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_REL);
  }
  /// The internal COLT line number assigned to this item.
  /// Example: /// Example: lineNumber
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *lineNumber() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LINENUMBER);
  }
  /// The name of the resource(s) affected by this maintenance item.
  /// Example: /// Example: resource
  /// Constraints: Minimum length = 0, Maximum length = 255
  const ::flatbuffers::String *resource() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RESOURCE);
  }
  /// The date that this item became inactive in ISO8601 UTC format.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *inactiveDate() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INACTIVEDATE);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  SensorMaintenance_Abridged_dataMode_Enum dataMode() const {
    return static_cast<SensorMaintenance_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_SITECODE) &&
           verifier.VerifyString(siteCode()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_STARTTIME) &&
           verifier.VerifyString(startTime()) &&
           VerifyOffset(verifier, VT_ENDTIME) &&
           verifier.VerifyString(endTime()) &&
           VerifyOffset(verifier, VT_RECALL) &&
           verifier.VerifyString(recall()) &&
           VerifyOffset(verifier, VT_DURATION) &&
           verifier.VerifyString(duration()) &&
           VerifyOffset(verifier, VT_MWOPSCAP) &&
           verifier.VerifyString(mwOpsCap()) &&
           VerifyOffset(verifier, VT_SSOPSCAP) &&
           verifier.VerifyString(ssOpsCap()) &&
           VerifyOffset(verifier, VT_MDOPSCAP) &&
           verifier.VerifyString(mdOpsCap()) &&
           VerifyOffset(verifier, VT_IMPACTEDFACES) &&
           verifier.VerifyString(impactedFaces()) &&
           VerifyOffset(verifier, VT_EQUIPSTATUS) &&
           verifier.VerifyString(equipStatus()) &&
           VerifyOffset(verifier, VT_ACTIVITY) &&
           verifier.VerifyString(activity()) &&
           VerifyOffset(verifier, VT_REMARK) &&
           verifier.VerifyString(remark()) &&
           VerifyOffset(verifier, VT_REQUESTOR) &&
           verifier.VerifyString(requestor()) &&
           VerifyOffset(verifier, VT_CHANGER) &&
           verifier.VerifyString(changer()) &&
           VerifyOffset(verifier, VT_APPROVER) &&
           verifier.VerifyString(approver()) &&
           VerifyOffset(verifier, VT_EOWID) &&
           verifier.VerifyString(eowId()) &&
           VerifyOffset(verifier, VT_REV) &&
           verifier.VerifyString(rev()) &&
           VerifyOffset(verifier, VT_PRIORITY) &&
           verifier.VerifyString(priority()) &&
           VerifyOffset(verifier, VT_REL) &&
           verifier.VerifyString(rel()) &&
           VerifyOffset(verifier, VT_LINENUMBER) &&
           verifier.VerifyString(lineNumber()) &&
           VerifyOffset(verifier, VT_RESOURCE) &&
           verifier.VerifyString(resource()) &&
           VerifyOffset(verifier, VT_INACTIVEDATE) &&
           verifier.VerifyString(inactiveDate()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct SensorMaintenance_AbridgedBuilder {
  typedef SensorMaintenance_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_siteCode(::flatbuffers::Offset<::flatbuffers::String> siteCode) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_SITECODE, siteCode);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_IDSENSOR, idSensor);
  }
  void add_startTime(::flatbuffers::Offset<::flatbuffers::String> startTime) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_STARTTIME, startTime);
  }
  void add_endTime(::flatbuffers::Offset<::flatbuffers::String> endTime) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_ENDTIME, endTime);
  }
  void add_recall(::flatbuffers::Offset<::flatbuffers::String> recall) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_RECALL, recall);
  }
  void add_duration(::flatbuffers::Offset<::flatbuffers::String> duration) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_DURATION, duration);
  }
  void add_mwOpsCap(::flatbuffers::Offset<::flatbuffers::String> mwOpsCap) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_MWOPSCAP, mwOpsCap);
  }
  void add_ssOpsCap(::flatbuffers::Offset<::flatbuffers::String> ssOpsCap) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_SSOPSCAP, ssOpsCap);
  }
  void add_mdOpsCap(::flatbuffers::Offset<::flatbuffers::String> mdOpsCap) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_MDOPSCAP, mdOpsCap);
  }
  void add_impactedFaces(::flatbuffers::Offset<::flatbuffers::String> impactedFaces) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_IMPACTEDFACES, impactedFaces);
  }
  void add_equipStatus(::flatbuffers::Offset<::flatbuffers::String> equipStatus) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_EQUIPSTATUS, equipStatus);
  }
  void add_activity(::flatbuffers::Offset<::flatbuffers::String> activity) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_ACTIVITY, activity);
  }
  void add_remark(::flatbuffers::Offset<::flatbuffers::String> remark) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_REMARK, remark);
  }
  void add_requestor(::flatbuffers::Offset<::flatbuffers::String> requestor) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_REQUESTOR, requestor);
  }
  void add_changer(::flatbuffers::Offset<::flatbuffers::String> changer) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_CHANGER, changer);
  }
  void add_approver(::flatbuffers::Offset<::flatbuffers::String> approver) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_APPROVER, approver);
  }
  void add_eowId(::flatbuffers::Offset<::flatbuffers::String> eowId) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_EOWID, eowId);
  }
  void add_rev(::flatbuffers::Offset<::flatbuffers::String> rev) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_REV, rev);
  }
  void add_priority(::flatbuffers::Offset<::flatbuffers::String> priority) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_PRIORITY, priority);
  }
  void add_rel(::flatbuffers::Offset<::flatbuffers::String> rel) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_REL, rel);
  }
  void add_lineNumber(::flatbuffers::Offset<::flatbuffers::String> lineNumber) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_LINENUMBER, lineNumber);
  }
  void add_resource(::flatbuffers::Offset<::flatbuffers::String> resource) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_RESOURCE, resource);
  }
  void add_inactiveDate(::flatbuffers::Offset<::flatbuffers::String> inactiveDate) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_INACTIVEDATE, inactiveDate);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_ORIGIN, origin);
  }
  void add_dataMode(SensorMaintenance_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(SensorMaintenance_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(SensorMaintenance_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  explicit SensorMaintenance_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SensorMaintenance_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SensorMaintenance_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SensorMaintenance_Abridged> CreateSensorMaintenance_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> siteCode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> startTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> endTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> recall = 0,
    ::flatbuffers::Offset<::flatbuffers::String> duration = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mwOpsCap = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ssOpsCap = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mdOpsCap = 0,
    ::flatbuffers::Offset<::flatbuffers::String> impactedFaces = 0,
    ::flatbuffers::Offset<::flatbuffers::String> equipStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> activity = 0,
    ::flatbuffers::Offset<::flatbuffers::String> remark = 0,
    ::flatbuffers::Offset<::flatbuffers::String> requestor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> changer = 0,
    ::flatbuffers::Offset<::flatbuffers::String> approver = 0,
    ::flatbuffers::Offset<::flatbuffers::String> eowId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rev = 0,
    ::flatbuffers::Offset<::flatbuffers::String> priority = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rel = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lineNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::String> resource = 0,
    ::flatbuffers::Offset<::flatbuffers::String> inactiveDate = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    SensorMaintenance_Abridged_dataMode_Enum dataMode = SensorMaintenance_Abridged_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  SensorMaintenance_AbridgedBuilder builder_(_fbb);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_inactiveDate(inactiveDate);
  builder_.add_resource(resource);
  builder_.add_lineNumber(lineNumber);
  builder_.add_rel(rel);
  builder_.add_priority(priority);
  builder_.add_rev(rev);
  builder_.add_eowId(eowId);
  builder_.add_approver(approver);
  builder_.add_changer(changer);
  builder_.add_requestor(requestor);
  builder_.add_remark(remark);
  builder_.add_activity(activity);
  builder_.add_equipStatus(equipStatus);
  builder_.add_impactedFaces(impactedFaces);
  builder_.add_mdOpsCap(mdOpsCap);
  builder_.add_ssOpsCap(ssOpsCap);
  builder_.add_mwOpsCap(mwOpsCap);
  builder_.add_duration(duration);
  builder_.add_recall(recall);
  builder_.add_endTime(endTime);
  builder_.add_startTime(startTime);
  builder_.add_idSensor(idSensor);
  builder_.add_siteCode(siteCode);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SensorMaintenance_Abridged> CreateSensorMaintenance_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *siteCode = nullptr,
    const char *idSensor = nullptr,
    const char *startTime = nullptr,
    const char *endTime = nullptr,
    const char *recall = nullptr,
    const char *duration = nullptr,
    const char *mwOpsCap = nullptr,
    const char *ssOpsCap = nullptr,
    const char *mdOpsCap = nullptr,
    const char *impactedFaces = nullptr,
    const char *equipStatus = nullptr,
    const char *activity = nullptr,
    const char *remark = nullptr,
    const char *requestor = nullptr,
    const char *changer = nullptr,
    const char *approver = nullptr,
    const char *eowId = nullptr,
    const char *rev = nullptr,
    const char *priority = nullptr,
    const char *rel = nullptr,
    const char *lineNumber = nullptr,
    const char *resource = nullptr,
    const char *inactiveDate = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    SensorMaintenance_Abridged_dataMode_Enum dataMode = SensorMaintenance_Abridged_dataMode_Enum_REAL,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto siteCode__ = siteCode ? _fbb.CreateString(siteCode) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto startTime__ = startTime ? _fbb.CreateString(startTime) : 0;
  auto endTime__ = endTime ? _fbb.CreateString(endTime) : 0;
  auto recall__ = recall ? _fbb.CreateString(recall) : 0;
  auto duration__ = duration ? _fbb.CreateString(duration) : 0;
  auto mwOpsCap__ = mwOpsCap ? _fbb.CreateString(mwOpsCap) : 0;
  auto ssOpsCap__ = ssOpsCap ? _fbb.CreateString(ssOpsCap) : 0;
  auto mdOpsCap__ = mdOpsCap ? _fbb.CreateString(mdOpsCap) : 0;
  auto impactedFaces__ = impactedFaces ? _fbb.CreateString(impactedFaces) : 0;
  auto equipStatus__ = equipStatus ? _fbb.CreateString(equipStatus) : 0;
  auto activity__ = activity ? _fbb.CreateString(activity) : 0;
  auto remark__ = remark ? _fbb.CreateString(remark) : 0;
  auto requestor__ = requestor ? _fbb.CreateString(requestor) : 0;
  auto changer__ = changer ? _fbb.CreateString(changer) : 0;
  auto approver__ = approver ? _fbb.CreateString(approver) : 0;
  auto eowId__ = eowId ? _fbb.CreateString(eowId) : 0;
  auto rev__ = rev ? _fbb.CreateString(rev) : 0;
  auto priority__ = priority ? _fbb.CreateString(priority) : 0;
  auto rel__ = rel ? _fbb.CreateString(rel) : 0;
  auto lineNumber__ = lineNumber ? _fbb.CreateString(lineNumber) : 0;
  auto resource__ = resource ? _fbb.CreateString(resource) : 0;
  auto inactiveDate__ = inactiveDate ? _fbb.CreateString(inactiveDate) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateSensorMaintenance_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      siteCode__,
      idSensor__,
      startTime__,
      endTime__,
      recall__,
      duration__,
      mwOpsCap__,
      ssOpsCap__,
      mdOpsCap__,
      impactedFaces__,
      equipStatus__,
      activity__,
      remark__,
      requestor__,
      changer__,
      approver__,
      eowId__,
      rev__,
      priority__,
      rel__,
      lineNumber__,
      resource__,
      inactiveDate__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode,
      origNetwork__);
}

inline const SensorMaintenance_Abridged *GetSensorMaintenance_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<SensorMaintenance_Abridged>(buf);
}

inline const SensorMaintenance_Abridged *GetSizePrefixedSensorMaintenance_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SensorMaintenance_Abridged>(buf);
}

inline const char *SensorMaintenance_AbridgedIdentifier() {
  return "SENS";
}

inline bool SensorMaintenance_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SensorMaintenance_AbridgedIdentifier());
}

inline bool SizePrefixedSensorMaintenance_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SensorMaintenance_AbridgedIdentifier(), true);
}

inline bool VerifySensorMaintenance_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SensorMaintenance_Abridged>(SensorMaintenance_AbridgedIdentifier());
}

inline bool VerifySizePrefixedSensorMaintenance_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SensorMaintenance_Abridged>(SensorMaintenance_AbridgedIdentifier());
}

inline void FinishSensorMaintenance_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SensorMaintenance_Abridged> root) {
  fbb.Finish(root, SensorMaintenance_AbridgedIdentifier());
}

inline void FinishSizePrefixedSensorMaintenance_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SensorMaintenance_Abridged> root) {
  fbb.FinishSizePrefixed(root, SensorMaintenance_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
