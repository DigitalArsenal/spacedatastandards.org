// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Conjunction_Ingest;
struct Conjunction_IngestBuilder;

enum Conjunction_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Conjunction_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Conjunction_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Conjunction_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Conjunction_Ingest_dataMode_Enum_EXERCISE = 3,
  Conjunction_Ingest_dataMode_Enum_MIN = Conjunction_Ingest_dataMode_Enum_REAL,
  Conjunction_Ingest_dataMode_Enum_MAX = Conjunction_Ingest_dataMode_Enum_EXERCISE
};

inline const Conjunction_Ingest_dataMode_Enum (&EnumValuesConjunction_Ingest_dataMode_Enum())[4] {
  static const Conjunction_Ingest_dataMode_Enum values[] = {
    Conjunction_Ingest_dataMode_Enum_REAL,
    Conjunction_Ingest_dataMode_Enum_TEST,
    Conjunction_Ingest_dataMode_Enum_SIMULATED,
    Conjunction_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesConjunction_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameConjunction_Ingest_dataMode_Enum(Conjunction_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Conjunction_Ingest_dataMode_Enum_REAL, Conjunction_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConjunction_Ingest_dataMode_Enum()[index];
}

/// /// Stores the results of a particular Conjunction Assessment (CA) run.
struct Conjunction_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Conjunction_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDONORBIT1 = 8,
    VT_IDONORBIT2 = 10,
    VT_TYPE = 12,
    VT_TCA = 14,
    VT_MISSDISTANCE = 16,
    VT_COLLISIONPROB = 18,
    VT_COLLISIONPROBMETHOD = 20,
    VT_EPHEMNAME1 = 22,
    VT_ESID1 = 24,
    VT_EPHEMNAME2 = 26,
    VT_ESID2 = 28,
    VT_RELPOSR = 30,
    VT_RELPOST = 32,
    VT_RELPOSN = 34,
    VT_RELVELMAG = 36,
    VT_RELVELR = 38,
    VT_RELVELT = 40,
    VT_RELVELN = 42,
    VT_SCREENENTRYTIME = 44,
    VT_SCREENEXITTIME = 46,
    VT_SCREENVOLUMEX = 48,
    VT_SCREENVOLUMEY = 50,
    VT_SCREENVOLUMEZ = 52,
    VT_VOLSHAPE = 54,
    VT_VOLENTRYTIME = 56,
    VT_VOLEXITTIME = 58,
    VT_PENETRATIONLEVELSIGMA = 60,
    VT_IDSTATEVECTOR1 = 62,
    VT_LASTOBTIME1 = 64,
    VT_CDAOM1 = 66,
    VT_CRAOM1 = 68,
    VT_THRUSTACCEL1 = 70,
    VT_IDSTATEVECTOR2 = 72,
    VT_LASTOBTIME2 = 74,
    VT_CDAOM2 = 76,
    VT_CRAOM2 = 78,
    VT_THRUSTACCEL2 = 80,
    VT_COMMENTS = 82,
    VT_CCIR = 84,
    VT_CONCERNNOTES = 86,
    VT_STATEDEPTNOTIFIED = 88,
    VT_OWNERCONTACTED = 90,
    VT_RAWFILEURI = 92,
    VT_MESSAGEFOR = 94,
    VT_MESSAGEID = 96,
    VT_UVWWARN = 98,
    VT_SMALLRELVELWARNING = 100,
    VT_LARGERELPOSWARNING = 102,
    VT_SMALLCOVWARNING = 104,
    VT_LARGECOVWARNING = 106,
    VT_TRANSACTIONID = 108,
    VT_SOURCE = 110,
    VT_ORIGIN = 112,
    VT_ORIGINATOR = 114,
    VT_EVENTID = 116,
    VT_DESCRIPTOR = 118,
    VT_TAGS = 120,
    VT_DATAMODE = 122,
    VT_CREATEDAT = 124,
    VT_CREATEDBY = 126,
    VT_STATEVECTOR1 = 128,
    VT_STATEVECTOR2 = 130,
    VT_SATNO1 = 132,
    VT_SATNO2 = 134,
    VT_ORIGIDONORBIT1 = 136,
    VT_ORIGIDONORBIT2 = 138,
    VT_ORIGNETWORK = 140
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: CONJUNCTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the primary satellite on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT1);
  }
  /// Unique identifier of the secondary satellite on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT2);
  }
  /// The type of data represented in this conjunction record (e.g. CONJUNCTION, CARA-WORKLIST, etc.).  If type is null the record is assumed to be a Conjunction.
  /// Example: /// Example: CONJUNCTION
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Time of closest approach (TCA) in UTC.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *tca() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TCA);
  }
  /// Distance between objects at Time of Closest Approach (TCA) in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double missDistance() const {
    return GetField<double>(VT_MISSDISTANCE, 0.0);
  }
  /// Probability of Collision is the probability (denoted p, where 0.0<=p<=1.0), that Object1 and Object2 will collide.
  /// Example: /// Example: 0.5
  /// Constraints: No constraints specified.
  double collisionProb() const {
    return GetField<double>(VT_COLLISIONPROB, 0.0);
  }
  /// The method that was used to calculate the collision probability, ex. FOSTER-1992.
  /// Example: /// Example: FOSTER-1992
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *collisionProbMethod() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLISIONPROBMETHOD);
  }
  /// The filename of the primary (object1) ephemeris used in the screening, if applicable.
  /// Example: /// Example: MEME_SPCFT_ABC_2180000_ops_nomnvr_unclassified.oem
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *ephemName1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPHEMNAME1);
  }
  /// Unique identifier of the parent Ephemeris Set of the primary (object1) ephemeris used in the screening, if applicable.
  /// Example: /// Example: a2ae2356-6d83-4e4b-896d-ddd1958800fa
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *esId1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ESID1);
  }
  /// The filename of the secondary (object2) ephemeris used in the screening, if applicable.
  /// Example: /// Example: MEME_SPCFT_DEF_2170000_ops_nomnvr_unclassified.txt
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *ephemName2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EPHEMNAME2);
  }
  /// Unique identifier of the parent Ephemeris Set of the secondary (object2) ephemeris used in the screening, if applicable.
  /// Example: /// Example: 6fa31433-8beb-4b9b-8bf9-326dbd041c3f
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *esId2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ESID2);
  }
  /// Distance between objects along Radial Vector at Time of Closest Approach in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relPosR() const {
    return GetField<double>(VT_RELPOSR, 0.0);
  }
  /// Distance between objects along Tangential Vector in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relPosT() const {
    return GetField<double>(VT_RELPOST, 0.0);
  }
  /// Distance between objects along Normal vector in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relPosN() const {
    return GetField<double>(VT_RELPOSN, 0.0);
  }
  /// Closing velocity magnitude (relative speed) at Time of Closest Approach in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relVelMag() const {
    return GetField<double>(VT_RELVELMAG, 0.0);
  }
  /// Closing velocity between objects along Radial Vector at Time of Closest Approach in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relVelR() const {
    return GetField<double>(VT_RELVELR, 0.0);
  }
  /// Closing velocity between objects along Tangential Vector in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relVelT() const {
    return GetField<double>(VT_RELVELT, 0.0);
  }
  /// Closing velocity between objects along Normal Vector in meters/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double relVelN() const {
    return GetField<double>(VT_RELVELN, 0.0);
  }
  /// The start time in UTC of the screening period for the conjunction assessment.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *screenEntryTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCREENENTRYTIME);
  }
  /// The stop time in UTC of the screening period for the conjunction assessment.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *screenExitTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SCREENEXITTIME);
  }
  /// Component size of screen in X component of  RTN (Radial, Transverse and Normal) frame in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double screenVolumeX() const {
    return GetField<double>(VT_SCREENVOLUMEX, 0.0);
  }
  /// Component size of screen in Y component of  RTN (Radial, Transverse and Normal) frame in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double screenVolumeY() const {
    return GetField<double>(VT_SCREENVOLUMEY, 0.0);
  }
  /// Component size of screen in Z component of  RTN (Radial, Transverse and Normal) frame in meters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double screenVolumeZ() const {
    return GetField<double>(VT_SCREENVOLUMEZ, 0.0);
  }
  /// The shape (BOX, ELLIPSOID) of the screening volume.
  /// Example: /// Example: ELLIPSOID
  /// Constraints: Minimum length = 0, Maximum length = 12
  const ::flatbuffers::String *volShape() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOLSHAPE);
  }
  /// The time at which the secondary (object2) enters the screening volume, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-01-01T01:02:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *volEntryTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOLENTRYTIME);
  }
  /// The time at which the secondary (object2) exits the screening volume, in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2021-01-01T01:02:28.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *volExitTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VOLEXITTIME);
  }
  /// Penetration Level Sigma.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double penetrationLevelSigma() const {
    return GetField<double>(VT_PENETRATIONLEVELSIGMA, 0.0);
  }
  /// Optional ID of the UDL State Vector at TCA of the primary object. When performing a create, this id will be ignored in favor of the UDL generated id of the stateVector1.
  /// Example: /// Example: REF-STATEVECTOR1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idStateVector1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSTATEVECTOR1);
  }
  /// Time of last positive metric observation of the primary satellite.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastObTime1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTOBTIME1);
  }
  /// The value of the primary (object1) Area times the drag coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.016386
  /// Constraints: No constraints specified.
  double cdAoM1() const {
    return GetField<double>(VT_CDAOM1, 0.0);
  }
  /// The value of the primary (object1) Area times the solar radiation pressure coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.  This parameter is sometimes referred to as AGOM.
  /// Example: /// Example: 0.013814
  /// Constraints: No constraints specified.
  double crAoM1() const {
    return GetField<double>(VT_CRAOM1, 0.0);
  }
  /// The primary (object1) acceleration, expressed in m/s^2, due to in-track thrust used to propagate the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.033814
  /// Constraints: No constraints specified.
  double thrustAccel1() const {
    return GetField<double>(VT_THRUSTACCEL1, 0.0);
  }
  /// Optional ID of the UDL State Vector at TCA of the secondary object. When performing a create, this id will be ignored in favor of the UDL generated id of the stateVector2.
  /// Example: /// Example: REF-STATEVECTOR2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idStateVector2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSTATEVECTOR2);
  }
  /// Time of last positive metric observation of the secondary satellite.
  /// Example: /// Example: 2021-01-01T01:01:01.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *lastObTime2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTOBTIME2);
  }
  /// The value of the secondary (object2) Area times the drag coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.016386
  /// Constraints: No constraints specified.
  double cdAoM2() const {
    return GetField<double>(VT_CDAOM2, 0.0);
  }
  /// The value of the secondary (object2) Area times the solar radiation pressure coefficient over the object Mass, expressed in m^2/kg, used for propagation of the primary state vector and covariance to TCA.  This parameter is sometimes referred to as AGOM.
  /// Example: /// Example: 0.013814
  /// Constraints: No constraints specified.
  double crAoM2() const {
    return GetField<double>(VT_CRAOM2, 0.0);
  }
  /// The secondary (object2) acceleration, expressed in m/s^2, due to in-track thrust used to propagate the primary state vector and covariance to TCA.
  /// Example: /// Example: 0.033814
  /// Constraints: No constraints specified.
  double thrustAccel2() const {
    return GetField<double>(VT_THRUSTACCEL2, 0.0);
  }
  /// Additional notes from data providers.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *comments() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMMENTS);
  }
  /// Commander's critical information requirements notes.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *ccir() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CCIR);
  }
  /// Emergency comments.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *concernNotes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONCERNNOTES);
  }
  /// Flag indicating if State department was notified.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool stateDeptNotified() const {
    return GetField<uint8_t>(VT_STATEDEPTNOTIFIED, 0) != 0;
  }
  /// Flag indicating if owner was contacted.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool ownerContacted() const {
    return GetField<uint8_t>(VT_OWNERCONTACTED, 0) != 0;
  }
  /// Link to filename associated with JMS record.
  /// Example: /// Example: Example link
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *rawFileURI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWFILEURI);
  }
  /// Spacecraft name(s) for which the Collision message is provided.
  /// Example: /// Example: Message for space craft A
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *messageFor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGEFOR);
  }
  /// JMS provided message ID link.
  /// Example: /// Example: MESSAGE-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *messageId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGEID);
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool uvwWarn() const {
    return GetField<uint8_t>(VT_UVWWARN, 0) != 0;
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool smallRelVelWarning() const {
    return GetField<uint8_t>(VT_SMALLRELVELWARNING, 0) != 0;
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool largeRelPosWarning() const {
    return GetField<uint8_t>(VT_LARGERELPOSWARNING, 0) != 0;
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool smallCovWarning() const {
    return GetField<uint8_t>(VT_SMALLCOVWARNING, 0) != 0;
  }
  /// Used for probability of collision calculation, not Warning/Alert Threshold notifications.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool largeCovWarning() const {
    return GetField<uint8_t>(VT_LARGECOVWARNING, 0) != 0;
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Creating agency or owner/operator (may be different than provider who submitted the conjunction message).
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *originator() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGINATOR);
  }
  /// Optional source-provided identifier for this conjunction event. In the case where multiple conjunction records are submitted for the same event, this field can be used to tie them together to the same event.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *eventId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EVENTID);
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: sample_descriptor here
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG1']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Conjunction_Ingest_dataMode_Enum dataMode() const {
    return static_cast<Conjunction_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *stateVector1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATEVECTOR1);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *stateVector2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_STATEVECTOR2);
  }
  /// Satellite/catalog number of the target on-orbit primary object.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t satNo1() const {
    return GetField<int32_t>(VT_SATNO1, 0);
  }
  /// Satellite/catalog number of the target on-orbit secondary object.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t satNo2() const {
    return GetField<int32_t>(VT_SATNO2, 0);
  }
  /// Optional place holder for an OnOrbit ID that does not exist in UDL.
  /// Example: /// Example: ORIGONORBIT1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *origIdOnOrbit1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIDONORBIT1);
  }
  /// Optional place holder for an OnOrbit ID that does not exist in UDL.
  /// Example: /// Example: ORIGONORBIT2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *origIdOnOrbit2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIDONORBIT2);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDONORBIT1) &&
           verifier.VerifyString(idOnOrbit1()) &&
           VerifyOffset(verifier, VT_IDONORBIT2) &&
           verifier.VerifyString(idOnOrbit2()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TCA) &&
           verifier.VerifyString(tca()) &&
           VerifyField<double>(verifier, VT_MISSDISTANCE, 8) &&
           VerifyField<double>(verifier, VT_COLLISIONPROB, 8) &&
           VerifyOffset(verifier, VT_COLLISIONPROBMETHOD) &&
           verifier.VerifyString(collisionProbMethod()) &&
           VerifyOffset(verifier, VT_EPHEMNAME1) &&
           verifier.VerifyString(ephemName1()) &&
           VerifyOffset(verifier, VT_ESID1) &&
           verifier.VerifyString(esId1()) &&
           VerifyOffset(verifier, VT_EPHEMNAME2) &&
           verifier.VerifyString(ephemName2()) &&
           VerifyOffset(verifier, VT_ESID2) &&
           verifier.VerifyString(esId2()) &&
           VerifyField<double>(verifier, VT_RELPOSR, 8) &&
           VerifyField<double>(verifier, VT_RELPOST, 8) &&
           VerifyField<double>(verifier, VT_RELPOSN, 8) &&
           VerifyField<double>(verifier, VT_RELVELMAG, 8) &&
           VerifyField<double>(verifier, VT_RELVELR, 8) &&
           VerifyField<double>(verifier, VT_RELVELT, 8) &&
           VerifyField<double>(verifier, VT_RELVELN, 8) &&
           VerifyOffset(verifier, VT_SCREENENTRYTIME) &&
           verifier.VerifyString(screenEntryTime()) &&
           VerifyOffset(verifier, VT_SCREENEXITTIME) &&
           verifier.VerifyString(screenExitTime()) &&
           VerifyField<double>(verifier, VT_SCREENVOLUMEX, 8) &&
           VerifyField<double>(verifier, VT_SCREENVOLUMEY, 8) &&
           VerifyField<double>(verifier, VT_SCREENVOLUMEZ, 8) &&
           VerifyOffset(verifier, VT_VOLSHAPE) &&
           verifier.VerifyString(volShape()) &&
           VerifyOffset(verifier, VT_VOLENTRYTIME) &&
           verifier.VerifyString(volEntryTime()) &&
           VerifyOffset(verifier, VT_VOLEXITTIME) &&
           verifier.VerifyString(volExitTime()) &&
           VerifyField<double>(verifier, VT_PENETRATIONLEVELSIGMA, 8) &&
           VerifyOffset(verifier, VT_IDSTATEVECTOR1) &&
           verifier.VerifyString(idStateVector1()) &&
           VerifyOffset(verifier, VT_LASTOBTIME1) &&
           verifier.VerifyString(lastObTime1()) &&
           VerifyField<double>(verifier, VT_CDAOM1, 8) &&
           VerifyField<double>(verifier, VT_CRAOM1, 8) &&
           VerifyField<double>(verifier, VT_THRUSTACCEL1, 8) &&
           VerifyOffset(verifier, VT_IDSTATEVECTOR2) &&
           verifier.VerifyString(idStateVector2()) &&
           VerifyOffset(verifier, VT_LASTOBTIME2) &&
           verifier.VerifyString(lastObTime2()) &&
           VerifyField<double>(verifier, VT_CDAOM2, 8) &&
           VerifyField<double>(verifier, VT_CRAOM2, 8) &&
           VerifyField<double>(verifier, VT_THRUSTACCEL2, 8) &&
           VerifyOffset(verifier, VT_COMMENTS) &&
           verifier.VerifyString(comments()) &&
           VerifyOffset(verifier, VT_CCIR) &&
           verifier.VerifyString(ccir()) &&
           VerifyOffset(verifier, VT_CONCERNNOTES) &&
           verifier.VerifyString(concernNotes()) &&
           VerifyField<uint8_t>(verifier, VT_STATEDEPTNOTIFIED, 1) &&
           VerifyField<uint8_t>(verifier, VT_OWNERCONTACTED, 1) &&
           VerifyOffset(verifier, VT_RAWFILEURI) &&
           verifier.VerifyString(rawFileURI()) &&
           VerifyOffset(verifier, VT_MESSAGEFOR) &&
           verifier.VerifyString(messageFor()) &&
           VerifyOffset(verifier, VT_MESSAGEID) &&
           verifier.VerifyString(messageId()) &&
           VerifyField<uint8_t>(verifier, VT_UVWWARN, 1) &&
           VerifyField<uint8_t>(verifier, VT_SMALLRELVELWARNING, 1) &&
           VerifyField<uint8_t>(verifier, VT_LARGERELPOSWARNING, 1) &&
           VerifyField<uint8_t>(verifier, VT_SMALLCOVWARNING, 1) &&
           VerifyField<uint8_t>(verifier, VT_LARGECOVWARNING, 1) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGINATOR) &&
           verifier.VerifyString(originator()) &&
           VerifyOffset(verifier, VT_EVENTID) &&
           verifier.VerifyString(eventId()) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(descriptor()) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_STATEVECTOR1) &&
           verifier.VerifyString(stateVector1()) &&
           VerifyOffset(verifier, VT_STATEVECTOR2) &&
           verifier.VerifyString(stateVector2()) &&
           VerifyField<int32_t>(verifier, VT_SATNO1, 4) &&
           VerifyField<int32_t>(verifier, VT_SATNO2, 4) &&
           VerifyOffset(verifier, VT_ORIGIDONORBIT1) &&
           verifier.VerifyString(origIdOnOrbit1()) &&
           VerifyOffset(verifier, VT_ORIGIDONORBIT2) &&
           verifier.VerifyString(origIdOnOrbit2()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct Conjunction_IngestBuilder {
  typedef Conjunction_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Conjunction_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idOnOrbit1(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_IDONORBIT1, idOnOrbit1);
  }
  void add_idOnOrbit2(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_IDONORBIT2, idOnOrbit2);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Conjunction_Ingest::VT_TYPE, type);
  }
  void add_tca(::flatbuffers::Offset<::flatbuffers::String> tca) {
    fbb_.AddOffset(Conjunction_Ingest::VT_TCA, tca);
  }
  void add_missDistance(double missDistance) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_MISSDISTANCE, missDistance, 0.0);
  }
  void add_collisionProb(double collisionProb) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_COLLISIONPROB, collisionProb, 0.0);
  }
  void add_collisionProbMethod(::flatbuffers::Offset<::flatbuffers::String> collisionProbMethod) {
    fbb_.AddOffset(Conjunction_Ingest::VT_COLLISIONPROBMETHOD, collisionProbMethod);
  }
  void add_ephemName1(::flatbuffers::Offset<::flatbuffers::String> ephemName1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_EPHEMNAME1, ephemName1);
  }
  void add_esId1(::flatbuffers::Offset<::flatbuffers::String> esId1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ESID1, esId1);
  }
  void add_ephemName2(::flatbuffers::Offset<::flatbuffers::String> ephemName2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_EPHEMNAME2, ephemName2);
  }
  void add_esId2(::flatbuffers::Offset<::flatbuffers::String> esId2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ESID2, esId2);
  }
  void add_relPosR(double relPosR) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELPOSR, relPosR, 0.0);
  }
  void add_relPosT(double relPosT) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELPOST, relPosT, 0.0);
  }
  void add_relPosN(double relPosN) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELPOSN, relPosN, 0.0);
  }
  void add_relVelMag(double relVelMag) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELVELMAG, relVelMag, 0.0);
  }
  void add_relVelR(double relVelR) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELVELR, relVelR, 0.0);
  }
  void add_relVelT(double relVelT) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELVELT, relVelT, 0.0);
  }
  void add_relVelN(double relVelN) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_RELVELN, relVelN, 0.0);
  }
  void add_screenEntryTime(::flatbuffers::Offset<::flatbuffers::String> screenEntryTime) {
    fbb_.AddOffset(Conjunction_Ingest::VT_SCREENENTRYTIME, screenEntryTime);
  }
  void add_screenExitTime(::flatbuffers::Offset<::flatbuffers::String> screenExitTime) {
    fbb_.AddOffset(Conjunction_Ingest::VT_SCREENEXITTIME, screenExitTime);
  }
  void add_screenVolumeX(double screenVolumeX) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_SCREENVOLUMEX, screenVolumeX, 0.0);
  }
  void add_screenVolumeY(double screenVolumeY) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_SCREENVOLUMEY, screenVolumeY, 0.0);
  }
  void add_screenVolumeZ(double screenVolumeZ) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_SCREENVOLUMEZ, screenVolumeZ, 0.0);
  }
  void add_volShape(::flatbuffers::Offset<::flatbuffers::String> volShape) {
    fbb_.AddOffset(Conjunction_Ingest::VT_VOLSHAPE, volShape);
  }
  void add_volEntryTime(::flatbuffers::Offset<::flatbuffers::String> volEntryTime) {
    fbb_.AddOffset(Conjunction_Ingest::VT_VOLENTRYTIME, volEntryTime);
  }
  void add_volExitTime(::flatbuffers::Offset<::flatbuffers::String> volExitTime) {
    fbb_.AddOffset(Conjunction_Ingest::VT_VOLEXITTIME, volExitTime);
  }
  void add_penetrationLevelSigma(double penetrationLevelSigma) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_PENETRATIONLEVELSIGMA, penetrationLevelSigma, 0.0);
  }
  void add_idStateVector1(::flatbuffers::Offset<::flatbuffers::String> idStateVector1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_IDSTATEVECTOR1, idStateVector1);
  }
  void add_lastObTime1(::flatbuffers::Offset<::flatbuffers::String> lastObTime1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_LASTOBTIME1, lastObTime1);
  }
  void add_cdAoM1(double cdAoM1) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_CDAOM1, cdAoM1, 0.0);
  }
  void add_crAoM1(double crAoM1) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_CRAOM1, crAoM1, 0.0);
  }
  void add_thrustAccel1(double thrustAccel1) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_THRUSTACCEL1, thrustAccel1, 0.0);
  }
  void add_idStateVector2(::flatbuffers::Offset<::flatbuffers::String> idStateVector2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_IDSTATEVECTOR2, idStateVector2);
  }
  void add_lastObTime2(::flatbuffers::Offset<::flatbuffers::String> lastObTime2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_LASTOBTIME2, lastObTime2);
  }
  void add_cdAoM2(double cdAoM2) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_CDAOM2, cdAoM2, 0.0);
  }
  void add_crAoM2(double crAoM2) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_CRAOM2, crAoM2, 0.0);
  }
  void add_thrustAccel2(double thrustAccel2) {
    fbb_.AddElement<double>(Conjunction_Ingest::VT_THRUSTACCEL2, thrustAccel2, 0.0);
  }
  void add_comments(::flatbuffers::Offset<::flatbuffers::String> comments) {
    fbb_.AddOffset(Conjunction_Ingest::VT_COMMENTS, comments);
  }
  void add_ccir(::flatbuffers::Offset<::flatbuffers::String> ccir) {
    fbb_.AddOffset(Conjunction_Ingest::VT_CCIR, ccir);
  }
  void add_concernNotes(::flatbuffers::Offset<::flatbuffers::String> concernNotes) {
    fbb_.AddOffset(Conjunction_Ingest::VT_CONCERNNOTES, concernNotes);
  }
  void add_stateDeptNotified(bool stateDeptNotified) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_STATEDEPTNOTIFIED, static_cast<uint8_t>(stateDeptNotified), 0);
  }
  void add_ownerContacted(bool ownerContacted) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_OWNERCONTACTED, static_cast<uint8_t>(ownerContacted), 0);
  }
  void add_rawFileURI(::flatbuffers::Offset<::flatbuffers::String> rawFileURI) {
    fbb_.AddOffset(Conjunction_Ingest::VT_RAWFILEURI, rawFileURI);
  }
  void add_messageFor(::flatbuffers::Offset<::flatbuffers::String> messageFor) {
    fbb_.AddOffset(Conjunction_Ingest::VT_MESSAGEFOR, messageFor);
  }
  void add_messageId(::flatbuffers::Offset<::flatbuffers::String> messageId) {
    fbb_.AddOffset(Conjunction_Ingest::VT_MESSAGEID, messageId);
  }
  void add_uvwWarn(bool uvwWarn) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_UVWWARN, static_cast<uint8_t>(uvwWarn), 0);
  }
  void add_smallRelVelWarning(bool smallRelVelWarning) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_SMALLRELVELWARNING, static_cast<uint8_t>(smallRelVelWarning), 0);
  }
  void add_largeRelPosWarning(bool largeRelPosWarning) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_LARGERELPOSWARNING, static_cast<uint8_t>(largeRelPosWarning), 0);
  }
  void add_smallCovWarning(bool smallCovWarning) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_SMALLCOVWARNING, static_cast<uint8_t>(smallCovWarning), 0);
  }
  void add_largeCovWarning(bool largeCovWarning) {
    fbb_.AddElement<uint8_t>(Conjunction_Ingest::VT_LARGECOVWARNING, static_cast<uint8_t>(largeCovWarning), 0);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(Conjunction_Ingest::VT_TRANSACTIONID, transactionId);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Conjunction_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ORIGIN, origin);
  }
  void add_originator(::flatbuffers::Offset<::flatbuffers::String> originator) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ORIGINATOR, originator);
  }
  void add_eventId(::flatbuffers::Offset<::flatbuffers::String> eventId) {
    fbb_.AddOffset(Conjunction_Ingest::VT_EVENTID, eventId);
  }
  void add_descriptor(::flatbuffers::Offset<::flatbuffers::String> descriptor) {
    fbb_.AddOffset(Conjunction_Ingest::VT_DESCRIPTOR, descriptor);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(Conjunction_Ingest::VT_TAGS, tags);
  }
  void add_dataMode(Conjunction_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Conjunction_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Conjunction_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Conjunction_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_stateVector1(::flatbuffers::Offset<::flatbuffers::String> stateVector1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_STATEVECTOR1, stateVector1);
  }
  void add_stateVector2(::flatbuffers::Offset<::flatbuffers::String> stateVector2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_STATEVECTOR2, stateVector2);
  }
  void add_satNo1(int32_t satNo1) {
    fbb_.AddElement<int32_t>(Conjunction_Ingest::VT_SATNO1, satNo1, 0);
  }
  void add_satNo2(int32_t satNo2) {
    fbb_.AddElement<int32_t>(Conjunction_Ingest::VT_SATNO2, satNo2, 0);
  }
  void add_origIdOnOrbit1(::flatbuffers::Offset<::flatbuffers::String> origIdOnOrbit1) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ORIGIDONORBIT1, origIdOnOrbit1);
  }
  void add_origIdOnOrbit2(::flatbuffers::Offset<::flatbuffers::String> origIdOnOrbit2) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ORIGIDONORBIT2, origIdOnOrbit2);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Conjunction_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  explicit Conjunction_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Conjunction_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Conjunction_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Conjunction_Ingest> CreateConjunction_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> tca = 0,
    double missDistance = 0.0,
    double collisionProb = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> collisionProbMethod = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ephemName1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> esId1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ephemName2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> esId2 = 0,
    double relPosR = 0.0,
    double relPosT = 0.0,
    double relPosN = 0.0,
    double relVelMag = 0.0,
    double relVelR = 0.0,
    double relVelT = 0.0,
    double relVelN = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> screenEntryTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> screenExitTime = 0,
    double screenVolumeX = 0.0,
    double screenVolumeY = 0.0,
    double screenVolumeZ = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> volShape = 0,
    ::flatbuffers::Offset<::flatbuffers::String> volEntryTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> volExitTime = 0,
    double penetrationLevelSigma = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> idStateVector1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastObTime1 = 0,
    double cdAoM1 = 0.0,
    double crAoM1 = 0.0,
    double thrustAccel1 = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> idStateVector2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastObTime2 = 0,
    double cdAoM2 = 0.0,
    double crAoM2 = 0.0,
    double thrustAccel2 = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> comments = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ccir = 0,
    ::flatbuffers::Offset<::flatbuffers::String> concernNotes = 0,
    bool stateDeptNotified = false,
    bool ownerContacted = false,
    ::flatbuffers::Offset<::flatbuffers::String> rawFileURI = 0,
    ::flatbuffers::Offset<::flatbuffers::String> messageFor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> messageId = 0,
    bool uvwWarn = false,
    bool smallRelVelWarning = false,
    bool largeRelPosWarning = false,
    bool smallCovWarning = false,
    bool largeCovWarning = false,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> originator = 0,
    ::flatbuffers::Offset<::flatbuffers::String> eventId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> descriptor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    Conjunction_Ingest_dataMode_Enum dataMode = Conjunction_Ingest_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stateVector1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> stateVector2 = 0,
    int32_t satNo1 = 0,
    int32_t satNo2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origIdOnOrbit1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origIdOnOrbit2 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  Conjunction_IngestBuilder builder_(_fbb);
  builder_.add_thrustAccel2(thrustAccel2);
  builder_.add_crAoM2(crAoM2);
  builder_.add_cdAoM2(cdAoM2);
  builder_.add_thrustAccel1(thrustAccel1);
  builder_.add_crAoM1(crAoM1);
  builder_.add_cdAoM1(cdAoM1);
  builder_.add_penetrationLevelSigma(penetrationLevelSigma);
  builder_.add_screenVolumeZ(screenVolumeZ);
  builder_.add_screenVolumeY(screenVolumeY);
  builder_.add_screenVolumeX(screenVolumeX);
  builder_.add_relVelN(relVelN);
  builder_.add_relVelT(relVelT);
  builder_.add_relVelR(relVelR);
  builder_.add_relVelMag(relVelMag);
  builder_.add_relPosN(relPosN);
  builder_.add_relPosT(relPosT);
  builder_.add_relPosR(relPosR);
  builder_.add_collisionProb(collisionProb);
  builder_.add_missDistance(missDistance);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origIdOnOrbit2(origIdOnOrbit2);
  builder_.add_origIdOnOrbit1(origIdOnOrbit1);
  builder_.add_satNo2(satNo2);
  builder_.add_satNo1(satNo1);
  builder_.add_stateVector2(stateVector2);
  builder_.add_stateVector1(stateVector1);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_tags(tags);
  builder_.add_descriptor(descriptor);
  builder_.add_eventId(eventId);
  builder_.add_originator(originator);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_transactionId(transactionId);
  builder_.add_messageId(messageId);
  builder_.add_messageFor(messageFor);
  builder_.add_rawFileURI(rawFileURI);
  builder_.add_concernNotes(concernNotes);
  builder_.add_ccir(ccir);
  builder_.add_comments(comments);
  builder_.add_lastObTime2(lastObTime2);
  builder_.add_idStateVector2(idStateVector2);
  builder_.add_lastObTime1(lastObTime1);
  builder_.add_idStateVector1(idStateVector1);
  builder_.add_volExitTime(volExitTime);
  builder_.add_volEntryTime(volEntryTime);
  builder_.add_volShape(volShape);
  builder_.add_screenExitTime(screenExitTime);
  builder_.add_screenEntryTime(screenEntryTime);
  builder_.add_esId2(esId2);
  builder_.add_ephemName2(ephemName2);
  builder_.add_esId1(esId1);
  builder_.add_ephemName1(ephemName1);
  builder_.add_collisionProbMethod(collisionProbMethod);
  builder_.add_tca(tca);
  builder_.add_type(type);
  builder_.add_idOnOrbit2(idOnOrbit2);
  builder_.add_idOnOrbit1(idOnOrbit1);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_largeCovWarning(largeCovWarning);
  builder_.add_smallCovWarning(smallCovWarning);
  builder_.add_largeRelPosWarning(largeRelPosWarning);
  builder_.add_smallRelVelWarning(smallRelVelWarning);
  builder_.add_uvwWarn(uvwWarn);
  builder_.add_ownerContacted(ownerContacted);
  builder_.add_stateDeptNotified(stateDeptNotified);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Conjunction_Ingest> CreateConjunction_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idOnOrbit1 = nullptr,
    const char *idOnOrbit2 = nullptr,
    const char *type = nullptr,
    const char *tca = nullptr,
    double missDistance = 0.0,
    double collisionProb = 0.0,
    const char *collisionProbMethod = nullptr,
    const char *ephemName1 = nullptr,
    const char *esId1 = nullptr,
    const char *ephemName2 = nullptr,
    const char *esId2 = nullptr,
    double relPosR = 0.0,
    double relPosT = 0.0,
    double relPosN = 0.0,
    double relVelMag = 0.0,
    double relVelR = 0.0,
    double relVelT = 0.0,
    double relVelN = 0.0,
    const char *screenEntryTime = nullptr,
    const char *screenExitTime = nullptr,
    double screenVolumeX = 0.0,
    double screenVolumeY = 0.0,
    double screenVolumeZ = 0.0,
    const char *volShape = nullptr,
    const char *volEntryTime = nullptr,
    const char *volExitTime = nullptr,
    double penetrationLevelSigma = 0.0,
    const char *idStateVector1 = nullptr,
    const char *lastObTime1 = nullptr,
    double cdAoM1 = 0.0,
    double crAoM1 = 0.0,
    double thrustAccel1 = 0.0,
    const char *idStateVector2 = nullptr,
    const char *lastObTime2 = nullptr,
    double cdAoM2 = 0.0,
    double crAoM2 = 0.0,
    double thrustAccel2 = 0.0,
    const char *comments = nullptr,
    const char *ccir = nullptr,
    const char *concernNotes = nullptr,
    bool stateDeptNotified = false,
    bool ownerContacted = false,
    const char *rawFileURI = nullptr,
    const char *messageFor = nullptr,
    const char *messageId = nullptr,
    bool uvwWarn = false,
    bool smallRelVelWarning = false,
    bool largeRelPosWarning = false,
    bool smallCovWarning = false,
    bool largeCovWarning = false,
    const char *transactionId = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *originator = nullptr,
    const char *eventId = nullptr,
    const char *descriptor = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    Conjunction_Ingest_dataMode_Enum dataMode = Conjunction_Ingest_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *stateVector1 = nullptr,
    const char *stateVector2 = nullptr,
    int32_t satNo1 = 0,
    int32_t satNo2 = 0,
    const char *origIdOnOrbit1 = nullptr,
    const char *origIdOnOrbit2 = nullptr,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idOnOrbit1__ = idOnOrbit1 ? _fbb.CreateString(idOnOrbit1) : 0;
  auto idOnOrbit2__ = idOnOrbit2 ? _fbb.CreateString(idOnOrbit2) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto tca__ = tca ? _fbb.CreateString(tca) : 0;
  auto collisionProbMethod__ = collisionProbMethod ? _fbb.CreateString(collisionProbMethod) : 0;
  auto ephemName1__ = ephemName1 ? _fbb.CreateString(ephemName1) : 0;
  auto esId1__ = esId1 ? _fbb.CreateString(esId1) : 0;
  auto ephemName2__ = ephemName2 ? _fbb.CreateString(ephemName2) : 0;
  auto esId2__ = esId2 ? _fbb.CreateString(esId2) : 0;
  auto screenEntryTime__ = screenEntryTime ? _fbb.CreateString(screenEntryTime) : 0;
  auto screenExitTime__ = screenExitTime ? _fbb.CreateString(screenExitTime) : 0;
  auto volShape__ = volShape ? _fbb.CreateString(volShape) : 0;
  auto volEntryTime__ = volEntryTime ? _fbb.CreateString(volEntryTime) : 0;
  auto volExitTime__ = volExitTime ? _fbb.CreateString(volExitTime) : 0;
  auto idStateVector1__ = idStateVector1 ? _fbb.CreateString(idStateVector1) : 0;
  auto lastObTime1__ = lastObTime1 ? _fbb.CreateString(lastObTime1) : 0;
  auto idStateVector2__ = idStateVector2 ? _fbb.CreateString(idStateVector2) : 0;
  auto lastObTime2__ = lastObTime2 ? _fbb.CreateString(lastObTime2) : 0;
  auto comments__ = comments ? _fbb.CreateString(comments) : 0;
  auto ccir__ = ccir ? _fbb.CreateString(ccir) : 0;
  auto concernNotes__ = concernNotes ? _fbb.CreateString(concernNotes) : 0;
  auto rawFileURI__ = rawFileURI ? _fbb.CreateString(rawFileURI) : 0;
  auto messageFor__ = messageFor ? _fbb.CreateString(messageFor) : 0;
  auto messageId__ = messageId ? _fbb.CreateString(messageId) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto originator__ = originator ? _fbb.CreateString(originator) : 0;
  auto eventId__ = eventId ? _fbb.CreateString(eventId) : 0;
  auto descriptor__ = descriptor ? _fbb.CreateString(descriptor) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto stateVector1__ = stateVector1 ? _fbb.CreateString(stateVector1) : 0;
  auto stateVector2__ = stateVector2 ? _fbb.CreateString(stateVector2) : 0;
  auto origIdOnOrbit1__ = origIdOnOrbit1 ? _fbb.CreateString(origIdOnOrbit1) : 0;
  auto origIdOnOrbit2__ = origIdOnOrbit2 ? _fbb.CreateString(origIdOnOrbit2) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateConjunction_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      idOnOrbit1__,
      idOnOrbit2__,
      type__,
      tca__,
      missDistance,
      collisionProb,
      collisionProbMethod__,
      ephemName1__,
      esId1__,
      ephemName2__,
      esId2__,
      relPosR,
      relPosT,
      relPosN,
      relVelMag,
      relVelR,
      relVelT,
      relVelN,
      screenEntryTime__,
      screenExitTime__,
      screenVolumeX,
      screenVolumeY,
      screenVolumeZ,
      volShape__,
      volEntryTime__,
      volExitTime__,
      penetrationLevelSigma,
      idStateVector1__,
      lastObTime1__,
      cdAoM1,
      crAoM1,
      thrustAccel1,
      idStateVector2__,
      lastObTime2__,
      cdAoM2,
      crAoM2,
      thrustAccel2,
      comments__,
      ccir__,
      concernNotes__,
      stateDeptNotified,
      ownerContacted,
      rawFileURI__,
      messageFor__,
      messageId__,
      uvwWarn,
      smallRelVelWarning,
      largeRelPosWarning,
      smallCovWarning,
      largeCovWarning,
      transactionId__,
      source__,
      origin__,
      originator__,
      eventId__,
      descriptor__,
      tags__,
      dataMode,
      createdAt__,
      createdBy__,
      stateVector1__,
      stateVector2__,
      satNo1,
      satNo2,
      origIdOnOrbit1__,
      origIdOnOrbit2__,
      origNetwork__);
}

inline const Conjunction_Ingest *GetConjunction_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<Conjunction_Ingest>(buf);
}

inline const Conjunction_Ingest *GetSizePrefixedConjunction_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Conjunction_Ingest>(buf);
}

inline const char *Conjunction_IngestIdentifier() {
  return "CONJ";
}

inline bool Conjunction_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Conjunction_IngestIdentifier());
}

inline bool SizePrefixedConjunction_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Conjunction_IngestIdentifier(), true);
}

inline bool VerifyConjunction_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Conjunction_Ingest>(Conjunction_IngestIdentifier());
}

inline bool VerifySizePrefixedConjunction_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Conjunction_Ingest>(Conjunction_IngestIdentifier());
}

inline void FinishConjunction_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Conjunction_Ingest> root) {
  fbb.Finish(root, Conjunction_IngestIdentifier());
}

inline void FinishSizePrefixedConjunction_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Conjunction_Ingest> root) {
  fbb.FinishSizePrefixed(root, Conjunction_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
