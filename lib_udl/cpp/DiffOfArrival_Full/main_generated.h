// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct DiffOfArrival_Full;
struct DiffOfArrival_FullBuilder;

enum DiffOfArrival_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  DiffOfArrival_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  DiffOfArrival_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  DiffOfArrival_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  DiffOfArrival_Full_dataMode_Enum_EXERCISE = 3,
  DiffOfArrival_Full_dataMode_Enum_MIN = DiffOfArrival_Full_dataMode_Enum_REAL,
  DiffOfArrival_Full_dataMode_Enum_MAX = DiffOfArrival_Full_dataMode_Enum_EXERCISE
};

inline const DiffOfArrival_Full_dataMode_Enum (&EnumValuesDiffOfArrival_Full_dataMode_Enum())[4] {
  static const DiffOfArrival_Full_dataMode_Enum values[] = {
    DiffOfArrival_Full_dataMode_Enum_REAL,
    DiffOfArrival_Full_dataMode_Enum_TEST,
    DiffOfArrival_Full_dataMode_Enum_SIMULATED,
    DiffOfArrival_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesDiffOfArrival_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameDiffOfArrival_Full_dataMode_Enum(DiffOfArrival_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, DiffOfArrival_Full_dataMode_Enum_REAL, DiffOfArrival_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDiffOfArrival_Full_dataMode_Enum()[index];
}

/// /// Model representation of Signal time and frequency difference of arrival (TDOA/FDOA) information obtained by using passive RF based sensor phenomenologies and sensor triangulation.
struct DiffOfArrival_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DiffOfArrival_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_OBTIME = 8,
    VT_IDONORBIT = 10,
    VT_IDSENSOR1 = 12,
    VT_IDSENSOR2 = 14,
    VT_SATNO = 16,
    VT_TASKID = 18,
    VT_ORIGOBJECTID = 20,
    VT_ORIGSENSORID1 = 22,
    VT_ORIGSENSORID2 = 24,
    VT_UCT = 26,
    VT_SENSOR1DELAY = 28,
    VT_SENSOR2DELAY = 30,
    VT_SENLAT = 32,
    VT_SENLON = 34,
    VT_SENALT = 36,
    VT_SEN2LAT = 38,
    VT_SEN2LON = 40,
    VT_SEN2ALT = 42,
    VT_FREQUENCY = 44,
    VT_BANDWIDTH = 46,
    VT_DELTARANGE = 48,
    VT_DELTARANGEUNC = 50,
    VT_DELTARANGERATE = 52,
    VT_DELTARANGERATEUNC = 54,
    VT_SNR = 56,
    VT_TDOA = 58,
    VT_TDOAUNC = 60,
    VT_FDOA = 62,
    VT_FDOAUNC = 64,
    VT_COLLECTIONMODE = 66,
    VT_RAWFILEURI = 68,
    VT_SOURCE = 70,
    VT_DATAMODE = 72,
    VT_TAGS = 74,
    VT_ORIGIN = 76,
    VT_CREATEDAT = 78,
    VT_CREATEDBY = 80,
    VT_ONORBIT = 82,
    VT_DESCRIPTOR = 84,
    VT_TRANSACTIONID = 86,
    VT_ORIGNETWORK = 88,
    VT_SOURCEDL = 90
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: DIFFOFARRIVAL-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Ob detection time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *obTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBTIME);
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Sensor ID of the primary/1st sensor used for this measurement.
  /// Example: /// Example: SENSOR1-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR1);
  }
  /// Sensor ID of the secondary/2nd sensor used for this measurement.
  /// Example: /// Example: SENSOR2-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR2);
  }
  /// Catalog number of the target on-orbit object.
  /// Example: /// Example: 25544
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier to indicate the specific tasking which produced this observation.
  /// Example: /// Example: TASK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *taskId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKID);
  }
  /// Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Optional identifier provided by DOA source to indicate the primary/1st sensor identifier used for this measurement. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR1-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId1() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID1);
  }
  /// Optional identifier provided by DOA source to indicate the secondary/2nd sensor identifier used for this this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR2-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId2() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID2);
  }
  /// Boolean indicating this observation is part of an uncorrelated track or was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool uct() const {
    return GetField<uint8_t>(VT_UCT, 0) != 0;
  }
  /// The signal arrival delay relative to sensor 1 in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double sensor1Delay() const {
    return GetField<double>(VT_SENSOR1DELAY, 0.0);
  }
  /// The signal arrival delay relative to sensor 2 in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double sensor2Delay() const {
    return GetField<double>(VT_SENSOR2DELAY, 0.0);
  }
  /// Sensor WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double senlat() const {
    return GetField<double>(VT_SENLAT, 0.0);
  }
  /// Sensor WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 120.1
  /// Constraints: No constraints specified.
  double senlon() const {
    return GetField<double>(VT_SENLON, 0.0);
  }
  /// Sensor altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senalt() const {
    return GetField<double>(VT_SENALT, 0.0);
  }
  /// Sensor 2 WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double sen2lat() const {
    return GetField<double>(VT_SEN2LAT, 0.0);
  }
  /// Sensor 2 WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double sen2lon() const {
    return GetField<double>(VT_SEN2LON, 0.0);
  }
  /// Sensor 2 altitude at obTime (if mobile/onorbit) in km. If null, can be obtained from sensor info.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double sen2alt() const {
    return GetField<double>(VT_SEN2ALT, 0.0);
  }
  /// Center frequency of the collect in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double frequency() const {
    return GetField<double>(VT_FREQUENCY, 0.0);
  }
  /// Bandwidth of the signal in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double bandwidth() const {
    return GetField<double>(VT_BANDWIDTH, 0.0);
  }
  /// Delta range, in km. Delta range calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double deltaRange() const {
    return GetField<double>(VT_DELTARANGE, 0.0);
  }
  /// One sigma uncertainty in delta range, in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double deltaRangeUnc() const {
    return GetField<double>(VT_DELTARANGEUNC, 0.0);
  }
  /// Delta range rate, in km/sec. Delta range rate calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double deltaRangeRate() const {
    return GetField<double>(VT_DELTARANGERATE, 0.0);
  }
  /// One sigma uncertainty in the delta range rate, in km/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double deltaRangeRateUnc() const {
    return GetField<double>(VT_DELTARANGERATEUNC, 0.0);
  }
  /// Signal to noise ratio, in dB.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double snr() const {
    return GetField<double>(VT_SNR, 0.0);
  }
  /// Time difference of arrival of the center frequency signal, in seconds.  TDOA calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double tdoa() const {
    return GetField<double>(VT_TDOA, 0.0);
  }
  /// One sigma uncertainty in time difference of arrival of the center frequency signal, in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double tdoaUnc() const {
    return GetField<double>(VT_TDOAUNC, 0.0);
  }
  /// Frequency difference of arrival of the center frequency signal, in Hz.  FDOA calculation convention is (sensor2 - sensor1).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double fdoa() const {
    return GetField<double>(VT_FDOA, 0.0);
  }
  /// One sigma uncertainty in frequency difference of arrival of the center frequency signal, in Hz.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double fdoaUnc() const {
    return GetField<double>(VT_FDOAUNC, 0.0);
  }
  /// Collection mode (e.g. SURVEY, SPOT_SEARCH, NEIGHBORHOOD_WATCH, DIRECTED_SEARCH, MANUAL, etc).
  /// Example: /// Example: SURVEY
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *collectionMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONMODE);
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: No example provided.
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *rawFileURI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWFILEURI);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  DiffOfArrival_Full_dataMode_Enum dataMode() const {
    return static_cast<DiffOfArrival_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *onOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ONORBIT);
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: Example descriptor
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_OBTIME) &&
           verifier.VerifyString(obTime()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyOffset(verifier, VT_IDSENSOR1) &&
           verifier.VerifyString(idSensor1()) &&
           VerifyOffset(verifier, VT_IDSENSOR2) &&
           verifier.VerifyString(idSensor2()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_TASKID) &&
           verifier.VerifyString(taskId()) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID1) &&
           verifier.VerifyString(origSensorId1()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID2) &&
           verifier.VerifyString(origSensorId2()) &&
           VerifyField<uint8_t>(verifier, VT_UCT, 1) &&
           VerifyField<double>(verifier, VT_SENSOR1DELAY, 8) &&
           VerifyField<double>(verifier, VT_SENSOR2DELAY, 8) &&
           VerifyField<double>(verifier, VT_SENLAT, 8) &&
           VerifyField<double>(verifier, VT_SENLON, 8) &&
           VerifyField<double>(verifier, VT_SENALT, 8) &&
           VerifyField<double>(verifier, VT_SEN2LAT, 8) &&
           VerifyField<double>(verifier, VT_SEN2LON, 8) &&
           VerifyField<double>(verifier, VT_SEN2ALT, 8) &&
           VerifyField<double>(verifier, VT_FREQUENCY, 8) &&
           VerifyField<double>(verifier, VT_BANDWIDTH, 8) &&
           VerifyField<double>(verifier, VT_DELTARANGE, 8) &&
           VerifyField<double>(verifier, VT_DELTARANGEUNC, 8) &&
           VerifyField<double>(verifier, VT_DELTARANGERATE, 8) &&
           VerifyField<double>(verifier, VT_DELTARANGERATEUNC, 8) &&
           VerifyField<double>(verifier, VT_SNR, 8) &&
           VerifyField<double>(verifier, VT_TDOA, 8) &&
           VerifyField<double>(verifier, VT_TDOAUNC, 8) &&
           VerifyField<double>(verifier, VT_FDOA, 8) &&
           VerifyField<double>(verifier, VT_FDOAUNC, 8) &&
           VerifyOffset(verifier, VT_COLLECTIONMODE) &&
           verifier.VerifyString(collectionMode()) &&
           VerifyOffset(verifier, VT_RAWFILEURI) &&
           verifier.VerifyString(rawFileURI()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_ONORBIT) &&
           verifier.VerifyString(onOrbit()) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(descriptor()) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           verifier.EndTable();
  }
};

struct DiffOfArrival_FullBuilder {
  typedef DiffOfArrival_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_obTime(::flatbuffers::Offset<::flatbuffers::String> obTime) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_OBTIME, obTime);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_IDONORBIT, idOnOrbit);
  }
  void add_idSensor1(::flatbuffers::Offset<::flatbuffers::String> idSensor1) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_IDSENSOR1, idSensor1);
  }
  void add_idSensor2(::flatbuffers::Offset<::flatbuffers::String> idSensor2) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_IDSENSOR2, idSensor2);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(DiffOfArrival_Full::VT_SATNO, satNo, 0);
  }
  void add_taskId(::flatbuffers::Offset<::flatbuffers::String> taskId) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_TASKID, taskId);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ORIGOBJECTID, origObjectId);
  }
  void add_origSensorId1(::flatbuffers::Offset<::flatbuffers::String> origSensorId1) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ORIGSENSORID1, origSensorId1);
  }
  void add_origSensorId2(::flatbuffers::Offset<::flatbuffers::String> origSensorId2) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ORIGSENSORID2, origSensorId2);
  }
  void add_uct(bool uct) {
    fbb_.AddElement<uint8_t>(DiffOfArrival_Full::VT_UCT, static_cast<uint8_t>(uct), 0);
  }
  void add_sensor1Delay(double sensor1Delay) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SENSOR1DELAY, sensor1Delay, 0.0);
  }
  void add_sensor2Delay(double sensor2Delay) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SENSOR2DELAY, sensor2Delay, 0.0);
  }
  void add_senlat(double senlat) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SENLAT, senlat, 0.0);
  }
  void add_senlon(double senlon) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SENLON, senlon, 0.0);
  }
  void add_senalt(double senalt) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SENALT, senalt, 0.0);
  }
  void add_sen2lat(double sen2lat) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SEN2LAT, sen2lat, 0.0);
  }
  void add_sen2lon(double sen2lon) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SEN2LON, sen2lon, 0.0);
  }
  void add_sen2alt(double sen2alt) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SEN2ALT, sen2alt, 0.0);
  }
  void add_frequency(double frequency) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_FREQUENCY, frequency, 0.0);
  }
  void add_bandwidth(double bandwidth) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_BANDWIDTH, bandwidth, 0.0);
  }
  void add_deltaRange(double deltaRange) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_DELTARANGE, deltaRange, 0.0);
  }
  void add_deltaRangeUnc(double deltaRangeUnc) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_DELTARANGEUNC, deltaRangeUnc, 0.0);
  }
  void add_deltaRangeRate(double deltaRangeRate) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_DELTARANGERATE, deltaRangeRate, 0.0);
  }
  void add_deltaRangeRateUnc(double deltaRangeRateUnc) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_DELTARANGERATEUNC, deltaRangeRateUnc, 0.0);
  }
  void add_snr(double snr) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_SNR, snr, 0.0);
  }
  void add_tdoa(double tdoa) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_TDOA, tdoa, 0.0);
  }
  void add_tdoaUnc(double tdoaUnc) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_TDOAUNC, tdoaUnc, 0.0);
  }
  void add_fdoa(double fdoa) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_FDOA, fdoa, 0.0);
  }
  void add_fdoaUnc(double fdoaUnc) {
    fbb_.AddElement<double>(DiffOfArrival_Full::VT_FDOAUNC, fdoaUnc, 0.0);
  }
  void add_collectionMode(::flatbuffers::Offset<::flatbuffers::String> collectionMode) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_COLLECTIONMODE, collectionMode);
  }
  void add_rawFileURI(::flatbuffers::Offset<::flatbuffers::String> rawFileURI) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_RAWFILEURI, rawFileURI);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_SOURCE, source);
  }
  void add_dataMode(DiffOfArrival_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(DiffOfArrival_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_TAGS, tags);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ORIGIN, origin);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_CREATEDBY, createdBy);
  }
  void add_onOrbit(::flatbuffers::Offset<::flatbuffers::String> onOrbit) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ONORBIT, onOrbit);
  }
  void add_descriptor(::flatbuffers::Offset<::flatbuffers::String> descriptor) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_DESCRIPTOR, descriptor);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_TRANSACTIONID, transactionId);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(DiffOfArrival_Full::VT_SOURCEDL, sourceDL);
  }
  explicit DiffOfArrival_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DiffOfArrival_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DiffOfArrival_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DiffOfArrival_Full> CreateDiffOfArrival_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor2 = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId1 = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId2 = 0,
    bool uct = false,
    double sensor1Delay = 0.0,
    double sensor2Delay = 0.0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double sen2lat = 0.0,
    double sen2lon = 0.0,
    double sen2alt = 0.0,
    double frequency = 0.0,
    double bandwidth = 0.0,
    double deltaRange = 0.0,
    double deltaRangeUnc = 0.0,
    double deltaRangeRate = 0.0,
    double deltaRangeRateUnc = 0.0,
    double snr = 0.0,
    double tdoa = 0.0,
    double tdoaUnc = 0.0,
    double fdoa = 0.0,
    double fdoaUnc = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionMode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rawFileURI = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    DiffOfArrival_Full_dataMode_Enum dataMode = DiffOfArrival_Full_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> onOrbit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> descriptor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0) {
  DiffOfArrival_FullBuilder builder_(_fbb);
  builder_.add_fdoaUnc(fdoaUnc);
  builder_.add_fdoa(fdoa);
  builder_.add_tdoaUnc(tdoaUnc);
  builder_.add_tdoa(tdoa);
  builder_.add_snr(snr);
  builder_.add_deltaRangeRateUnc(deltaRangeRateUnc);
  builder_.add_deltaRangeRate(deltaRangeRate);
  builder_.add_deltaRangeUnc(deltaRangeUnc);
  builder_.add_deltaRange(deltaRange);
  builder_.add_bandwidth(bandwidth);
  builder_.add_frequency(frequency);
  builder_.add_sen2alt(sen2alt);
  builder_.add_sen2lon(sen2lon);
  builder_.add_sen2lat(sen2lat);
  builder_.add_senalt(senalt);
  builder_.add_senlon(senlon);
  builder_.add_senlat(senlat);
  builder_.add_sensor2Delay(sensor2Delay);
  builder_.add_sensor1Delay(sensor1Delay);
  builder_.add_sourceDL(sourceDL);
  builder_.add_origNetwork(origNetwork);
  builder_.add_transactionId(transactionId);
  builder_.add_descriptor(descriptor);
  builder_.add_onOrbit(onOrbit);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origin(origin);
  builder_.add_tags(tags);
  builder_.add_source(source);
  builder_.add_rawFileURI(rawFileURI);
  builder_.add_collectionMode(collectionMode);
  builder_.add_origSensorId2(origSensorId2);
  builder_.add_origSensorId1(origSensorId1);
  builder_.add_origObjectId(origObjectId);
  builder_.add_taskId(taskId);
  builder_.add_satNo(satNo);
  builder_.add_idSensor2(idSensor2);
  builder_.add_idSensor1(idSensor1);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_obTime(obTime);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_uct(uct);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DiffOfArrival_Full> CreateDiffOfArrival_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *obTime = nullptr,
    const char *idOnOrbit = nullptr,
    const char *idSensor1 = nullptr,
    const char *idSensor2 = nullptr,
    int32_t satNo = 0,
    const char *taskId = nullptr,
    const char *origObjectId = nullptr,
    const char *origSensorId1 = nullptr,
    const char *origSensorId2 = nullptr,
    bool uct = false,
    double sensor1Delay = 0.0,
    double sensor2Delay = 0.0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double sen2lat = 0.0,
    double sen2lon = 0.0,
    double sen2alt = 0.0,
    double frequency = 0.0,
    double bandwidth = 0.0,
    double deltaRange = 0.0,
    double deltaRangeUnc = 0.0,
    double deltaRangeRate = 0.0,
    double deltaRangeRateUnc = 0.0,
    double snr = 0.0,
    double tdoa = 0.0,
    double tdoaUnc = 0.0,
    double fdoa = 0.0,
    double fdoaUnc = 0.0,
    const char *collectionMode = nullptr,
    const char *rawFileURI = nullptr,
    const char *source = nullptr,
    DiffOfArrival_Full_dataMode_Enum dataMode = DiffOfArrival_Full_dataMode_Enum_REAL,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr,
    const char *origin = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *onOrbit = nullptr,
    const char *descriptor = nullptr,
    const char *transactionId = nullptr,
    const char *origNetwork = nullptr,
    const char *sourceDL = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto obTime__ = obTime ? _fbb.CreateString(obTime) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto idSensor1__ = idSensor1 ? _fbb.CreateString(idSensor1) : 0;
  auto idSensor2__ = idSensor2 ? _fbb.CreateString(idSensor2) : 0;
  auto taskId__ = taskId ? _fbb.CreateString(taskId) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto origSensorId1__ = origSensorId1 ? _fbb.CreateString(origSensorId1) : 0;
  auto origSensorId2__ = origSensorId2 ? _fbb.CreateString(origSensorId2) : 0;
  auto collectionMode__ = collectionMode ? _fbb.CreateString(collectionMode) : 0;
  auto rawFileURI__ = rawFileURI ? _fbb.CreateString(rawFileURI) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto onOrbit__ = onOrbit ? _fbb.CreateString(onOrbit) : 0;
  auto descriptor__ = descriptor ? _fbb.CreateString(descriptor) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  return CreateDiffOfArrival_Full(
      _fbb,
      id__,
      classificationMarking__,
      obTime__,
      idOnOrbit__,
      idSensor1__,
      idSensor2__,
      satNo,
      taskId__,
      origObjectId__,
      origSensorId1__,
      origSensorId2__,
      uct,
      sensor1Delay,
      sensor2Delay,
      senlat,
      senlon,
      senalt,
      sen2lat,
      sen2lon,
      sen2alt,
      frequency,
      bandwidth,
      deltaRange,
      deltaRangeUnc,
      deltaRangeRate,
      deltaRangeRateUnc,
      snr,
      tdoa,
      tdoaUnc,
      fdoa,
      fdoaUnc,
      collectionMode__,
      rawFileURI__,
      source__,
      dataMode,
      tags__,
      origin__,
      createdAt__,
      createdBy__,
      onOrbit__,
      descriptor__,
      transactionId__,
      origNetwork__,
      sourceDL__);
}

inline const DiffOfArrival_Full *GetDiffOfArrival_Full(const void *buf) {
  return ::flatbuffers::GetRoot<DiffOfArrival_Full>(buf);
}

inline const DiffOfArrival_Full *GetSizePrefixedDiffOfArrival_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DiffOfArrival_Full>(buf);
}

inline const char *DiffOfArrival_FullIdentifier() {
  return "DIFF";
}

inline bool DiffOfArrival_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DiffOfArrival_FullIdentifier());
}

inline bool SizePrefixedDiffOfArrival_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DiffOfArrival_FullIdentifier(), true);
}

inline bool VerifyDiffOfArrival_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DiffOfArrival_Full>(DiffOfArrival_FullIdentifier());
}

inline bool VerifySizePrefixedDiffOfArrival_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DiffOfArrival_Full>(DiffOfArrival_FullIdentifier());
}

inline void FinishDiffOfArrival_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DiffOfArrival_Full> root) {
  fbb.Finish(root, DiffOfArrival_FullIdentifier());
}

inline void FinishSizePrefixedDiffOfArrival_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DiffOfArrival_Full> root) {
  fbb.FinishSizePrefixed(root, DiffOfArrival_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
