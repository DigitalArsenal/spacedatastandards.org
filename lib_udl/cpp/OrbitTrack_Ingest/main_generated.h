// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct OrbitTrack_Ingest;
struct OrbitTrack_IngestBuilder;

enum OrbitTrack_Ingest_objIdent_Enum : int8_t {
  /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  OrbitTrack_Ingest_objIdent_Enum_ASSUMED_FRIEND = 0,
  /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  OrbitTrack_Ingest_objIdent_Enum_FRIEND = 1,
  /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  OrbitTrack_Ingest_objIdent_Enum_HOSTILE = 2,
  /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  OrbitTrack_Ingest_objIdent_Enum_NEUTRAL = 3,
  /// Track object which has not been evaluated.
  OrbitTrack_Ingest_objIdent_Enum_PENDING = 4,
  /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  OrbitTrack_Ingest_objIdent_Enum_SUSPECT = 5,
  /// Track object which has been evaluated and does not meet criteria for any standard identity.
  OrbitTrack_Ingest_objIdent_Enum_UNKNOWN = 6,
  OrbitTrack_Ingest_objIdent_Enum_MIN = OrbitTrack_Ingest_objIdent_Enum_ASSUMED_FRIEND,
  OrbitTrack_Ingest_objIdent_Enum_MAX = OrbitTrack_Ingest_objIdent_Enum_UNKNOWN
};

inline const OrbitTrack_Ingest_objIdent_Enum (&EnumValuesOrbitTrack_Ingest_objIdent_Enum())[7] {
  static const OrbitTrack_Ingest_objIdent_Enum values[] = {
    OrbitTrack_Ingest_objIdent_Enum_ASSUMED_FRIEND,
    OrbitTrack_Ingest_objIdent_Enum_FRIEND,
    OrbitTrack_Ingest_objIdent_Enum_HOSTILE,
    OrbitTrack_Ingest_objIdent_Enum_NEUTRAL,
    OrbitTrack_Ingest_objIdent_Enum_PENDING,
    OrbitTrack_Ingest_objIdent_Enum_SUSPECT,
    OrbitTrack_Ingest_objIdent_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesOrbitTrack_Ingest_objIdent_Enum() {
  static const char * const names[8] = {
    "ASSUMED_FRIEND",
    "FRIEND",
    "HOSTILE",
    "NEUTRAL",
    "PENDING",
    "SUSPECT",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrbitTrack_Ingest_objIdent_Enum(OrbitTrack_Ingest_objIdent_Enum e) {
  if (::flatbuffers::IsOutRange(e, OrbitTrack_Ingest_objIdent_Enum_ASSUMED_FRIEND, OrbitTrack_Ingest_objIdent_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrbitTrack_Ingest_objIdent_Enum()[index];
}

enum OrbitTrack_Ingest_objectType_Enum : int8_t {
  /// No description available.
  OrbitTrack_Ingest_objectType_Enum_DEBRIS = 0,
  /// No description available.
  OrbitTrack_Ingest_objectType_Enum_MANNED = 1,
  /// No description available.
  OrbitTrack_Ingest_objectType_Enum_PAYLOAD = 2,
  /// No description available.
  OrbitTrack_Ingest_objectType_Enum_PLATFORM = 3,
  /// No description available.
  OrbitTrack_Ingest_objectType_Enum_ROCKET_BODY = 4,
  /// No description available.
  OrbitTrack_Ingest_objectType_Enum_UNKNOWN = 5,
  OrbitTrack_Ingest_objectType_Enum_MIN = OrbitTrack_Ingest_objectType_Enum_DEBRIS,
  OrbitTrack_Ingest_objectType_Enum_MAX = OrbitTrack_Ingest_objectType_Enum_UNKNOWN
};

inline const OrbitTrack_Ingest_objectType_Enum (&EnumValuesOrbitTrack_Ingest_objectType_Enum())[6] {
  static const OrbitTrack_Ingest_objectType_Enum values[] = {
    OrbitTrack_Ingest_objectType_Enum_DEBRIS,
    OrbitTrack_Ingest_objectType_Enum_MANNED,
    OrbitTrack_Ingest_objectType_Enum_PAYLOAD,
    OrbitTrack_Ingest_objectType_Enum_PLATFORM,
    OrbitTrack_Ingest_objectType_Enum_ROCKET_BODY,
    OrbitTrack_Ingest_objectType_Enum_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesOrbitTrack_Ingest_objectType_Enum() {
  static const char * const names[7] = {
    "DEBRIS",
    "MANNED",
    "PAYLOAD",
    "PLATFORM",
    "ROCKET_BODY",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrbitTrack_Ingest_objectType_Enum(OrbitTrack_Ingest_objectType_Enum e) {
  if (::flatbuffers::IsOutRange(e, OrbitTrack_Ingest_objectType_Enum_DEBRIS, OrbitTrack_Ingest_objectType_Enum_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrbitTrack_Ingest_objectType_Enum()[index];
}

enum OrbitTrack_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  OrbitTrack_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  OrbitTrack_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  OrbitTrack_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  OrbitTrack_Ingest_dataMode_Enum_EXERCISE = 3,
  OrbitTrack_Ingest_dataMode_Enum_MIN = OrbitTrack_Ingest_dataMode_Enum_REAL,
  OrbitTrack_Ingest_dataMode_Enum_MAX = OrbitTrack_Ingest_dataMode_Enum_EXERCISE
};

inline const OrbitTrack_Ingest_dataMode_Enum (&EnumValuesOrbitTrack_Ingest_dataMode_Enum())[4] {
  static const OrbitTrack_Ingest_dataMode_Enum values[] = {
    OrbitTrack_Ingest_dataMode_Enum_REAL,
    OrbitTrack_Ingest_dataMode_Enum_TEST,
    OrbitTrack_Ingest_dataMode_Enum_SIMULATED,
    OrbitTrack_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesOrbitTrack_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameOrbitTrack_Ingest_dataMode_Enum(OrbitTrack_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, OrbitTrack_Ingest_dataMode_Enum_REAL, OrbitTrack_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOrbitTrack_Ingest_dataMode_Enum()[index];
}

/// /// Keplerian orbital elements describing an orbit for a particular on-orbit satellite and applicable sensor data aiding in the orbit prediction.
struct OrbitTrack_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OrbitTrack_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDONORBIT = 8,
    VT_SATNO = 10,
    VT_ORIGOBJECTID = 12,
    VT_IDELSET = 14,
    VT_TS = 16,
    VT_LAT = 18,
    VT_LON = 20,
    VT_ALT = 22,
    VT_RDFRF = 24,
    VT_CALLSIGN = 26,
    VT_RPTNUM = 28,
    VT_OBJIDENT = 30,
    VT_IDENTAMP = 32,
    VT_SATSTATUS = 34,
    VT_OBJECTTYPE = 36,
    VT_COUNTRYCODE = 38,
    VT_DECAY = 40,
    VT_CHARLIELINE = 42,
    VT_AOUTYPE = 44,
    VT_AOUDATA = 46,
    VT_SPD = 48,
    VT_ANGELEV = 50,
    VT_CNTNMNT = 52,
    VT_XREF = 54,
    VT_CHXREF = 56,
    VT_AMPLIFICATION = 58,
    VT_IFF = 60,
    VT_REINFORCED = 62,
    VT_REDUCED = 64,
    VT_HQ = 66,
    VT_DUMMY = 68,
    VT_TASKFORCE = 70,
    VT_FEINT = 72,
    VT_INSTALLATION = 74,
    VT_VEHTYPE = 76,
    VT_TRKID = 78,
    VT_TRACKSENSORS = 80,
    VT_CREATEDAT = 82,
    VT_CREATEDBY = 84,
    VT_SOURCE = 86,
    VT_ORIGIN = 88,
    VT_DATAMODE = 90,
    VT_ORIGNETWORK = 92
  };
  /// Unique identifier of the record, auto-generated by the system if not provided on create operations.
  /// Example: /// Example: ORBIT_TRACK_ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: 32375
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Satellite/catalog number of the target on-orbit object.
  /// Example: /// Example: 37375
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier provided by observation source to indicate the target on-orbit object of this track. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: L2045
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Unique identifier of the Elset associated with this object.
  /// Example: /// Example: c715a619-8695-44d2-9e7d-effd257b4843
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idElset() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDELSET);
  }
  /// Track timestamp in ISO8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *ts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  /// WGS-84 latitude of the track object subpoint, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 19.88550102
  /// Constraints: No constraints specified.
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  /// WGS-84 longitude of the track object subpoint, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 46.74596844
  /// Constraints: No constraints specified.
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  /// Track point altitude relative to WGS-84 ellipsoid, in meters.
  /// Example: /// Example: 585.71
  /// Constraints: No constraints specified.
  double alt() const {
    return GetField<double>(VT_ALT, 0.0);
  }
  /// Radio frequency of the track, measured in megahertz (MHz).
  /// Example: /// Example: 1.5273
  /// Constraints: No constraints specified.
  double rdfRF() const {
    return GetField<double>(VT_RDFRF, 0.0);
  }
  /// International radio call sign assigned to the track. This is an 8-character alphanumeric code.
  /// Example: /// Example: Charlie
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *callSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  /// Report number received from the reporting source for this track.
  /// Example: /// Example: 123
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *rptNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RPTNUM);
  }
  /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
  ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
  ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
  ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
  ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
  ///  PENDING: Track object which has not been evaluated.
  ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
  ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
  /// Example: /// Example: FRIEND
  /// Constraints: Minimum length = 0, Maximum length = 32
  OrbitTrack_Ingest_objIdent_Enum objIdent() const {
    return static_cast<OrbitTrack_Ingest_objIdent_Enum>(GetField<int8_t>(VT_OBJIDENT, 0));
  }
  /// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
  ///  FAKER: Friendly track, object, or entity acting as an exercise hostile.
  ///  JOKER: Friendly track, object, or entity acting as an exercise suspect.
  ///  KILO: Friendly high-value object.
  ///  TRAVELLER: Suspect land or surface track following a recognized traffic route.
  ///  ZOMBIE: Suspect track, object, or entity of special interest.
  /// Example: /// Example: JOKER
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *identAmp() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTAMP);
  }
  /// Status of the satellite.
  /// Example: /// Example: INACTIVE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *satStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SATSTATUS);
  }
  /// The on-orbit category assigned to this track object (DEBRIS, MANNED, PAYLOAD, PLATFORM, ROCKET BODY, UNKNOWN).
  /// Example: /// Example: PAYLOAD
  /// Constraints: Minimum length = 0, Maximum length = 32
  OrbitTrack_Ingest_objectType_Enum objectType() const {
    return static_cast<OrbitTrack_Ingest_objectType_Enum>(GetField<int8_t>(VT_OBJECTTYPE, 0));
  }
  /// The country code. This value is typically the ISO 3166 Alpha-2 two-character country code, however it can also represent various consortiums that do not appear in the ISO document. The code must correspond to an existing country in the UDL’s country API. Call udl/country/{code} to get any associated FIPS code, ISO Alpha-3 code, or alternate code values that exist for the specified country code.
  /// Example: /// Example: US
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *countryCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COUNTRYCODE);
  }
  /// Predicted change in Mean Motion (velocity) in radians/herg^2.  herg is a unit of time measure equal to 806.8120769 seconds, and is the orbital period of an imaginary satellite rotating about the Earth at zero altitude.
  /// Example: /// Example: 0.5868
  /// Constraints: No constraints specified.
  double decay() const {
    return GetField<double>(VT_DECAY, 0.0);
  }
  /// One-line Charlie elements set.
  /// Example: /// Example: 323751332255940400010000003635829600010200072500098205001150
  /// Constraints: Minimum length = 0, Maximum length = 100
  const ::flatbuffers::String *charlieLine() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHARLIELINE);
  }
  /// The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouData array and is required if aouData is not null. See the aouData field definition for specific information.
  /// Example: /// Example: ELLIPSE
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *aouType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AOUTYPE);
  }
  /// Three element array representing an Area of Uncertainty (AoU).  The array element definitions and units are type specific depending on the aouType specified in this record:
  /// ELLIPSE:
  ///    brg - orientation in degrees of the ellipse
  ///    a1 - semi-major axis in meters
  ///    a2 - semi-minor axis in meters
  /// BEARING (BEARING BOX or MTST BEARING BOX):
  ///    brg - orientation in degrees of the bearing box 
  ///    a1 - length of bearing box in meters 
  ///    a2 - half-width of bearing box in meters 
  /// OTHER (All other type values):
  ///    brg - line of bearing in degrees true 
  ///    a1 - bearing error in degrees 
  ///    a2 - estimated range in meters.
  /// Example: /// Example: [34.3, 26.5, 1.2]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *aouData() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_AOUDATA);
  }
  /// Track object speed, in km/sec.
  /// Example: /// Example: 15.03443
  /// Constraints: No constraints specified.
  double spd() const {
    return GetField<double>(VT_SPD, 0.0);
  }
  /// The angle formed between the line of sight of the observer and the horizon at track timestamp, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
  /// Example: /// Example: 15.2
  /// Constraints: No constraints specified.
  double angElev() const {
    return GetField<double>(VT_ANGELEV, 0.0);
  }
  /// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
  /// Example: /// Example: 90
  /// Constraints: No constraints specified.
  double cntnmnt() const {
    return GetField<double>(VT_CNTNMNT, 0.0);
  }
  /// Source cross-reference code for the command that originated the track report.
  /// Example: /// Example: XE
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *xref() const {
    return GetPointer<const ::flatbuffers::String *>(VT_XREF);
  }
  /// The cross-reference code of the channel on which this track report was received, if the report came over a comms channel.
  /// Example: /// Example: FHKX
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *chXRef() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CHXREF);
  }
  /// Free-form remarks entered for the satellite.
  /// Example: /// Example: A note regarding this spacecraft
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *amplification() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AMPLIFICATION);
  }
  /// A text aplifier displaying IFF/SIF/AIS Identification modes and codes.
  /// Example: /// Example: ID Mode
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *iff() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IFF);
  }
  /// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool reinforced() const {
    return GetField<uint8_t>(VT_REINFORCED, 0) != 0;
  }
  /// Flag indicating that this track represents a reduced object or group.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool reduced() const {
    return GetField<uint8_t>(VT_REDUCED, 0) != 0;
  }
  /// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool hq() const {
    return GetField<uint8_t>(VT_HQ, 0) != 0;
  }
  /// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool dummy() const {
    return GetField<uint8_t>(VT_DUMMY, 0) != 0;
  }
  /// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool taskForce() const {
    return GetField<uint8_t>(VT_TASKFORCE, 0) != 0;
  }
  /// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool feint() const {
    return GetField<uint8_t>(VT_FEINT, 0) != 0;
  }
  /// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool installation() const {
    return GetField<uint8_t>(VT_INSTALLATION, 0) != 0;
  }
  /// The type of vehicle with which the device is associated.  Based on MIL-STD-2525 symbology definitions.
  /// Example: /// Example: SPACE
  /// Constraints: Minimum length = 0, Maximum length = 10
  const ::flatbuffers::String *vehType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VEHTYPE);
  }
  /// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
  /// Example: /// Example: 3668f135-fcba-4630-a43d-e7782e11d988
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *trkId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRKID);
  }
  /// TrackSensor Collection.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *trackSensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TRACKSENSORS);
  }
  /// Time the row was created in the database.
  /// Example: /// Example: 2021-02-25T12:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  OrbitTrack_Ingest_dataMode_Enum dataMode() const {
    return static_cast<OrbitTrack_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_IDELSET) &&
           verifier.VerifyString(idElset()) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(ts()) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<double>(verifier, VT_ALT, 8) &&
           VerifyField<double>(verifier, VT_RDFRF, 8) &&
           VerifyOffset(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callSign()) &&
           VerifyOffset(verifier, VT_RPTNUM) &&
           verifier.VerifyString(rptNum()) &&
           VerifyField<int8_t>(verifier, VT_OBJIDENT, 1) &&
           VerifyOffset(verifier, VT_IDENTAMP) &&
           verifier.VerifyString(identAmp()) &&
           VerifyOffset(verifier, VT_SATSTATUS) &&
           verifier.VerifyString(satStatus()) &&
           VerifyField<int8_t>(verifier, VT_OBJECTTYPE, 1) &&
           VerifyOffset(verifier, VT_COUNTRYCODE) &&
           verifier.VerifyString(countryCode()) &&
           VerifyField<double>(verifier, VT_DECAY, 8) &&
           VerifyOffset(verifier, VT_CHARLIELINE) &&
           verifier.VerifyString(charlieLine()) &&
           VerifyOffset(verifier, VT_AOUTYPE) &&
           verifier.VerifyString(aouType()) &&
           VerifyOffset(verifier, VT_AOUDATA) &&
           verifier.VerifyVector(aouData()) &&
           verifier.VerifyVectorOfStrings(aouData()) &&
           VerifyField<double>(verifier, VT_SPD, 8) &&
           VerifyField<double>(verifier, VT_ANGELEV, 8) &&
           VerifyField<double>(verifier, VT_CNTNMNT, 8) &&
           VerifyOffset(verifier, VT_XREF) &&
           verifier.VerifyString(xref()) &&
           VerifyOffset(verifier, VT_CHXREF) &&
           verifier.VerifyString(chXRef()) &&
           VerifyOffset(verifier, VT_AMPLIFICATION) &&
           verifier.VerifyString(amplification()) &&
           VerifyOffset(verifier, VT_IFF) &&
           verifier.VerifyString(iff()) &&
           VerifyField<uint8_t>(verifier, VT_REINFORCED, 1) &&
           VerifyField<uint8_t>(verifier, VT_REDUCED, 1) &&
           VerifyField<uint8_t>(verifier, VT_HQ, 1) &&
           VerifyField<uint8_t>(verifier, VT_DUMMY, 1) &&
           VerifyField<uint8_t>(verifier, VT_TASKFORCE, 1) &&
           VerifyField<uint8_t>(verifier, VT_FEINT, 1) &&
           VerifyField<uint8_t>(verifier, VT_INSTALLATION, 1) &&
           VerifyOffset(verifier, VT_VEHTYPE) &&
           verifier.VerifyString(vehType()) &&
           VerifyOffset(verifier, VT_TRKID) &&
           verifier.VerifyString(trkId()) &&
           VerifyOffset(verifier, VT_TRACKSENSORS) &&
           verifier.VerifyVector(trackSensors()) &&
           verifier.VerifyVectorOfStrings(trackSensors()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct OrbitTrack_IngestBuilder {
  typedef OrbitTrack_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_IDONORBIT, idOnOrbit);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(OrbitTrack_Ingest::VT_SATNO, satNo, 0);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_ORIGOBJECTID, origObjectId);
  }
  void add_idElset(::flatbuffers::Offset<::flatbuffers::String> idElset) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_IDELSET, idElset);
  }
  void add_ts(::flatbuffers::Offset<::flatbuffers::String> ts) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_TS, ts);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_LON, lon, 0.0);
  }
  void add_alt(double alt) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_ALT, alt, 0.0);
  }
  void add_rdfRF(double rdfRF) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_RDFRF, rdfRF, 0.0);
  }
  void add_callSign(::flatbuffers::Offset<::flatbuffers::String> callSign) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_CALLSIGN, callSign);
  }
  void add_rptNum(::flatbuffers::Offset<::flatbuffers::String> rptNum) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_RPTNUM, rptNum);
  }
  void add_objIdent(OrbitTrack_Ingest_objIdent_Enum objIdent) {
    fbb_.AddElement<int8_t>(OrbitTrack_Ingest::VT_OBJIDENT, static_cast<int8_t>(objIdent), 0);
  }
  void add_identAmp(::flatbuffers::Offset<::flatbuffers::String> identAmp) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_IDENTAMP, identAmp);
  }
  void add_satStatus(::flatbuffers::Offset<::flatbuffers::String> satStatus) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_SATSTATUS, satStatus);
  }
  void add_objectType(OrbitTrack_Ingest_objectType_Enum objectType) {
    fbb_.AddElement<int8_t>(OrbitTrack_Ingest::VT_OBJECTTYPE, static_cast<int8_t>(objectType), 0);
  }
  void add_countryCode(::flatbuffers::Offset<::flatbuffers::String> countryCode) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_COUNTRYCODE, countryCode);
  }
  void add_decay(double decay) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_DECAY, decay, 0.0);
  }
  void add_charlieLine(::flatbuffers::Offset<::flatbuffers::String> charlieLine) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_CHARLIELINE, charlieLine);
  }
  void add_aouType(::flatbuffers::Offset<::flatbuffers::String> aouType) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_AOUTYPE, aouType);
  }
  void add_aouData(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aouData) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_AOUDATA, aouData);
  }
  void add_spd(double spd) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_SPD, spd, 0.0);
  }
  void add_angElev(double angElev) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_ANGELEV, angElev, 0.0);
  }
  void add_cntnmnt(double cntnmnt) {
    fbb_.AddElement<double>(OrbitTrack_Ingest::VT_CNTNMNT, cntnmnt, 0.0);
  }
  void add_xref(::flatbuffers::Offset<::flatbuffers::String> xref) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_XREF, xref);
  }
  void add_chXRef(::flatbuffers::Offset<::flatbuffers::String> chXRef) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_CHXREF, chXRef);
  }
  void add_amplification(::flatbuffers::Offset<::flatbuffers::String> amplification) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_AMPLIFICATION, amplification);
  }
  void add_iff(::flatbuffers::Offset<::flatbuffers::String> iff) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_IFF, iff);
  }
  void add_reinforced(bool reinforced) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_REINFORCED, static_cast<uint8_t>(reinforced), 0);
  }
  void add_reduced(bool reduced) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_REDUCED, static_cast<uint8_t>(reduced), 0);
  }
  void add_hq(bool hq) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_HQ, static_cast<uint8_t>(hq), 0);
  }
  void add_dummy(bool dummy) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_DUMMY, static_cast<uint8_t>(dummy), 0);
  }
  void add_taskForce(bool taskForce) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_TASKFORCE, static_cast<uint8_t>(taskForce), 0);
  }
  void add_feint(bool feint) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_FEINT, static_cast<uint8_t>(feint), 0);
  }
  void add_installation(bool installation) {
    fbb_.AddElement<uint8_t>(OrbitTrack_Ingest::VT_INSTALLATION, static_cast<uint8_t>(installation), 0);
  }
  void add_vehType(::flatbuffers::Offset<::flatbuffers::String> vehType) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_VEHTYPE, vehType);
  }
  void add_trkId(::flatbuffers::Offset<::flatbuffers::String> trkId) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_TRKID, trkId);
  }
  void add_trackSensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> trackSensors) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_TRACKSENSORS, trackSensors);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_ORIGIN, origin);
  }
  void add_dataMode(OrbitTrack_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(OrbitTrack_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(OrbitTrack_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  explicit OrbitTrack_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OrbitTrack_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OrbitTrack_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OrbitTrack_Ingest> CreateOrbitTrack_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idElset = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ts = 0,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0,
    double rdfRF = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> callSign = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rptNum = 0,
    OrbitTrack_Ingest_objIdent_Enum objIdent = OrbitTrack_Ingest_objIdent_Enum_ASSUMED_FRIEND,
    ::flatbuffers::Offset<::flatbuffers::String> identAmp = 0,
    ::flatbuffers::Offset<::flatbuffers::String> satStatus = 0,
    OrbitTrack_Ingest_objectType_Enum objectType = OrbitTrack_Ingest_objectType_Enum_DEBRIS,
    ::flatbuffers::Offset<::flatbuffers::String> countryCode = 0,
    double decay = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> charlieLine = 0,
    ::flatbuffers::Offset<::flatbuffers::String> aouType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aouData = 0,
    double spd = 0.0,
    double angElev = 0.0,
    double cntnmnt = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> xref = 0,
    ::flatbuffers::Offset<::flatbuffers::String> chXRef = 0,
    ::flatbuffers::Offset<::flatbuffers::String> amplification = 0,
    ::flatbuffers::Offset<::flatbuffers::String> iff = 0,
    bool reinforced = false,
    bool reduced = false,
    bool hq = false,
    bool dummy = false,
    bool taskForce = false,
    bool feint = false,
    bool installation = false,
    ::flatbuffers::Offset<::flatbuffers::String> vehType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trkId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> trackSensors = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    OrbitTrack_Ingest_dataMode_Enum dataMode = OrbitTrack_Ingest_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  OrbitTrack_IngestBuilder builder_(_fbb);
  builder_.add_cntnmnt(cntnmnt);
  builder_.add_angElev(angElev);
  builder_.add_spd(spd);
  builder_.add_decay(decay);
  builder_.add_rdfRF(rdfRF);
  builder_.add_alt(alt);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_trackSensors(trackSensors);
  builder_.add_trkId(trkId);
  builder_.add_vehType(vehType);
  builder_.add_iff(iff);
  builder_.add_amplification(amplification);
  builder_.add_chXRef(chXRef);
  builder_.add_xref(xref);
  builder_.add_aouData(aouData);
  builder_.add_aouType(aouType);
  builder_.add_charlieLine(charlieLine);
  builder_.add_countryCode(countryCode);
  builder_.add_satStatus(satStatus);
  builder_.add_identAmp(identAmp);
  builder_.add_rptNum(rptNum);
  builder_.add_callSign(callSign);
  builder_.add_ts(ts);
  builder_.add_idElset(idElset);
  builder_.add_origObjectId(origObjectId);
  builder_.add_satNo(satNo);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_installation(installation);
  builder_.add_feint(feint);
  builder_.add_taskForce(taskForce);
  builder_.add_dummy(dummy);
  builder_.add_hq(hq);
  builder_.add_reduced(reduced);
  builder_.add_reinforced(reinforced);
  builder_.add_objectType(objectType);
  builder_.add_objIdent(objIdent);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OrbitTrack_Ingest> CreateOrbitTrack_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idOnOrbit = nullptr,
    int32_t satNo = 0,
    const char *origObjectId = nullptr,
    const char *idElset = nullptr,
    const char *ts = nullptr,
    double lat = 0.0,
    double lon = 0.0,
    double alt = 0.0,
    double rdfRF = 0.0,
    const char *callSign = nullptr,
    const char *rptNum = nullptr,
    OrbitTrack_Ingest_objIdent_Enum objIdent = OrbitTrack_Ingest_objIdent_Enum_ASSUMED_FRIEND,
    const char *identAmp = nullptr,
    const char *satStatus = nullptr,
    OrbitTrack_Ingest_objectType_Enum objectType = OrbitTrack_Ingest_objectType_Enum_DEBRIS,
    const char *countryCode = nullptr,
    double decay = 0.0,
    const char *charlieLine = nullptr,
    const char *aouType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *aouData = nullptr,
    double spd = 0.0,
    double angElev = 0.0,
    double cntnmnt = 0.0,
    const char *xref = nullptr,
    const char *chXRef = nullptr,
    const char *amplification = nullptr,
    const char *iff = nullptr,
    bool reinforced = false,
    bool reduced = false,
    bool hq = false,
    bool dummy = false,
    bool taskForce = false,
    bool feint = false,
    bool installation = false,
    const char *vehType = nullptr,
    const char *trkId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *trackSensors = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    OrbitTrack_Ingest_dataMode_Enum dataMode = OrbitTrack_Ingest_dataMode_Enum_REAL,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto idElset__ = idElset ? _fbb.CreateString(idElset) : 0;
  auto ts__ = ts ? _fbb.CreateString(ts) : 0;
  auto callSign__ = callSign ? _fbb.CreateString(callSign) : 0;
  auto rptNum__ = rptNum ? _fbb.CreateString(rptNum) : 0;
  auto identAmp__ = identAmp ? _fbb.CreateString(identAmp) : 0;
  auto satStatus__ = satStatus ? _fbb.CreateString(satStatus) : 0;
  auto countryCode__ = countryCode ? _fbb.CreateString(countryCode) : 0;
  auto charlieLine__ = charlieLine ? _fbb.CreateString(charlieLine) : 0;
  auto aouType__ = aouType ? _fbb.CreateString(aouType) : 0;
  auto aouData__ = aouData ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*aouData) : 0;
  auto xref__ = xref ? _fbb.CreateString(xref) : 0;
  auto chXRef__ = chXRef ? _fbb.CreateString(chXRef) : 0;
  auto amplification__ = amplification ? _fbb.CreateString(amplification) : 0;
  auto iff__ = iff ? _fbb.CreateString(iff) : 0;
  auto vehType__ = vehType ? _fbb.CreateString(vehType) : 0;
  auto trkId__ = trkId ? _fbb.CreateString(trkId) : 0;
  auto trackSensors__ = trackSensors ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*trackSensors) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateOrbitTrack_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      idOnOrbit__,
      satNo,
      origObjectId__,
      idElset__,
      ts__,
      lat,
      lon,
      alt,
      rdfRF,
      callSign__,
      rptNum__,
      objIdent,
      identAmp__,
      satStatus__,
      objectType,
      countryCode__,
      decay,
      charlieLine__,
      aouType__,
      aouData__,
      spd,
      angElev,
      cntnmnt,
      xref__,
      chXRef__,
      amplification__,
      iff__,
      reinforced,
      reduced,
      hq,
      dummy,
      taskForce,
      feint,
      installation,
      vehType__,
      trkId__,
      trackSensors__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      dataMode,
      origNetwork__);
}

inline const OrbitTrack_Ingest *GetOrbitTrack_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<OrbitTrack_Ingest>(buf);
}

inline const OrbitTrack_Ingest *GetSizePrefixedOrbitTrack_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<OrbitTrack_Ingest>(buf);
}

inline const char *OrbitTrack_IngestIdentifier() {
  return "ORBI";
}

inline bool OrbitTrack_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OrbitTrack_IngestIdentifier());
}

inline bool SizePrefixedOrbitTrack_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, OrbitTrack_IngestIdentifier(), true);
}

inline bool VerifyOrbitTrack_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<OrbitTrack_Ingest>(OrbitTrack_IngestIdentifier());
}

inline bool VerifySizePrefixedOrbitTrack_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<OrbitTrack_Ingest>(OrbitTrack_IngestIdentifier());
}

inline void FinishOrbitTrack_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OrbitTrack_Ingest> root) {
  fbb.Finish(root, OrbitTrack_IngestIdentifier());
}

inline void FinishSizePrefixedOrbitTrack_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<OrbitTrack_Ingest> root) {
  fbb.FinishSizePrefixed(root, OrbitTrack_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
