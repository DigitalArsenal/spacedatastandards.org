// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct ISRCollectionTaskings_Abridged;
struct ISRCollectionTaskings_AbridgedBuilder;

enum ISRCollectionTaskings_Abridged_type_Enum : int8_t {
  /// No description available.
  ISRCollectionTaskings_Abridged_type_Enum_DELIBERATE = 0,
  /// No description available.
  ISRCollectionTaskings_Abridged_type_Enum_DYNAMIC = 1,
  /// No description available.
  ISRCollectionTaskings_Abridged_type_Enum_TRAINING = 2,
  /// No description available.
  ISRCollectionTaskings_Abridged_type_Enum_TRANSIT = 3,
  ISRCollectionTaskings_Abridged_type_Enum_MIN = ISRCollectionTaskings_Abridged_type_Enum_DELIBERATE,
  ISRCollectionTaskings_Abridged_type_Enum_MAX = ISRCollectionTaskings_Abridged_type_Enum_TRANSIT
};

inline const ISRCollectionTaskings_Abridged_type_Enum (&EnumValuesISRCollectionTaskings_Abridged_type_Enum())[4] {
  static const ISRCollectionTaskings_Abridged_type_Enum values[] = {
    ISRCollectionTaskings_Abridged_type_Enum_DELIBERATE,
    ISRCollectionTaskings_Abridged_type_Enum_DYNAMIC,
    ISRCollectionTaskings_Abridged_type_Enum_TRAINING,
    ISRCollectionTaskings_Abridged_type_Enum_TRANSIT
  };
  return values;
}

inline const char * const *EnumNamesISRCollectionTaskings_Abridged_type_Enum() {
  static const char * const names[5] = {
    "DELIBERATE",
    "DYNAMIC",
    "TRAINING",
    "TRANSIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameISRCollectionTaskings_Abridged_type_Enum(ISRCollectionTaskings_Abridged_type_Enum e) {
  if (::flatbuffers::IsOutRange(e, ISRCollectionTaskings_Abridged_type_Enum_DELIBERATE, ISRCollectionTaskings_Abridged_type_Enum_TRANSIT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesISRCollectionTaskings_Abridged_type_Enum()[index];
}

enum ISRCollectionTaskings_Abridged_collectionType_Enum : int8_t {
  /// No description available.
  ISRCollectionTaskings_Abridged_collectionType_Enum_SIMULTANEOUS = 0,
  /// No description available.
  ISRCollectionTaskings_Abridged_collectionType_Enum_SEQUENTIAL = 1,
  /// No description available.
  ISRCollectionTaskings_Abridged_collectionType_Enum_OPERATIONALLY = 2,
  /// No description available.
  ISRCollectionTaskings_Abridged_collectionType_Enum_DRIVEN = 3,
  /// No description available.
  ISRCollectionTaskings_Abridged_collectionType_Enum_PRIORITY = 4,
  /// No description available.
  ISRCollectionTaskings_Abridged_collectionType_Enum_ORDER = 5,
  ISRCollectionTaskings_Abridged_collectionType_Enum_MIN = ISRCollectionTaskings_Abridged_collectionType_Enum_SIMULTANEOUS,
  ISRCollectionTaskings_Abridged_collectionType_Enum_MAX = ISRCollectionTaskings_Abridged_collectionType_Enum_ORDER
};

inline const ISRCollectionTaskings_Abridged_collectionType_Enum (&EnumValuesISRCollectionTaskings_Abridged_collectionType_Enum())[6] {
  static const ISRCollectionTaskings_Abridged_collectionType_Enum values[] = {
    ISRCollectionTaskings_Abridged_collectionType_Enum_SIMULTANEOUS,
    ISRCollectionTaskings_Abridged_collectionType_Enum_SEQUENTIAL,
    ISRCollectionTaskings_Abridged_collectionType_Enum_OPERATIONALLY,
    ISRCollectionTaskings_Abridged_collectionType_Enum_DRIVEN,
    ISRCollectionTaskings_Abridged_collectionType_Enum_PRIORITY,
    ISRCollectionTaskings_Abridged_collectionType_Enum_ORDER
  };
  return values;
}

inline const char * const *EnumNamesISRCollectionTaskings_Abridged_collectionType_Enum() {
  static const char * const names[7] = {
    "SIMULTANEOUS",
    "SEQUENTIAL",
    "OPERATIONALLY",
    "DRIVEN",
    "PRIORITY",
    "ORDER",
    nullptr
  };
  return names;
}

inline const char *EnumNameISRCollectionTaskings_Abridged_collectionType_Enum(ISRCollectionTaskings_Abridged_collectionType_Enum e) {
  if (::flatbuffers::IsOutRange(e, ISRCollectionTaskings_Abridged_collectionType_Enum_SIMULTANEOUS, ISRCollectionTaskings_Abridged_collectionType_Enum_ORDER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesISRCollectionTaskings_Abridged_collectionType_Enum()[index];
}

/// /// Individual taskings to complete the mission.
struct ISRCollectionTaskings_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ISRCollectionTaskings_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_COLLECTIONTYPE = 8,
    VT_TASKINGAOR = 10,
    VT_EIGHTLINE = 12,
    VT_TASKINGPRIMARYINTELDISCIPLINE = 14,
    VT_TASKINGPRIMARYSUBCATEGORY = 16,
    VT_TASKINGSECONDARYINTELDISCIPLINE = 18,
    VT_TASKINGSECONDARYSUBCATEGORY = 20,
    VT_TASKINGROLE = 22,
    VT_TASKINGOPERATION = 24,
    VT_TASKINGPRIORITY = 26,
    VT_TASKINGSUPPORTEDUNIT = 28,
    VT_TASKINGEMPHASIS = 30,
    VT_TASKINGRETASKTIME = 32,
    VT_TASKINGSTARTPOINTLAT = 34,
    VT_TASKINGSTARTPOINTLONG = 36,
    VT_TASKINGCOLLECTIONAREA = 38,
    VT_TASKINGJOA = 40,
    VT_TASKINGSYNCMATRIXBIN = 42,
    VT_TASKINGCOUNTRY = 44,
    VT_TASKINGREGION = 46,
    VT_TASKINGSUBREGION = 48,
    VT_SROTRACK = 50,
    VT_SPECIALCOMGUIDANCE = 52,
    VT_COLLECTIONPERIODS = 54,
    VT_TASKINGCOLLECTIONREQUIREMENTS = 56
  };
  /// Tasking Unique Identifier.
  /// Example: /// Example: ISRCOLLECTIONTASKINGS-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Type of tasking.
  /// Example: /// Example: Deliberate
  /// Constraints: Minimum length = 1, Maximum length = 16
  ISRCollectionTaskings_Abridged_type_Enum type() const {
    return static_cast<ISRCollectionTaskings_Abridged_type_Enum>(GetField<int8_t>(VT_TYPE, 0));
  }
  /// Type of collection tasked.
  /// Example: /// Example: Simultaneous
  /// Constraints: Minimum length = 1, Maximum length = 16
  ISRCollectionTaskings_Abridged_collectionType_Enum collectionType() const {
    return static_cast<ISRCollectionTaskings_Abridged_collectionType_Enum>(GetField<int8_t>(VT_COLLECTIONTYPE, 0));
  }
  /// Human readable definition of this taskings Area Of Responsibility.
  /// Example: /// Example: Kandahar
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingAOR() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGAOR);
  }
  /// Eight line.
  /// Example: /// Example: No example provided.
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *eightLine() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EIGHTLINE);
  }
  /// Primary type of intelligence to be collected during the mission.
  /// Example: /// Example: Sig
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingPrimaryIntelDiscipline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGPRIMARYINTELDISCIPLINE);
  }
  /// Sub category of primary intelligence to be collected.
  /// Example: /// Example: FMV
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingPrimarySubCategory() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGPRIMARYSUBCATEGORY);
  }
  /// Type of tasking intelligence to be collected second.
  /// Example: /// Example: Intelligence_2
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingSecondaryIntelDiscipline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGSECONDARYINTELDISCIPLINE);
  }
  /// Mission sub category for secondary intelligence discipline to be collected.
  /// Example: /// Example: Convoy
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingSecondarySubCategory() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGSECONDARYSUBCATEGORY);
  }
  /// What is the primary objective(Role) of this task.
  /// Example: /// Example: Provide Targeting of Lead Vehicle
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingRole() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGROLE);
  }
  /// Tasking operation name.
  /// Example: /// Example: OP-HONEY-BADGER
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingOperation() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGOPERATION);
  }
  /// Tasking Priority (1-n).
  /// Example: /// Example: 10.23
  /// Constraints: No constraints specified.
  double taskingPriority() const {
    return GetField<double>(VT_TASKINGPRIORITY, 0.0);
  }
  /// Military Base to transmit the dissemination of this data.
  /// Example: /// Example: ENVOYS
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingSupportedUnit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGSUPPORTEDUNIT);
  }
  /// Tasking emphasis.
  /// Example: /// Example: EMPHASIS
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingEmphasis() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGEMPHASIS);
  }
  /// Time of retasking, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-01-19T01:01:15.001Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *taskingRetaskTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGRETASKTIME);
  }
  /// WGS-84 latitude of the start position, in degrees. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double taskingStartPointLat() const {
    return GetField<double>(VT_TASKINGSTARTPOINTLAT, 0.0);
  }
  /// WGS-84 longitude of the start position, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double taskingStartPointLong() const {
    return GetField<double>(VT_TASKINGSTARTPOINTLONG, 0.0);
  }
  /// Tasking geographical collection area.
  /// Example: /// Example: AREA
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *taskingCollectionArea() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGCOLLECTIONAREA);
  }
  /// Joint Operations Area.
  /// Example: /// Example: AREA
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingJoa() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGJOA);
  }
  /// A synchronization matrix is used to organize the logistics synchronization process during a mission.
  /// Example: /// Example: MATRIX
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingSyncMatrixBin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGSYNCMATRIXBIN);
  }
  /// Country code of the tasking.  A Country may represent countries, multi-national consortiums, and international organizations.
  /// Example: /// Example: CODE
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *taskingCountry() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGCOUNTRY);
  }
  /// Region of the tasking.
  /// Example: /// Example: REGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingRegion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGREGION);
  }
  /// Subregion of the tasking.
  /// Example: /// Example: SUBREGION
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *taskingSubRegion() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKINGSUBREGION);
  }
  /// Value of the Sensitive Reconnaissance Operations Track.
  /// Example: /// Example: SRO
  /// Constraints: Minimum length = 0, Maximum length = 32
  const ::flatbuffers::String *sroTrack() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SROTRACK);
  }
  /// Free text field for the user to specify special instructions needed for this collection.
  /// Example: /// Example: TEXT
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *specialComGuidance() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPECIALCOMGUIDANCE);
  }
  /// No description provided.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *collectionPeriods() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONPERIODS);
  }
  /// Tasking desired collection requirements.
  /// Example: /// Example: No example provided.
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *taskingCollectionRequirements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TASKINGCOLLECTIONREQUIREMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_COLLECTIONTYPE, 1) &&
           VerifyOffset(verifier, VT_TASKINGAOR) &&
           verifier.VerifyString(taskingAOR()) &&
           VerifyOffset(verifier, VT_EIGHTLINE) &&
           verifier.VerifyString(eightLine()) &&
           VerifyOffset(verifier, VT_TASKINGPRIMARYINTELDISCIPLINE) &&
           verifier.VerifyString(taskingPrimaryIntelDiscipline()) &&
           VerifyOffset(verifier, VT_TASKINGPRIMARYSUBCATEGORY) &&
           verifier.VerifyString(taskingPrimarySubCategory()) &&
           VerifyOffset(verifier, VT_TASKINGSECONDARYINTELDISCIPLINE) &&
           verifier.VerifyString(taskingSecondaryIntelDiscipline()) &&
           VerifyOffset(verifier, VT_TASKINGSECONDARYSUBCATEGORY) &&
           verifier.VerifyString(taskingSecondarySubCategory()) &&
           VerifyOffset(verifier, VT_TASKINGROLE) &&
           verifier.VerifyString(taskingRole()) &&
           VerifyOffset(verifier, VT_TASKINGOPERATION) &&
           verifier.VerifyString(taskingOperation()) &&
           VerifyField<double>(verifier, VT_TASKINGPRIORITY, 8) &&
           VerifyOffset(verifier, VT_TASKINGSUPPORTEDUNIT) &&
           verifier.VerifyString(taskingSupportedUnit()) &&
           VerifyOffset(verifier, VT_TASKINGEMPHASIS) &&
           verifier.VerifyString(taskingEmphasis()) &&
           VerifyOffset(verifier, VT_TASKINGRETASKTIME) &&
           verifier.VerifyString(taskingRetaskTime()) &&
           VerifyField<double>(verifier, VT_TASKINGSTARTPOINTLAT, 8) &&
           VerifyField<double>(verifier, VT_TASKINGSTARTPOINTLONG, 8) &&
           VerifyOffset(verifier, VT_TASKINGCOLLECTIONAREA) &&
           verifier.VerifyString(taskingCollectionArea()) &&
           VerifyOffset(verifier, VT_TASKINGJOA) &&
           verifier.VerifyString(taskingJoa()) &&
           VerifyOffset(verifier, VT_TASKINGSYNCMATRIXBIN) &&
           verifier.VerifyString(taskingSyncMatrixBin()) &&
           VerifyOffset(verifier, VT_TASKINGCOUNTRY) &&
           verifier.VerifyString(taskingCountry()) &&
           VerifyOffset(verifier, VT_TASKINGREGION) &&
           verifier.VerifyString(taskingRegion()) &&
           VerifyOffset(verifier, VT_TASKINGSUBREGION) &&
           verifier.VerifyString(taskingSubRegion()) &&
           VerifyOffset(verifier, VT_SROTRACK) &&
           verifier.VerifyString(sroTrack()) &&
           VerifyOffset(verifier, VT_SPECIALCOMGUIDANCE) &&
           verifier.VerifyString(specialComGuidance()) &&
           VerifyOffset(verifier, VT_COLLECTIONPERIODS) &&
           verifier.VerifyString(collectionPeriods()) &&
           VerifyOffset(verifier, VT_TASKINGCOLLECTIONREQUIREMENTS) &&
           verifier.VerifyVector(taskingCollectionRequirements()) &&
           verifier.VerifyVectorOfStrings(taskingCollectionRequirements()) &&
           verifier.EndTable();
  }
};

struct ISRCollectionTaskings_AbridgedBuilder {
  typedef ISRCollectionTaskings_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_ID, id);
  }
  void add_type(ISRCollectionTaskings_Abridged_type_Enum type) {
    fbb_.AddElement<int8_t>(ISRCollectionTaskings_Abridged::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_collectionType(ISRCollectionTaskings_Abridged_collectionType_Enum collectionType) {
    fbb_.AddElement<int8_t>(ISRCollectionTaskings_Abridged::VT_COLLECTIONTYPE, static_cast<int8_t>(collectionType), 0);
  }
  void add_taskingAOR(::flatbuffers::Offset<::flatbuffers::String> taskingAOR) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGAOR, taskingAOR);
  }
  void add_eightLine(::flatbuffers::Offset<::flatbuffers::String> eightLine) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_EIGHTLINE, eightLine);
  }
  void add_taskingPrimaryIntelDiscipline(::flatbuffers::Offset<::flatbuffers::String> taskingPrimaryIntelDiscipline) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGPRIMARYINTELDISCIPLINE, taskingPrimaryIntelDiscipline);
  }
  void add_taskingPrimarySubCategory(::flatbuffers::Offset<::flatbuffers::String> taskingPrimarySubCategory) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGPRIMARYSUBCATEGORY, taskingPrimarySubCategory);
  }
  void add_taskingSecondaryIntelDiscipline(::flatbuffers::Offset<::flatbuffers::String> taskingSecondaryIntelDiscipline) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGSECONDARYINTELDISCIPLINE, taskingSecondaryIntelDiscipline);
  }
  void add_taskingSecondarySubCategory(::flatbuffers::Offset<::flatbuffers::String> taskingSecondarySubCategory) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGSECONDARYSUBCATEGORY, taskingSecondarySubCategory);
  }
  void add_taskingRole(::flatbuffers::Offset<::flatbuffers::String> taskingRole) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGROLE, taskingRole);
  }
  void add_taskingOperation(::flatbuffers::Offset<::flatbuffers::String> taskingOperation) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGOPERATION, taskingOperation);
  }
  void add_taskingPriority(double taskingPriority) {
    fbb_.AddElement<double>(ISRCollectionTaskings_Abridged::VT_TASKINGPRIORITY, taskingPriority, 0.0);
  }
  void add_taskingSupportedUnit(::flatbuffers::Offset<::flatbuffers::String> taskingSupportedUnit) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGSUPPORTEDUNIT, taskingSupportedUnit);
  }
  void add_taskingEmphasis(::flatbuffers::Offset<::flatbuffers::String> taskingEmphasis) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGEMPHASIS, taskingEmphasis);
  }
  void add_taskingRetaskTime(::flatbuffers::Offset<::flatbuffers::String> taskingRetaskTime) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGRETASKTIME, taskingRetaskTime);
  }
  void add_taskingStartPointLat(double taskingStartPointLat) {
    fbb_.AddElement<double>(ISRCollectionTaskings_Abridged::VT_TASKINGSTARTPOINTLAT, taskingStartPointLat, 0.0);
  }
  void add_taskingStartPointLong(double taskingStartPointLong) {
    fbb_.AddElement<double>(ISRCollectionTaskings_Abridged::VT_TASKINGSTARTPOINTLONG, taskingStartPointLong, 0.0);
  }
  void add_taskingCollectionArea(::flatbuffers::Offset<::flatbuffers::String> taskingCollectionArea) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGCOLLECTIONAREA, taskingCollectionArea);
  }
  void add_taskingJoa(::flatbuffers::Offset<::flatbuffers::String> taskingJoa) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGJOA, taskingJoa);
  }
  void add_taskingSyncMatrixBin(::flatbuffers::Offset<::flatbuffers::String> taskingSyncMatrixBin) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGSYNCMATRIXBIN, taskingSyncMatrixBin);
  }
  void add_taskingCountry(::flatbuffers::Offset<::flatbuffers::String> taskingCountry) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGCOUNTRY, taskingCountry);
  }
  void add_taskingRegion(::flatbuffers::Offset<::flatbuffers::String> taskingRegion) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGREGION, taskingRegion);
  }
  void add_taskingSubRegion(::flatbuffers::Offset<::flatbuffers::String> taskingSubRegion) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGSUBREGION, taskingSubRegion);
  }
  void add_sroTrack(::flatbuffers::Offset<::flatbuffers::String> sroTrack) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_SROTRACK, sroTrack);
  }
  void add_specialComGuidance(::flatbuffers::Offset<::flatbuffers::String> specialComGuidance) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_SPECIALCOMGUIDANCE, specialComGuidance);
  }
  void add_collectionPeriods(::flatbuffers::Offset<::flatbuffers::String> collectionPeriods) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_COLLECTIONPERIODS, collectionPeriods);
  }
  void add_taskingCollectionRequirements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> taskingCollectionRequirements) {
    fbb_.AddOffset(ISRCollectionTaskings_Abridged::VT_TASKINGCOLLECTIONREQUIREMENTS, taskingCollectionRequirements);
  }
  explicit ISRCollectionTaskings_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ISRCollectionTaskings_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ISRCollectionTaskings_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ISRCollectionTaskings_Abridged> CreateISRCollectionTaskings_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ISRCollectionTaskings_Abridged_type_Enum type = ISRCollectionTaskings_Abridged_type_Enum_DELIBERATE,
    ISRCollectionTaskings_Abridged_collectionType_Enum collectionType = ISRCollectionTaskings_Abridged_collectionType_Enum_SIMULTANEOUS,
    ::flatbuffers::Offset<::flatbuffers::String> taskingAOR = 0,
    ::flatbuffers::Offset<::flatbuffers::String> eightLine = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingPrimaryIntelDiscipline = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingPrimarySubCategory = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingSecondaryIntelDiscipline = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingSecondarySubCategory = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingRole = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingOperation = 0,
    double taskingPriority = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingSupportedUnit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingEmphasis = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingRetaskTime = 0,
    double taskingStartPointLat = 0.0,
    double taskingStartPointLong = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingCollectionArea = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingJoa = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingSyncMatrixBin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingCountry = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingRegion = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskingSubRegion = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sroTrack = 0,
    ::flatbuffers::Offset<::flatbuffers::String> specialComGuidance = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionPeriods = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> taskingCollectionRequirements = 0) {
  ISRCollectionTaskings_AbridgedBuilder builder_(_fbb);
  builder_.add_taskingStartPointLong(taskingStartPointLong);
  builder_.add_taskingStartPointLat(taskingStartPointLat);
  builder_.add_taskingPriority(taskingPriority);
  builder_.add_taskingCollectionRequirements(taskingCollectionRequirements);
  builder_.add_collectionPeriods(collectionPeriods);
  builder_.add_specialComGuidance(specialComGuidance);
  builder_.add_sroTrack(sroTrack);
  builder_.add_taskingSubRegion(taskingSubRegion);
  builder_.add_taskingRegion(taskingRegion);
  builder_.add_taskingCountry(taskingCountry);
  builder_.add_taskingSyncMatrixBin(taskingSyncMatrixBin);
  builder_.add_taskingJoa(taskingJoa);
  builder_.add_taskingCollectionArea(taskingCollectionArea);
  builder_.add_taskingRetaskTime(taskingRetaskTime);
  builder_.add_taskingEmphasis(taskingEmphasis);
  builder_.add_taskingSupportedUnit(taskingSupportedUnit);
  builder_.add_taskingOperation(taskingOperation);
  builder_.add_taskingRole(taskingRole);
  builder_.add_taskingSecondarySubCategory(taskingSecondarySubCategory);
  builder_.add_taskingSecondaryIntelDiscipline(taskingSecondaryIntelDiscipline);
  builder_.add_taskingPrimarySubCategory(taskingPrimarySubCategory);
  builder_.add_taskingPrimaryIntelDiscipline(taskingPrimaryIntelDiscipline);
  builder_.add_eightLine(eightLine);
  builder_.add_taskingAOR(taskingAOR);
  builder_.add_id(id);
  builder_.add_collectionType(collectionType);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ISRCollectionTaskings_Abridged> CreateISRCollectionTaskings_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    ISRCollectionTaskings_Abridged_type_Enum type = ISRCollectionTaskings_Abridged_type_Enum_DELIBERATE,
    ISRCollectionTaskings_Abridged_collectionType_Enum collectionType = ISRCollectionTaskings_Abridged_collectionType_Enum_SIMULTANEOUS,
    const char *taskingAOR = nullptr,
    const char *eightLine = nullptr,
    const char *taskingPrimaryIntelDiscipline = nullptr,
    const char *taskingPrimarySubCategory = nullptr,
    const char *taskingSecondaryIntelDiscipline = nullptr,
    const char *taskingSecondarySubCategory = nullptr,
    const char *taskingRole = nullptr,
    const char *taskingOperation = nullptr,
    double taskingPriority = 0.0,
    const char *taskingSupportedUnit = nullptr,
    const char *taskingEmphasis = nullptr,
    const char *taskingRetaskTime = nullptr,
    double taskingStartPointLat = 0.0,
    double taskingStartPointLong = 0.0,
    const char *taskingCollectionArea = nullptr,
    const char *taskingJoa = nullptr,
    const char *taskingSyncMatrixBin = nullptr,
    const char *taskingCountry = nullptr,
    const char *taskingRegion = nullptr,
    const char *taskingSubRegion = nullptr,
    const char *sroTrack = nullptr,
    const char *specialComGuidance = nullptr,
    const char *collectionPeriods = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *taskingCollectionRequirements = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto taskingAOR__ = taskingAOR ? _fbb.CreateString(taskingAOR) : 0;
  auto eightLine__ = eightLine ? _fbb.CreateString(eightLine) : 0;
  auto taskingPrimaryIntelDiscipline__ = taskingPrimaryIntelDiscipline ? _fbb.CreateString(taskingPrimaryIntelDiscipline) : 0;
  auto taskingPrimarySubCategory__ = taskingPrimarySubCategory ? _fbb.CreateString(taskingPrimarySubCategory) : 0;
  auto taskingSecondaryIntelDiscipline__ = taskingSecondaryIntelDiscipline ? _fbb.CreateString(taskingSecondaryIntelDiscipline) : 0;
  auto taskingSecondarySubCategory__ = taskingSecondarySubCategory ? _fbb.CreateString(taskingSecondarySubCategory) : 0;
  auto taskingRole__ = taskingRole ? _fbb.CreateString(taskingRole) : 0;
  auto taskingOperation__ = taskingOperation ? _fbb.CreateString(taskingOperation) : 0;
  auto taskingSupportedUnit__ = taskingSupportedUnit ? _fbb.CreateString(taskingSupportedUnit) : 0;
  auto taskingEmphasis__ = taskingEmphasis ? _fbb.CreateString(taskingEmphasis) : 0;
  auto taskingRetaskTime__ = taskingRetaskTime ? _fbb.CreateString(taskingRetaskTime) : 0;
  auto taskingCollectionArea__ = taskingCollectionArea ? _fbb.CreateString(taskingCollectionArea) : 0;
  auto taskingJoa__ = taskingJoa ? _fbb.CreateString(taskingJoa) : 0;
  auto taskingSyncMatrixBin__ = taskingSyncMatrixBin ? _fbb.CreateString(taskingSyncMatrixBin) : 0;
  auto taskingCountry__ = taskingCountry ? _fbb.CreateString(taskingCountry) : 0;
  auto taskingRegion__ = taskingRegion ? _fbb.CreateString(taskingRegion) : 0;
  auto taskingSubRegion__ = taskingSubRegion ? _fbb.CreateString(taskingSubRegion) : 0;
  auto sroTrack__ = sroTrack ? _fbb.CreateString(sroTrack) : 0;
  auto specialComGuidance__ = specialComGuidance ? _fbb.CreateString(specialComGuidance) : 0;
  auto collectionPeriods__ = collectionPeriods ? _fbb.CreateString(collectionPeriods) : 0;
  auto taskingCollectionRequirements__ = taskingCollectionRequirements ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*taskingCollectionRequirements) : 0;
  return CreateISRCollectionTaskings_Abridged(
      _fbb,
      id__,
      type,
      collectionType,
      taskingAOR__,
      eightLine__,
      taskingPrimaryIntelDiscipline__,
      taskingPrimarySubCategory__,
      taskingSecondaryIntelDiscipline__,
      taskingSecondarySubCategory__,
      taskingRole__,
      taskingOperation__,
      taskingPriority,
      taskingSupportedUnit__,
      taskingEmphasis__,
      taskingRetaskTime__,
      taskingStartPointLat,
      taskingStartPointLong,
      taskingCollectionArea__,
      taskingJoa__,
      taskingSyncMatrixBin__,
      taskingCountry__,
      taskingRegion__,
      taskingSubRegion__,
      sroTrack__,
      specialComGuidance__,
      collectionPeriods__,
      taskingCollectionRequirements__);
}

inline const ISRCollectionTaskings_Abridged *GetISRCollectionTaskings_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<ISRCollectionTaskings_Abridged>(buf);
}

inline const ISRCollectionTaskings_Abridged *GetSizePrefixedISRCollectionTaskings_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<ISRCollectionTaskings_Abridged>(buf);
}

inline const char *ISRCollectionTaskings_AbridgedIdentifier() {
  return "ISRC";
}

inline bool ISRCollectionTaskings_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ISRCollectionTaskings_AbridgedIdentifier());
}

inline bool SizePrefixedISRCollectionTaskings_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ISRCollectionTaskings_AbridgedIdentifier(), true);
}

inline bool VerifyISRCollectionTaskings_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<ISRCollectionTaskings_Abridged>(ISRCollectionTaskings_AbridgedIdentifier());
}

inline bool VerifySizePrefixedISRCollectionTaskings_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<ISRCollectionTaskings_Abridged>(ISRCollectionTaskings_AbridgedIdentifier());
}

inline void FinishISRCollectionTaskings_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ISRCollectionTaskings_Abridged> root) {
  fbb.Finish(root, ISRCollectionTaskings_AbridgedIdentifier());
}

inline void FinishSizePrefixedISRCollectionTaskings_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<ISRCollectionTaskings_Abridged> root) {
  fbb.FinishSizePrefixed(root, ISRCollectionTaskings_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
