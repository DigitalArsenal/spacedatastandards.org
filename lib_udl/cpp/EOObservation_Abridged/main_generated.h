// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct EOObservation_Abridged;
struct EOObservation_AbridgedBuilder;

enum EOObservation_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  EOObservation_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  EOObservation_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  EOObservation_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  EOObservation_Abridged_dataMode_Enum_EXERCISE = 3,
  EOObservation_Abridged_dataMode_Enum_MIN = EOObservation_Abridged_dataMode_Enum_REAL,
  EOObservation_Abridged_dataMode_Enum_MAX = EOObservation_Abridged_dataMode_Enum_EXERCISE
};

inline const EOObservation_Abridged_dataMode_Enum (&EnumValuesEOObservation_Abridged_dataMode_Enum())[4] {
  static const EOObservation_Abridged_dataMode_Enum values[] = {
    EOObservation_Abridged_dataMode_Enum_REAL,
    EOObservation_Abridged_dataMode_Enum_TEST,
    EOObservation_Abridged_dataMode_Enum_SIMULATED,
    EOObservation_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesEOObservation_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameEOObservation_Abridged_dataMode_Enum(EOObservation_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, EOObservation_Abridged_dataMode_Enum_REAL, EOObservation_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEOObservation_Abridged_dataMode_Enum()[index];
}

enum EOObservation_Abridged_referenceFrame_Enum : int8_t {
  /// No description available.
  EOObservation_Abridged_referenceFrame_Enum_J2000 = 0,
  /// No description available.
  EOObservation_Abridged_referenceFrame_Enum_GCRF = 1,
  /// No description available.
  EOObservation_Abridged_referenceFrame_Enum_ITRF = 2,
  /// No description available.
  EOObservation_Abridged_referenceFrame_Enum_TEME = 3,
  EOObservation_Abridged_referenceFrame_Enum_MIN = EOObservation_Abridged_referenceFrame_Enum_J2000,
  EOObservation_Abridged_referenceFrame_Enum_MAX = EOObservation_Abridged_referenceFrame_Enum_TEME
};

inline const EOObservation_Abridged_referenceFrame_Enum (&EnumValuesEOObservation_Abridged_referenceFrame_Enum())[4] {
  static const EOObservation_Abridged_referenceFrame_Enum values[] = {
    EOObservation_Abridged_referenceFrame_Enum_J2000,
    EOObservation_Abridged_referenceFrame_Enum_GCRF,
    EOObservation_Abridged_referenceFrame_Enum_ITRF,
    EOObservation_Abridged_referenceFrame_Enum_TEME
  };
  return values;
}

inline const char * const *EnumNamesEOObservation_Abridged_referenceFrame_Enum() {
  static const char * const names[5] = {
    "J2000",
    "GCRF",
    "ITRF",
    "TEME",
    nullptr
  };
  return names;
}

inline const char *EnumNameEOObservation_Abridged_referenceFrame_Enum(EOObservation_Abridged_referenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, EOObservation_Abridged_referenceFrame_Enum_J2000, EOObservation_Abridged_referenceFrame_Enum_TEME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEOObservation_Abridged_referenceFrame_Enum()[index];
}

enum EOObservation_Abridged_senReferenceFrame_Enum : int8_t {
  /// No description available.
  EOObservation_Abridged_senReferenceFrame_Enum_J2000 = 0,
  /// No description available.
  EOObservation_Abridged_senReferenceFrame_Enum_EFG_TDR = 1,
  /// No description available.
  EOObservation_Abridged_senReferenceFrame_Enum_ECR_ECEF = 2,
  /// No description available.
  EOObservation_Abridged_senReferenceFrame_Enum_TEME = 3,
  /// No description available.
  EOObservation_Abridged_senReferenceFrame_Enum_ITRF = 4,
  /// No description available.
  EOObservation_Abridged_senReferenceFrame_Enum_GCRF = 5,
  EOObservation_Abridged_senReferenceFrame_Enum_MIN = EOObservation_Abridged_senReferenceFrame_Enum_J2000,
  EOObservation_Abridged_senReferenceFrame_Enum_MAX = EOObservation_Abridged_senReferenceFrame_Enum_GCRF
};

inline const EOObservation_Abridged_senReferenceFrame_Enum (&EnumValuesEOObservation_Abridged_senReferenceFrame_Enum())[6] {
  static const EOObservation_Abridged_senReferenceFrame_Enum values[] = {
    EOObservation_Abridged_senReferenceFrame_Enum_J2000,
    EOObservation_Abridged_senReferenceFrame_Enum_EFG_TDR,
    EOObservation_Abridged_senReferenceFrame_Enum_ECR_ECEF,
    EOObservation_Abridged_senReferenceFrame_Enum_TEME,
    EOObservation_Abridged_senReferenceFrame_Enum_ITRF,
    EOObservation_Abridged_senReferenceFrame_Enum_GCRF
  };
  return values;
}

inline const char * const *EnumNamesEOObservation_Abridged_senReferenceFrame_Enum() {
  static const char * const names[7] = {
    "J2000",
    "EFG_TDR",
    "ECR_ECEF",
    "TEME",
    "ITRF",
    "GCRF",
    nullptr
  };
  return names;
}

inline const char *EnumNameEOObservation_Abridged_senReferenceFrame_Enum(EOObservation_Abridged_senReferenceFrame_Enum e) {
  if (::flatbuffers::IsOutRange(e, EOObservation_Abridged_senReferenceFrame_Enum_J2000, EOObservation_Abridged_senReferenceFrame_Enum_GCRF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEOObservation_Abridged_senReferenceFrame_Enum()[index];
}

/// /// Model representation of observation data for electro-optical based sensor phenomenologies. ECI J2K is the preferred reference frame for EOObservations, however, several user-specified reference frames are accommodated. Users should check the EOObservation record as well as the 'Discover' tab in the storefront to confirm the coordinate frames used by the data provider.
struct EOObservation_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EOObservation_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_OBTIME = 8,
    VT_CORRQUALITY = 10,
    VT_IDONORBIT = 12,
    VT_IDSENSOR = 14,
    VT_IDSKYIMAGERY = 16,
    VT_COLLECTMETHOD = 18,
    VT_SATNO = 20,
    VT_TASKID = 22,
    VT_TRANSACTIONID = 24,
    VT_TRACKID = 26,
    VT_OBPOSITION = 28,
    VT_ORIGOBJECTID = 30,
    VT_ORIGSENSORID = 32,
    VT_UCT = 34,
    VT_AZIMUTH = 36,
    VT_AZIMUTHUNC = 38,
    VT_AZIMUTHBIAS = 40,
    VT_AZIMUTHRATE = 42,
    VT_ELEVATION = 44,
    VT_ELEVATIONUNC = 46,
    VT_ELEVATIONBIAS = 48,
    VT_ELEVATIONRATE = 50,
    VT_RANGE = 52,
    VT_RANGEUNC = 54,
    VT_RANGEBIAS = 56,
    VT_RANGERATE = 58,
    VT_RANGERATEUNC = 60,
    VT_RA = 62,
    VT_RARATE = 64,
    VT_RAUNC = 66,
    VT_RABIAS = 68,
    VT_DECLINATION = 70,
    VT_DECLINATIONRATE = 72,
    VT_DECLINATIONUNC = 74,
    VT_DECLINATIONBIAS = 76,
    VT_LOSX = 78,
    VT_LOSY = 80,
    VT_LOSZ = 82,
    VT_LOSUNC = 84,
    VT_LOSXVEL = 86,
    VT_LOSYVEL = 88,
    VT_LOSZVEL = 90,
    VT_SENLAT = 92,
    VT_SENLON = 94,
    VT_SENALT = 96,
    VT_SENX = 98,
    VT_SENY = 100,
    VT_SENZ = 102,
    VT_SENVELX = 104,
    VT_SENVELY = 106,
    VT_SENVELZ = 108,
    VT_SENQUAT = 110,
    VT_FOVCOUNT = 112,
    VT_EXPDURATION = 114,
    VT_ZEROPTD = 116,
    VT_NETOBJSIG = 118,
    VT_NETOBJSIGUNC = 120,
    VT_MAG = 122,
    VT_MAGUNC = 124,
    VT_MAGNORMRANGE = 126,
    VT_GEOLAT = 128,
    VT_GEOLON = 130,
    VT_GEOALT = 132,
    VT_GEORANGE = 134,
    VT_SKYBKGRND = 136,
    VT_PRIMARYEXTINCTION = 138,
    VT_PRIMARYEXTINCTIONUNC = 140,
    VT_SOLARPHASEANGLE = 142,
    VT_SOLAREQPHASEANGLE = 144,
    VT_SOLARDECANGLE = 146,
    VT_SHUTTERDELAY = 148,
    VT_TIMINGBIAS = 150,
    VT_RAWFILEURI = 152,
    VT_INTENSITY = 154,
    VT_BGINTENSITY = 156,
    VT_DESCRIPTOR = 158,
    VT_SOURCE = 160,
    VT_ORIGIN = 162,
    VT_DATAMODE = 164,
    VT_CREATEDAT = 166,
    VT_CREATEDBY = 168,
    VT_REFERENCEFRAME = 170,
    VT_SENREFERENCEFRAME = 172,
    VT_UMBRA = 174,
    VT_PENUMBRA = 176,
    VT_ORIGNETWORK = 178,
    VT_SOURCEDL = 180,
    VT_TYPE = 182
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: EOOBSERVATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Ob detection time in ISO 8601 UTC with microsecond precision.
  /// Example: /// Example: 2018-01-01T16:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *obTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBTIME);
  }
  /// Object Correlation Quality value (non-standardized). Users should consult data providers regarding the expected range of values.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double corrQuality() const {
    return GetField<double>(VT_CORRQUALITY, 0.0);
  }
  /// Unique identifier of the target on-orbit object, if correlated.
  /// Example: /// Example: ONORBIT-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: SENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Unique identifier of the Sky Imagery.
  /// Example: /// Example: SKYIMAGERY-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSkyImagery() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSKYIMAGERY);
  }
  /// Method indicating telescope movement during collection (AUTOTRACK, MANUAL AUTOTRACK, MANUAL RATE TRACK, MANUAL SIDEREAL, SIDEREAL, RATE TRACK).
  /// Example: /// Example: AUTOTRACK
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *collectMethod() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTMETHOD);
  }
  /// Satellite/Catalog number of the target on-orbit object.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier to indicate the specific tasking which produced this observation.
  /// Example: /// Example: TASK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *taskId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TASKID);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// Optional identifier of the track to which this observation belongs.
  /// Example: /// Example: TRACK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *trackId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRACKID);
  }
  /// The position of this observation within a track (FENCE, FIRST, IN, LAST, SINGLE).  This identifier is optional and, if null, no assumption should be made regarding whether other observations may or may not exist to compose a track.
  /// Example: /// Example: FIRST
  /// Constraints: Minimum length = 0, Maximum length = 8
  const ::flatbuffers::String *obPosition() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBPOSITION);
  }
  /// Optional identifier provided by observation source to indicate the target onorbit object of this observation. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: ORIGOBJECT-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Optional identifier provided by observation source to indicate the sensor identifier which produced this observation. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: ORIGSENSOR-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// Boolean indicating this observation is part of an uncorrelated track or was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an on-orbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool uct() const {
    return GetField<uint8_t>(VT_UCT, 0) != 0;
  }
  /// Line of sight azimuth angle in degrees and topocentric frame.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double azimuth() const {
    return GetField<double>(VT_AZIMUTH, 0.0);
  }
  /// One sigma uncertainty in the line of sight azimuth angle, in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double azimuthUnc() const {
    return GetField<double>(VT_AZIMUTHUNC, 0.0);
  }
  /// Sensor line of sight azimuth angle bias in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double azimuthBias() const {
    return GetField<double>(VT_AZIMUTHBIAS, 0.0);
  }
  /// Rate of change of the line of sight azimuth in degrees per second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double azimuthRate() const {
    return GetField<double>(VT_AZIMUTHRATE, 0.0);
  }
  /// Line of sight elevation in degrees and topocentric frame.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double elevation() const {
    return GetField<double>(VT_ELEVATION, 0.0);
  }
  /// One sigma uncertainty in the line of sight elevation angle, in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double elevationUnc() const {
    return GetField<double>(VT_ELEVATIONUNC, 0.0);
  }
  /// Sensor line of sight elevation bias in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double elevationBias() const {
    return GetField<double>(VT_ELEVATIONBIAS, 0.0);
  }
  /// Rate of change of the line of sight elevation in degrees per second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double elevationRate() const {
    return GetField<double>(VT_ELEVATIONRATE, 0.0);
  }
  /// Line of sight range in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double range() const {
    return GetField<double>(VT_RANGE, 0.0);
  }
  /// One sigma uncertainty in the line of sight range, in kilometers.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rangeUnc() const {
    return GetField<double>(VT_RANGEUNC, 0.0);
  }
  /// Sensor line of sight range bias in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rangeBias() const {
    return GetField<double>(VT_RANGEBIAS, 0.0);
  }
  /// Rate of change of the line of sight range in km/sec.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rangeRate() const {
    return GetField<double>(VT_RANGERATE, 0.0);
  }
  /// One sigma uncertainty in the line of sight range rate, in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double rangeRateUnc() const {
    return GetField<double>(VT_RANGERATEUNC, 0.0);
  }
  /// Line of sight right ascension, in degrees, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double ra() const {
    return GetField<double>(VT_RA, 0.0);
  }
  /// Line of sight right ascension rate of change, in degrees/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double raRate() const {
    return GetField<double>(VT_RARATE, 0.0);
  }
  /// One sigma uncertainty in the line of sight right ascension angle, in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double raUnc() const {
    return GetField<double>(VT_RAUNC, 0.0);
  }
  /// Sensor line of sight right ascension bias in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double raBias() const {
    return GetField<double>(VT_RABIAS, 0.0);
  }
  /// Line of sight declination, in degrees, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double declination() const {
    return GetField<double>(VT_DECLINATION, 0.0);
  }
  /// Line of sight declination rate of change, in degrees/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double declinationRate() const {
    return GetField<double>(VT_DECLINATIONRATE, 0.0);
  }
  /// One sigma uncertainty in the line of sight declination angle, in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double declinationUnc() const {
    return GetField<double>(VT_DECLINATIONUNC, 0.0);
  }
  /// Sensor line of sight declination angle bias in degrees.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double declinationBias() const {
    return GetField<double>(VT_DECLINATIONBIAS, 0.0);
  }
  /// Line-of-sight cartesian X position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losx() const {
    return GetField<double>(VT_LOSX, 0.0);
  }
  /// Line-of-sight cartesian Y position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losy() const {
    return GetField<double>(VT_LOSY, 0.0);
  }
  /// Line-of-sight cartesian Z position of the target, in km, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losz() const {
    return GetField<double>(VT_LOSZ, 0.0);
  }
  /// One sigma uncertainty in the line of sight pointing in micro-radians.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losUnc() const {
    return GetField<double>(VT_LOSUNC, 0.0);
  }
  /// Line-of-sight cartesian X velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losxvel() const {
    return GetField<double>(VT_LOSXVEL, 0.0);
  }
  /// Line-of-sight cartesian Y velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double losyvel() const {
    return GetField<double>(VT_LOSYVEL, 0.0);
  }
  /// Line-of-sight cartesian Z velocity of target, in km/sec, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double loszvel() const {
    return GetField<double>(VT_LOSZVEL, 0.0);
  }
  /// Sensor WGS84 latitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double senlat() const {
    return GetField<double>(VT_SENLAT, 0.0);
  }
  /// Sensor WGS84 longitude at obTime (if mobile/onorbit) in degrees. If null, can be obtained from sensor info. -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  double senlon() const {
    return GetField<double>(VT_SENLON, 0.0);
  }
  /// Sensor altitude at obTime (if mobile/onorbit) in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senalt() const {
    return GetField<double>(VT_SENALT, 0.0);
  }
  /// Cartesian X position of the observing mobile/onorbit sensor at obTime, in km, in the specified senReferenceFrame.  If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senx() const {
    return GetField<double>(VT_SENX, 0.0);
  }
  /// Cartesian Y position of the observing mobile/onorbit sensor at obTime, in km, in the specified senReferenceFrame.  If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double seny() const {
    return GetField<double>(VT_SENY, 0.0);
  }
  /// Cartesian Z position of the observing mobile/onorbit sensor at obTime, in km, in the specified senReferenceFrame.  If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senz() const {
    return GetField<double>(VT_SENZ, 0.0);
  }
  /// Cartesian X velocity of the observing mobile/onorbit sensor at obTime, in km/sec, in the specified senReferenceFrame.  If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvelx() const {
    return GetField<double>(VT_SENVELX, 0.0);
  }
  /// Cartesian Y velocity of the observing mobile/onorbit sensor at obTime, in km/sec, in the specified senReferenceFrame.  If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvely() const {
    return GetField<double>(VT_SENVELY, 0.0);
  }
  /// Cartesian Z velocity of the observing mobile/onorbit sensor at obTime, in km/sec, in the specified senReferenceFrame.  If senReferenceFrame is null then J2K should be assumed.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvelz() const {
    return GetField<double>(VT_SENVELZ, 0.0);
  }
  /// The quaternion describing the rotation of the sensor in relation to the body-fixed frame used for this system into the local geodetic frame, at observation time (obTime). The array element order convention is scalar component first, followed by the three vector components (qc, q1, q2, q3).
  /// Example: /// Example: [0.4492, 0.02, 0.8765, 0.2213]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *senQuat() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SENQUAT);
  }
  /// The number of RSOs detected in the sensor field of view.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t fovCount() const {
    return GetField<int32_t>(VT_FOVCOUNT, 0);
  }
  /// Image exposure duration in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double expDuration() const {
    return GetField<double>(VT_EXPDURATION, 0.0);
  }
  /// Formula: 2.5 * log_10 (zero_mag_counts / expDuration).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double zeroptd() const {
    return GetField<double>(VT_ZEROPTD, 0.0);
  }
  /// Net object signature = counts / expDuration.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double netObjSig() const {
    return GetField<double>(VT_NETOBJSIG, 0.0);
  }
  /// Net object signature uncertainty = counts uncertainty / expDuration.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double netObjSigUnc() const {
    return GetField<double>(VT_NETOBJSIGUNC, 0.0);
  }
  /// Calibrated magnitude in units of magnitudes.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double mag() const {
    return GetField<double>(VT_MAG, 0.0);
  }
  /// Uncertainty of calibrated magnitude in units of magnitudes.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double magUnc() const {
    return GetField<double>(VT_MAGUNC, 0.0);
  }
  /// Formula: mag - 5.0 * log_10(geo_range / 1000000.0).
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double magNormRange() const {
    return GetField<double>(VT_MAGNORMRANGE, 0.0);
  }
  /// For GEO detections, the latitude in degrees north.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double geolat() const {
    return GetField<double>(VT_GEOLAT, 0.0);
  }
  /// For GEO detections, the longitude in degrees east.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double geolon() const {
    return GetField<double>(VT_GEOLON, 0.0);
  }
  /// For GEO detections, the altitude in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double geoalt() const {
    return GetField<double>(VT_GEOALT, 0.0);
  }
  /// For GEO detections, the range in km.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double georange() const {
    return GetField<double>(VT_GEORANGE, 0.0);
  }
  /// Average Sky Background signal, in Magnitudes. Sky Background refers to the incoming light from an apparently empty part of the night sky.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double skyBkgrnd() const {
    return GetField<double>(VT_SKYBKGRND, 0.0);
  }
  /// Primary Extinction Coefficient, in Magnitudes. Primary Extinction is the coefficient applied to the airmass to determine how much the observed visual magnitude has been attenuated by the atmosphere. Extinction, in general, describes the absorption and scattering of electromagnetic radiation by dust and gas between an emitting astronomical object and the observer.  See the EOObservationDetails API for specification of extinction coefficients for multiple spectral filters.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double primaryExtinction() const {
    return GetField<double>(VT_PRIMARYEXTINCTION, 0.0);
  }
  /// Primary Extinction Coefficient Uncertainty, in Magnitudes.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double primaryExtinctionUnc() const {
    return GetField<double>(VT_PRIMARYEXTINCTIONUNC, 0.0);
  }
  /// The angle, in degrees, between the target-to-observer vector and the target-to-sun vector.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double solarPhaseAngle() const {
    return GetField<double>(VT_SOLARPHASEANGLE, 0.0);
  }
  /// The angle, in degrees, between the projections of the target-to-observer vector and the target-to-sun vector onto the equatorial plane. The angle is represented as negative when closing and positive when opening.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double solarEqPhaseAngle() const {
    return GetField<double>(VT_SOLAREQPHASEANGLE, 0.0);
  }
  /// Angle from the sun to the equatorial plane.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double solarDecAngle() const {
    return GetField<double>(VT_SOLARDECANGLE, 0.0);
  }
  /// Shutter delay in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double shutterDelay() const {
    return GetField<double>(VT_SHUTTERDELAY, 0.0);
  }
  /// Sensor timing bias in seconds.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double timingBias() const {
    return GetField<double>(VT_TIMINGBIAS, 0.0);
  }
  /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
  /// Example: /// Example: Example URI
  /// Constraints: Minimum length = 0, Maximum length = 256
  const ::flatbuffers::String *rawFileURI() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RAWFILEURI);
  }
  /// Intensity of the target for IR observations, in kw/sr/um.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double intensity() const {
    return GetField<double>(VT_INTENSITY, 0.0);
  }
  /// Background intensity for IR observations, in kw/sr/um.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double bgIntensity() const {
    return GetField<double>(VT_BGINTENSITY, 0.0);
  }
  /// Optional source-provided and searchable metadata or descriptor of the data.
  /// Example: /// Example: PROVIDED_DATA1
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *descriptor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTOR);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  EOObservation_Abridged_dataMode_Enum dataMode() const {
    return static_cast<EOObservation_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// The reference frame of the EOObservation measurements. If the referenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  EOObservation_Abridged_referenceFrame_Enum referenceFrame() const {
    return static_cast<EOObservation_Abridged_referenceFrame_Enum>(GetField<int8_t>(VT_REFERENCEFRAME, 0));
  }
  /// The reference frame of the observing sensor state. If the senReferenceFrame is null it is assumed to be J2000.
  /// Example: /// Example: J2000
  /// Constraints: Minimum length = 0, Maximum length = 24
  EOObservation_Abridged_senReferenceFrame_Enum senReferenceFrame() const {
    return static_cast<EOObservation_Abridged_senReferenceFrame_Enum>(GetField<int8_t>(VT_SENREFERENCEFRAME, 0));
  }
  /// Boolean indicating that the target object was in umbral eclipse at the time of this observation.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool umbra() const {
    return GetField<uint8_t>(VT_UMBRA, 0) != 0;
  }
  /// Boolean indicating that the target object was in a penumbral eclipse at the time of this observation.
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool penumbra() const {
    return GetField<uint8_t>(VT_PENUMBRA, 0) != 0;
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Read only enumeration specifying the type of observation (e.g. OPTICAL, RADAR, RF, etc).
  /// Example: /// Example: OPTICAL
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_OBTIME) &&
           verifier.VerifyString(obTime()) &&
           VerifyField<double>(verifier, VT_CORRQUALITY, 8) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_IDSKYIMAGERY) &&
           verifier.VerifyString(idSkyImagery()) &&
           VerifyOffset(verifier, VT_COLLECTMETHOD) &&
           verifier.VerifyString(collectMethod()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_TASKID) &&
           verifier.VerifyString(taskId()) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_TRACKID) &&
           verifier.VerifyString(trackId()) &&
           VerifyOffset(verifier, VT_OBPOSITION) &&
           verifier.VerifyString(obPosition()) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyField<uint8_t>(verifier, VT_UCT, 1) &&
           VerifyField<double>(verifier, VT_AZIMUTH, 8) &&
           VerifyField<double>(verifier, VT_AZIMUTHUNC, 8) &&
           VerifyField<double>(verifier, VT_AZIMUTHBIAS, 8) &&
           VerifyField<double>(verifier, VT_AZIMUTHRATE, 8) &&
           VerifyField<double>(verifier, VT_ELEVATION, 8) &&
           VerifyField<double>(verifier, VT_ELEVATIONUNC, 8) &&
           VerifyField<double>(verifier, VT_ELEVATIONBIAS, 8) &&
           VerifyField<double>(verifier, VT_ELEVATIONRATE, 8) &&
           VerifyField<double>(verifier, VT_RANGE, 8) &&
           VerifyField<double>(verifier, VT_RANGEUNC, 8) &&
           VerifyField<double>(verifier, VT_RANGEBIAS, 8) &&
           VerifyField<double>(verifier, VT_RANGERATE, 8) &&
           VerifyField<double>(verifier, VT_RANGERATEUNC, 8) &&
           VerifyField<double>(verifier, VT_RA, 8) &&
           VerifyField<double>(verifier, VT_RARATE, 8) &&
           VerifyField<double>(verifier, VT_RAUNC, 8) &&
           VerifyField<double>(verifier, VT_RABIAS, 8) &&
           VerifyField<double>(verifier, VT_DECLINATION, 8) &&
           VerifyField<double>(verifier, VT_DECLINATIONRATE, 8) &&
           VerifyField<double>(verifier, VT_DECLINATIONUNC, 8) &&
           VerifyField<double>(verifier, VT_DECLINATIONBIAS, 8) &&
           VerifyField<double>(verifier, VT_LOSX, 8) &&
           VerifyField<double>(verifier, VT_LOSY, 8) &&
           VerifyField<double>(verifier, VT_LOSZ, 8) &&
           VerifyField<double>(verifier, VT_LOSUNC, 8) &&
           VerifyField<double>(verifier, VT_LOSXVEL, 8) &&
           VerifyField<double>(verifier, VT_LOSYVEL, 8) &&
           VerifyField<double>(verifier, VT_LOSZVEL, 8) &&
           VerifyField<double>(verifier, VT_SENLAT, 8) &&
           VerifyField<double>(verifier, VT_SENLON, 8) &&
           VerifyField<double>(verifier, VT_SENALT, 8) &&
           VerifyField<double>(verifier, VT_SENX, 8) &&
           VerifyField<double>(verifier, VT_SENY, 8) &&
           VerifyField<double>(verifier, VT_SENZ, 8) &&
           VerifyField<double>(verifier, VT_SENVELX, 8) &&
           VerifyField<double>(verifier, VT_SENVELY, 8) &&
           VerifyField<double>(verifier, VT_SENVELZ, 8) &&
           VerifyOffset(verifier, VT_SENQUAT) &&
           verifier.VerifyVector(senQuat()) &&
           verifier.VerifyVectorOfStrings(senQuat()) &&
           VerifyField<int32_t>(verifier, VT_FOVCOUNT, 4) &&
           VerifyField<double>(verifier, VT_EXPDURATION, 8) &&
           VerifyField<double>(verifier, VT_ZEROPTD, 8) &&
           VerifyField<double>(verifier, VT_NETOBJSIG, 8) &&
           VerifyField<double>(verifier, VT_NETOBJSIGUNC, 8) &&
           VerifyField<double>(verifier, VT_MAG, 8) &&
           VerifyField<double>(verifier, VT_MAGUNC, 8) &&
           VerifyField<double>(verifier, VT_MAGNORMRANGE, 8) &&
           VerifyField<double>(verifier, VT_GEOLAT, 8) &&
           VerifyField<double>(verifier, VT_GEOLON, 8) &&
           VerifyField<double>(verifier, VT_GEOALT, 8) &&
           VerifyField<double>(verifier, VT_GEORANGE, 8) &&
           VerifyField<double>(verifier, VT_SKYBKGRND, 8) &&
           VerifyField<double>(verifier, VT_PRIMARYEXTINCTION, 8) &&
           VerifyField<double>(verifier, VT_PRIMARYEXTINCTIONUNC, 8) &&
           VerifyField<double>(verifier, VT_SOLARPHASEANGLE, 8) &&
           VerifyField<double>(verifier, VT_SOLAREQPHASEANGLE, 8) &&
           VerifyField<double>(verifier, VT_SOLARDECANGLE, 8) &&
           VerifyField<double>(verifier, VT_SHUTTERDELAY, 8) &&
           VerifyField<double>(verifier, VT_TIMINGBIAS, 8) &&
           VerifyOffset(verifier, VT_RAWFILEURI) &&
           verifier.VerifyString(rawFileURI()) &&
           VerifyField<double>(verifier, VT_INTENSITY, 8) &&
           VerifyField<double>(verifier, VT_BGINTENSITY, 8) &&
           VerifyOffset(verifier, VT_DESCRIPTOR) &&
           verifier.VerifyString(descriptor()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyField<int8_t>(verifier, VT_REFERENCEFRAME, 1) &&
           VerifyField<int8_t>(verifier, VT_SENREFERENCEFRAME, 1) &&
           VerifyField<uint8_t>(verifier, VT_UMBRA, 1) &&
           VerifyField<uint8_t>(verifier, VT_PENUMBRA, 1) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           verifier.EndTable();
  }
};

struct EOObservation_AbridgedBuilder {
  typedef EOObservation_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(EOObservation_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(EOObservation_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_obTime(::flatbuffers::Offset<::flatbuffers::String> obTime) {
    fbb_.AddOffset(EOObservation_Abridged::VT_OBTIME, obTime);
  }
  void add_corrQuality(double corrQuality) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_CORRQUALITY, corrQuality, 0.0);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(EOObservation_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(EOObservation_Abridged::VT_IDSENSOR, idSensor);
  }
  void add_idSkyImagery(::flatbuffers::Offset<::flatbuffers::String> idSkyImagery) {
    fbb_.AddOffset(EOObservation_Abridged::VT_IDSKYIMAGERY, idSkyImagery);
  }
  void add_collectMethod(::flatbuffers::Offset<::flatbuffers::String> collectMethod) {
    fbb_.AddOffset(EOObservation_Abridged::VT_COLLECTMETHOD, collectMethod);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(EOObservation_Abridged::VT_SATNO, satNo, 0);
  }
  void add_taskId(::flatbuffers::Offset<::flatbuffers::String> taskId) {
    fbb_.AddOffset(EOObservation_Abridged::VT_TASKID, taskId);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(EOObservation_Abridged::VT_TRANSACTIONID, transactionId);
  }
  void add_trackId(::flatbuffers::Offset<::flatbuffers::String> trackId) {
    fbb_.AddOffset(EOObservation_Abridged::VT_TRACKID, trackId);
  }
  void add_obPosition(::flatbuffers::Offset<::flatbuffers::String> obPosition) {
    fbb_.AddOffset(EOObservation_Abridged::VT_OBPOSITION, obPosition);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(EOObservation_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(EOObservation_Abridged::VT_ORIGSENSORID, origSensorId);
  }
  void add_uct(bool uct) {
    fbb_.AddElement<uint8_t>(EOObservation_Abridged::VT_UCT, static_cast<uint8_t>(uct), 0);
  }
  void add_azimuth(double azimuth) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_AZIMUTH, azimuth, 0.0);
  }
  void add_azimuthUnc(double azimuthUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_AZIMUTHUNC, azimuthUnc, 0.0);
  }
  void add_azimuthBias(double azimuthBias) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_AZIMUTHBIAS, azimuthBias, 0.0);
  }
  void add_azimuthRate(double azimuthRate) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_AZIMUTHRATE, azimuthRate, 0.0);
  }
  void add_elevation(double elevation) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_ELEVATION, elevation, 0.0);
  }
  void add_elevationUnc(double elevationUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_ELEVATIONUNC, elevationUnc, 0.0);
  }
  void add_elevationBias(double elevationBias) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_ELEVATIONBIAS, elevationBias, 0.0);
  }
  void add_elevationRate(double elevationRate) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_ELEVATIONRATE, elevationRate, 0.0);
  }
  void add_range(double range) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RANGE, range, 0.0);
  }
  void add_rangeUnc(double rangeUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RANGEUNC, rangeUnc, 0.0);
  }
  void add_rangeBias(double rangeBias) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RANGEBIAS, rangeBias, 0.0);
  }
  void add_rangeRate(double rangeRate) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RANGERATE, rangeRate, 0.0);
  }
  void add_rangeRateUnc(double rangeRateUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RANGERATEUNC, rangeRateUnc, 0.0);
  }
  void add_ra(double ra) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RA, ra, 0.0);
  }
  void add_raRate(double raRate) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RARATE, raRate, 0.0);
  }
  void add_raUnc(double raUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RAUNC, raUnc, 0.0);
  }
  void add_raBias(double raBias) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_RABIAS, raBias, 0.0);
  }
  void add_declination(double declination) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_DECLINATION, declination, 0.0);
  }
  void add_declinationRate(double declinationRate) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_DECLINATIONRATE, declinationRate, 0.0);
  }
  void add_declinationUnc(double declinationUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_DECLINATIONUNC, declinationUnc, 0.0);
  }
  void add_declinationBias(double declinationBias) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_DECLINATIONBIAS, declinationBias, 0.0);
  }
  void add_losx(double losx) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSX, losx, 0.0);
  }
  void add_losy(double losy) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSY, losy, 0.0);
  }
  void add_losz(double losz) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSZ, losz, 0.0);
  }
  void add_losUnc(double losUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSUNC, losUnc, 0.0);
  }
  void add_losxvel(double losxvel) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSXVEL, losxvel, 0.0);
  }
  void add_losyvel(double losyvel) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSYVEL, losyvel, 0.0);
  }
  void add_loszvel(double loszvel) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_LOSZVEL, loszvel, 0.0);
  }
  void add_senlat(double senlat) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENLAT, senlat, 0.0);
  }
  void add_senlon(double senlon) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENLON, senlon, 0.0);
  }
  void add_senalt(double senalt) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENALT, senalt, 0.0);
  }
  void add_senx(double senx) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENX, senx, 0.0);
  }
  void add_seny(double seny) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENY, seny, 0.0);
  }
  void add_senz(double senz) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENZ, senz, 0.0);
  }
  void add_senvelx(double senvelx) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENVELX, senvelx, 0.0);
  }
  void add_senvely(double senvely) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENVELY, senvely, 0.0);
  }
  void add_senvelz(double senvelz) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SENVELZ, senvelz, 0.0);
  }
  void add_senQuat(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> senQuat) {
    fbb_.AddOffset(EOObservation_Abridged::VT_SENQUAT, senQuat);
  }
  void add_fovCount(int32_t fovCount) {
    fbb_.AddElement<int32_t>(EOObservation_Abridged::VT_FOVCOUNT, fovCount, 0);
  }
  void add_expDuration(double expDuration) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_EXPDURATION, expDuration, 0.0);
  }
  void add_zeroptd(double zeroptd) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_ZEROPTD, zeroptd, 0.0);
  }
  void add_netObjSig(double netObjSig) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_NETOBJSIG, netObjSig, 0.0);
  }
  void add_netObjSigUnc(double netObjSigUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_NETOBJSIGUNC, netObjSigUnc, 0.0);
  }
  void add_mag(double mag) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_MAG, mag, 0.0);
  }
  void add_magUnc(double magUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_MAGUNC, magUnc, 0.0);
  }
  void add_magNormRange(double magNormRange) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_MAGNORMRANGE, magNormRange, 0.0);
  }
  void add_geolat(double geolat) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_GEOLAT, geolat, 0.0);
  }
  void add_geolon(double geolon) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_GEOLON, geolon, 0.0);
  }
  void add_geoalt(double geoalt) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_GEOALT, geoalt, 0.0);
  }
  void add_georange(double georange) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_GEORANGE, georange, 0.0);
  }
  void add_skyBkgrnd(double skyBkgrnd) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SKYBKGRND, skyBkgrnd, 0.0);
  }
  void add_primaryExtinction(double primaryExtinction) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_PRIMARYEXTINCTION, primaryExtinction, 0.0);
  }
  void add_primaryExtinctionUnc(double primaryExtinctionUnc) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_PRIMARYEXTINCTIONUNC, primaryExtinctionUnc, 0.0);
  }
  void add_solarPhaseAngle(double solarPhaseAngle) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SOLARPHASEANGLE, solarPhaseAngle, 0.0);
  }
  void add_solarEqPhaseAngle(double solarEqPhaseAngle) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SOLAREQPHASEANGLE, solarEqPhaseAngle, 0.0);
  }
  void add_solarDecAngle(double solarDecAngle) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SOLARDECANGLE, solarDecAngle, 0.0);
  }
  void add_shutterDelay(double shutterDelay) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_SHUTTERDELAY, shutterDelay, 0.0);
  }
  void add_timingBias(double timingBias) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_TIMINGBIAS, timingBias, 0.0);
  }
  void add_rawFileURI(::flatbuffers::Offset<::flatbuffers::String> rawFileURI) {
    fbb_.AddOffset(EOObservation_Abridged::VT_RAWFILEURI, rawFileURI);
  }
  void add_intensity(double intensity) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_INTENSITY, intensity, 0.0);
  }
  void add_bgIntensity(double bgIntensity) {
    fbb_.AddElement<double>(EOObservation_Abridged::VT_BGINTENSITY, bgIntensity, 0.0);
  }
  void add_descriptor(::flatbuffers::Offset<::flatbuffers::String> descriptor) {
    fbb_.AddOffset(EOObservation_Abridged::VT_DESCRIPTOR, descriptor);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(EOObservation_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(EOObservation_Abridged::VT_ORIGIN, origin);
  }
  void add_dataMode(EOObservation_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(EOObservation_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(EOObservation_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(EOObservation_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_referenceFrame(EOObservation_Abridged_referenceFrame_Enum referenceFrame) {
    fbb_.AddElement<int8_t>(EOObservation_Abridged::VT_REFERENCEFRAME, static_cast<int8_t>(referenceFrame), 0);
  }
  void add_senReferenceFrame(EOObservation_Abridged_senReferenceFrame_Enum senReferenceFrame) {
    fbb_.AddElement<int8_t>(EOObservation_Abridged::VT_SENREFERENCEFRAME, static_cast<int8_t>(senReferenceFrame), 0);
  }
  void add_umbra(bool umbra) {
    fbb_.AddElement<uint8_t>(EOObservation_Abridged::VT_UMBRA, static_cast<uint8_t>(umbra), 0);
  }
  void add_penumbra(bool penumbra) {
    fbb_.AddElement<uint8_t>(EOObservation_Abridged::VT_PENUMBRA, static_cast<uint8_t>(penumbra), 0);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(EOObservation_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(EOObservation_Abridged::VT_SOURCEDL, sourceDL);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(EOObservation_Abridged::VT_TYPE, type);
  }
  explicit EOObservation_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EOObservation_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EOObservation_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EOObservation_Abridged> CreateEOObservation_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obTime = 0,
    double corrQuality = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSkyImagery = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectMethod = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> taskId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> trackId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> obPosition = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    bool uct = false,
    double azimuth = 0.0,
    double azimuthUnc = 0.0,
    double azimuthBias = 0.0,
    double azimuthRate = 0.0,
    double elevation = 0.0,
    double elevationUnc = 0.0,
    double elevationBias = 0.0,
    double elevationRate = 0.0,
    double range = 0.0,
    double rangeUnc = 0.0,
    double rangeBias = 0.0,
    double rangeRate = 0.0,
    double rangeRateUnc = 0.0,
    double ra = 0.0,
    double raRate = 0.0,
    double raUnc = 0.0,
    double raBias = 0.0,
    double declination = 0.0,
    double declinationRate = 0.0,
    double declinationUnc = 0.0,
    double declinationBias = 0.0,
    double losx = 0.0,
    double losy = 0.0,
    double losz = 0.0,
    double losUnc = 0.0,
    double losxvel = 0.0,
    double losyvel = 0.0,
    double loszvel = 0.0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double senx = 0.0,
    double seny = 0.0,
    double senz = 0.0,
    double senvelx = 0.0,
    double senvely = 0.0,
    double senvelz = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> senQuat = 0,
    int32_t fovCount = 0,
    double expDuration = 0.0,
    double zeroptd = 0.0,
    double netObjSig = 0.0,
    double netObjSigUnc = 0.0,
    double mag = 0.0,
    double magUnc = 0.0,
    double magNormRange = 0.0,
    double geolat = 0.0,
    double geolon = 0.0,
    double geoalt = 0.0,
    double georange = 0.0,
    double skyBkgrnd = 0.0,
    double primaryExtinction = 0.0,
    double primaryExtinctionUnc = 0.0,
    double solarPhaseAngle = 0.0,
    double solarEqPhaseAngle = 0.0,
    double solarDecAngle = 0.0,
    double shutterDelay = 0.0,
    double timingBias = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> rawFileURI = 0,
    double intensity = 0.0,
    double bgIntensity = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> descriptor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    EOObservation_Abridged_dataMode_Enum dataMode = EOObservation_Abridged_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    EOObservation_Abridged_referenceFrame_Enum referenceFrame = EOObservation_Abridged_referenceFrame_Enum_J2000,
    EOObservation_Abridged_senReferenceFrame_Enum senReferenceFrame = EOObservation_Abridged_senReferenceFrame_Enum_J2000,
    bool umbra = false,
    bool penumbra = false,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0) {
  EOObservation_AbridgedBuilder builder_(_fbb);
  builder_.add_bgIntensity(bgIntensity);
  builder_.add_intensity(intensity);
  builder_.add_timingBias(timingBias);
  builder_.add_shutterDelay(shutterDelay);
  builder_.add_solarDecAngle(solarDecAngle);
  builder_.add_solarEqPhaseAngle(solarEqPhaseAngle);
  builder_.add_solarPhaseAngle(solarPhaseAngle);
  builder_.add_primaryExtinctionUnc(primaryExtinctionUnc);
  builder_.add_primaryExtinction(primaryExtinction);
  builder_.add_skyBkgrnd(skyBkgrnd);
  builder_.add_georange(georange);
  builder_.add_geoalt(geoalt);
  builder_.add_geolon(geolon);
  builder_.add_geolat(geolat);
  builder_.add_magNormRange(magNormRange);
  builder_.add_magUnc(magUnc);
  builder_.add_mag(mag);
  builder_.add_netObjSigUnc(netObjSigUnc);
  builder_.add_netObjSig(netObjSig);
  builder_.add_zeroptd(zeroptd);
  builder_.add_expDuration(expDuration);
  builder_.add_senvelz(senvelz);
  builder_.add_senvely(senvely);
  builder_.add_senvelx(senvelx);
  builder_.add_senz(senz);
  builder_.add_seny(seny);
  builder_.add_senx(senx);
  builder_.add_senalt(senalt);
  builder_.add_senlon(senlon);
  builder_.add_senlat(senlat);
  builder_.add_loszvel(loszvel);
  builder_.add_losyvel(losyvel);
  builder_.add_losxvel(losxvel);
  builder_.add_losUnc(losUnc);
  builder_.add_losz(losz);
  builder_.add_losy(losy);
  builder_.add_losx(losx);
  builder_.add_declinationBias(declinationBias);
  builder_.add_declinationUnc(declinationUnc);
  builder_.add_declinationRate(declinationRate);
  builder_.add_declination(declination);
  builder_.add_raBias(raBias);
  builder_.add_raUnc(raUnc);
  builder_.add_raRate(raRate);
  builder_.add_ra(ra);
  builder_.add_rangeRateUnc(rangeRateUnc);
  builder_.add_rangeRate(rangeRate);
  builder_.add_rangeBias(rangeBias);
  builder_.add_rangeUnc(rangeUnc);
  builder_.add_range(range);
  builder_.add_elevationRate(elevationRate);
  builder_.add_elevationBias(elevationBias);
  builder_.add_elevationUnc(elevationUnc);
  builder_.add_elevation(elevation);
  builder_.add_azimuthRate(azimuthRate);
  builder_.add_azimuthBias(azimuthBias);
  builder_.add_azimuthUnc(azimuthUnc);
  builder_.add_azimuth(azimuth);
  builder_.add_corrQuality(corrQuality);
  builder_.add_type(type);
  builder_.add_sourceDL(sourceDL);
  builder_.add_origNetwork(origNetwork);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_descriptor(descriptor);
  builder_.add_rawFileURI(rawFileURI);
  builder_.add_fovCount(fovCount);
  builder_.add_senQuat(senQuat);
  builder_.add_origSensorId(origSensorId);
  builder_.add_origObjectId(origObjectId);
  builder_.add_obPosition(obPosition);
  builder_.add_trackId(trackId);
  builder_.add_transactionId(transactionId);
  builder_.add_taskId(taskId);
  builder_.add_satNo(satNo);
  builder_.add_collectMethod(collectMethod);
  builder_.add_idSkyImagery(idSkyImagery);
  builder_.add_idSensor(idSensor);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_obTime(obTime);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_penumbra(penumbra);
  builder_.add_umbra(umbra);
  builder_.add_senReferenceFrame(senReferenceFrame);
  builder_.add_referenceFrame(referenceFrame);
  builder_.add_dataMode(dataMode);
  builder_.add_uct(uct);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EOObservation_Abridged> CreateEOObservation_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *obTime = nullptr,
    double corrQuality = 0.0,
    const char *idOnOrbit = nullptr,
    const char *idSensor = nullptr,
    const char *idSkyImagery = nullptr,
    const char *collectMethod = nullptr,
    int32_t satNo = 0,
    const char *taskId = nullptr,
    const char *transactionId = nullptr,
    const char *trackId = nullptr,
    const char *obPosition = nullptr,
    const char *origObjectId = nullptr,
    const char *origSensorId = nullptr,
    bool uct = false,
    double azimuth = 0.0,
    double azimuthUnc = 0.0,
    double azimuthBias = 0.0,
    double azimuthRate = 0.0,
    double elevation = 0.0,
    double elevationUnc = 0.0,
    double elevationBias = 0.0,
    double elevationRate = 0.0,
    double range = 0.0,
    double rangeUnc = 0.0,
    double rangeBias = 0.0,
    double rangeRate = 0.0,
    double rangeRateUnc = 0.0,
    double ra = 0.0,
    double raRate = 0.0,
    double raUnc = 0.0,
    double raBias = 0.0,
    double declination = 0.0,
    double declinationRate = 0.0,
    double declinationUnc = 0.0,
    double declinationBias = 0.0,
    double losx = 0.0,
    double losy = 0.0,
    double losz = 0.0,
    double losUnc = 0.0,
    double losxvel = 0.0,
    double losyvel = 0.0,
    double loszvel = 0.0,
    double senlat = 0.0,
    double senlon = 0.0,
    double senalt = 0.0,
    double senx = 0.0,
    double seny = 0.0,
    double senz = 0.0,
    double senvelx = 0.0,
    double senvely = 0.0,
    double senvelz = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *senQuat = nullptr,
    int32_t fovCount = 0,
    double expDuration = 0.0,
    double zeroptd = 0.0,
    double netObjSig = 0.0,
    double netObjSigUnc = 0.0,
    double mag = 0.0,
    double magUnc = 0.0,
    double magNormRange = 0.0,
    double geolat = 0.0,
    double geolon = 0.0,
    double geoalt = 0.0,
    double georange = 0.0,
    double skyBkgrnd = 0.0,
    double primaryExtinction = 0.0,
    double primaryExtinctionUnc = 0.0,
    double solarPhaseAngle = 0.0,
    double solarEqPhaseAngle = 0.0,
    double solarDecAngle = 0.0,
    double shutterDelay = 0.0,
    double timingBias = 0.0,
    const char *rawFileURI = nullptr,
    double intensity = 0.0,
    double bgIntensity = 0.0,
    const char *descriptor = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    EOObservation_Abridged_dataMode_Enum dataMode = EOObservation_Abridged_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    EOObservation_Abridged_referenceFrame_Enum referenceFrame = EOObservation_Abridged_referenceFrame_Enum_J2000,
    EOObservation_Abridged_senReferenceFrame_Enum senReferenceFrame = EOObservation_Abridged_senReferenceFrame_Enum_J2000,
    bool umbra = false,
    bool penumbra = false,
    const char *origNetwork = nullptr,
    const char *sourceDL = nullptr,
    const char *type = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto obTime__ = obTime ? _fbb.CreateString(obTime) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto idSkyImagery__ = idSkyImagery ? _fbb.CreateString(idSkyImagery) : 0;
  auto collectMethod__ = collectMethod ? _fbb.CreateString(collectMethod) : 0;
  auto taskId__ = taskId ? _fbb.CreateString(taskId) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto trackId__ = trackId ? _fbb.CreateString(trackId) : 0;
  auto obPosition__ = obPosition ? _fbb.CreateString(obPosition) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto senQuat__ = senQuat ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*senQuat) : 0;
  auto rawFileURI__ = rawFileURI ? _fbb.CreateString(rawFileURI) : 0;
  auto descriptor__ = descriptor ? _fbb.CreateString(descriptor) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  return CreateEOObservation_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      obTime__,
      corrQuality,
      idOnOrbit__,
      idSensor__,
      idSkyImagery__,
      collectMethod__,
      satNo,
      taskId__,
      transactionId__,
      trackId__,
      obPosition__,
      origObjectId__,
      origSensorId__,
      uct,
      azimuth,
      azimuthUnc,
      azimuthBias,
      azimuthRate,
      elevation,
      elevationUnc,
      elevationBias,
      elevationRate,
      range,
      rangeUnc,
      rangeBias,
      rangeRate,
      rangeRateUnc,
      ra,
      raRate,
      raUnc,
      raBias,
      declination,
      declinationRate,
      declinationUnc,
      declinationBias,
      losx,
      losy,
      losz,
      losUnc,
      losxvel,
      losyvel,
      loszvel,
      senlat,
      senlon,
      senalt,
      senx,
      seny,
      senz,
      senvelx,
      senvely,
      senvelz,
      senQuat__,
      fovCount,
      expDuration,
      zeroptd,
      netObjSig,
      netObjSigUnc,
      mag,
      magUnc,
      magNormRange,
      geolat,
      geolon,
      geoalt,
      georange,
      skyBkgrnd,
      primaryExtinction,
      primaryExtinctionUnc,
      solarPhaseAngle,
      solarEqPhaseAngle,
      solarDecAngle,
      shutterDelay,
      timingBias,
      rawFileURI__,
      intensity,
      bgIntensity,
      descriptor__,
      source__,
      origin__,
      dataMode,
      createdAt__,
      createdBy__,
      referenceFrame,
      senReferenceFrame,
      umbra,
      penumbra,
      origNetwork__,
      sourceDL__,
      type__);
}

inline const EOObservation_Abridged *GetEOObservation_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<EOObservation_Abridged>(buf);
}

inline const EOObservation_Abridged *GetSizePrefixedEOObservation_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<EOObservation_Abridged>(buf);
}

inline const char *EOObservation_AbridgedIdentifier() {
  return "EOOB";
}

inline bool EOObservation_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOObservation_AbridgedIdentifier());
}

inline bool SizePrefixedEOObservation_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, EOObservation_AbridgedIdentifier(), true);
}

inline bool VerifyEOObservation_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<EOObservation_Abridged>(EOObservation_AbridgedIdentifier());
}

inline bool VerifySizePrefixedEOObservation_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<EOObservation_Abridged>(EOObservation_AbridgedIdentifier());
}

inline void FinishEOObservation_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOObservation_Abridged> root) {
  fbb.Finish(root, EOObservation_AbridgedIdentifier());
}

inline void FinishSizePrefixedEOObservation_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<EOObservation_Abridged> root) {
  fbb.FinishSizePrefixed(root, EOObservation_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
