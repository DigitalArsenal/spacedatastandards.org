// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SolarArrayDetails_Ingest;
struct SolarArrayDetails_IngestBuilder;

enum SolarArrayDetails_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  SolarArrayDetails_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  SolarArrayDetails_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  SolarArrayDetails_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  SolarArrayDetails_Ingest_dataMode_Enum_EXERCISE = 3,
  SolarArrayDetails_Ingest_dataMode_Enum_MIN = SolarArrayDetails_Ingest_dataMode_Enum_REAL,
  SolarArrayDetails_Ingest_dataMode_Enum_MAX = SolarArrayDetails_Ingest_dataMode_Enum_EXERCISE
};

inline const SolarArrayDetails_Ingest_dataMode_Enum (&EnumValuesSolarArrayDetails_Ingest_dataMode_Enum())[4] {
  static const SolarArrayDetails_Ingest_dataMode_Enum values[] = {
    SolarArrayDetails_Ingest_dataMode_Enum_REAL,
    SolarArrayDetails_Ingest_dataMode_Enum_TEST,
    SolarArrayDetails_Ingest_dataMode_Enum_SIMULATED,
    SolarArrayDetails_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSolarArrayDetails_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSolarArrayDetails_Ingest_dataMode_Enum(SolarArrayDetails_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, SolarArrayDetails_Ingest_dataMode_Enum_REAL, SolarArrayDetails_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSolarArrayDetails_Ingest_dataMode_Enum()[index];
}

/// /// Model representation of Information on spacecraft SolarArrayDetails. A SolarArray may have multiple details records compiled by various sources.
struct SolarArrayDetails_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SolarArrayDetails_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_IDSOLARARRAY = 6,
    VT_CLASSIFICATIONMARKING = 8,
    VT_TYPE = 10,
    VT_TECHNOLOGY = 12,
    VT_JUNCTIONTECHNOLOGY = 14,
    VT_MANUFACTURERORGID = 16,
    VT_SPAN = 18,
    VT_AREA = 20,
    VT_DESCRIPTION = 22,
    VT_CREATEDAT = 24,
    VT_CREATEDBY = 26,
    VT_SOURCE = 28,
    VT_ORIGIN = 30,
    VT_ORIGNETWORK = 32,
    VT_DATAMODE = 34,
    VT_TAGS = 36
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SOLARARRAYDETAILS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Unique identifier of the parent SolarArray.
  /// Example: /// Example: SOLARARRAY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idSolarArray() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSOLARARRAY);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Type of solar array (e.g. U Shaped).
  /// Example: /// Example: U Shaped
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  /// Solar array technology (e.g. Ga-As).
  /// Example: /// Example: Ga-As
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *technology() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TECHNOLOGY);
  }
  /// Solar array junction technology (e.g. Triple).
  /// Example: /// Example: Triple
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *junctionTechnology() const {
    return GetPointer<const ::flatbuffers::String *>(VT_JUNCTIONTECHNOLOGY);
  }
  /// Unique identifier of the organization that manufactures the solar array.
  /// Example: /// Example: MANUFACTURERORG-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *manufacturerOrgId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MANUFACTURERORGID);
  }
  /// Solar Array span in meters.
  /// Example: /// Example: 123.4
  /// Constraints: No constraints specified.
  double span() const {
    return GetField<double>(VT_SPAN, 0.0);
  }
  /// Solar Array area in square meters.
  /// Example: /// Example: 123.4
  /// Constraints: No constraints specified.
  double area() const {
    return GetField<double>(VT_AREA, 0.0);
  }
  /// Solar array description/notes.
  /// Example: /// Example: Example notes
  /// Constraints: Minimum length = 0, Maximum length = 2147483647
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  SolarArrayDetails_Ingest_dataMode_Enum dataMode() const {
    return static_cast<SolarArrayDetails_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
  /// Example: /// Example: ['TAG1', 'TAG2']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tags() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TAGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_IDSOLARARRAY) &&
           verifier.VerifyString(idSolarArray()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_TECHNOLOGY) &&
           verifier.VerifyString(technology()) &&
           VerifyOffset(verifier, VT_JUNCTIONTECHNOLOGY) &&
           verifier.VerifyString(junctionTechnology()) &&
           VerifyOffset(verifier, VT_MANUFACTURERORGID) &&
           verifier.VerifyString(manufacturerOrgId()) &&
           VerifyField<double>(verifier, VT_SPAN, 8) &&
           VerifyField<double>(verifier, VT_AREA, 8) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_TAGS) &&
           verifier.VerifyVector(tags()) &&
           verifier.VerifyVectorOfStrings(tags()) &&
           verifier.EndTable();
  }
};

struct SolarArrayDetails_IngestBuilder {
  typedef SolarArrayDetails_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_ID, id);
  }
  void add_idSolarArray(::flatbuffers::Offset<::flatbuffers::String> idSolarArray) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_IDSOLARARRAY, idSolarArray);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_TYPE, type);
  }
  void add_technology(::flatbuffers::Offset<::flatbuffers::String> technology) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_TECHNOLOGY, technology);
  }
  void add_junctionTechnology(::flatbuffers::Offset<::flatbuffers::String> junctionTechnology) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_JUNCTIONTECHNOLOGY, junctionTechnology);
  }
  void add_manufacturerOrgId(::flatbuffers::Offset<::flatbuffers::String> manufacturerOrgId) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_MANUFACTURERORGID, manufacturerOrgId);
  }
  void add_span(double span) {
    fbb_.AddElement<double>(SolarArrayDetails_Ingest::VT_SPAN, span, 0.0);
  }
  void add_area(double area) {
    fbb_.AddElement<double>(SolarArrayDetails_Ingest::VT_AREA, area, 0.0);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_DESCRIPTION, description);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(SolarArrayDetails_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(SolarArrayDetails_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_tags(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags) {
    fbb_.AddOffset(SolarArrayDetails_Ingest::VT_TAGS, tags);
  }
  explicit SolarArrayDetails_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SolarArrayDetails_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SolarArrayDetails_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SolarArrayDetails_Ingest> CreateSolarArrayDetails_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSolarArray = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> technology = 0,
    ::flatbuffers::Offset<::flatbuffers::String> junctionTechnology = 0,
    ::flatbuffers::Offset<::flatbuffers::String> manufacturerOrgId = 0,
    double span = 0.0,
    double area = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    SolarArrayDetails_Ingest_dataMode_Enum dataMode = SolarArrayDetails_Ingest_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tags = 0) {
  SolarArrayDetails_IngestBuilder builder_(_fbb);
  builder_.add_area(area);
  builder_.add_span(span);
  builder_.add_tags(tags);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_description(description);
  builder_.add_manufacturerOrgId(manufacturerOrgId);
  builder_.add_junctionTechnology(junctionTechnology);
  builder_.add_technology(technology);
  builder_.add_type(type);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idSolarArray(idSolarArray);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SolarArrayDetails_Ingest> CreateSolarArrayDetails_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *idSolarArray = nullptr,
    const char *classificationMarking = nullptr,
    const char *type = nullptr,
    const char *technology = nullptr,
    const char *junctionTechnology = nullptr,
    const char *manufacturerOrgId = nullptr,
    double span = 0.0,
    double area = 0.0,
    const char *description = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    SolarArrayDetails_Ingest_dataMode_Enum dataMode = SolarArrayDetails_Ingest_dataMode_Enum_REAL,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tags = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto idSolarArray__ = idSolarArray ? _fbb.CreateString(idSolarArray) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto technology__ = technology ? _fbb.CreateString(technology) : 0;
  auto junctionTechnology__ = junctionTechnology ? _fbb.CreateString(junctionTechnology) : 0;
  auto manufacturerOrgId__ = manufacturerOrgId ? _fbb.CreateString(manufacturerOrgId) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto tags__ = tags ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tags) : 0;
  return CreateSolarArrayDetails_Ingest(
      _fbb,
      id__,
      idSolarArray__,
      classificationMarking__,
      type__,
      technology__,
      junctionTechnology__,
      manufacturerOrgId__,
      span,
      area,
      description__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      origNetwork__,
      dataMode,
      tags__);
}

inline const SolarArrayDetails_Ingest *GetSolarArrayDetails_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<SolarArrayDetails_Ingest>(buf);
}

inline const SolarArrayDetails_Ingest *GetSizePrefixedSolarArrayDetails_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SolarArrayDetails_Ingest>(buf);
}

inline const char *SolarArrayDetails_IngestIdentifier() {
  return "SOLA";
}

inline bool SolarArrayDetails_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SolarArrayDetails_IngestIdentifier());
}

inline bool SizePrefixedSolarArrayDetails_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SolarArrayDetails_IngestIdentifier(), true);
}

inline bool VerifySolarArrayDetails_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SolarArrayDetails_Ingest>(SolarArrayDetails_IngestIdentifier());
}

inline bool VerifySizePrefixedSolarArrayDetails_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SolarArrayDetails_Ingest>(SolarArrayDetails_IngestIdentifier());
}

inline void FinishSolarArrayDetails_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SolarArrayDetails_Ingest> root) {
  fbb.Finish(root, SolarArrayDetails_IngestIdentifier());
}

inline void FinishSizePrefixedSolarArrayDetails_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SolarArrayDetails_Ingest> root) {
  fbb.FinishSizePrefixed(root, SolarArrayDetails_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
