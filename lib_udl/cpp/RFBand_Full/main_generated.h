// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct RFBand_Full;
struct RFBand_FullBuilder;

enum RFBand_Full_mode_Enum : int8_t {
  /// No description available.
  RFBand_Full_mode_Enum_TX = 0,
  /// No description available.
  RFBand_Full_mode_Enum_RX = 1,
  RFBand_Full_mode_Enum_MIN = RFBand_Full_mode_Enum_TX,
  RFBand_Full_mode_Enum_MAX = RFBand_Full_mode_Enum_RX
};

inline const RFBand_Full_mode_Enum (&EnumValuesRFBand_Full_mode_Enum())[2] {
  static const RFBand_Full_mode_Enum values[] = {
    RFBand_Full_mode_Enum_TX,
    RFBand_Full_mode_Enum_RX
  };
  return values;
}

inline const char * const *EnumNamesRFBand_Full_mode_Enum() {
  static const char * const names[3] = {
    "TX",
    "RX",
    nullptr
  };
  return names;
}

inline const char *EnumNameRFBand_Full_mode_Enum(RFBand_Full_mode_Enum e) {
  if (::flatbuffers::IsOutRange(e, RFBand_Full_mode_Enum_TX, RFBand_Full_mode_Enum_RX)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRFBand_Full_mode_Enum()[index];
}

enum RFBand_Full_purpose_Enum : int8_t {
  /// No description available.
  RFBand_Full_purpose_Enum_COMM = 0,
  /// No description available.
  RFBand_Full_purpose_Enum_TTC = 1,
  /// No description available.
  RFBand_Full_purpose_Enum_OPS = 2,
  /// No description available.
  RFBand_Full_purpose_Enum_OTHER = 3,
  RFBand_Full_purpose_Enum_MIN = RFBand_Full_purpose_Enum_COMM,
  RFBand_Full_purpose_Enum_MAX = RFBand_Full_purpose_Enum_OTHER
};

inline const RFBand_Full_purpose_Enum (&EnumValuesRFBand_Full_purpose_Enum())[4] {
  static const RFBand_Full_purpose_Enum values[] = {
    RFBand_Full_purpose_Enum_COMM,
    RFBand_Full_purpose_Enum_TTC,
    RFBand_Full_purpose_Enum_OPS,
    RFBand_Full_purpose_Enum_OTHER
  };
  return values;
}

inline const char * const *EnumNamesRFBand_Full_purpose_Enum() {
  static const char * const names[5] = {
    "COMM",
    "TTC",
    "OPS",
    "OTHER",
    nullptr
  };
  return names;
}

inline const char *EnumNameRFBand_Full_purpose_Enum(RFBand_Full_purpose_Enum e) {
  if (::flatbuffers::IsOutRange(e, RFBand_Full_purpose_Enum_COMM, RFBand_Full_purpose_Enum_OTHER)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRFBand_Full_purpose_Enum()[index];
}

enum RFBand_Full_polarization_Enum : int8_t {
  /// No description available.
  RFBand_Full_polarization_Enum_H = 0,
  /// No description available.
  RFBand_Full_polarization_Enum_V = 1,
  /// No description available.
  RFBand_Full_polarization_Enum_R = 2,
  /// No description available.
  RFBand_Full_polarization_Enum_L = 3,
  RFBand_Full_polarization_Enum_MIN = RFBand_Full_polarization_Enum_H,
  RFBand_Full_polarization_Enum_MAX = RFBand_Full_polarization_Enum_L
};

inline const RFBand_Full_polarization_Enum (&EnumValuesRFBand_Full_polarization_Enum())[4] {
  static const RFBand_Full_polarization_Enum values[] = {
    RFBand_Full_polarization_Enum_H,
    RFBand_Full_polarization_Enum_V,
    RFBand_Full_polarization_Enum_R,
    RFBand_Full_polarization_Enum_L
  };
  return values;
}

inline const char * const *EnumNamesRFBand_Full_polarization_Enum() {
  static const char * const names[5] = {
    "H",
    "V",
    "R",
    "L",
    nullptr
  };
  return names;
}

inline const char *EnumNameRFBand_Full_polarization_Enum(RFBand_Full_polarization_Enum e) {
  if (::flatbuffers::IsOutRange(e, RFBand_Full_polarization_Enum_H, RFBand_Full_polarization_Enum_L)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRFBand_Full_polarization_Enum()[index];
}

enum RFBand_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  RFBand_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  RFBand_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  RFBand_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  RFBand_Full_dataMode_Enum_EXERCISE = 3,
  RFBand_Full_dataMode_Enum_MIN = RFBand_Full_dataMode_Enum_REAL,
  RFBand_Full_dataMode_Enum_MAX = RFBand_Full_dataMode_Enum_EXERCISE
};

inline const RFBand_Full_dataMode_Enum (&EnumValuesRFBand_Full_dataMode_Enum())[4] {
  static const RFBand_Full_dataMode_Enum values[] = {
    RFBand_Full_dataMode_Enum_REAL,
    RFBand_Full_dataMode_Enum_TEST,
    RFBand_Full_dataMode_Enum_SIMULATED,
    RFBand_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesRFBand_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameRFBand_Full_dataMode_Enum(RFBand_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, RFBand_Full_dataMode_Enum_REAL, RFBand_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRFBand_Full_dataMode_Enum()[index];
}

/// /// Details on a particular Radio Frequency (RF) band, also known as a carrier, which may be in use by any type of Entity for communications or operations.
struct RFBand_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RFBand_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_IDENTITY = 6,
    VT_CLASSIFICATIONMARKING = 8,
    VT_NAME = 10,
    VT_BAND = 12,
    VT_MODE = 14,
    VT_PURPOSE = 16,
    VT_FREQMIN = 18,
    VT_FREQMAX = 20,
    VT_CENTERFREQ = 22,
    VT_PEAKGAIN = 24,
    VT_EDGEGAIN = 26,
    VT_BANDWIDTH = 28,
    VT_BEAMWIDTH = 30,
    VT_POLARIZATION = 32,
    VT_ERP = 34,
    VT_EIRP = 36,
    VT_SOURCE = 38,
    VT_ORIGIN = 40,
    VT_DATAMODE = 42,
    VT_CREATEDAT = 44,
    VT_CREATEDBY = 46,
    VT_UPDATEDAT = 48,
    VT_UPDATEDBY = 50,
    VT_ORIGNETWORK = 52
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: RFBAND-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Unique identifier of the parent Entity which uses this band.
  /// Example: /// Example: ENTITY-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idEntity() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDENTITY);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// RF Band name.
  /// Example: /// Example: BAND_NAME
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  /// Name of the band of this RF range (e.g. X,K,Ku,Ka,L,S,C,UHF,VHF,EHF,SHF,UNK,VLF,HF,E,Q,V,W). See RFBandType for more details and descriptions of each band name.
  /// Example: /// Example: Ku
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *band() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BAND);
  }
  /// RF Band mode (e.g. TX, RX).
  /// Example: /// Example: TX
  /// Constraints: Minimum length = 0, Maximum length = 4
  RFBand_Full_mode_Enum mode() const {
    return static_cast<RFBand_Full_mode_Enum>(GetField<int8_t>(VT_MODE, 0));
  }
  /// Purpose or use of the RF Band -- COMM = communications, TTC = Telemetry/Tracking/Control, OPS = Operations, OTHER = Other).
  /// Example: /// Example: TTC
  /// Constraints: Minimum length = 0, Maximum length = 16
  RFBand_Full_purpose_Enum purpose() const {
    return static_cast<RFBand_Full_purpose_Enum>(GetField<int8_t>(VT_PURPOSE, 0));
  }
  /// Start/minimum of transmit RF frequency range, if applicable, in Mhz.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  double freqMin() const {
    return GetField<double>(VT_FREQMIN, 0.0);
  }
  /// End/maximum of transmit RF frequency range, if applicable, in Mhz.
  /// Example: /// Example: 2000.23
  /// Constraints: No constraints specified.
  double freqMax() const {
    return GetField<double>(VT_FREQMAX, 0.0);
  }
  /// Center frequency of RF frequency range, if applicable, in Mhz.
  /// Example: /// Example: 1000.23
  /// Constraints: No constraints specified.
  double centerFreq() const {
    return GetField<double>(VT_CENTERFREQ, 0.0);
  }
  /// RF Range maximum gain, in dBi.
  /// Example: /// Example: 120.23
  /// Constraints: No constraints specified.
  double peakGain() const {
    return GetField<double>(VT_PEAKGAIN, 0.0);
  }
  /// RF Range edge gain, in dBi.
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double edgeGain() const {
    return GetField<double>(VT_EDGEGAIN, 0.0);
  }
  /// RF Band frequency range bandwidth in Mhz.
  /// Example: /// Example: 100.23
  /// Constraints: No constraints specified.
  double bandwidth() const {
    return GetField<double>(VT_BANDWIDTH, 0.0);
  }
  /// Angle between the half-power (-3 dB) points of the main lobe of the antenna, in degrees.
  /// Example: /// Example: 45.23
  /// Constraints: No constraints specified.
  double beamwidth() const {
    return GetField<double>(VT_BEAMWIDTH, 0.0);
  }
  /// Transponder polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the Earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the Earth's surface.
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  RFBand_Full_polarization_Enum polarization() const {
    return static_cast<RFBand_Full_polarization_Enum>(GetField<int8_t>(VT_POLARIZATION, 0));
  }
  /// Effective Radiated Power (ERP) is the total power in decibel watts radiated by an actual antenna relative to a half-wave dipole rather than a theoretical isotropic antenna. A half-wave dipole has a gain of 2.15 dB compared to an isotropic antenna.  EIRP(dB) = ERP (dB)+2.15 dB or EIRP (W) = 1.64*ERP(W). Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
  /// Example: /// Example: 2.23
  /// Constraints: No constraints specified.
  double erp() const {
    return GetField<double>(VT_ERP, 0.0);
  }
  /// EIRP is defined as the RMS power input in decibel watts required to a lossless half-wave dipole antenna to give the same maximum power density far from the antenna as the actual transmitter. It is equal to the power input to the transmitter's antenna multiplied by the antenna gain relative to a half-wave dipole. Effective radiated power and effective isotropic radiated power both measure the amount of power a radio transmitter and antenna (or other source of electromagnetic waves) radiates in a specific direction: in the direction of maximum signal strength (the "main lobe") of its radiation pattern.
  /// Example: /// Example: 2.23
  /// Constraints: No constraints specified.
  double eirp() const {
    return GetField<double>(VT_EIRP, 0.0);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  RFBand_Full_dataMode_Enum dataMode() const {
    return static_cast<RFBand_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_IDENTITY) &&
           verifier.VerifyString(idEntity()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_BAND) &&
           verifier.VerifyString(band()) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_PURPOSE, 1) &&
           VerifyField<double>(verifier, VT_FREQMIN, 8) &&
           VerifyField<double>(verifier, VT_FREQMAX, 8) &&
           VerifyField<double>(verifier, VT_CENTERFREQ, 8) &&
           VerifyField<double>(verifier, VT_PEAKGAIN, 8) &&
           VerifyField<double>(verifier, VT_EDGEGAIN, 8) &&
           VerifyField<double>(verifier, VT_BANDWIDTH, 8) &&
           VerifyField<double>(verifier, VT_BEAMWIDTH, 8) &&
           VerifyField<int8_t>(verifier, VT_POLARIZATION, 1) &&
           VerifyField<double>(verifier, VT_ERP, 8) &&
           VerifyField<double>(verifier, VT_EIRP, 8) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct RFBand_FullBuilder {
  typedef RFBand_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(RFBand_Full::VT_ID, id);
  }
  void add_idEntity(::flatbuffers::Offset<::flatbuffers::String> idEntity) {
    fbb_.AddOffset(RFBand_Full::VT_IDENTITY, idEntity);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(RFBand_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(RFBand_Full::VT_NAME, name);
  }
  void add_band(::flatbuffers::Offset<::flatbuffers::String> band) {
    fbb_.AddOffset(RFBand_Full::VT_BAND, band);
  }
  void add_mode(RFBand_Full_mode_Enum mode) {
    fbb_.AddElement<int8_t>(RFBand_Full::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_purpose(RFBand_Full_purpose_Enum purpose) {
    fbb_.AddElement<int8_t>(RFBand_Full::VT_PURPOSE, static_cast<int8_t>(purpose), 0);
  }
  void add_freqMin(double freqMin) {
    fbb_.AddElement<double>(RFBand_Full::VT_FREQMIN, freqMin, 0.0);
  }
  void add_freqMax(double freqMax) {
    fbb_.AddElement<double>(RFBand_Full::VT_FREQMAX, freqMax, 0.0);
  }
  void add_centerFreq(double centerFreq) {
    fbb_.AddElement<double>(RFBand_Full::VT_CENTERFREQ, centerFreq, 0.0);
  }
  void add_peakGain(double peakGain) {
    fbb_.AddElement<double>(RFBand_Full::VT_PEAKGAIN, peakGain, 0.0);
  }
  void add_edgeGain(double edgeGain) {
    fbb_.AddElement<double>(RFBand_Full::VT_EDGEGAIN, edgeGain, 0.0);
  }
  void add_bandwidth(double bandwidth) {
    fbb_.AddElement<double>(RFBand_Full::VT_BANDWIDTH, bandwidth, 0.0);
  }
  void add_beamwidth(double beamwidth) {
    fbb_.AddElement<double>(RFBand_Full::VT_BEAMWIDTH, beamwidth, 0.0);
  }
  void add_polarization(RFBand_Full_polarization_Enum polarization) {
    fbb_.AddElement<int8_t>(RFBand_Full::VT_POLARIZATION, static_cast<int8_t>(polarization), 0);
  }
  void add_erp(double erp) {
    fbb_.AddElement<double>(RFBand_Full::VT_ERP, erp, 0.0);
  }
  void add_eirp(double eirp) {
    fbb_.AddElement<double>(RFBand_Full::VT_EIRP, eirp, 0.0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(RFBand_Full::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(RFBand_Full::VT_ORIGIN, origin);
  }
  void add_dataMode(RFBand_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(RFBand_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(RFBand_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(RFBand_Full::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(RFBand_Full::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(RFBand_Full::VT_UPDATEDBY, updatedBy);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(RFBand_Full::VT_ORIGNETWORK, origNetwork);
  }
  explicit RFBand_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RFBand_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RFBand_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RFBand_Full> CreateRFBand_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idEntity = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> band = 0,
    RFBand_Full_mode_Enum mode = RFBand_Full_mode_Enum_TX,
    RFBand_Full_purpose_Enum purpose = RFBand_Full_purpose_Enum_COMM,
    double freqMin = 0.0,
    double freqMax = 0.0,
    double centerFreq = 0.0,
    double peakGain = 0.0,
    double edgeGain = 0.0,
    double bandwidth = 0.0,
    double beamwidth = 0.0,
    RFBand_Full_polarization_Enum polarization = RFBand_Full_polarization_Enum_H,
    double erp = 0.0,
    double eirp = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    RFBand_Full_dataMode_Enum dataMode = RFBand_Full_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  RFBand_FullBuilder builder_(_fbb);
  builder_.add_eirp(eirp);
  builder_.add_erp(erp);
  builder_.add_beamwidth(beamwidth);
  builder_.add_bandwidth(bandwidth);
  builder_.add_edgeGain(edgeGain);
  builder_.add_peakGain(peakGain);
  builder_.add_centerFreq(centerFreq);
  builder_.add_freqMax(freqMax);
  builder_.add_freqMin(freqMin);
  builder_.add_origNetwork(origNetwork);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_band(band);
  builder_.add_name(name);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idEntity(idEntity);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_polarization(polarization);
  builder_.add_purpose(purpose);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RFBand_Full> CreateRFBand_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *idEntity = nullptr,
    const char *classificationMarking = nullptr,
    const char *name = nullptr,
    const char *band = nullptr,
    RFBand_Full_mode_Enum mode = RFBand_Full_mode_Enum_TX,
    RFBand_Full_purpose_Enum purpose = RFBand_Full_purpose_Enum_COMM,
    double freqMin = 0.0,
    double freqMax = 0.0,
    double centerFreq = 0.0,
    double peakGain = 0.0,
    double edgeGain = 0.0,
    double bandwidth = 0.0,
    double beamwidth = 0.0,
    RFBand_Full_polarization_Enum polarization = RFBand_Full_polarization_Enum_H,
    double erp = 0.0,
    double eirp = 0.0,
    const char *source = nullptr,
    const char *origin = nullptr,
    RFBand_Full_dataMode_Enum dataMode = RFBand_Full_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto idEntity__ = idEntity ? _fbb.CreateString(idEntity) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto band__ = band ? _fbb.CreateString(band) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateRFBand_Full(
      _fbb,
      id__,
      idEntity__,
      classificationMarking__,
      name__,
      band__,
      mode,
      purpose,
      freqMin,
      freqMax,
      centerFreq,
      peakGain,
      edgeGain,
      bandwidth,
      beamwidth,
      polarization,
      erp,
      eirp,
      source__,
      origin__,
      dataMode,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      origNetwork__);
}

inline const RFBand_Full *GetRFBand_Full(const void *buf) {
  return ::flatbuffers::GetRoot<RFBand_Full>(buf);
}

inline const RFBand_Full *GetSizePrefixedRFBand_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<RFBand_Full>(buf);
}

inline const char *RFBand_FullIdentifier() {
  return "RFBA";
}

inline bool RFBand_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RFBand_FullIdentifier());
}

inline bool SizePrefixedRFBand_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, RFBand_FullIdentifier(), true);
}

inline bool VerifyRFBand_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<RFBand_Full>(RFBand_FullIdentifier());
}

inline bool VerifySizePrefixedRFBand_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<RFBand_Full>(RFBand_FullIdentifier());
}

inline void FinishRFBand_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RFBand_Full> root) {
  fbb.Finish(root, RFBand_FullIdentifier());
}

inline void FinishSizePrefixedRFBand_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<RFBand_Full> root) {
  fbb.FinishSizePrefixed(root, RFBand_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
