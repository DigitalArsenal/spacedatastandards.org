// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct Sensorlimits_Full;
struct Sensorlimits_FullBuilder;

enum Sensorlimits_Full_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  Sensorlimits_Full_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  Sensorlimits_Full_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  Sensorlimits_Full_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  Sensorlimits_Full_dataMode_Enum_EXERCISE = 3,
  Sensorlimits_Full_dataMode_Enum_MIN = Sensorlimits_Full_dataMode_Enum_REAL,
  Sensorlimits_Full_dataMode_Enum_MAX = Sensorlimits_Full_dataMode_Enum_EXERCISE
};

inline const Sensorlimits_Full_dataMode_Enum (&EnumValuesSensorlimits_Full_dataMode_Enum())[4] {
  static const Sensorlimits_Full_dataMode_Enum values[] = {
    Sensorlimits_Full_dataMode_Enum_REAL,
    Sensorlimits_Full_dataMode_Enum_TEST,
    Sensorlimits_Full_dataMode_Enum_SIMULATED,
    Sensorlimits_Full_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSensorlimits_Full_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSensorlimits_Full_dataMode_Enum(Sensorlimits_Full_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, Sensorlimits_Full_dataMode_Enum_REAL, Sensorlimits_Full_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSensorlimits_Full_dataMode_Enum()[index];
}

/// /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
struct Sensorlimits_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Sensorlimits_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IDSENSORLIMITS = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_ORIGNETWORK = 8,
    VT_UPPERLEFTAZIMUTHLIMIT = 10,
    VT_UPPERRIGHTAZIMUTHLIMIT = 12,
    VT_LOWERRIGHTAZIMUTHLIMIT = 14,
    VT_LOWERLEFTAZIMUTHLIMIT = 16,
    VT_LOWERLEFTELEVATIONLIMIT = 18,
    VT_UPPERLEFTELEVATIONLIMIT = 20,
    VT_LOWERRIGHTELEVATIONLIMIT = 22,
    VT_UPPERRIGHTELEVATIONLIMIT = 24,
    VT_SOURCE = 26,
    VT_DATAMODE = 28,
    VT_CREATEDAT = 30,
    VT_CREATEDBY = 32,
    VT_UPDATEDAT = 34,
    VT_UPDATEDBY = 36,
    VT_IDSENSOR = 38
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SENSORLIMITS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idSensorLimits() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSORLIMITS);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperLeftAzimuthLimit() const {
    return GetField<double>(VT_UPPERLEFTAZIMUTHLIMIT, 0.0);
  }
  /// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperRightAzimuthLimit() const {
    return GetField<double>(VT_UPPERRIGHTAZIMUTHLIMIT, 0.0);
  }
  /// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerRightAzimuthLimit() const {
    return GetField<double>(VT_LOWERRIGHTAZIMUTHLIMIT, 0.0);
  }
  /// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerLeftAzimuthLimit() const {
    return GetField<double>(VT_LOWERLEFTAZIMUTHLIMIT, 0.0);
  }
  /// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerLeftElevationLimit() const {
    return GetField<double>(VT_LOWERLEFTELEVATIONLIMIT, 0.0);
  }
  /// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperLeftElevationLimit() const {
    return GetField<double>(VT_UPPERLEFTELEVATIONLIMIT, 0.0);
  }
  /// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double lowerRightElevationLimit() const {
    return GetField<double>(VT_LOWERRIGHTELEVATIONLIMIT, 0.0);
  }
  /// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
  /// Example: /// Example: 1.23
  /// Constraints: No constraints specified.
  double upperRightElevationLimit() const {
    return GetField<double>(VT_UPPERRIGHTELEVATIONLIMIT, 0.0);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  Sensorlimits_Full_dataMode_Enum dataMode() const {
    return static_cast<Sensorlimits_Full_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Time the row was last updated in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *updatedAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDAT);
  }
  /// Application user who updated the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *updatedBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UPDATEDBY);
  }
  /// Unique identifier of the target sensor object.
  /// Example: /// Example: SENSORLIMITS-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_IDSENSORLIMITS) &&
           verifier.VerifyString(idSensorLimits()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<double>(verifier, VT_UPPERLEFTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPERRIGHTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERRIGHTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERLEFTAZIMUTHLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERLEFTELEVATIONLIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPERLEFTELEVATIONLIMIT, 8) &&
           VerifyField<double>(verifier, VT_LOWERRIGHTELEVATIONLIMIT, 8) &&
           VerifyField<double>(verifier, VT_UPPERRIGHTELEVATIONLIMIT, 8) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_UPDATEDAT) &&
           verifier.VerifyString(updatedAt()) &&
           VerifyOffset(verifier, VT_UPDATEDBY) &&
           verifier.VerifyString(updatedBy()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           verifier.EndTable();
  }
};

struct Sensorlimits_FullBuilder {
  typedef Sensorlimits_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_idSensorLimits(::flatbuffers::Offset<::flatbuffers::String> idSensorLimits) {
    fbb_.AddOffset(Sensorlimits_Full::VT_IDSENSORLIMITS, idSensorLimits);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(Sensorlimits_Full::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(Sensorlimits_Full::VT_ORIGNETWORK, origNetwork);
  }
  void add_upperLeftAzimuthLimit(double upperLeftAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_UPPERLEFTAZIMUTHLIMIT, upperLeftAzimuthLimit, 0.0);
  }
  void add_upperRightAzimuthLimit(double upperRightAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_UPPERRIGHTAZIMUTHLIMIT, upperRightAzimuthLimit, 0.0);
  }
  void add_lowerRightAzimuthLimit(double lowerRightAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_LOWERRIGHTAZIMUTHLIMIT, lowerRightAzimuthLimit, 0.0);
  }
  void add_lowerLeftAzimuthLimit(double lowerLeftAzimuthLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_LOWERLEFTAZIMUTHLIMIT, lowerLeftAzimuthLimit, 0.0);
  }
  void add_lowerLeftElevationLimit(double lowerLeftElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_LOWERLEFTELEVATIONLIMIT, lowerLeftElevationLimit, 0.0);
  }
  void add_upperLeftElevationLimit(double upperLeftElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_UPPERLEFTELEVATIONLIMIT, upperLeftElevationLimit, 0.0);
  }
  void add_lowerRightElevationLimit(double lowerRightElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_LOWERRIGHTELEVATIONLIMIT, lowerRightElevationLimit, 0.0);
  }
  void add_upperRightElevationLimit(double upperRightElevationLimit) {
    fbb_.AddElement<double>(Sensorlimits_Full::VT_UPPERRIGHTELEVATIONLIMIT, upperRightElevationLimit, 0.0);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(Sensorlimits_Full::VT_SOURCE, source);
  }
  void add_dataMode(Sensorlimits_Full_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(Sensorlimits_Full::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(Sensorlimits_Full::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(Sensorlimits_Full::VT_CREATEDBY, createdBy);
  }
  void add_updatedAt(::flatbuffers::Offset<::flatbuffers::String> updatedAt) {
    fbb_.AddOffset(Sensorlimits_Full::VT_UPDATEDAT, updatedAt);
  }
  void add_updatedBy(::flatbuffers::Offset<::flatbuffers::String> updatedBy) {
    fbb_.AddOffset(Sensorlimits_Full::VT_UPDATEDBY, updatedBy);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(Sensorlimits_Full::VT_IDSENSOR, idSensor);
  }
  explicit Sensorlimits_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Sensorlimits_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Sensorlimits_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Sensorlimits_Full> CreateSensorlimits_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> idSensorLimits = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    double upperLeftAzimuthLimit = 0.0,
    double upperRightAzimuthLimit = 0.0,
    double lowerRightAzimuthLimit = 0.0,
    double lowerLeftAzimuthLimit = 0.0,
    double lowerLeftElevationLimit = 0.0,
    double upperLeftElevationLimit = 0.0,
    double lowerRightElevationLimit = 0.0,
    double upperRightElevationLimit = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    Sensorlimits_Full_dataMode_Enum dataMode = Sensorlimits_Full_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> updatedBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0) {
  Sensorlimits_FullBuilder builder_(_fbb);
  builder_.add_upperRightElevationLimit(upperRightElevationLimit);
  builder_.add_lowerRightElevationLimit(lowerRightElevationLimit);
  builder_.add_upperLeftElevationLimit(upperLeftElevationLimit);
  builder_.add_lowerLeftElevationLimit(lowerLeftElevationLimit);
  builder_.add_lowerLeftAzimuthLimit(lowerLeftAzimuthLimit);
  builder_.add_lowerRightAzimuthLimit(lowerRightAzimuthLimit);
  builder_.add_upperRightAzimuthLimit(upperRightAzimuthLimit);
  builder_.add_upperLeftAzimuthLimit(upperLeftAzimuthLimit);
  builder_.add_idSensor(idSensor);
  builder_.add_updatedBy(updatedBy);
  builder_.add_updatedAt(updatedAt);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_source(source);
  builder_.add_origNetwork(origNetwork);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_idSensorLimits(idSensorLimits);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Sensorlimits_Full> CreateSensorlimits_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *idSensorLimits = nullptr,
    const char *classificationMarking = nullptr,
    const char *origNetwork = nullptr,
    double upperLeftAzimuthLimit = 0.0,
    double upperRightAzimuthLimit = 0.0,
    double lowerRightAzimuthLimit = 0.0,
    double lowerLeftAzimuthLimit = 0.0,
    double lowerLeftElevationLimit = 0.0,
    double upperLeftElevationLimit = 0.0,
    double lowerRightElevationLimit = 0.0,
    double upperRightElevationLimit = 0.0,
    const char *source = nullptr,
    Sensorlimits_Full_dataMode_Enum dataMode = Sensorlimits_Full_dataMode_Enum_REAL,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *updatedAt = nullptr,
    const char *updatedBy = nullptr,
    const char *idSensor = nullptr) {
  auto idSensorLimits__ = idSensorLimits ? _fbb.CreateString(idSensorLimits) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto updatedAt__ = updatedAt ? _fbb.CreateString(updatedAt) : 0;
  auto updatedBy__ = updatedBy ? _fbb.CreateString(updatedBy) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  return CreateSensorlimits_Full(
      _fbb,
      idSensorLimits__,
      classificationMarking__,
      origNetwork__,
      upperLeftAzimuthLimit,
      upperRightAzimuthLimit,
      lowerRightAzimuthLimit,
      lowerLeftAzimuthLimit,
      lowerLeftElevationLimit,
      upperLeftElevationLimit,
      lowerRightElevationLimit,
      upperRightElevationLimit,
      source__,
      dataMode,
      createdAt__,
      createdBy__,
      updatedAt__,
      updatedBy__,
      idSensor__);
}

inline const Sensorlimits_Full *GetSensorlimits_Full(const void *buf) {
  return ::flatbuffers::GetRoot<Sensorlimits_Full>(buf);
}

inline const Sensorlimits_Full *GetSizePrefixedSensorlimits_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Sensorlimits_Full>(buf);
}

inline const char *Sensorlimits_FullIdentifier() {
  return "SENS";
}

inline bool Sensorlimits_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Sensorlimits_FullIdentifier());
}

inline bool SizePrefixedSensorlimits_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, Sensorlimits_FullIdentifier(), true);
}

inline bool VerifySensorlimits_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Sensorlimits_Full>(Sensorlimits_FullIdentifier());
}

inline bool VerifySizePrefixedSensorlimits_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Sensorlimits_Full>(Sensorlimits_FullIdentifier());
}

inline void FinishSensorlimits_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Sensorlimits_Full> root) {
  fbb.Finish(root, Sensorlimits_FullIdentifier());
}

inline void FinishSizePrefixedSensorlimits_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Sensorlimits_Full> root) {
  fbb.FinishSizePrefixed(root, Sensorlimits_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
