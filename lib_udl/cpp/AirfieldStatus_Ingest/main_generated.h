// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AirfieldStatus_Ingest;
struct AirfieldStatus_IngestBuilder;

enum AirfieldStatus_Ingest_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  AirfieldStatus_Ingest_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  AirfieldStatus_Ingest_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  AirfieldStatus_Ingest_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  AirfieldStatus_Ingest_dataMode_Enum_EXERCISE = 3,
  AirfieldStatus_Ingest_dataMode_Enum_MIN = AirfieldStatus_Ingest_dataMode_Enum_REAL,
  AirfieldStatus_Ingest_dataMode_Enum_MAX = AirfieldStatus_Ingest_dataMode_Enum_EXERCISE
};

inline const AirfieldStatus_Ingest_dataMode_Enum (&EnumValuesAirfieldStatus_Ingest_dataMode_Enum())[4] {
  static const AirfieldStatus_Ingest_dataMode_Enum values[] = {
    AirfieldStatus_Ingest_dataMode_Enum_REAL,
    AirfieldStatus_Ingest_dataMode_Enum_TEST,
    AirfieldStatus_Ingest_dataMode_Enum_SIMULATED,
    AirfieldStatus_Ingest_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesAirfieldStatus_Ingest_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAirfieldStatus_Ingest_dataMode_Enum(AirfieldStatus_Ingest_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, AirfieldStatus_Ingest_dataMode_Enum_REAL, AirfieldStatus_Ingest_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAirfieldStatus_Ingest_dataMode_Enum()[index];
}

/// /// The airfield status contains dynamic data of an airfield's capabilities.
struct AirfieldStatus_Ingest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AirfieldStatus_IngestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDAIRFIELD = 8,
    VT_ALTAIRFIELDID = 10,
    VT_PASSENGERSERVICEMOG = 12,
    VT_FLEETSERVICEMOG = 14,
    VT_CARGOMOG = 16,
    VT_FUELMOG = 18,
    VT_FUELTYPES = 20,
    VT_FUELQTYS = 22,
    VT_MXMOG = 24,
    VT_OPERATINGMOG = 26,
    VT_NUMCOG = 28,
    VT_WIDEWORKINGMOG = 30,
    VT_WIDEPARKINGMOG = 32,
    VT_NARROWWORKINGMOG = 34,
    VT_NARROWPARKINGMOG = 36,
    VT_MHETYPES = 38,
    VT_MHEQTYS = 40,
    VT_MEDCAP = 42,
    VT_ARFFCAT = 44,
    VT_GSETIME = 46,
    VT_PRIRWYNUM = 48,
    VT_RWYCONDREADING = 50,
    VT_RWYFRICTIONFACTOR = 52,
    VT_RWYMARKINGS = 54,
    VT_MESSAGE = 56,
    VT_PRIFREQ = 58,
    VT_SLOTTYPESREQ = 60,
    VT_CREATEDAT = 62,
    VT_CREATEDBY = 64,
    VT_SOURCEDL = 66,
    VT_SOURCE = 68,
    VT_ORIGIN = 70,
    VT_ORIGNETWORK = 72,
    VT_DATAMODE = 74
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the Airfield for which this status is referencing.
  /// Example: /// Example: 3136498f-2969-3535-1432-e984b2e2e686
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *idAirfield() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDAIRFIELD);
  }
  /// Alternate airfield identifier provided by the source.
  /// Example: /// Example: AIRFIELD-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *altAirfieldId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ALTAIRFIELDID);
  }
  /// Maximum on ground (MOG) number of high-reach/wide-body passenger aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  int32_t passengerServiceMOG() const {
    return GetField<int32_t>(VT_PASSENGERSERVICEMOG, 0);
  }
  /// Maximum on ground (MOG) number of fleet aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t fleetServiceMOG() const {
    return GetField<int32_t>(VT_FLEETSERVICEMOG, 0);
  }
  /// Maximum on ground (MOG) number of high-reach/wide-body cargo aircraft that can be serviced simultaneously based on spacing and manpower at the time of status.
  /// Example: /// Example: 8
  /// Constraints: No constraints specified.
  int32_t cargoMOG() const {
    return GetField<int32_t>(VT_CARGOMOG, 0);
  }
  /// Maximum on ground (MOG) number of aircraft that can be simultaneously refueled based on spacing and manpower at the time of status.
  /// Example: /// Example: 9
  /// Constraints: No constraints specified.
  int32_t fuelMOG() const {
    return GetField<int32_t>(VT_FUELMOG, 0);
  }
  /// Array of fuel types available at the airfield. This array must be the same length as fuelQtys.
  /// Example: /// Example: ['JP-8', 'Jet A', 'AVGAS']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *fuelTypes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_FUELTYPES);
  }
  /// Array of quantities for each fuel type at the airfield, in kilograms. The values in this array must correspond to the position index in fuelTypes. This array must be the same length as fuelTypes.
  /// Example: /// Example: [263083.6, 286674.9, 18143.69]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *fuelQtys() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_FUELQTYS);
  }
  /// Maximum on ground (MOG) number of aircraft that can be simultaneously ground handled for standard maintenance based on spacing and manpower at the time of status.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t mxMOG() const {
    return GetField<int32_t>(VT_MXMOG, 0);
  }
  /// Maximum on ground (MOG) number of aircraft due to items not directly related to the airfield infrastructure or aircraft servicing capability based on spacing and manpower at the time of status.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t operatingMOG() const {
    return GetField<int32_t>(VT_OPERATINGMOG, 0);
  }
  /// The number of aircraft that are currently on ground (COG) at the airfield.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t numCOG() const {
    return GetField<int32_t>(VT_NUMCOG, 0);
  }
  /// Maximum on ground (MOG) number of working wide-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t wideWorkingMOG() const {
    return GetField<int32_t>(VT_WIDEWORKINGMOG, 0);
  }
  /// Maximum on ground (MOG) number of parking wide-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 7
  /// Constraints: No constraints specified.
  int32_t wideParkingMOG() const {
    return GetField<int32_t>(VT_WIDEPARKINGMOG, 0);
  }
  /// Maximum on ground (MOG) number of working narrow-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 4
  /// Constraints: No constraints specified.
  int32_t narrowWorkingMOG() const {
    return GetField<int32_t>(VT_NARROWWORKINGMOG, 0);
  }
  /// Maximum on ground (MOG) number of parking narrow-body aircraft based on spacing and manpower at the time of status.
  /// Example: /// Example: 5
  /// Constraints: No constraints specified.
  int32_t narrowParkingMOG() const {
    return GetField<int32_t>(VT_NARROWPARKINGMOG, 0);
  }
  /// Array of material handling equipment types at the airfield. This array must be the same length as mheQtys.
  /// Example: /// Example: ['30k', 'AT', '60k']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mheTypes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MHETYPES);
  }
  /// Array of quantities for each material handling equipment types at the airfield. The values in this array must correspond to the position index in mheTypes. This array must be the same length as mheTypes.
  /// Example: /// Example: [1, 3, 1]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *mheQtys() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_MHEQTYS);
  }
  /// The level of medical support and capabilities available at the airfield.
  /// Example: /// Example: Large Field Hospital
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *medCap() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MEDCAP);
  }
  /// The category of aircraft rescue and fire fighting (ARFF) services that are currently available at the airfield. Entries should include  the code (FAA or ICAO) and the category.
  /// Example: /// Example: FAA-A
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *arffCat() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ARFFCAT);
  }
  /// The expected time to receive ground support equipment (e.g. power units, air units, cables, hoses, etc.), in minutes.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t gseTime() const {
    return GetField<int32_t>(VT_GSETIME, 0);
  }
  /// The number or ID of primary runway at the airfield.
  /// Example: /// Example: 35R
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *priRwyNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PRIRWYNUM);
  }
  /// The primary runway condition reading value used for determining runway braking action, from 0 to 26. A value of 0 indicates braking action is poor or non-existent, where a value of 26 indicates braking action is good.
  /// Example: /// Example: 23
  /// Constraints: No constraints specified.
  int32_t rwyCondReading() const {
    return GetField<int32_t>(VT_RWYCONDREADING, 0);
  }
  /// The primary runway friction factor which is dependent on the surface friction between the tires of the aircraft and the runway surface, from 0 to 100. A lower number indicates less friction and less braking response.
  /// Example: /// Example: 10
  /// Constraints: No constraints specified.
  int32_t rwyFrictionFactor() const {
    return GetField<int32_t>(VT_RWYFRICTIONFACTOR, 0);
  }
  /// Array of markings currently on the primary runway.
  /// Example: /// Example: ['Aiming Point', 'Threshold']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *rwyMarkings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_RWYMARKINGS);
  }
  /// Description of the current status of the airfield.
  /// Example: /// Example: Status message about the airfield.
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  /// The primary frequency which the airfield is currently operating, in megahertz.
  /// Example: /// Example: 123.45
  /// Constraints: No constraints specified.
  double priFreq() const {
    return GetField<double>(VT_PRIFREQ, 0.0);
  }
  /// Array of slot types that an airfield requires a particular aircraft provide in order to consume a slot at this location.
  /// Example: /// Example: ['PARKING', 'WORKING', 'LANDING']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *slotTypesReq() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SLOTTYPESREQ);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2022-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  AirfieldStatus_Ingest_dataMode_Enum dataMode() const {
    return static_cast<AirfieldStatus_Ingest_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDAIRFIELD) &&
           verifier.VerifyString(idAirfield()) &&
           VerifyOffset(verifier, VT_ALTAIRFIELDID) &&
           verifier.VerifyString(altAirfieldId()) &&
           VerifyField<int32_t>(verifier, VT_PASSENGERSERVICEMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_FLEETSERVICEMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_CARGOMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_FUELMOG, 4) &&
           VerifyOffset(verifier, VT_FUELTYPES) &&
           verifier.VerifyVector(fuelTypes()) &&
           verifier.VerifyVectorOfStrings(fuelTypes()) &&
           VerifyOffset(verifier, VT_FUELQTYS) &&
           verifier.VerifyVector(fuelQtys()) &&
           verifier.VerifyVectorOfStrings(fuelQtys()) &&
           VerifyField<int32_t>(verifier, VT_MXMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_OPERATINGMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMCOG, 4) &&
           VerifyField<int32_t>(verifier, VT_WIDEWORKINGMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_WIDEPARKINGMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_NARROWWORKINGMOG, 4) &&
           VerifyField<int32_t>(verifier, VT_NARROWPARKINGMOG, 4) &&
           VerifyOffset(verifier, VT_MHETYPES) &&
           verifier.VerifyVector(mheTypes()) &&
           verifier.VerifyVectorOfStrings(mheTypes()) &&
           VerifyOffset(verifier, VT_MHEQTYS) &&
           verifier.VerifyVector(mheQtys()) &&
           verifier.VerifyVectorOfStrings(mheQtys()) &&
           VerifyOffset(verifier, VT_MEDCAP) &&
           verifier.VerifyString(medCap()) &&
           VerifyOffset(verifier, VT_ARFFCAT) &&
           verifier.VerifyString(arffCat()) &&
           VerifyField<int32_t>(verifier, VT_GSETIME, 4) &&
           VerifyOffset(verifier, VT_PRIRWYNUM) &&
           verifier.VerifyString(priRwyNum()) &&
           VerifyField<int32_t>(verifier, VT_RWYCONDREADING, 4) &&
           VerifyField<int32_t>(verifier, VT_RWYFRICTIONFACTOR, 4) &&
           VerifyOffset(verifier, VT_RWYMARKINGS) &&
           verifier.VerifyVector(rwyMarkings()) &&
           verifier.VerifyVectorOfStrings(rwyMarkings()) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           VerifyField<double>(verifier, VT_PRIFREQ, 8) &&
           VerifyOffset(verifier, VT_SLOTTYPESREQ) &&
           verifier.VerifyVector(slotTypesReq()) &&
           verifier.VerifyVectorOfStrings(slotTypesReq()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct AirfieldStatus_IngestBuilder {
  typedef AirfieldStatus_Ingest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idAirfield(::flatbuffers::Offset<::flatbuffers::String> idAirfield) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_IDAIRFIELD, idAirfield);
  }
  void add_altAirfieldId(::flatbuffers::Offset<::flatbuffers::String> altAirfieldId) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_ALTAIRFIELDID, altAirfieldId);
  }
  void add_passengerServiceMOG(int32_t passengerServiceMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_PASSENGERSERVICEMOG, passengerServiceMOG, 0);
  }
  void add_fleetServiceMOG(int32_t fleetServiceMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_FLEETSERVICEMOG, fleetServiceMOG, 0);
  }
  void add_cargoMOG(int32_t cargoMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_CARGOMOG, cargoMOG, 0);
  }
  void add_fuelMOG(int32_t fuelMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_FUELMOG, fuelMOG, 0);
  }
  void add_fuelTypes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> fuelTypes) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_FUELTYPES, fuelTypes);
  }
  void add_fuelQtys(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> fuelQtys) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_FUELQTYS, fuelQtys);
  }
  void add_mxMOG(int32_t mxMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_MXMOG, mxMOG, 0);
  }
  void add_operatingMOG(int32_t operatingMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_OPERATINGMOG, operatingMOG, 0);
  }
  void add_numCOG(int32_t numCOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_NUMCOG, numCOG, 0);
  }
  void add_wideWorkingMOG(int32_t wideWorkingMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_WIDEWORKINGMOG, wideWorkingMOG, 0);
  }
  void add_wideParkingMOG(int32_t wideParkingMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_WIDEPARKINGMOG, wideParkingMOG, 0);
  }
  void add_narrowWorkingMOG(int32_t narrowWorkingMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_NARROWWORKINGMOG, narrowWorkingMOG, 0);
  }
  void add_narrowParkingMOG(int32_t narrowParkingMOG) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_NARROWPARKINGMOG, narrowParkingMOG, 0);
  }
  void add_mheTypes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mheTypes) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_MHETYPES, mheTypes);
  }
  void add_mheQtys(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mheQtys) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_MHEQTYS, mheQtys);
  }
  void add_medCap(::flatbuffers::Offset<::flatbuffers::String> medCap) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_MEDCAP, medCap);
  }
  void add_arffCat(::flatbuffers::Offset<::flatbuffers::String> arffCat) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_ARFFCAT, arffCat);
  }
  void add_gseTime(int32_t gseTime) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_GSETIME, gseTime, 0);
  }
  void add_priRwyNum(::flatbuffers::Offset<::flatbuffers::String> priRwyNum) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_PRIRWYNUM, priRwyNum);
  }
  void add_rwyCondReading(int32_t rwyCondReading) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_RWYCONDREADING, rwyCondReading, 0);
  }
  void add_rwyFrictionFactor(int32_t rwyFrictionFactor) {
    fbb_.AddElement<int32_t>(AirfieldStatus_Ingest::VT_RWYFRICTIONFACTOR, rwyFrictionFactor, 0);
  }
  void add_rwyMarkings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> rwyMarkings) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_RWYMARKINGS, rwyMarkings);
  }
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_MESSAGE, message);
  }
  void add_priFreq(double priFreq) {
    fbb_.AddElement<double>(AirfieldStatus_Ingest::VT_PRIFREQ, priFreq, 0.0);
  }
  void add_slotTypesReq(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> slotTypesReq) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_SLOTTYPESREQ, slotTypesReq);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_CREATEDBY, createdBy);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_SOURCEDL, sourceDL);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(AirfieldStatus_Ingest::VT_ORIGNETWORK, origNetwork);
  }
  void add_dataMode(AirfieldStatus_Ingest_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(AirfieldStatus_Ingest::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit AirfieldStatus_IngestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AirfieldStatus_Ingest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AirfieldStatus_Ingest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AirfieldStatus_Ingest> CreateAirfieldStatus_Ingest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idAirfield = 0,
    ::flatbuffers::Offset<::flatbuffers::String> altAirfieldId = 0,
    int32_t passengerServiceMOG = 0,
    int32_t fleetServiceMOG = 0,
    int32_t cargoMOG = 0,
    int32_t fuelMOG = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> fuelTypes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> fuelQtys = 0,
    int32_t mxMOG = 0,
    int32_t operatingMOG = 0,
    int32_t numCOG = 0,
    int32_t wideWorkingMOG = 0,
    int32_t wideParkingMOG = 0,
    int32_t narrowWorkingMOG = 0,
    int32_t narrowParkingMOG = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mheTypes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> mheQtys = 0,
    ::flatbuffers::Offset<::flatbuffers::String> medCap = 0,
    ::flatbuffers::Offset<::flatbuffers::String> arffCat = 0,
    int32_t gseTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> priRwyNum = 0,
    int32_t rwyCondReading = 0,
    int32_t rwyFrictionFactor = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> rwyMarkings = 0,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0,
    double priFreq = 0.0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> slotTypesReq = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    AirfieldStatus_Ingest_dataMode_Enum dataMode = AirfieldStatus_Ingest_dataMode_Enum_REAL) {
  AirfieldStatus_IngestBuilder builder_(_fbb);
  builder_.add_priFreq(priFreq);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_sourceDL(sourceDL);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_slotTypesReq(slotTypesReq);
  builder_.add_message(message);
  builder_.add_rwyMarkings(rwyMarkings);
  builder_.add_rwyFrictionFactor(rwyFrictionFactor);
  builder_.add_rwyCondReading(rwyCondReading);
  builder_.add_priRwyNum(priRwyNum);
  builder_.add_gseTime(gseTime);
  builder_.add_arffCat(arffCat);
  builder_.add_medCap(medCap);
  builder_.add_mheQtys(mheQtys);
  builder_.add_mheTypes(mheTypes);
  builder_.add_narrowParkingMOG(narrowParkingMOG);
  builder_.add_narrowWorkingMOG(narrowWorkingMOG);
  builder_.add_wideParkingMOG(wideParkingMOG);
  builder_.add_wideWorkingMOG(wideWorkingMOG);
  builder_.add_numCOG(numCOG);
  builder_.add_operatingMOG(operatingMOG);
  builder_.add_mxMOG(mxMOG);
  builder_.add_fuelQtys(fuelQtys);
  builder_.add_fuelTypes(fuelTypes);
  builder_.add_fuelMOG(fuelMOG);
  builder_.add_cargoMOG(cargoMOG);
  builder_.add_fleetServiceMOG(fleetServiceMOG);
  builder_.add_passengerServiceMOG(passengerServiceMOG);
  builder_.add_altAirfieldId(altAirfieldId);
  builder_.add_idAirfield(idAirfield);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AirfieldStatus_Ingest> CreateAirfieldStatus_IngestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idAirfield = nullptr,
    const char *altAirfieldId = nullptr,
    int32_t passengerServiceMOG = 0,
    int32_t fleetServiceMOG = 0,
    int32_t cargoMOG = 0,
    int32_t fuelMOG = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *fuelTypes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *fuelQtys = nullptr,
    int32_t mxMOG = 0,
    int32_t operatingMOG = 0,
    int32_t numCOG = 0,
    int32_t wideWorkingMOG = 0,
    int32_t wideParkingMOG = 0,
    int32_t narrowWorkingMOG = 0,
    int32_t narrowParkingMOG = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *mheTypes = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *mheQtys = nullptr,
    const char *medCap = nullptr,
    const char *arffCat = nullptr,
    int32_t gseTime = 0,
    const char *priRwyNum = nullptr,
    int32_t rwyCondReading = 0,
    int32_t rwyFrictionFactor = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *rwyMarkings = nullptr,
    const char *message = nullptr,
    double priFreq = 0.0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *slotTypesReq = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *sourceDL = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    AirfieldStatus_Ingest_dataMode_Enum dataMode = AirfieldStatus_Ingest_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idAirfield__ = idAirfield ? _fbb.CreateString(idAirfield) : 0;
  auto altAirfieldId__ = altAirfieldId ? _fbb.CreateString(altAirfieldId) : 0;
  auto fuelTypes__ = fuelTypes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*fuelTypes) : 0;
  auto fuelQtys__ = fuelQtys ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*fuelQtys) : 0;
  auto mheTypes__ = mheTypes ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*mheTypes) : 0;
  auto mheQtys__ = mheQtys ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*mheQtys) : 0;
  auto medCap__ = medCap ? _fbb.CreateString(medCap) : 0;
  auto arffCat__ = arffCat ? _fbb.CreateString(arffCat) : 0;
  auto priRwyNum__ = priRwyNum ? _fbb.CreateString(priRwyNum) : 0;
  auto rwyMarkings__ = rwyMarkings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*rwyMarkings) : 0;
  auto message__ = message ? _fbb.CreateString(message) : 0;
  auto slotTypesReq__ = slotTypesReq ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*slotTypesReq) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateAirfieldStatus_Ingest(
      _fbb,
      id__,
      classificationMarking__,
      idAirfield__,
      altAirfieldId__,
      passengerServiceMOG,
      fleetServiceMOG,
      cargoMOG,
      fuelMOG,
      fuelTypes__,
      fuelQtys__,
      mxMOG,
      operatingMOG,
      numCOG,
      wideWorkingMOG,
      wideParkingMOG,
      narrowWorkingMOG,
      narrowParkingMOG,
      mheTypes__,
      mheQtys__,
      medCap__,
      arffCat__,
      gseTime,
      priRwyNum__,
      rwyCondReading,
      rwyFrictionFactor,
      rwyMarkings__,
      message__,
      priFreq,
      slotTypesReq__,
      createdAt__,
      createdBy__,
      sourceDL__,
      source__,
      origin__,
      origNetwork__,
      dataMode);
}

inline const AirfieldStatus_Ingest *GetAirfieldStatus_Ingest(const void *buf) {
  return ::flatbuffers::GetRoot<AirfieldStatus_Ingest>(buf);
}

inline const AirfieldStatus_Ingest *GetSizePrefixedAirfieldStatus_Ingest(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AirfieldStatus_Ingest>(buf);
}

inline const char *AirfieldStatus_IngestIdentifier() {
  return "AIRF";
}

inline bool AirfieldStatus_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirfieldStatus_IngestIdentifier());
}

inline bool SizePrefixedAirfieldStatus_IngestBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirfieldStatus_IngestIdentifier(), true);
}

inline bool VerifyAirfieldStatus_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AirfieldStatus_Ingest>(AirfieldStatus_IngestIdentifier());
}

inline bool VerifySizePrefixedAirfieldStatus_IngestBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AirfieldStatus_Ingest>(AirfieldStatus_IngestIdentifier());
}

inline void FinishAirfieldStatus_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirfieldStatus_Ingest> root) {
  fbb.Finish(root, AirfieldStatus_IngestIdentifier());
}

inline void FinishSizePrefixedAirfieldStatus_IngestBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirfieldStatus_Ingest> root) {
  fbb.FinishSizePrefixed(root, AirfieldStatus_IngestIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
