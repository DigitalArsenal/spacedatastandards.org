// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AirTransportMissionHazMat_Full;
struct AirTransportMissionHazMat_FullBuilder;

/// /// Collection of Hazardous Material information associated with this Air Transport Mission.
struct AirTransportMissionHazMat_Full FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AirTransportMissionHazMat_FullBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTHAZMATID = 4,
    VT_ITEMNAME = 6,
    VT_UNNUM = 8,
    VT_PIECES = 10,
    VT_WEIGHT = 12,
    VT_NETEXPWT = 14,
    VT_CLASSDIV = 16,
    VT_CGC = 18,
    VT_CGN = 20,
    VT_APPLICABLENOTES = 22,
    VT_ONITIN = 24,
    VT_ONICAO = 26,
    VT_OFFITIN = 28,
    VT_OFFICAO = 30,
    VT_PLANNED = 32
  };
  /// The hazMat identifier provided by the originating source.
  /// Example: /// Example: cb6289e0f38534e01291ab6421d42724
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *extHazMatId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTHAZMATID);
  }
  /// United Nations proper shipping name of the hazardous material according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: LITHIUM METAL BATTERIES
  /// Constraints: Minimum length = 0, Maximum length = 1024
  const ::flatbuffers::String *itemName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ITEMNAME);
  }
  /// United Nations number or North America number that identifies hazardous materials according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: 0181
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *unNum() const {
    return GetPointer<const ::flatbuffers::String *>(VT_UNNUM);
  }
  /// Number of pieces of hazardous cargo.
  /// Example: /// Example: 29
  /// Constraints: No constraints specified.
  int32_t pieces() const {
    return GetField<int32_t>(VT_PIECES, 0);
  }
  /// Total weight of hazardous cargo, including non-explosive parts, in kilograms.
  /// Example: /// Example: 22.1
  /// Constraints: No constraints specified.
  double weight() const {
    return GetField<double>(VT_WEIGHT, 0.0);
  }
  /// Net explosive weight of the hazardous material, in kilograms.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  double netExpWt() const {
    return GetField<double>(VT_NETEXPWT, 0.0);
  }
  /// Class and division of the hazardous material according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double classDiv() const {
    return GetField<double>(VT_CLASSDIV, 0.0);
  }
  /// Compatibility group code used to specify the controls for the transportation and storage of hazardous materials according to the Hazardous Materials Regulations issued by the U.S. Department of Transportation.
  /// Example: /// Example: A
  /// Constraints: Minimum length = 0, Maximum length = 2
  const ::flatbuffers::String *cgc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CGC);
  }
  /// Comma delimited list of Note IDs for compatibility groups, specific to GDSS systems.
  /// Example: /// Example: 4,5,7,8
  /// Constraints: Minimum length = 0, Maximum length = 100
  const ::flatbuffers::String *cgn() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CGN);
  }
  /// Comma delimited list of Note IDs for Item Class Segregation groups, specific to GDSS systems.
  /// Example: /// Example: 11,12
  /// Constraints: Minimum length = 0, Maximum length = 100
  const ::flatbuffers::String *applicableNotes() const {
    return GetPointer<const ::flatbuffers::String *>(VT_APPLICABLENOTES);
  }
  /// Itinerary number that identifies where the hazardous material is loaded.
  /// Example: /// Example: 50
  /// Constraints: No constraints specified.
  int32_t onItin() const {
    return GetField<int32_t>(VT_ONITIN, 0);
  }
  /// The International Civil Aviation Organization (ICAO) code of the site where the hazardous material is loaded.
  /// Example: /// Example: LIRQ
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *onICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ONICAO);
  }
  /// Itinerary number that identifies where the hazardous material is unloaded.
  /// Example: /// Example: 300
  /// Constraints: No constraints specified.
  int32_t offItin() const {
    return GetField<int32_t>(VT_OFFITIN, 0);
  }
  /// The International Civil Aviation Organization (ICAO) code of the site where the hazardous material is unloaded.
  /// Example: /// Example: MBPV
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *offICAO() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OFFICAO);
  }
  /// Flag indicating if hazardous material is associated with this air transport mission. Possible values are P (planned to be associated with the mission) or A (actually associated with the mission). Enum: [P, A].
  /// Example: /// Example: P
  /// Constraints: Minimum length = 0, Maximum length = 1
  const ::flatbuffers::String *planned() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PLANNED);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EXTHAZMATID) &&
           verifier.VerifyString(extHazMatId()) &&
           VerifyOffset(verifier, VT_ITEMNAME) &&
           verifier.VerifyString(itemName()) &&
           VerifyOffset(verifier, VT_UNNUM) &&
           verifier.VerifyString(unNum()) &&
           VerifyField<int32_t>(verifier, VT_PIECES, 4) &&
           VerifyField<double>(verifier, VT_WEIGHT, 8) &&
           VerifyField<double>(verifier, VT_NETEXPWT, 8) &&
           VerifyField<double>(verifier, VT_CLASSDIV, 8) &&
           VerifyOffset(verifier, VT_CGC) &&
           verifier.VerifyString(cgc()) &&
           VerifyOffset(verifier, VT_CGN) &&
           verifier.VerifyString(cgn()) &&
           VerifyOffset(verifier, VT_APPLICABLENOTES) &&
           verifier.VerifyString(applicableNotes()) &&
           VerifyField<int32_t>(verifier, VT_ONITIN, 4) &&
           VerifyOffset(verifier, VT_ONICAO) &&
           verifier.VerifyString(onICAO()) &&
           VerifyField<int32_t>(verifier, VT_OFFITIN, 4) &&
           VerifyOffset(verifier, VT_OFFICAO) &&
           verifier.VerifyString(offICAO()) &&
           VerifyOffset(verifier, VT_PLANNED) &&
           verifier.VerifyString(planned()) &&
           verifier.EndTable();
  }
};

struct AirTransportMissionHazMat_FullBuilder {
  typedef AirTransportMissionHazMat_Full Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_extHazMatId(::flatbuffers::Offset<::flatbuffers::String> extHazMatId) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_EXTHAZMATID, extHazMatId);
  }
  void add_itemName(::flatbuffers::Offset<::flatbuffers::String> itemName) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_ITEMNAME, itemName);
  }
  void add_unNum(::flatbuffers::Offset<::flatbuffers::String> unNum) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_UNNUM, unNum);
  }
  void add_pieces(int32_t pieces) {
    fbb_.AddElement<int32_t>(AirTransportMissionHazMat_Full::VT_PIECES, pieces, 0);
  }
  void add_weight(double weight) {
    fbb_.AddElement<double>(AirTransportMissionHazMat_Full::VT_WEIGHT, weight, 0.0);
  }
  void add_netExpWt(double netExpWt) {
    fbb_.AddElement<double>(AirTransportMissionHazMat_Full::VT_NETEXPWT, netExpWt, 0.0);
  }
  void add_classDiv(double classDiv) {
    fbb_.AddElement<double>(AirTransportMissionHazMat_Full::VT_CLASSDIV, classDiv, 0.0);
  }
  void add_cgc(::flatbuffers::Offset<::flatbuffers::String> cgc) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_CGC, cgc);
  }
  void add_cgn(::flatbuffers::Offset<::flatbuffers::String> cgn) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_CGN, cgn);
  }
  void add_applicableNotes(::flatbuffers::Offset<::flatbuffers::String> applicableNotes) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_APPLICABLENOTES, applicableNotes);
  }
  void add_onItin(int32_t onItin) {
    fbb_.AddElement<int32_t>(AirTransportMissionHazMat_Full::VT_ONITIN, onItin, 0);
  }
  void add_onICAO(::flatbuffers::Offset<::flatbuffers::String> onICAO) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_ONICAO, onICAO);
  }
  void add_offItin(int32_t offItin) {
    fbb_.AddElement<int32_t>(AirTransportMissionHazMat_Full::VT_OFFITIN, offItin, 0);
  }
  void add_offICAO(::flatbuffers::Offset<::flatbuffers::String> offICAO) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_OFFICAO, offICAO);
  }
  void add_planned(::flatbuffers::Offset<::flatbuffers::String> planned) {
    fbb_.AddOffset(AirTransportMissionHazMat_Full::VT_PLANNED, planned);
  }
  explicit AirTransportMissionHazMat_FullBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AirTransportMissionHazMat_Full> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AirTransportMissionHazMat_Full>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AirTransportMissionHazMat_Full> CreateAirTransportMissionHazMat_Full(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> extHazMatId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> itemName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> unNum = 0,
    int32_t pieces = 0,
    double weight = 0.0,
    double netExpWt = 0.0,
    double classDiv = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> cgc = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cgn = 0,
    ::flatbuffers::Offset<::flatbuffers::String> applicableNotes = 0,
    int32_t onItin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> onICAO = 0,
    int32_t offItin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> offICAO = 0,
    ::flatbuffers::Offset<::flatbuffers::String> planned = 0) {
  AirTransportMissionHazMat_FullBuilder builder_(_fbb);
  builder_.add_classDiv(classDiv);
  builder_.add_netExpWt(netExpWt);
  builder_.add_weight(weight);
  builder_.add_planned(planned);
  builder_.add_offICAO(offICAO);
  builder_.add_offItin(offItin);
  builder_.add_onICAO(onICAO);
  builder_.add_onItin(onItin);
  builder_.add_applicableNotes(applicableNotes);
  builder_.add_cgn(cgn);
  builder_.add_cgc(cgc);
  builder_.add_pieces(pieces);
  builder_.add_unNum(unNum);
  builder_.add_itemName(itemName);
  builder_.add_extHazMatId(extHazMatId);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AirTransportMissionHazMat_Full> CreateAirTransportMissionHazMat_FullDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *extHazMatId = nullptr,
    const char *itemName = nullptr,
    const char *unNum = nullptr,
    int32_t pieces = 0,
    double weight = 0.0,
    double netExpWt = 0.0,
    double classDiv = 0.0,
    const char *cgc = nullptr,
    const char *cgn = nullptr,
    const char *applicableNotes = nullptr,
    int32_t onItin = 0,
    const char *onICAO = nullptr,
    int32_t offItin = 0,
    const char *offICAO = nullptr,
    const char *planned = nullptr) {
  auto extHazMatId__ = extHazMatId ? _fbb.CreateString(extHazMatId) : 0;
  auto itemName__ = itemName ? _fbb.CreateString(itemName) : 0;
  auto unNum__ = unNum ? _fbb.CreateString(unNum) : 0;
  auto cgc__ = cgc ? _fbb.CreateString(cgc) : 0;
  auto cgn__ = cgn ? _fbb.CreateString(cgn) : 0;
  auto applicableNotes__ = applicableNotes ? _fbb.CreateString(applicableNotes) : 0;
  auto onICAO__ = onICAO ? _fbb.CreateString(onICAO) : 0;
  auto offICAO__ = offICAO ? _fbb.CreateString(offICAO) : 0;
  auto planned__ = planned ? _fbb.CreateString(planned) : 0;
  return CreateAirTransportMissionHazMat_Full(
      _fbb,
      extHazMatId__,
      itemName__,
      unNum__,
      pieces,
      weight,
      netExpWt,
      classDiv,
      cgc__,
      cgn__,
      applicableNotes__,
      onItin,
      onICAO__,
      offItin,
      offICAO__,
      planned__);
}

inline const AirTransportMissionHazMat_Full *GetAirTransportMissionHazMat_Full(const void *buf) {
  return ::flatbuffers::GetRoot<AirTransportMissionHazMat_Full>(buf);
}

inline const AirTransportMissionHazMat_Full *GetSizePrefixedAirTransportMissionHazMat_Full(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AirTransportMissionHazMat_Full>(buf);
}

inline const char *AirTransportMissionHazMat_FullIdentifier() {
  return "AIRT";
}

inline bool AirTransportMissionHazMat_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirTransportMissionHazMat_FullIdentifier());
}

inline bool SizePrefixedAirTransportMissionHazMat_FullBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AirTransportMissionHazMat_FullIdentifier(), true);
}

inline bool VerifyAirTransportMissionHazMat_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AirTransportMissionHazMat_Full>(AirTransportMissionHazMat_FullIdentifier());
}

inline bool VerifySizePrefixedAirTransportMissionHazMat_FullBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AirTransportMissionHazMat_Full>(AirTransportMissionHazMat_FullIdentifier());
}

inline void FinishAirTransportMissionHazMat_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirTransportMissionHazMat_Full> root) {
  fbb.Finish(root, AirTransportMissionHazMat_FullIdentifier());
}

inline void FinishSizePrefixedAirTransportMissionHazMat_FullBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AirTransportMissionHazMat_Full> root) {
  fbb.FinishSizePrefixed(root, AirTransportMissionHazMat_FullIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
