// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct SARObservation_Abridged;
struct SARObservation_AbridgedBuilder;

enum SARObservation_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  SARObservation_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  SARObservation_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  SARObservation_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  SARObservation_Abridged_dataMode_Enum_EXERCISE = 3,
  SARObservation_Abridged_dataMode_Enum_MIN = SARObservation_Abridged_dataMode_Enum_REAL,
  SARObservation_Abridged_dataMode_Enum_MAX = SARObservation_Abridged_dataMode_Enum_EXERCISE
};

inline const SARObservation_Abridged_dataMode_Enum (&EnumValuesSARObservation_Abridged_dataMode_Enum())[4] {
  static const SARObservation_Abridged_dataMode_Enum values[] = {
    SARObservation_Abridged_dataMode_Enum_REAL,
    SARObservation_Abridged_dataMode_Enum_TEST,
    SARObservation_Abridged_dataMode_Enum_SIMULATED,
    SARObservation_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesSARObservation_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameSARObservation_Abridged_dataMode_Enum(SARObservation_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, SARObservation_Abridged_dataMode_Enum_REAL, SARObservation_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSARObservation_Abridged_dataMode_Enum()[index];
}

/// /// Model representation of observation data for SAR based sensor phenomenologies. J2000 is the preferred coordinate frame for all observations, but in some cases observations may be in another frame depending on the provider. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
struct SARObservation_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SARObservation_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDONORBIT = 8,
    VT_SATNO = 10,
    VT_ORIGOBJECTID = 12,
    VT_IDSENSOR = 14,
    VT_ORIGSENSORID = 16,
    VT_EXTERNALID = 18,
    VT_COLLECTIONID = 20,
    VT_DETECTIONID = 22,
    VT_COLLECTIONSTART = 24,
    VT_COLLECTIONEND = 26,
    VT_CENTERTIME = 28,
    VT_DETECTIONSTART = 30,
    VT_DETECTIONEND = 32,
    VT_DWELLTIME = 34,
    VT_ORBITSTATE = 36,
    VT_SARMODE = 38,
    VT_OPERATINGBAND = 40,
    VT_OPERATINGFREQ = 42,
    VT_SNR = 44,
    VT_TXPOLARIZATION = 46,
    VT_RXPOLARIZATION = 48,
    VT_GRAZEANGLE = 50,
    VT_INCIDENCEANGLE = 52,
    VT_SQUINTANGLE = 54,
    VT_PULSEBANDWIDTH = 56,
    VT_PULSEDURATION = 58,
    VT_CONTINUOUSSPOTANGLE = 60,
    VT_SLANTRANGE = 62,
    VT_NEARRANGE = 64,
    VT_FARRANGE = 66,
    VT_SWATHLENGTH = 68,
    VT_ATEXT = 70,
    VT_AGJSON = 72,
    VT_ATYPE = 74,
    VT_ANDIMS = 76,
    VT_ASRID = 78,
    VT_SPACINGRANGE = 80,
    VT_SPACINGAZIMUTH = 82,
    VT_LOOKSAZIMUTH = 84,
    VT_LOOKSRANGE = 86,
    VT_RESOLUTIONRANGE = 88,
    VT_RESOLUTIONAZIMUTH = 90,
    VT_OBDIRECTION = 92,
    VT_COORDSYS = 94,
    VT_TARGETPOSX = 96,
    VT_TARGETPOSY = 98,
    VT_TARGETPOSZ = 100,
    VT_SENALT = 102,
    VT_SENVELX = 104,
    VT_SENVELY = 106,
    VT_SENVELZ = 108,
    VT_SENLATSTART = 110,
    VT_SENLONSTART = 112,
    VT_SENLATEND = 114,
    VT_SENLONEND = 116,
    VT_TRANSACTIONID = 118,
    VT_SRCTYPS = 120,
    VT_SRCIDS = 122,
    VT_CREATEDAT = 124,
    VT_CREATEDBY = 126,
    VT_SOURCE = 128,
    VT_ORIGIN = 130,
    VT_ORIGNETWORK = 132,
    VT_SOURCEDL = 134,
    VT_DATAMODE = 136
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: SAROBSERVATION-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the spacecraft hosting the sensor associated with this collection.
  /// Example: /// Example: 36036
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idOnOrbit() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDONORBIT);
  }
  /// Satellite/Catalog number of the spacecraft hosting the sensor associated with this collection.
  /// Example: /// Example: 36036
  /// Constraints: No constraints specified.
  int32_t satNo() const {
    return GetField<int32_t>(VT_SATNO, 0);
  }
  /// Optional identifier provided by the source to indicate the onorbit object hosting the sensor associated with this collection. This may be an internal identifier and not necessarily a valid satellite number.
  /// Example: /// Example: 36036
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origObjectId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGOBJECTID);
  }
  /// Unique identifier of the reporting sensor.
  /// Example: /// Example: 36036-1L
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idSensor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDSENSOR);
  }
  /// Optional identifier provided by the source to indicate the sensor for this collection. This may be an internal identifier and not necessarily a valid sensor ID.
  /// Example: /// Example: SMOS-1L
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origSensorId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGSENSORID);
  }
  /// Optional ID from external systems. This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
  /// Example: /// Example: EXTERNAL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *externalId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALID);
  }
  /// Optional identifier to indicate the specific collection tasking which produced this observation.
  /// Example: /// Example: COLLECTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *collectionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONID);
  }
  /// Identifier of the specific detection within a collection which produced this observation.
  /// Example: /// Example: DETECTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *detectionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DETECTIONID);
  }
  /// Collection start time in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2023-04-22T17:35:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *collectionStart() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONSTART);
  }
  /// Collection end time in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2023-04-22T17:38:10.20177Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *collectionEnd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COLLECTIONEND);
  }
  /// The datetime at the center point of the collection in ISO 8601 UTC format with microsecond precision.
  /// Example: /// Example: 2023-04-22T17:36:35.100885Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *centerTime() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CENTERTIME);
  }
  /// The detection start time in ISO 8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2023-07-08T17:35:01.615396Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *detectionStart() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DETECTIONSTART);
  }
  /// The detection end time in ISO 8601 UTC format, with microsecond precision.
  /// Example: /// Example: 2023-07-08T17:35:20.77219Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *detectionEnd() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DETECTIONEND);
  }
  /// The duration, in seconds, of this detection.
  /// Example: /// Example: 79.156794
  /// Constraints: No constraints specified.
  double dwellTime() const {
    return GetField<double>(VT_DWELLTIME, 0.0);
  }
  /// The orbital direction (ASCENDING, DESCENDING) of the platform during the collection.
  /// Example: /// Example: ASCENDING
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *orbitState() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORBITSTATE);
  }
  /// Collection mode setting for this collection (e.g. AREA, SPOTLIGHT, STRIP, etc.).
  /// Example: /// Example: SPOTLIGHT
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *sarMode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SARMODE);
  }
  /// Name of the band containing operating frequency for the collection (e.g. C, E, EHF, HF, K, Ka, Ku, L, Q, S, SHF, UNK, UHF, V, VHF, VLF, W, X). See RFBandType for more details and descriptions of each band name.
  /// Example: /// Example: L
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *operatingBand() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OPERATINGBAND);
  }
  /// The operating frequency, in Mhz, for the collection.
  /// Example: /// Example: 2345.6
  /// Constraints: No constraints specified.
  double operatingFreq() const {
    return GetField<double>(VT_OPERATINGFREQ, 0.0);
  }
  /// Signal to noise ratio, in dB.
  /// Example: /// Example: 10.1
  /// Constraints: No constraints specified.
  double snr() const {
    return GetField<double>(VT_SNR, 0.0);
  }
  /// Transmit polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface.
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *txPolarization() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TXPOLARIZATION);
  }
  /// Receive polarization e.g. H - (Horizontally Polarized) Perpendicular to Earth's surface, V - (Vertically Polarized) Parallel to Earth's surface, L - (Left Hand Circularly Polarized) Rotating left relative to the earth's surface, R - (Right Hand Circularly Polarized) Rotating right relative to the earth's surface.
  /// Example: /// Example: H
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *rxPolarization() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RXPOLARIZATION);
  }
  /// The graze angle (also referred to as look angle) for the collection in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double grazeAngle() const {
    return GetField<double>(VT_GRAZEANGLE, 0.0);
  }
  /// The center incidence angle in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double incidenceAngle() const {
    return GetField<double>(VT_INCIDENCEANGLE, 0.0);
  }
  /// The squint angle for the collection in degrees.
  /// Example: /// Example: 1.2
  /// Constraints: No constraints specified.
  double squintAngle() const {
    return GetField<double>(VT_SQUINTANGLE, 0.0);
  }
  /// The bandwidth frequency of the pulse in Mhz.
  /// Example: /// Example: 500.1
  /// Constraints: No constraints specified.
  double pulseBandwidth() const {
    return GetField<double>(VT_PULSEBANDWIDTH, 0.0);
  }
  /// The duration of a pulse in seconds.
  /// Example: /// Example: 1.1e-05
  /// Constraints: No constraints specified.
  double pulseDuration() const {
    return GetField<double>(VT_PULSEDURATION, 0.0);
  }
  /// Required sweep angle for the continuous spot scene in degrees.
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double continuousSpotAngle() const {
    return GetField<double>(VT_CONTINUOUSSPOTANGLE, 0.0);
  }
  /// Slant distance from sensor to center point of imaging event in kilometers.
  /// Example: /// Example: 60.1
  /// Constraints: No constraints specified.
  double slantRange() const {
    return GetField<double>(VT_SLANTRANGE, 0.0);
  }
  /// Specifies the closest range, in kilometers, from the flight path to target during the collection.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  double nearRange() const {
    return GetField<double>(VT_NEARRANGE, 0.0);
  }
  /// Specifies the farthest range, in kilometers, from the flight path to target during the collection.
  /// Example: /// Example: 34.1
  /// Constraints: No constraints specified.
  double farRange() const {
    return GetField<double>(VT_FARRANGE, 0.0);
  }
  /// The length of the collection as projected on the ground in kilometers.
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  double swathLength() const {
    return GetField<double>(VT_SWATHLENGTH, 0.0);
  }
  /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
  /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *atext() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATEXT);
  }
  /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
  /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *agjson() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AGJSON);
  }
  /// Type of region as projected on the ground (POLYGON, POINT, LINE).
  /// Example: /// Example: POLYGON
  /// Constraints: Minimum length = 0, Maximum length = 128
  const ::flatbuffers::String *atype() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ATYPE);
  }
  /// Number of dimensions of the geometry depicted by region.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t andims() const {
    return GetField<int32_t>(VT_ANDIMS, 0);
  }
  /// Geographical spatial_ref_sys for region.
  /// Example: /// Example: 3
  /// Constraints: No constraints specified.
  int32_t asrid() const {
    return GetField<int32_t>(VT_ASRID, 0);
  }
  /// The pixel spacing in the range direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  double spacingRange() const {
    return GetField<double>(VT_SPACINGRANGE, 0.0);
  }
  /// The pixel spacing in the azimuth direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  double spacingAzimuth() const {
    return GetField<double>(VT_SPACINGAZIMUTH, 0.0);
  }
  /// The number of looks in the azimuth direction.
  /// Example: /// Example: 2
  /// Constraints: No constraints specified.
  int32_t looksAzimuth() const {
    return GetField<int32_t>(VT_LOOKSAZIMUTH, 0);
  }
  /// The number of looks in the range direction.
  /// Example: /// Example: 1
  /// Constraints: No constraints specified.
  int32_t looksRange() const {
    return GetField<int32_t>(VT_LOOKSRANGE, 0);
  }
  /// The resolution in the range direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  double resolutionRange() const {
    return GetField<double>(VT_RESOLUTIONRANGE, 0.0);
  }
  /// The resolution in the azimuth direction measured in meters.
  /// Example: /// Example: 0.123
  /// Constraints: No constraints specified.
  double resolutionAzimuth() const {
    return GetField<double>(VT_RESOLUTIONAZIMUTH, 0.0);
  }
  /// The antenna pointing direction (LEFT, RIGHT).
  /// Example: /// Example: RIGHT
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *obDirection() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OBDIRECTION);
  }
  /// The coordinate system used for the sensor velocity and target position vectors for the collection.
  /// Example: /// Example: ECEF
  /// Constraints: Minimum length = 0, Maximum length = 16
  const ::flatbuffers::String *coordSys() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COORDSYS);
  }
  /// The collection target X position in kilometers.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  double targetposx() const {
    return GetField<double>(VT_TARGETPOSX, 0.0);
  }
  /// The collection target Y position in kilometers.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  double targetposy() const {
    return GetField<double>(VT_TARGETPOSY, 0.0);
  }
  /// The collection target Z position in kilometers.
  /// Example: /// Example: 50.23
  /// Constraints: No constraints specified.
  double targetposz() const {
    return GetField<double>(VT_TARGETPOSZ, 0.0);
  }
  /// Sensor altitude during collection in kilometers.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senalt() const {
    return GetField<double>(VT_SENALT, 0.0);
  }
  /// Sensor platform X-velocity during collection in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvelx() const {
    return GetField<double>(VT_SENVELX, 0.0);
  }
  /// Sensor platform Y-velocity during collection in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvely() const {
    return GetField<double>(VT_SENVELY, 0.0);
  }
  /// Sensor platform Z-velocity during collection in kilometers/second.
  /// Example: /// Example: 1.1
  /// Constraints: No constraints specified.
  double senvelz() const {
    return GetField<double>(VT_SENVELZ, 0.0);
  }
  /// WGS-84 sensor latitude sub-point at collect start time (collectionStart), represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double senlatStart() const {
    return GetField<double>(VT_SENLATSTART, 0.0);
  }
  /// WGS-84 sensor longitude sub-point at collect start time (collectionStart), represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  double senlonStart() const {
    return GetField<double>(VT_SENLONSTART, 0.0);
  }
  /// WGS-84 sensor latitude sub-point at collect end time (collectionEnd), represented as -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 45.1
  /// Constraints: No constraints specified.
  double senlatEnd() const {
    return GetField<double>(VT_SENLATEND, 0.0);
  }
  /// WGS-84 sensor longitude sub-point at collect end time (collectionEnd), represented as -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: 179.1
  /// Constraints: No constraints specified.
  double senlonEnd() const {
    return GetField<double>(VT_SENLONEND, 0.0);
  }
  /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
  /// Example: /// Example: TRANSACTION-ID
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *transactionId() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TRANSACTIONID);
  }
  /// Array of UDL record types (e.g. ANALYTICMAGERY, ESID, GROUNDIMAGE, NOTIFICATION, POI, SV, TRACK) that are related to the SAR Observation. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
  /// Example: /// Example: ['ESID', 'GROUNDIMAGE']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *srcTyps() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRCTYPS);
  }
  /// Array of UUIDs of the UDL data records that are related to the SAR Observation. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/sarobservation/{uuid}).
  /// Example: /// Example: ['f7e01cd4-626b-441f-a423-17b160eb78ba', '223833c4-be0d-4fdb-a2e4-325a48eccced']
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *srcIds() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_SRCIDS);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2023-04-22T17:51:40.854Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: OPS1
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  SARObservation_Abridged_dataMode_Enum dataMode() const {
    return static_cast<SARObservation_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDONORBIT) &&
           verifier.VerifyString(idOnOrbit()) &&
           VerifyField<int32_t>(verifier, VT_SATNO, 4) &&
           VerifyOffset(verifier, VT_ORIGOBJECTID) &&
           verifier.VerifyString(origObjectId()) &&
           VerifyOffset(verifier, VT_IDSENSOR) &&
           verifier.VerifyString(idSensor()) &&
           VerifyOffset(verifier, VT_ORIGSENSORID) &&
           verifier.VerifyString(origSensorId()) &&
           VerifyOffset(verifier, VT_EXTERNALID) &&
           verifier.VerifyString(externalId()) &&
           VerifyOffset(verifier, VT_COLLECTIONID) &&
           verifier.VerifyString(collectionId()) &&
           VerifyOffset(verifier, VT_DETECTIONID) &&
           verifier.VerifyString(detectionId()) &&
           VerifyOffset(verifier, VT_COLLECTIONSTART) &&
           verifier.VerifyString(collectionStart()) &&
           VerifyOffset(verifier, VT_COLLECTIONEND) &&
           verifier.VerifyString(collectionEnd()) &&
           VerifyOffset(verifier, VT_CENTERTIME) &&
           verifier.VerifyString(centerTime()) &&
           VerifyOffset(verifier, VT_DETECTIONSTART) &&
           verifier.VerifyString(detectionStart()) &&
           VerifyOffset(verifier, VT_DETECTIONEND) &&
           verifier.VerifyString(detectionEnd()) &&
           VerifyField<double>(verifier, VT_DWELLTIME, 8) &&
           VerifyOffset(verifier, VT_ORBITSTATE) &&
           verifier.VerifyString(orbitState()) &&
           VerifyOffset(verifier, VT_SARMODE) &&
           verifier.VerifyString(sarMode()) &&
           VerifyOffset(verifier, VT_OPERATINGBAND) &&
           verifier.VerifyString(operatingBand()) &&
           VerifyField<double>(verifier, VT_OPERATINGFREQ, 8) &&
           VerifyField<double>(verifier, VT_SNR, 8) &&
           VerifyOffset(verifier, VT_TXPOLARIZATION) &&
           verifier.VerifyString(txPolarization()) &&
           VerifyOffset(verifier, VT_RXPOLARIZATION) &&
           verifier.VerifyString(rxPolarization()) &&
           VerifyField<double>(verifier, VT_GRAZEANGLE, 8) &&
           VerifyField<double>(verifier, VT_INCIDENCEANGLE, 8) &&
           VerifyField<double>(verifier, VT_SQUINTANGLE, 8) &&
           VerifyField<double>(verifier, VT_PULSEBANDWIDTH, 8) &&
           VerifyField<double>(verifier, VT_PULSEDURATION, 8) &&
           VerifyField<double>(verifier, VT_CONTINUOUSSPOTANGLE, 8) &&
           VerifyField<double>(verifier, VT_SLANTRANGE, 8) &&
           VerifyField<double>(verifier, VT_NEARRANGE, 8) &&
           VerifyField<double>(verifier, VT_FARRANGE, 8) &&
           VerifyField<double>(verifier, VT_SWATHLENGTH, 8) &&
           VerifyOffset(verifier, VT_ATEXT) &&
           verifier.VerifyString(atext()) &&
           VerifyOffset(verifier, VT_AGJSON) &&
           verifier.VerifyString(agjson()) &&
           VerifyOffset(verifier, VT_ATYPE) &&
           verifier.VerifyString(atype()) &&
           VerifyField<int32_t>(verifier, VT_ANDIMS, 4) &&
           VerifyField<int32_t>(verifier, VT_ASRID, 4) &&
           VerifyField<double>(verifier, VT_SPACINGRANGE, 8) &&
           VerifyField<double>(verifier, VT_SPACINGAZIMUTH, 8) &&
           VerifyField<int32_t>(verifier, VT_LOOKSAZIMUTH, 4) &&
           VerifyField<int32_t>(verifier, VT_LOOKSRANGE, 4) &&
           VerifyField<double>(verifier, VT_RESOLUTIONRANGE, 8) &&
           VerifyField<double>(verifier, VT_RESOLUTIONAZIMUTH, 8) &&
           VerifyOffset(verifier, VT_OBDIRECTION) &&
           verifier.VerifyString(obDirection()) &&
           VerifyOffset(verifier, VT_COORDSYS) &&
           verifier.VerifyString(coordSys()) &&
           VerifyField<double>(verifier, VT_TARGETPOSX, 8) &&
           VerifyField<double>(verifier, VT_TARGETPOSY, 8) &&
           VerifyField<double>(verifier, VT_TARGETPOSZ, 8) &&
           VerifyField<double>(verifier, VT_SENALT, 8) &&
           VerifyField<double>(verifier, VT_SENVELX, 8) &&
           VerifyField<double>(verifier, VT_SENVELY, 8) &&
           VerifyField<double>(verifier, VT_SENVELZ, 8) &&
           VerifyField<double>(verifier, VT_SENLATSTART, 8) &&
           VerifyField<double>(verifier, VT_SENLONSTART, 8) &&
           VerifyField<double>(verifier, VT_SENLATEND, 8) &&
           VerifyField<double>(verifier, VT_SENLONEND, 8) &&
           VerifyOffset(verifier, VT_TRANSACTIONID) &&
           verifier.VerifyString(transactionId()) &&
           VerifyOffset(verifier, VT_SRCTYPS) &&
           verifier.VerifyVector(srcTyps()) &&
           verifier.VerifyVectorOfStrings(srcTyps()) &&
           VerifyOffset(verifier, VT_SRCIDS) &&
           verifier.VerifyVector(srcIds()) &&
           verifier.VerifyVectorOfStrings(srcIds()) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           verifier.EndTable();
  }
};

struct SARObservation_AbridgedBuilder {
  typedef SARObservation_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(SARObservation_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idOnOrbit(::flatbuffers::Offset<::flatbuffers::String> idOnOrbit) {
    fbb_.AddOffset(SARObservation_Abridged::VT_IDONORBIT, idOnOrbit);
  }
  void add_satNo(int32_t satNo) {
    fbb_.AddElement<int32_t>(SARObservation_Abridged::VT_SATNO, satNo, 0);
  }
  void add_origObjectId(::flatbuffers::Offset<::flatbuffers::String> origObjectId) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ORIGOBJECTID, origObjectId);
  }
  void add_idSensor(::flatbuffers::Offset<::flatbuffers::String> idSensor) {
    fbb_.AddOffset(SARObservation_Abridged::VT_IDSENSOR, idSensor);
  }
  void add_origSensorId(::flatbuffers::Offset<::flatbuffers::String> origSensorId) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ORIGSENSORID, origSensorId);
  }
  void add_externalId(::flatbuffers::Offset<::flatbuffers::String> externalId) {
    fbb_.AddOffset(SARObservation_Abridged::VT_EXTERNALID, externalId);
  }
  void add_collectionId(::flatbuffers::Offset<::flatbuffers::String> collectionId) {
    fbb_.AddOffset(SARObservation_Abridged::VT_COLLECTIONID, collectionId);
  }
  void add_detectionId(::flatbuffers::Offset<::flatbuffers::String> detectionId) {
    fbb_.AddOffset(SARObservation_Abridged::VT_DETECTIONID, detectionId);
  }
  void add_collectionStart(::flatbuffers::Offset<::flatbuffers::String> collectionStart) {
    fbb_.AddOffset(SARObservation_Abridged::VT_COLLECTIONSTART, collectionStart);
  }
  void add_collectionEnd(::flatbuffers::Offset<::flatbuffers::String> collectionEnd) {
    fbb_.AddOffset(SARObservation_Abridged::VT_COLLECTIONEND, collectionEnd);
  }
  void add_centerTime(::flatbuffers::Offset<::flatbuffers::String> centerTime) {
    fbb_.AddOffset(SARObservation_Abridged::VT_CENTERTIME, centerTime);
  }
  void add_detectionStart(::flatbuffers::Offset<::flatbuffers::String> detectionStart) {
    fbb_.AddOffset(SARObservation_Abridged::VT_DETECTIONSTART, detectionStart);
  }
  void add_detectionEnd(::flatbuffers::Offset<::flatbuffers::String> detectionEnd) {
    fbb_.AddOffset(SARObservation_Abridged::VT_DETECTIONEND, detectionEnd);
  }
  void add_dwellTime(double dwellTime) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_DWELLTIME, dwellTime, 0.0);
  }
  void add_orbitState(::flatbuffers::Offset<::flatbuffers::String> orbitState) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ORBITSTATE, orbitState);
  }
  void add_sarMode(::flatbuffers::Offset<::flatbuffers::String> sarMode) {
    fbb_.AddOffset(SARObservation_Abridged::VT_SARMODE, sarMode);
  }
  void add_operatingBand(::flatbuffers::Offset<::flatbuffers::String> operatingBand) {
    fbb_.AddOffset(SARObservation_Abridged::VT_OPERATINGBAND, operatingBand);
  }
  void add_operatingFreq(double operatingFreq) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_OPERATINGFREQ, operatingFreq, 0.0);
  }
  void add_snr(double snr) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SNR, snr, 0.0);
  }
  void add_txPolarization(::flatbuffers::Offset<::flatbuffers::String> txPolarization) {
    fbb_.AddOffset(SARObservation_Abridged::VT_TXPOLARIZATION, txPolarization);
  }
  void add_rxPolarization(::flatbuffers::Offset<::flatbuffers::String> rxPolarization) {
    fbb_.AddOffset(SARObservation_Abridged::VT_RXPOLARIZATION, rxPolarization);
  }
  void add_grazeAngle(double grazeAngle) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_GRAZEANGLE, grazeAngle, 0.0);
  }
  void add_incidenceAngle(double incidenceAngle) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_INCIDENCEANGLE, incidenceAngle, 0.0);
  }
  void add_squintAngle(double squintAngle) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SQUINTANGLE, squintAngle, 0.0);
  }
  void add_pulseBandwidth(double pulseBandwidth) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_PULSEBANDWIDTH, pulseBandwidth, 0.0);
  }
  void add_pulseDuration(double pulseDuration) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_PULSEDURATION, pulseDuration, 0.0);
  }
  void add_continuousSpotAngle(double continuousSpotAngle) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_CONTINUOUSSPOTANGLE, continuousSpotAngle, 0.0);
  }
  void add_slantRange(double slantRange) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SLANTRANGE, slantRange, 0.0);
  }
  void add_nearRange(double nearRange) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_NEARRANGE, nearRange, 0.0);
  }
  void add_farRange(double farRange) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_FARRANGE, farRange, 0.0);
  }
  void add_swathLength(double swathLength) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SWATHLENGTH, swathLength, 0.0);
  }
  void add_atext(::flatbuffers::Offset<::flatbuffers::String> atext) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ATEXT, atext);
  }
  void add_agjson(::flatbuffers::Offset<::flatbuffers::String> agjson) {
    fbb_.AddOffset(SARObservation_Abridged::VT_AGJSON, agjson);
  }
  void add_atype(::flatbuffers::Offset<::flatbuffers::String> atype) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ATYPE, atype);
  }
  void add_andims(int32_t andims) {
    fbb_.AddElement<int32_t>(SARObservation_Abridged::VT_ANDIMS, andims, 0);
  }
  void add_asrid(int32_t asrid) {
    fbb_.AddElement<int32_t>(SARObservation_Abridged::VT_ASRID, asrid, 0);
  }
  void add_spacingRange(double spacingRange) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SPACINGRANGE, spacingRange, 0.0);
  }
  void add_spacingAzimuth(double spacingAzimuth) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SPACINGAZIMUTH, spacingAzimuth, 0.0);
  }
  void add_looksAzimuth(int32_t looksAzimuth) {
    fbb_.AddElement<int32_t>(SARObservation_Abridged::VT_LOOKSAZIMUTH, looksAzimuth, 0);
  }
  void add_looksRange(int32_t looksRange) {
    fbb_.AddElement<int32_t>(SARObservation_Abridged::VT_LOOKSRANGE, looksRange, 0);
  }
  void add_resolutionRange(double resolutionRange) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_RESOLUTIONRANGE, resolutionRange, 0.0);
  }
  void add_resolutionAzimuth(double resolutionAzimuth) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_RESOLUTIONAZIMUTH, resolutionAzimuth, 0.0);
  }
  void add_obDirection(::flatbuffers::Offset<::flatbuffers::String> obDirection) {
    fbb_.AddOffset(SARObservation_Abridged::VT_OBDIRECTION, obDirection);
  }
  void add_coordSys(::flatbuffers::Offset<::flatbuffers::String> coordSys) {
    fbb_.AddOffset(SARObservation_Abridged::VT_COORDSYS, coordSys);
  }
  void add_targetposx(double targetposx) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_TARGETPOSX, targetposx, 0.0);
  }
  void add_targetposy(double targetposy) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_TARGETPOSY, targetposy, 0.0);
  }
  void add_targetposz(double targetposz) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_TARGETPOSZ, targetposz, 0.0);
  }
  void add_senalt(double senalt) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENALT, senalt, 0.0);
  }
  void add_senvelx(double senvelx) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENVELX, senvelx, 0.0);
  }
  void add_senvely(double senvely) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENVELY, senvely, 0.0);
  }
  void add_senvelz(double senvelz) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENVELZ, senvelz, 0.0);
  }
  void add_senlatStart(double senlatStart) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENLATSTART, senlatStart, 0.0);
  }
  void add_senlonStart(double senlonStart) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENLONSTART, senlonStart, 0.0);
  }
  void add_senlatEnd(double senlatEnd) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENLATEND, senlatEnd, 0.0);
  }
  void add_senlonEnd(double senlonEnd) {
    fbb_.AddElement<double>(SARObservation_Abridged::VT_SENLONEND, senlonEnd, 0.0);
  }
  void add_transactionId(::flatbuffers::Offset<::flatbuffers::String> transactionId) {
    fbb_.AddOffset(SARObservation_Abridged::VT_TRANSACTIONID, transactionId);
  }
  void add_srcTyps(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcTyps) {
    fbb_.AddOffset(SARObservation_Abridged::VT_SRCTYPS, srcTyps);
  }
  void add_srcIds(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcIds) {
    fbb_.AddOffset(SARObservation_Abridged::VT_SRCIDS, srcIds);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(SARObservation_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(SARObservation_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(SARObservation_Abridged::VT_SOURCE, source);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ORIGIN, origin);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(SARObservation_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(SARObservation_Abridged::VT_SOURCEDL, sourceDL);
  }
  void add_dataMode(SARObservation_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(SARObservation_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  explicit SARObservation_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SARObservation_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SARObservation_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SARObservation_Abridged> CreateSARObservation_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idOnOrbit = 0,
    int32_t satNo = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origObjectId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idSensor = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origSensorId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> externalId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> detectionId = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionStart = 0,
    ::flatbuffers::Offset<::flatbuffers::String> collectionEnd = 0,
    ::flatbuffers::Offset<::flatbuffers::String> centerTime = 0,
    ::flatbuffers::Offset<::flatbuffers::String> detectionStart = 0,
    ::flatbuffers::Offset<::flatbuffers::String> detectionEnd = 0,
    double dwellTime = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> orbitState = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sarMode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> operatingBand = 0,
    double operatingFreq = 0.0,
    double snr = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> txPolarization = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rxPolarization = 0,
    double grazeAngle = 0.0,
    double incidenceAngle = 0.0,
    double squintAngle = 0.0,
    double pulseBandwidth = 0.0,
    double pulseDuration = 0.0,
    double continuousSpotAngle = 0.0,
    double slantRange = 0.0,
    double nearRange = 0.0,
    double farRange = 0.0,
    double swathLength = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> atext = 0,
    ::flatbuffers::Offset<::flatbuffers::String> agjson = 0,
    ::flatbuffers::Offset<::flatbuffers::String> atype = 0,
    int32_t andims = 0,
    int32_t asrid = 0,
    double spacingRange = 0.0,
    double spacingAzimuth = 0.0,
    int32_t looksAzimuth = 0,
    int32_t looksRange = 0,
    double resolutionRange = 0.0,
    double resolutionAzimuth = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> obDirection = 0,
    ::flatbuffers::Offset<::flatbuffers::String> coordSys = 0,
    double targetposx = 0.0,
    double targetposy = 0.0,
    double targetposz = 0.0,
    double senalt = 0.0,
    double senvelx = 0.0,
    double senvely = 0.0,
    double senvelz = 0.0,
    double senlatStart = 0.0,
    double senlonStart = 0.0,
    double senlatEnd = 0.0,
    double senlonEnd = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> transactionId = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcTyps = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> srcIds = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    SARObservation_Abridged_dataMode_Enum dataMode = SARObservation_Abridged_dataMode_Enum_REAL) {
  SARObservation_AbridgedBuilder builder_(_fbb);
  builder_.add_senlonEnd(senlonEnd);
  builder_.add_senlatEnd(senlatEnd);
  builder_.add_senlonStart(senlonStart);
  builder_.add_senlatStart(senlatStart);
  builder_.add_senvelz(senvelz);
  builder_.add_senvely(senvely);
  builder_.add_senvelx(senvelx);
  builder_.add_senalt(senalt);
  builder_.add_targetposz(targetposz);
  builder_.add_targetposy(targetposy);
  builder_.add_targetposx(targetposx);
  builder_.add_resolutionAzimuth(resolutionAzimuth);
  builder_.add_resolutionRange(resolutionRange);
  builder_.add_spacingAzimuth(spacingAzimuth);
  builder_.add_spacingRange(spacingRange);
  builder_.add_swathLength(swathLength);
  builder_.add_farRange(farRange);
  builder_.add_nearRange(nearRange);
  builder_.add_slantRange(slantRange);
  builder_.add_continuousSpotAngle(continuousSpotAngle);
  builder_.add_pulseDuration(pulseDuration);
  builder_.add_pulseBandwidth(pulseBandwidth);
  builder_.add_squintAngle(squintAngle);
  builder_.add_incidenceAngle(incidenceAngle);
  builder_.add_grazeAngle(grazeAngle);
  builder_.add_snr(snr);
  builder_.add_operatingFreq(operatingFreq);
  builder_.add_dwellTime(dwellTime);
  builder_.add_sourceDL(sourceDL);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_srcIds(srcIds);
  builder_.add_srcTyps(srcTyps);
  builder_.add_transactionId(transactionId);
  builder_.add_coordSys(coordSys);
  builder_.add_obDirection(obDirection);
  builder_.add_looksRange(looksRange);
  builder_.add_looksAzimuth(looksAzimuth);
  builder_.add_asrid(asrid);
  builder_.add_andims(andims);
  builder_.add_atype(atype);
  builder_.add_agjson(agjson);
  builder_.add_atext(atext);
  builder_.add_rxPolarization(rxPolarization);
  builder_.add_txPolarization(txPolarization);
  builder_.add_operatingBand(operatingBand);
  builder_.add_sarMode(sarMode);
  builder_.add_orbitState(orbitState);
  builder_.add_detectionEnd(detectionEnd);
  builder_.add_detectionStart(detectionStart);
  builder_.add_centerTime(centerTime);
  builder_.add_collectionEnd(collectionEnd);
  builder_.add_collectionStart(collectionStart);
  builder_.add_detectionId(detectionId);
  builder_.add_collectionId(collectionId);
  builder_.add_externalId(externalId);
  builder_.add_origSensorId(origSensorId);
  builder_.add_idSensor(idSensor);
  builder_.add_origObjectId(origObjectId);
  builder_.add_satNo(satNo);
  builder_.add_idOnOrbit(idOnOrbit);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SARObservation_Abridged> CreateSARObservation_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idOnOrbit = nullptr,
    int32_t satNo = 0,
    const char *origObjectId = nullptr,
    const char *idSensor = nullptr,
    const char *origSensorId = nullptr,
    const char *externalId = nullptr,
    const char *collectionId = nullptr,
    const char *detectionId = nullptr,
    const char *collectionStart = nullptr,
    const char *collectionEnd = nullptr,
    const char *centerTime = nullptr,
    const char *detectionStart = nullptr,
    const char *detectionEnd = nullptr,
    double dwellTime = 0.0,
    const char *orbitState = nullptr,
    const char *sarMode = nullptr,
    const char *operatingBand = nullptr,
    double operatingFreq = 0.0,
    double snr = 0.0,
    const char *txPolarization = nullptr,
    const char *rxPolarization = nullptr,
    double grazeAngle = 0.0,
    double incidenceAngle = 0.0,
    double squintAngle = 0.0,
    double pulseBandwidth = 0.0,
    double pulseDuration = 0.0,
    double continuousSpotAngle = 0.0,
    double slantRange = 0.0,
    double nearRange = 0.0,
    double farRange = 0.0,
    double swathLength = 0.0,
    const char *atext = nullptr,
    const char *agjson = nullptr,
    const char *atype = nullptr,
    int32_t andims = 0,
    int32_t asrid = 0,
    double spacingRange = 0.0,
    double spacingAzimuth = 0.0,
    int32_t looksAzimuth = 0,
    int32_t looksRange = 0,
    double resolutionRange = 0.0,
    double resolutionAzimuth = 0.0,
    const char *obDirection = nullptr,
    const char *coordSys = nullptr,
    double targetposx = 0.0,
    double targetposy = 0.0,
    double targetposz = 0.0,
    double senalt = 0.0,
    double senvelx = 0.0,
    double senvely = 0.0,
    double senvelz = 0.0,
    double senlatStart = 0.0,
    double senlonStart = 0.0,
    double senlatEnd = 0.0,
    double senlonEnd = 0.0,
    const char *transactionId = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *srcTyps = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *srcIds = nullptr,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *origin = nullptr,
    const char *origNetwork = nullptr,
    const char *sourceDL = nullptr,
    SARObservation_Abridged_dataMode_Enum dataMode = SARObservation_Abridged_dataMode_Enum_REAL) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idOnOrbit__ = idOnOrbit ? _fbb.CreateString(idOnOrbit) : 0;
  auto origObjectId__ = origObjectId ? _fbb.CreateString(origObjectId) : 0;
  auto idSensor__ = idSensor ? _fbb.CreateString(idSensor) : 0;
  auto origSensorId__ = origSensorId ? _fbb.CreateString(origSensorId) : 0;
  auto externalId__ = externalId ? _fbb.CreateString(externalId) : 0;
  auto collectionId__ = collectionId ? _fbb.CreateString(collectionId) : 0;
  auto detectionId__ = detectionId ? _fbb.CreateString(detectionId) : 0;
  auto collectionStart__ = collectionStart ? _fbb.CreateString(collectionStart) : 0;
  auto collectionEnd__ = collectionEnd ? _fbb.CreateString(collectionEnd) : 0;
  auto centerTime__ = centerTime ? _fbb.CreateString(centerTime) : 0;
  auto detectionStart__ = detectionStart ? _fbb.CreateString(detectionStart) : 0;
  auto detectionEnd__ = detectionEnd ? _fbb.CreateString(detectionEnd) : 0;
  auto orbitState__ = orbitState ? _fbb.CreateString(orbitState) : 0;
  auto sarMode__ = sarMode ? _fbb.CreateString(sarMode) : 0;
  auto operatingBand__ = operatingBand ? _fbb.CreateString(operatingBand) : 0;
  auto txPolarization__ = txPolarization ? _fbb.CreateString(txPolarization) : 0;
  auto rxPolarization__ = rxPolarization ? _fbb.CreateString(rxPolarization) : 0;
  auto atext__ = atext ? _fbb.CreateString(atext) : 0;
  auto agjson__ = agjson ? _fbb.CreateString(agjson) : 0;
  auto atype__ = atype ? _fbb.CreateString(atype) : 0;
  auto obDirection__ = obDirection ? _fbb.CreateString(obDirection) : 0;
  auto coordSys__ = coordSys ? _fbb.CreateString(coordSys) : 0;
  auto transactionId__ = transactionId ? _fbb.CreateString(transactionId) : 0;
  auto srcTyps__ = srcTyps ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*srcTyps) : 0;
  auto srcIds__ = srcIds ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*srcIds) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  return CreateSARObservation_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      idOnOrbit__,
      satNo,
      origObjectId__,
      idSensor__,
      origSensorId__,
      externalId__,
      collectionId__,
      detectionId__,
      collectionStart__,
      collectionEnd__,
      centerTime__,
      detectionStart__,
      detectionEnd__,
      dwellTime,
      orbitState__,
      sarMode__,
      operatingBand__,
      operatingFreq,
      snr,
      txPolarization__,
      rxPolarization__,
      grazeAngle,
      incidenceAngle,
      squintAngle,
      pulseBandwidth,
      pulseDuration,
      continuousSpotAngle,
      slantRange,
      nearRange,
      farRange,
      swathLength,
      atext__,
      agjson__,
      atype__,
      andims,
      asrid,
      spacingRange,
      spacingAzimuth,
      looksAzimuth,
      looksRange,
      resolutionRange,
      resolutionAzimuth,
      obDirection__,
      coordSys__,
      targetposx,
      targetposy,
      targetposz,
      senalt,
      senvelx,
      senvely,
      senvelz,
      senlatStart,
      senlonStart,
      senlatEnd,
      senlonEnd,
      transactionId__,
      srcTyps__,
      srcIds__,
      createdAt__,
      createdBy__,
      source__,
      origin__,
      origNetwork__,
      sourceDL__,
      dataMode);
}

inline const SARObservation_Abridged *GetSARObservation_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<SARObservation_Abridged>(buf);
}

inline const SARObservation_Abridged *GetSizePrefixedSARObservation_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<SARObservation_Abridged>(buf);
}

inline const char *SARObservation_AbridgedIdentifier() {
  return "SARO";
}

inline bool SARObservation_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SARObservation_AbridgedIdentifier());
}

inline bool SizePrefixedSARObservation_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, SARObservation_AbridgedIdentifier(), true);
}

inline bool VerifySARObservation_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<SARObservation_Abridged>(SARObservation_AbridgedIdentifier());
}

inline bool VerifySizePrefixedSARObservation_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<SARObservation_Abridged>(SARObservation_AbridgedIdentifier());
}

inline void FinishSARObservation_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SARObservation_Abridged> root) {
  fbb.Finish(root, SARObservation_AbridgedIdentifier());
}

inline void FinishSizePrefixedSARObservation_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<SARObservation_Abridged> root) {
  fbb.FinishSizePrefixed(root, SARObservation_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
