// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MAIN_H_
#define FLATBUFFERS_GENERATED_MAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

struct AIS_Abridged;
struct AIS_AbridgedBuilder;

enum AIS_Abridged_dataMode_Enum : int8_t {
  /// Data collected or produced that pertains to real-world objects, events, and analysis.
  AIS_Abridged_dataMode_Enum_REAL = 0,
  /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  AIS_Abridged_dataMode_Enum_TEST = 1,
  /// Synthetic data generated by a model to mimic real-world datasets.
  AIS_Abridged_dataMode_Enum_SIMULATED = 2,
  /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
  AIS_Abridged_dataMode_Enum_EXERCISE = 3,
  AIS_Abridged_dataMode_Enum_MIN = AIS_Abridged_dataMode_Enum_REAL,
  AIS_Abridged_dataMode_Enum_MAX = AIS_Abridged_dataMode_Enum_EXERCISE
};

inline const AIS_Abridged_dataMode_Enum (&EnumValuesAIS_Abridged_dataMode_Enum())[4] {
  static const AIS_Abridged_dataMode_Enum values[] = {
    AIS_Abridged_dataMode_Enum_REAL,
    AIS_Abridged_dataMode_Enum_TEST,
    AIS_Abridged_dataMode_Enum_SIMULATED,
    AIS_Abridged_dataMode_Enum_EXERCISE
  };
  return values;
}

inline const char * const *EnumNamesAIS_Abridged_dataMode_Enum() {
  static const char * const names[5] = {
    "REAL",
    "TEST",
    "SIMULATED",
    "EXERCISE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAIS_Abridged_dataMode_Enum(AIS_Abridged_dataMode_Enum e) {
  if (::flatbuffers::IsOutRange(e, AIS_Abridged_dataMode_Enum_REAL, AIS_Abridged_dataMode_Enum_EXERCISE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAIS_Abridged_dataMode_Enum()[index];
}

/// /// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
struct AIS_Abridged FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AIS_AbridgedBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_CLASSIFICATIONMARKING = 6,
    VT_IDTRACK = 8,
    VT_IDVESSEL = 10,
    VT_MMSI = 12,
    VT_IMON = 14,
    VT_TS = 16,
    VT_SHIPNAME = 18,
    VT_SHIPTYPE = 20,
    VT_ENGAGEDIN = 22,
    VT_SPECIALCRAFT = 24,
    VT_CARGOTYPE = 26,
    VT_CALLSIGN = 28,
    VT_VESSELFLAG = 30,
    VT_LAT = 32,
    VT_LON = 34,
    VT_POSHIACCURACY = 36,
    VT_POSHILATENCY = 38,
    VT_SPEED = 40,
    VT_TRUEHEADING = 42,
    VT_COURSE = 44,
    VT_RATEOFTURN = 46,
    VT_SPECIALMANEUVER = 48,
    VT_NAVSTATUS = 50,
    VT_POSDEVICETYPE = 52,
    VT_ANTENNAREFDIMENSIONS = 54,
    VT_LENGTH = 56,
    VT_WIDTH = 58,
    VT_DRAUGHT = 60,
    VT_SHIPDESCRIPTION = 62,
    VT_DESTINATION = 64,
    VT_DESTINATIONETA = 66,
    VT_CURRENTPORTGUID = 68,
    VT_CURRENTPORTLOCODE = 70,
    VT_LASTPORTGUID = 72,
    VT_LASTPORTLOCODE = 74,
    VT_NEXTPORTGUID = 76,
    VT_NEXTPORTLOCODE = 78,
    VT_ETACALCULATED = 80,
    VT_ETAUPDATED = 82,
    VT_DISTANCETOGO = 84,
    VT_DISTANCETRAVELLED = 86,
    VT_AVGSPEED = 88,
    VT_MAXSPEED = 90,
    VT_CREATEDAT = 92,
    VT_CREATEDBY = 94,
    VT_SOURCE = 96,
    VT_SOURCEDL = 98,
    VT_ORIGIN = 100,
    VT_DATAMODE = 102,
    VT_ORIGNETWORK = 104
  };
  /// Unique identifier of the record, auto-generated by the system.
  /// Example: /// Example: AIS-ID
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  /// Classification marking of the data in IC/CAPCO Portion-marked format.
  /// Example: /// Example: U
  /// Constraints: Minimum length = 1, Maximum length = 128
  const ::flatbuffers::String *classificationMarking() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CLASSIFICATIONMARKING);
  }
  /// Unique identifier of the Track.
  /// Example: /// Example: TRACK-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idTrack() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDTRACK);
  }
  /// Unique identifier of the vessel.
  /// Example: /// Example: VESSEL-ID
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *idVessel() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IDVESSEL);
  }
  /// The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel.
  /// Example: /// Example: 304010417
  /// Constraints: No constraints specified.
  int64_t mmsi() const {
    return GetField<int64_t>(VT_MMSI, 0);
  }
  /// The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel.
  /// Example: /// Example: 9015462
  /// Constraints: No constraints specified.
  int64_t imon() const {
    return GetField<int64_t>(VT_IMON, 0);
  }
  /// The timestamp that the vessel position was recorded, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *ts() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TS);
  }
  /// The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name.
  /// Example: /// Example: DORNUM
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *shipName() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHIPNAME);
  }
  /// The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels.
  /// Example: /// Example: Passenger
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *shipType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHIPTYPE);
  }
  /// The activity that the vessel is engaged in.  This entry applies only when the shipType = Other.
  /// Example: /// Example: Cargo
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *engagedIn() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENGAGEDIN);
  }
  /// The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft.
  /// Example: /// Example: Tug
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *specialCraft() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SPECIALCRAFT);
  }
  /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Freight
  /// Constraints: Minimum length = 0, Maximum length = 48
  const ::flatbuffers::String *cargoType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CARGOTYPE);
  }
  /// A uniquely designated identifier for the vessel's transmitter station.
  /// Example: /// Example: V2OZ
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *callSign() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CALLSIGN);
  }
  /// The flag of the subject vessel according to AIS transmission.
  /// Example: /// Example: United States
  /// Constraints: Minimum length = 0, Maximum length = 36
  const ::flatbuffers::String *vesselFlag() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VESSELFLAG);
  }
  /// WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator).
  /// Example: /// Example: 47.758499
  /// Constraints: No constraints specified.
  double lat() const {
    return GetField<double>(VT_LAT, 0.0);
  }
  /// WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).
  /// Example: /// Example: -5.154223
  /// Constraints: No constraints specified.
  double lon() const {
    return GetField<double>(VT_LON, 0.0);
  }
  /// Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool posHiAccuracy() const {
    return GetField<uint8_t>(VT_POSHIACCURACY, 0) != 0;
  }
  /// Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds).
  /// Example: /// Example: True
  /// Constraints: No constraints specified.
  bool posHiLatency() const {
    return GetField<uint8_t>(VT_POSHILATENCY, 0) != 0;
  }
  /// The speed-over-ground reported by the vessel, in kilometers/hour.
  /// Example: /// Example: 10.5
  /// Constraints: No constraints specified.
  double speed() const {
    return GetField<double>(VT_SPEED, 0.0);
  }
  /// The true heading reported by the vessel, in degrees.
  /// Example: /// Example: 329.1
  /// Constraints: No constraints specified.
  double trueHeading() const {
    return GetField<double>(VT_TRUEHEADING, 0.0);
  }
  /// The course-over-ground reported by the vessel, in degrees.
  /// Example: /// Example: 157.1
  /// Constraints: No constraints specified.
  double course() const {
    return GetField<double>(VT_COURSE, 0.0);
  }
  /// The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right.
  /// Example: /// Example: 22.1
  /// Constraints: No constraints specified.
  double rateOfTurn() const {
    return GetField<double>(VT_RATEOFTURN, 0.0);
  }
  /// Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation).
  /// Example: /// Example: False
  /// Constraints: No constraints specified.
  bool specialManeuver() const {
    return GetField<uint8_t>(VT_SPECIALMANEUVER, 0) != 0;
  }
  /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: Underway Using Engine
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *navStatus() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAVSTATUS);
  }
  /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
  /// Example: /// Example: GPS
  /// Constraints: Minimum length = 0, Maximum length = 24
  const ::flatbuffers::String *posDeviceType() const {
    return GetPointer<const ::flatbuffers::String *>(VT_POSDEVICETYPE);
  }
  /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
  /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
  /// Constraints: No constraints specified.
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *antennaRefDimensions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ANTENNAREFDIMENSIONS);
  }
  /// The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater.
  /// Example: /// Example: 511.1
  /// Constraints: No constraints specified.
  double length() const {
    return GetField<double>(VT_LENGTH, 0.0);
  }
  /// The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater.
  /// Example: /// Example: 24.1
  /// Constraints: No constraints specified.
  double width() const {
    return GetField<double>(VT_WIDTH, 0.0);
  }
  /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
  /// Example: /// Example: 21.1
  /// Constraints: No constraints specified.
  double draught() const {
    return GetField<double>(VT_DRAUGHT, 0.0);
  }
  /// Further description or explanation of the vessel or type.
  /// Example: /// Example: Search and rescue vessels
  /// Constraints: Minimum length = 0, Maximum length = 100
  const ::flatbuffers::String *shipDescription() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHIPDESCRIPTION);
  }
  /// The destination of the vessel according to the AIS transmission.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 20
  const ::flatbuffers::String *destination() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESTINATION);
  }
  /// The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *destinationETA() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESTINATIONETA);
  }
  /// The US Geographic Unique Identifier of the current port hosting the vessel.
  /// Example: /// Example: 0ABC
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *currentPortGUID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENTPORTGUID);
  }
  /// The UN Location Code of the current port hosting the vessel.
  /// Example: /// Example: XF013
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *currentPortLOCODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CURRENTPORTLOCODE);
  }
  /// The US Geographic Unique Identifier of the last port visited by the vessel.
  /// Example: /// Example: 0VAX
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *lastPortGUID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTPORTGUID);
  }
  /// The UN Location Code of the last port visited by the vessel.
  /// Example: /// Example: USSKY
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *lastPortLOCODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LASTPORTLOCODE);
  }
  /// The US Geographic Unique Identifier of the next destination port of the vessel.
  /// Example: /// Example: 0Z8Q
  /// Constraints: Minimum length = 0, Maximum length = 4
  const ::flatbuffers::String *nextPortGUID() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEXTPORTGUID);
  }
  /// The UN  Location Code of the next destination port of the vessel.
  /// Example: /// Example: USCLE
  /// Constraints: Minimum length = 0, Maximum length = 5
  const ::flatbuffers::String *nextPortLOCODE() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NEXTPORTLOCODE);
  }
  /// The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *etaCalculated() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ETACALCULATED);
  }
  /// The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format.
  /// Example: /// Example: 2021-02-25T12:00:00.123456Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *etaUpdated() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ETAUPDATED);
  }
  /// The remaining distance, in kilometers, for the vessel to reach the reported destination.
  /// Example: /// Example: 150.5
  /// Constraints: No constraints specified.
  double distanceToGo() const {
    return GetField<double>(VT_DISTANCETOGO, 0.0);
  }
  /// The distance, in kilometers, that the vessel has travelled since departing the last port.
  /// Example: /// Example: 200.3
  /// Constraints: No constraints specified.
  double distanceTravelled() const {
    return GetField<double>(VT_DISTANCETRAVELLED, 0.0);
  }
  /// The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port).
  /// Example: /// Example: 12.1
  /// Constraints: No constraints specified.
  double avgSpeed() const {
    return GetField<double>(VT_AVGSPEED, 0.0);
  }
  /// The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port).
  /// Example: /// Example: 13.3
  /// Constraints: No constraints specified.
  double maxSpeed() const {
    return GetField<double>(VT_MAXSPEED, 0.0);
  }
  /// Time the row was created in the database, auto-populated by the system.
  /// Example: /// Example: 2018-01-01T16:00:00.123Z
  /// Constraints: No constraints specified.
  const ::flatbuffers::String *createdAt() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDAT);
  }
  /// Application user who created the row in the database, auto-populated by the system.
  /// Example: /// Example: some.user
  /// Constraints: Minimum length = 1, Maximum length = 64
  const ::flatbuffers::String *createdBy() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CREATEDBY);
  }
  /// Source of the data.
  /// Example: /// Example: Bluestaq
  /// Constraints: Minimum length = 1, Maximum length = 36
  const ::flatbuffers::String *source() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE);
  }
  /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
  /// Example: /// Example: AXE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *sourceDL() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCEDL);
  }
  /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
  /// Example: /// Example: THIRD_PARTY_DATASOURCE
  /// Constraints: Minimum length = 0, Maximum length = 64
  const ::flatbuffers::String *origin() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGIN);
  }
  /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
  /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
  /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
  /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
  /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
  /// Example: /// Example: TEST
  /// Constraints: Minimum length = 1, Maximum length = 32
  AIS_Abridged_dataMode_Enum dataMode() const {
    return static_cast<AIS_Abridged_dataMode_Enum>(GetField<int8_t>(VT_DATAMODE, 0));
  }
  /// The originating source network on which this record was created, auto-populated by the system.
  /// Example: /// Example: ORIG
  /// Constraints: Minimum length = 1, Maximum length = 32
  const ::flatbuffers::String *origNetwork() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ORIGNETWORK);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_CLASSIFICATIONMARKING) &&
           verifier.VerifyString(classificationMarking()) &&
           VerifyOffset(verifier, VT_IDTRACK) &&
           verifier.VerifyString(idTrack()) &&
           VerifyOffset(verifier, VT_IDVESSEL) &&
           verifier.VerifyString(idVessel()) &&
           VerifyField<int64_t>(verifier, VT_MMSI, 8) &&
           VerifyField<int64_t>(verifier, VT_IMON, 8) &&
           VerifyOffset(verifier, VT_TS) &&
           verifier.VerifyString(ts()) &&
           VerifyOffset(verifier, VT_SHIPNAME) &&
           verifier.VerifyString(shipName()) &&
           VerifyOffset(verifier, VT_SHIPTYPE) &&
           verifier.VerifyString(shipType()) &&
           VerifyOffset(verifier, VT_ENGAGEDIN) &&
           verifier.VerifyString(engagedIn()) &&
           VerifyOffset(verifier, VT_SPECIALCRAFT) &&
           verifier.VerifyString(specialCraft()) &&
           VerifyOffset(verifier, VT_CARGOTYPE) &&
           verifier.VerifyString(cargoType()) &&
           VerifyOffset(verifier, VT_CALLSIGN) &&
           verifier.VerifyString(callSign()) &&
           VerifyOffset(verifier, VT_VESSELFLAG) &&
           verifier.VerifyString(vesselFlag()) &&
           VerifyField<double>(verifier, VT_LAT, 8) &&
           VerifyField<double>(verifier, VT_LON, 8) &&
           VerifyField<uint8_t>(verifier, VT_POSHIACCURACY, 1) &&
           VerifyField<uint8_t>(verifier, VT_POSHILATENCY, 1) &&
           VerifyField<double>(verifier, VT_SPEED, 8) &&
           VerifyField<double>(verifier, VT_TRUEHEADING, 8) &&
           VerifyField<double>(verifier, VT_COURSE, 8) &&
           VerifyField<double>(verifier, VT_RATEOFTURN, 8) &&
           VerifyField<uint8_t>(verifier, VT_SPECIALMANEUVER, 1) &&
           VerifyOffset(verifier, VT_NAVSTATUS) &&
           verifier.VerifyString(navStatus()) &&
           VerifyOffset(verifier, VT_POSDEVICETYPE) &&
           verifier.VerifyString(posDeviceType()) &&
           VerifyOffset(verifier, VT_ANTENNAREFDIMENSIONS) &&
           verifier.VerifyVector(antennaRefDimensions()) &&
           verifier.VerifyVectorOfStrings(antennaRefDimensions()) &&
           VerifyField<double>(verifier, VT_LENGTH, 8) &&
           VerifyField<double>(verifier, VT_WIDTH, 8) &&
           VerifyField<double>(verifier, VT_DRAUGHT, 8) &&
           VerifyOffset(verifier, VT_SHIPDESCRIPTION) &&
           verifier.VerifyString(shipDescription()) &&
           VerifyOffset(verifier, VT_DESTINATION) &&
           verifier.VerifyString(destination()) &&
           VerifyOffset(verifier, VT_DESTINATIONETA) &&
           verifier.VerifyString(destinationETA()) &&
           VerifyOffset(verifier, VT_CURRENTPORTGUID) &&
           verifier.VerifyString(currentPortGUID()) &&
           VerifyOffset(verifier, VT_CURRENTPORTLOCODE) &&
           verifier.VerifyString(currentPortLOCODE()) &&
           VerifyOffset(verifier, VT_LASTPORTGUID) &&
           verifier.VerifyString(lastPortGUID()) &&
           VerifyOffset(verifier, VT_LASTPORTLOCODE) &&
           verifier.VerifyString(lastPortLOCODE()) &&
           VerifyOffset(verifier, VT_NEXTPORTGUID) &&
           verifier.VerifyString(nextPortGUID()) &&
           VerifyOffset(verifier, VT_NEXTPORTLOCODE) &&
           verifier.VerifyString(nextPortLOCODE()) &&
           VerifyOffset(verifier, VT_ETACALCULATED) &&
           verifier.VerifyString(etaCalculated()) &&
           VerifyOffset(verifier, VT_ETAUPDATED) &&
           verifier.VerifyString(etaUpdated()) &&
           VerifyField<double>(verifier, VT_DISTANCETOGO, 8) &&
           VerifyField<double>(verifier, VT_DISTANCETRAVELLED, 8) &&
           VerifyField<double>(verifier, VT_AVGSPEED, 8) &&
           VerifyField<double>(verifier, VT_MAXSPEED, 8) &&
           VerifyOffset(verifier, VT_CREATEDAT) &&
           verifier.VerifyString(createdAt()) &&
           VerifyOffset(verifier, VT_CREATEDBY) &&
           verifier.VerifyString(createdBy()) &&
           VerifyOffset(verifier, VT_SOURCE) &&
           verifier.VerifyString(source()) &&
           VerifyOffset(verifier, VT_SOURCEDL) &&
           verifier.VerifyString(sourceDL()) &&
           VerifyOffset(verifier, VT_ORIGIN) &&
           verifier.VerifyString(origin()) &&
           VerifyField<int8_t>(verifier, VT_DATAMODE, 1) &&
           VerifyOffset(verifier, VT_ORIGNETWORK) &&
           verifier.VerifyString(origNetwork()) &&
           verifier.EndTable();
  }
};

struct AIS_AbridgedBuilder {
  typedef AIS_Abridged Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(AIS_Abridged::VT_ID, id);
  }
  void add_classificationMarking(::flatbuffers::Offset<::flatbuffers::String> classificationMarking) {
    fbb_.AddOffset(AIS_Abridged::VT_CLASSIFICATIONMARKING, classificationMarking);
  }
  void add_idTrack(::flatbuffers::Offset<::flatbuffers::String> idTrack) {
    fbb_.AddOffset(AIS_Abridged::VT_IDTRACK, idTrack);
  }
  void add_idVessel(::flatbuffers::Offset<::flatbuffers::String> idVessel) {
    fbb_.AddOffset(AIS_Abridged::VT_IDVESSEL, idVessel);
  }
  void add_mmsi(int64_t mmsi) {
    fbb_.AddElement<int64_t>(AIS_Abridged::VT_MMSI, mmsi, 0);
  }
  void add_imon(int64_t imon) {
    fbb_.AddElement<int64_t>(AIS_Abridged::VT_IMON, imon, 0);
  }
  void add_ts(::flatbuffers::Offset<::flatbuffers::String> ts) {
    fbb_.AddOffset(AIS_Abridged::VT_TS, ts);
  }
  void add_shipName(::flatbuffers::Offset<::flatbuffers::String> shipName) {
    fbb_.AddOffset(AIS_Abridged::VT_SHIPNAME, shipName);
  }
  void add_shipType(::flatbuffers::Offset<::flatbuffers::String> shipType) {
    fbb_.AddOffset(AIS_Abridged::VT_SHIPTYPE, shipType);
  }
  void add_engagedIn(::flatbuffers::Offset<::flatbuffers::String> engagedIn) {
    fbb_.AddOffset(AIS_Abridged::VT_ENGAGEDIN, engagedIn);
  }
  void add_specialCraft(::flatbuffers::Offset<::flatbuffers::String> specialCraft) {
    fbb_.AddOffset(AIS_Abridged::VT_SPECIALCRAFT, specialCraft);
  }
  void add_cargoType(::flatbuffers::Offset<::flatbuffers::String> cargoType) {
    fbb_.AddOffset(AIS_Abridged::VT_CARGOTYPE, cargoType);
  }
  void add_callSign(::flatbuffers::Offset<::flatbuffers::String> callSign) {
    fbb_.AddOffset(AIS_Abridged::VT_CALLSIGN, callSign);
  }
  void add_vesselFlag(::flatbuffers::Offset<::flatbuffers::String> vesselFlag) {
    fbb_.AddOffset(AIS_Abridged::VT_VESSELFLAG, vesselFlag);
  }
  void add_lat(double lat) {
    fbb_.AddElement<double>(AIS_Abridged::VT_LAT, lat, 0.0);
  }
  void add_lon(double lon) {
    fbb_.AddElement<double>(AIS_Abridged::VT_LON, lon, 0.0);
  }
  void add_posHiAccuracy(bool posHiAccuracy) {
    fbb_.AddElement<uint8_t>(AIS_Abridged::VT_POSHIACCURACY, static_cast<uint8_t>(posHiAccuracy), 0);
  }
  void add_posHiLatency(bool posHiLatency) {
    fbb_.AddElement<uint8_t>(AIS_Abridged::VT_POSHILATENCY, static_cast<uint8_t>(posHiLatency), 0);
  }
  void add_speed(double speed) {
    fbb_.AddElement<double>(AIS_Abridged::VT_SPEED, speed, 0.0);
  }
  void add_trueHeading(double trueHeading) {
    fbb_.AddElement<double>(AIS_Abridged::VT_TRUEHEADING, trueHeading, 0.0);
  }
  void add_course(double course) {
    fbb_.AddElement<double>(AIS_Abridged::VT_COURSE, course, 0.0);
  }
  void add_rateOfTurn(double rateOfTurn) {
    fbb_.AddElement<double>(AIS_Abridged::VT_RATEOFTURN, rateOfTurn, 0.0);
  }
  void add_specialManeuver(bool specialManeuver) {
    fbb_.AddElement<uint8_t>(AIS_Abridged::VT_SPECIALMANEUVER, static_cast<uint8_t>(specialManeuver), 0);
  }
  void add_navStatus(::flatbuffers::Offset<::flatbuffers::String> navStatus) {
    fbb_.AddOffset(AIS_Abridged::VT_NAVSTATUS, navStatus);
  }
  void add_posDeviceType(::flatbuffers::Offset<::flatbuffers::String> posDeviceType) {
    fbb_.AddOffset(AIS_Abridged::VT_POSDEVICETYPE, posDeviceType);
  }
  void add_antennaRefDimensions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> antennaRefDimensions) {
    fbb_.AddOffset(AIS_Abridged::VT_ANTENNAREFDIMENSIONS, antennaRefDimensions);
  }
  void add_length(double length) {
    fbb_.AddElement<double>(AIS_Abridged::VT_LENGTH, length, 0.0);
  }
  void add_width(double width) {
    fbb_.AddElement<double>(AIS_Abridged::VT_WIDTH, width, 0.0);
  }
  void add_draught(double draught) {
    fbb_.AddElement<double>(AIS_Abridged::VT_DRAUGHT, draught, 0.0);
  }
  void add_shipDescription(::flatbuffers::Offset<::flatbuffers::String> shipDescription) {
    fbb_.AddOffset(AIS_Abridged::VT_SHIPDESCRIPTION, shipDescription);
  }
  void add_destination(::flatbuffers::Offset<::flatbuffers::String> destination) {
    fbb_.AddOffset(AIS_Abridged::VT_DESTINATION, destination);
  }
  void add_destinationETA(::flatbuffers::Offset<::flatbuffers::String> destinationETA) {
    fbb_.AddOffset(AIS_Abridged::VT_DESTINATIONETA, destinationETA);
  }
  void add_currentPortGUID(::flatbuffers::Offset<::flatbuffers::String> currentPortGUID) {
    fbb_.AddOffset(AIS_Abridged::VT_CURRENTPORTGUID, currentPortGUID);
  }
  void add_currentPortLOCODE(::flatbuffers::Offset<::flatbuffers::String> currentPortLOCODE) {
    fbb_.AddOffset(AIS_Abridged::VT_CURRENTPORTLOCODE, currentPortLOCODE);
  }
  void add_lastPortGUID(::flatbuffers::Offset<::flatbuffers::String> lastPortGUID) {
    fbb_.AddOffset(AIS_Abridged::VT_LASTPORTGUID, lastPortGUID);
  }
  void add_lastPortLOCODE(::flatbuffers::Offset<::flatbuffers::String> lastPortLOCODE) {
    fbb_.AddOffset(AIS_Abridged::VT_LASTPORTLOCODE, lastPortLOCODE);
  }
  void add_nextPortGUID(::flatbuffers::Offset<::flatbuffers::String> nextPortGUID) {
    fbb_.AddOffset(AIS_Abridged::VT_NEXTPORTGUID, nextPortGUID);
  }
  void add_nextPortLOCODE(::flatbuffers::Offset<::flatbuffers::String> nextPortLOCODE) {
    fbb_.AddOffset(AIS_Abridged::VT_NEXTPORTLOCODE, nextPortLOCODE);
  }
  void add_etaCalculated(::flatbuffers::Offset<::flatbuffers::String> etaCalculated) {
    fbb_.AddOffset(AIS_Abridged::VT_ETACALCULATED, etaCalculated);
  }
  void add_etaUpdated(::flatbuffers::Offset<::flatbuffers::String> etaUpdated) {
    fbb_.AddOffset(AIS_Abridged::VT_ETAUPDATED, etaUpdated);
  }
  void add_distanceToGo(double distanceToGo) {
    fbb_.AddElement<double>(AIS_Abridged::VT_DISTANCETOGO, distanceToGo, 0.0);
  }
  void add_distanceTravelled(double distanceTravelled) {
    fbb_.AddElement<double>(AIS_Abridged::VT_DISTANCETRAVELLED, distanceTravelled, 0.0);
  }
  void add_avgSpeed(double avgSpeed) {
    fbb_.AddElement<double>(AIS_Abridged::VT_AVGSPEED, avgSpeed, 0.0);
  }
  void add_maxSpeed(double maxSpeed) {
    fbb_.AddElement<double>(AIS_Abridged::VT_MAXSPEED, maxSpeed, 0.0);
  }
  void add_createdAt(::flatbuffers::Offset<::flatbuffers::String> createdAt) {
    fbb_.AddOffset(AIS_Abridged::VT_CREATEDAT, createdAt);
  }
  void add_createdBy(::flatbuffers::Offset<::flatbuffers::String> createdBy) {
    fbb_.AddOffset(AIS_Abridged::VT_CREATEDBY, createdBy);
  }
  void add_source(::flatbuffers::Offset<::flatbuffers::String> source) {
    fbb_.AddOffset(AIS_Abridged::VT_SOURCE, source);
  }
  void add_sourceDL(::flatbuffers::Offset<::flatbuffers::String> sourceDL) {
    fbb_.AddOffset(AIS_Abridged::VT_SOURCEDL, sourceDL);
  }
  void add_origin(::flatbuffers::Offset<::flatbuffers::String> origin) {
    fbb_.AddOffset(AIS_Abridged::VT_ORIGIN, origin);
  }
  void add_dataMode(AIS_Abridged_dataMode_Enum dataMode) {
    fbb_.AddElement<int8_t>(AIS_Abridged::VT_DATAMODE, static_cast<int8_t>(dataMode), 0);
  }
  void add_origNetwork(::flatbuffers::Offset<::flatbuffers::String> origNetwork) {
    fbb_.AddOffset(AIS_Abridged::VT_ORIGNETWORK, origNetwork);
  }
  explicit AIS_AbridgedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AIS_Abridged> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AIS_Abridged>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AIS_Abridged> CreateAIS_Abridged(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> classificationMarking = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idTrack = 0,
    ::flatbuffers::Offset<::flatbuffers::String> idVessel = 0,
    int64_t mmsi = 0,
    int64_t imon = 0,
    ::flatbuffers::Offset<::flatbuffers::String> ts = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shipName = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shipType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> engagedIn = 0,
    ::flatbuffers::Offset<::flatbuffers::String> specialCraft = 0,
    ::flatbuffers::Offset<::flatbuffers::String> cargoType = 0,
    ::flatbuffers::Offset<::flatbuffers::String> callSign = 0,
    ::flatbuffers::Offset<::flatbuffers::String> vesselFlag = 0,
    double lat = 0.0,
    double lon = 0.0,
    bool posHiAccuracy = false,
    bool posHiLatency = false,
    double speed = 0.0,
    double trueHeading = 0.0,
    double course = 0.0,
    double rateOfTurn = 0.0,
    bool specialManeuver = false,
    ::flatbuffers::Offset<::flatbuffers::String> navStatus = 0,
    ::flatbuffers::Offset<::flatbuffers::String> posDeviceType = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> antennaRefDimensions = 0,
    double length = 0.0,
    double width = 0.0,
    double draught = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> shipDescription = 0,
    ::flatbuffers::Offset<::flatbuffers::String> destination = 0,
    ::flatbuffers::Offset<::flatbuffers::String> destinationETA = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currentPortGUID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> currentPortLOCODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastPortGUID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> lastPortLOCODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nextPortGUID = 0,
    ::flatbuffers::Offset<::flatbuffers::String> nextPortLOCODE = 0,
    ::flatbuffers::Offset<::flatbuffers::String> etaCalculated = 0,
    ::flatbuffers::Offset<::flatbuffers::String> etaUpdated = 0,
    double distanceToGo = 0.0,
    double distanceTravelled = 0.0,
    double avgSpeed = 0.0,
    double maxSpeed = 0.0,
    ::flatbuffers::Offset<::flatbuffers::String> createdAt = 0,
    ::flatbuffers::Offset<::flatbuffers::String> createdBy = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source = 0,
    ::flatbuffers::Offset<::flatbuffers::String> sourceDL = 0,
    ::flatbuffers::Offset<::flatbuffers::String> origin = 0,
    AIS_Abridged_dataMode_Enum dataMode = AIS_Abridged_dataMode_Enum_REAL,
    ::flatbuffers::Offset<::flatbuffers::String> origNetwork = 0) {
  AIS_AbridgedBuilder builder_(_fbb);
  builder_.add_maxSpeed(maxSpeed);
  builder_.add_avgSpeed(avgSpeed);
  builder_.add_distanceTravelled(distanceTravelled);
  builder_.add_distanceToGo(distanceToGo);
  builder_.add_draught(draught);
  builder_.add_width(width);
  builder_.add_length(length);
  builder_.add_rateOfTurn(rateOfTurn);
  builder_.add_course(course);
  builder_.add_trueHeading(trueHeading);
  builder_.add_speed(speed);
  builder_.add_lon(lon);
  builder_.add_lat(lat);
  builder_.add_imon(imon);
  builder_.add_mmsi(mmsi);
  builder_.add_origNetwork(origNetwork);
  builder_.add_origin(origin);
  builder_.add_sourceDL(sourceDL);
  builder_.add_source(source);
  builder_.add_createdBy(createdBy);
  builder_.add_createdAt(createdAt);
  builder_.add_etaUpdated(etaUpdated);
  builder_.add_etaCalculated(etaCalculated);
  builder_.add_nextPortLOCODE(nextPortLOCODE);
  builder_.add_nextPortGUID(nextPortGUID);
  builder_.add_lastPortLOCODE(lastPortLOCODE);
  builder_.add_lastPortGUID(lastPortGUID);
  builder_.add_currentPortLOCODE(currentPortLOCODE);
  builder_.add_currentPortGUID(currentPortGUID);
  builder_.add_destinationETA(destinationETA);
  builder_.add_destination(destination);
  builder_.add_shipDescription(shipDescription);
  builder_.add_antennaRefDimensions(antennaRefDimensions);
  builder_.add_posDeviceType(posDeviceType);
  builder_.add_navStatus(navStatus);
  builder_.add_vesselFlag(vesselFlag);
  builder_.add_callSign(callSign);
  builder_.add_cargoType(cargoType);
  builder_.add_specialCraft(specialCraft);
  builder_.add_engagedIn(engagedIn);
  builder_.add_shipType(shipType);
  builder_.add_shipName(shipName);
  builder_.add_ts(ts);
  builder_.add_idVessel(idVessel);
  builder_.add_idTrack(idTrack);
  builder_.add_classificationMarking(classificationMarking);
  builder_.add_id(id);
  builder_.add_dataMode(dataMode);
  builder_.add_specialManeuver(specialManeuver);
  builder_.add_posHiLatency(posHiLatency);
  builder_.add_posHiAccuracy(posHiAccuracy);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AIS_Abridged> CreateAIS_AbridgedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *classificationMarking = nullptr,
    const char *idTrack = nullptr,
    const char *idVessel = nullptr,
    int64_t mmsi = 0,
    int64_t imon = 0,
    const char *ts = nullptr,
    const char *shipName = nullptr,
    const char *shipType = nullptr,
    const char *engagedIn = nullptr,
    const char *specialCraft = nullptr,
    const char *cargoType = nullptr,
    const char *callSign = nullptr,
    const char *vesselFlag = nullptr,
    double lat = 0.0,
    double lon = 0.0,
    bool posHiAccuracy = false,
    bool posHiLatency = false,
    double speed = 0.0,
    double trueHeading = 0.0,
    double course = 0.0,
    double rateOfTurn = 0.0,
    bool specialManeuver = false,
    const char *navStatus = nullptr,
    const char *posDeviceType = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *antennaRefDimensions = nullptr,
    double length = 0.0,
    double width = 0.0,
    double draught = 0.0,
    const char *shipDescription = nullptr,
    const char *destination = nullptr,
    const char *destinationETA = nullptr,
    const char *currentPortGUID = nullptr,
    const char *currentPortLOCODE = nullptr,
    const char *lastPortGUID = nullptr,
    const char *lastPortLOCODE = nullptr,
    const char *nextPortGUID = nullptr,
    const char *nextPortLOCODE = nullptr,
    const char *etaCalculated = nullptr,
    const char *etaUpdated = nullptr,
    double distanceToGo = 0.0,
    double distanceTravelled = 0.0,
    double avgSpeed = 0.0,
    double maxSpeed = 0.0,
    const char *createdAt = nullptr,
    const char *createdBy = nullptr,
    const char *source = nullptr,
    const char *sourceDL = nullptr,
    const char *origin = nullptr,
    AIS_Abridged_dataMode_Enum dataMode = AIS_Abridged_dataMode_Enum_REAL,
    const char *origNetwork = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto classificationMarking__ = classificationMarking ? _fbb.CreateString(classificationMarking) : 0;
  auto idTrack__ = idTrack ? _fbb.CreateString(idTrack) : 0;
  auto idVessel__ = idVessel ? _fbb.CreateString(idVessel) : 0;
  auto ts__ = ts ? _fbb.CreateString(ts) : 0;
  auto shipName__ = shipName ? _fbb.CreateString(shipName) : 0;
  auto shipType__ = shipType ? _fbb.CreateString(shipType) : 0;
  auto engagedIn__ = engagedIn ? _fbb.CreateString(engagedIn) : 0;
  auto specialCraft__ = specialCraft ? _fbb.CreateString(specialCraft) : 0;
  auto cargoType__ = cargoType ? _fbb.CreateString(cargoType) : 0;
  auto callSign__ = callSign ? _fbb.CreateString(callSign) : 0;
  auto vesselFlag__ = vesselFlag ? _fbb.CreateString(vesselFlag) : 0;
  auto navStatus__ = navStatus ? _fbb.CreateString(navStatus) : 0;
  auto posDeviceType__ = posDeviceType ? _fbb.CreateString(posDeviceType) : 0;
  auto antennaRefDimensions__ = antennaRefDimensions ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*antennaRefDimensions) : 0;
  auto shipDescription__ = shipDescription ? _fbb.CreateString(shipDescription) : 0;
  auto destination__ = destination ? _fbb.CreateString(destination) : 0;
  auto destinationETA__ = destinationETA ? _fbb.CreateString(destinationETA) : 0;
  auto currentPortGUID__ = currentPortGUID ? _fbb.CreateString(currentPortGUID) : 0;
  auto currentPortLOCODE__ = currentPortLOCODE ? _fbb.CreateString(currentPortLOCODE) : 0;
  auto lastPortGUID__ = lastPortGUID ? _fbb.CreateString(lastPortGUID) : 0;
  auto lastPortLOCODE__ = lastPortLOCODE ? _fbb.CreateString(lastPortLOCODE) : 0;
  auto nextPortGUID__ = nextPortGUID ? _fbb.CreateString(nextPortGUID) : 0;
  auto nextPortLOCODE__ = nextPortLOCODE ? _fbb.CreateString(nextPortLOCODE) : 0;
  auto etaCalculated__ = etaCalculated ? _fbb.CreateString(etaCalculated) : 0;
  auto etaUpdated__ = etaUpdated ? _fbb.CreateString(etaUpdated) : 0;
  auto createdAt__ = createdAt ? _fbb.CreateString(createdAt) : 0;
  auto createdBy__ = createdBy ? _fbb.CreateString(createdBy) : 0;
  auto source__ = source ? _fbb.CreateString(source) : 0;
  auto sourceDL__ = sourceDL ? _fbb.CreateString(sourceDL) : 0;
  auto origin__ = origin ? _fbb.CreateString(origin) : 0;
  auto origNetwork__ = origNetwork ? _fbb.CreateString(origNetwork) : 0;
  return CreateAIS_Abridged(
      _fbb,
      id__,
      classificationMarking__,
      idTrack__,
      idVessel__,
      mmsi,
      imon,
      ts__,
      shipName__,
      shipType__,
      engagedIn__,
      specialCraft__,
      cargoType__,
      callSign__,
      vesselFlag__,
      lat,
      lon,
      posHiAccuracy,
      posHiLatency,
      speed,
      trueHeading,
      course,
      rateOfTurn,
      specialManeuver,
      navStatus__,
      posDeviceType__,
      antennaRefDimensions__,
      length,
      width,
      draught,
      shipDescription__,
      destination__,
      destinationETA__,
      currentPortGUID__,
      currentPortLOCODE__,
      lastPortGUID__,
      lastPortLOCODE__,
      nextPortGUID__,
      nextPortLOCODE__,
      etaCalculated__,
      etaUpdated__,
      distanceToGo,
      distanceTravelled,
      avgSpeed,
      maxSpeed,
      createdAt__,
      createdBy__,
      source__,
      sourceDL__,
      origin__,
      dataMode,
      origNetwork__);
}

inline const AIS_Abridged *GetAIS_Abridged(const void *buf) {
  return ::flatbuffers::GetRoot<AIS_Abridged>(buf);
}

inline const AIS_Abridged *GetSizePrefixedAIS_Abridged(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<AIS_Abridged>(buf);
}

inline const char *AIS_AbridgedIdentifier() {
  return "AISA";
}

inline bool AIS_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AIS_AbridgedIdentifier());
}

inline bool SizePrefixedAIS_AbridgedBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, AIS_AbridgedIdentifier(), true);
}

inline bool VerifyAIS_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<AIS_Abridged>(AIS_AbridgedIdentifier());
}

inline bool VerifySizePrefixedAIS_AbridgedBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<AIS_Abridged>(AIS_AbridgedIdentifier());
}

inline void FinishAIS_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AIS_Abridged> root) {
  fbb.Finish(root, AIS_AbridgedIdentifier());
}

inline void FinishSizePrefixedAIS_AbridgedBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<AIS_Abridged> root) {
  fbb.FinishSizePrefixed(root, AIS_AbridgedIdentifier());
}

#endif  // FLATBUFFERS_GENERATED_MAIN_H_
