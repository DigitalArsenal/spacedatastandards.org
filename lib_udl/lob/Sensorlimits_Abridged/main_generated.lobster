// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum Sensorlimits_Abridged_dataMode_Enum:
    /// Data collected or produced that pertains to real-world objects, events, and analysis.
    Sensorlimits_Abridged_dataMode_Enum_REAL = 0
    /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    Sensorlimits_Abridged_dataMode_Enum_TEST = 1
    /// Synthetic data generated by a model to mimic real-world datasets.
    Sensorlimits_Abridged_dataMode_Enum_SIMULATED = 2
    /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
    Sensorlimits_Abridged_dataMode_Enum_EXERCISE = 3

class Sensorlimits_Abridged

/// /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
class Sensorlimits_Abridged : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: SENSORLIMITS-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    def idSensorLimits() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    def classificationMarking() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: ORIG
    /// Constraints: Minimum length = 1, Maximum length = 32
    def origNetwork() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def upperLeftAzimuthLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 10, 0.0)
    /// Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def upperRightAzimuthLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 12, 0.0)
    /// Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def lowerRightAzimuthLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 14, 0.0)
    /// Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def lowerLeftAzimuthLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 16, 0.0)
    /// Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def lowerLeftElevationLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 18, 0.0)
    /// Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def upperLeftElevationLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def lowerRightElevationLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def upperRightElevationLimit() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 64
    def source() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    def dataMode() -> Sensorlimits_Abridged_dataMode_Enum:
        return Sensorlimits_Abridged_dataMode_Enum(flatbuffers.field_int8(buf_, pos_, 28, 0))
    /// Time the row was created in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def createdAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// Application user who created the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    def createdBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 32)
    /// Unique identifier of the target sensor object.
    /// Example: /// Example: SENSORLIMITS-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idSensor() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)

def GetRootAsSensorlimits_Abridged(buf:string): return Sensorlimits_Abridged { buf, flatbuffers.indirect(buf, 0) }

struct Sensorlimits_AbridgedBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(16)
        return this
    def add_idSensorLimits(idSensorLimits:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, idSensorLimits)
        return this
    def add_classificationMarking(classificationMarking:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, classificationMarking)
        return this
    def add_origNetwork(origNetwork:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, origNetwork)
        return this
    def add_upperLeftAzimuthLimit(upperLeftAzimuthLimit:float):
        b_.PrependFloat64Slot(3, upperLeftAzimuthLimit, 0.0)
        return this
    def add_upperRightAzimuthLimit(upperRightAzimuthLimit:float):
        b_.PrependFloat64Slot(4, upperRightAzimuthLimit, 0.0)
        return this
    def add_lowerRightAzimuthLimit(lowerRightAzimuthLimit:float):
        b_.PrependFloat64Slot(5, lowerRightAzimuthLimit, 0.0)
        return this
    def add_lowerLeftAzimuthLimit(lowerLeftAzimuthLimit:float):
        b_.PrependFloat64Slot(6, lowerLeftAzimuthLimit, 0.0)
        return this
    def add_lowerLeftElevationLimit(lowerLeftElevationLimit:float):
        b_.PrependFloat64Slot(7, lowerLeftElevationLimit, 0.0)
        return this
    def add_upperLeftElevationLimit(upperLeftElevationLimit:float):
        b_.PrependFloat64Slot(8, upperLeftElevationLimit, 0.0)
        return this
    def add_lowerRightElevationLimit(lowerRightElevationLimit:float):
        b_.PrependFloat64Slot(9, lowerRightElevationLimit, 0.0)
        return this
    def add_upperRightElevationLimit(upperRightElevationLimit:float):
        b_.PrependFloat64Slot(10, upperRightElevationLimit, 0.0)
        return this
    def add_source(source:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, source)
        return this
    def add_dataMode(dataMode:Sensorlimits_Abridged_dataMode_Enum):
        b_.PrependInt8Slot(12, dataMode, 0)
        return this
    def add_createdAt(createdAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, createdAt)
        return this
    def add_createdBy(createdBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, createdBy)
        return this
    def add_idSensor(idSensor:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, idSensor)
        return this
    def end():
        return b_.EndObject()

