// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum AirspaceControlMeans_Full_cmShape_Enum:
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_POLYARC = 0
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_E1TRACK = 1
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_POLYGON = 2
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_CIRCLE = 3
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_CORRIDOR = 4
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_APOINT = 5
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_AORBIT = 6
    /// No description available.
    AirspaceControlMeans_Full_cmShape_Enum_GEOLINE = 7

class AirspaceControlMeans_Full

/// /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
class AirspaceControlMeans_Full : flatbuffers.handle
    /// The code for the type of airspace control means.
    /// Example: /// Example: ACM:ADAREA
    /// Constraints: Minimum length = 0, Maximum length = 8
    def cmType() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Airspace control means name or designator.
    /// Example: /// Example: DESIG:C34
    /// Constraints: Minimum length = 0, Maximum length = 32
    def cmId() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
    /// Example: /// Example: POLYARC
    /// Constraints: Minimum length = 0, Maximum length = 8
    def cmShape() -> AirspaceControlMeans_Full_cmShape_Enum:
        return AirspaceControlMeans_Full_cmShape_Enum(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Designates the means by which a defined airspace control means is to be used.
    /// Example: /// Example: USE:AIRCOR
    /// Constraints: Minimum length = 0, Maximum length = 8
    def usage() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Unique Link 16 identifier assigned to the airspace control means.
    /// Example: /// Example: F3356
    /// Constraints: Minimum length = 0, Maximum length = 8
    def link16Id() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
    /// Example: /// Example: 18000FT
    /// Constraints: Minimum length = 0, Maximum length = 8
    def transAltitude() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
    /// Example: /// Example: NAR
    /// Constraints: Minimum length = 0, Maximum length = 8
    def geoDatumAlt() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
    /// Example: /// Example: 152345N0505657E
    /// Constraints: Minimum length = 0, Maximum length = 16
    def coord0() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
    /// Example: /// Example: 1523N05057E
    /// Constraints: Minimum length = 0, Maximum length = 16
    def coord1() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
    /// Example: /// Example: 330
    /// Constraints: No constraints specified.
    def bearing0() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
    /// Example: /// Example: 160
    /// Constraints: No constraints specified.
    def bearing1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
    /// Example: /// Example: 30.04
    /// Constraints: No constraints specified.
    def radMag0() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
    /// Example: /// Example: 50.12
    /// Constraints: No constraints specified.
    def radMag1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
    /// Example: /// Example: NM
    /// Constraints: Minimum length = 0, Maximum length = 8
    def radMagUnit() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
    /// Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
    /// Constraints: No constraints specified.
    def polyCoord(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 32) + i * 4)
    def polyCoord_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 32)
    /// Index of a segment in an airtrack, which is defined by an ordered set of points.
    /// Example: /// Example: 99
    /// Constraints: No constraints specified.
    def trackLeg() -> int:
        return flatbuffers.field_int32(buf_, pos_, 34, 0)
    /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
    /// Example: /// Example: 5.2
    /// Constraints: No constraints specified.
    def widthLeft() -> float:
        return flatbuffers.field_float64(buf_, pos_, 36, 0.0)
    /// Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
    /// Example: /// Example: 10.4
    /// Constraints: No constraints specified.
    def widthRight() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
    /// Example: /// Example: 15.6
    /// Constraints: No constraints specified.
    def width() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
    /// Example: /// Example: KM
    /// Constraints: Minimum length = 0, Maximum length = 8
    def widthUnit() -> string:
        return flatbuffers.field_string(buf_, pos_, 42)
    /// An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
    /// Example: /// Example: ['POB', 'RDU', 'IAD']
    /// Constraints: No constraints specified.
    def corrWayPoints(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 44) + i * 4)
    def corrWayPoints_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 44)
    /// Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
    /// Example: /// Example: C
    /// Constraints: Minimum length = 0, Maximum length = 1
    def orbitAlignment() -> string:
        return flatbuffers.field_string(buf_, pos_, 46)
    /// Description of the airspace vertical dimension.
    /// Example: /// Example: BRRA:GL-100AGL
    /// Constraints: Minimum length = 0, Maximum length = 16
    def effVDim() -> string:
        return flatbuffers.field_string(buf_, pos_, 48)
    /// The timePeriod set describes the effective datetime for a given airspace control means.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def airspaceTimePeriod(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 50) + i * 4)
    def airspaceTimePeriod_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 50)
    /// The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def airspaceControlPoint(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 52) + i * 4)
    def airspaceControlPoint_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 52)
    /// The commander responsible within a specified geographical area for the airspace control operation assigned to him.
    /// Example: /// Example: RHEIN MAIN CP
    /// Constraints: Minimum length = 0, Maximum length = 36
    def ctrlAuth() -> string:
        return flatbuffers.field_string(buf_, pos_, 54)
    /// The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
    /// Example: /// Example: ['125.25MHZ']
    /// Constraints: No constraints specified.
    def ctrlAuthFreqs(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 56) + i * 4)
    def ctrlAuthFreqs_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 56)
    /// Used to provide transit intstructions for the airspace control means.
    /// Example: /// Example: SITUATION
    /// Constraints: Minimum length = 0, Maximum length = 64
    def genTextInd() -> string:
        return flatbuffers.field_string(buf_, pos_, 58)
    /// General informat detailing the transit instruction for the airspace control means.
    /// Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
    /// Constraints: Minimum length = 0, Maximum length = 128
    def freeText() -> string:
        return flatbuffers.field_string(buf_, pos_, 60)

def GetRootAsAirspaceControlMeans_Full(buf:string): return AirspaceControlMeans_Full { buf, flatbuffers.indirect(buf, 0) }

struct AirspaceControlMeans_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(29)
        return this
    def add_cmType(cmType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, cmType)
        return this
    def add_cmId(cmId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, cmId)
        return this
    def add_cmShape(cmShape:AirspaceControlMeans_Full_cmShape_Enum):
        b_.PrependInt8Slot(2, cmShape, 0)
        return this
    def add_usage(usage:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, usage)
        return this
    def add_link16Id(link16Id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, link16Id)
        return this
    def add_transAltitude(transAltitude:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, transAltitude)
        return this
    def add_geoDatumAlt(geoDatumAlt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, geoDatumAlt)
        return this
    def add_coord0(coord0:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, coord0)
        return this
    def add_coord1(coord1:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, coord1)
        return this
    def add_bearing0(bearing0:float):
        b_.PrependFloat64Slot(9, bearing0, 0.0)
        return this
    def add_bearing1(bearing1:float):
        b_.PrependFloat64Slot(10, bearing1, 0.0)
        return this
    def add_radMag0(radMag0:float):
        b_.PrependFloat64Slot(11, radMag0, 0.0)
        return this
    def add_radMag1(radMag1:float):
        b_.PrependFloat64Slot(12, radMag1, 0.0)
        return this
    def add_radMagUnit(radMagUnit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, radMagUnit)
        return this
    def add_polyCoord(polyCoord:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, polyCoord)
        return this
    def add_trackLeg(trackLeg:int):
        b_.PrependInt32Slot(15, trackLeg, 0)
        return this
    def add_widthLeft(widthLeft:float):
        b_.PrependFloat64Slot(16, widthLeft, 0.0)
        return this
    def add_widthRight(widthRight:float):
        b_.PrependFloat64Slot(17, widthRight, 0.0)
        return this
    def add_width(width:float):
        b_.PrependFloat64Slot(18, width, 0.0)
        return this
    def add_widthUnit(widthUnit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, widthUnit)
        return this
    def add_corrWayPoints(corrWayPoints:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, corrWayPoints)
        return this
    def add_orbitAlignment(orbitAlignment:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, orbitAlignment)
        return this
    def add_effVDim(effVDim:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, effVDim)
        return this
    def add_airspaceTimePeriod(airspaceTimePeriod:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(23, airspaceTimePeriod)
        return this
    def add_airspaceControlPoint(airspaceControlPoint:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(24, airspaceControlPoint)
        return this
    def add_ctrlAuth(ctrlAuth:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(25, ctrlAuth)
        return this
    def add_ctrlAuthFreqs(ctrlAuthFreqs:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(26, ctrlAuthFreqs)
        return this
    def add_genTextInd(genTextInd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(27, genTextInd)
        return this
    def add_freeText(freeText:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(28, freeText)
        return this
    def end():
        return b_.EndObject()

def AirspaceControlMeans_FullStartPolyCoordVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceControlMeans_FullCreatePolyCoordVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AirspaceControlMeans_FullStartCorrWayPointsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceControlMeans_FullCreateCorrWayPointsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AirspaceControlMeans_FullStartAirspaceTimePeriodVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceControlMeans_FullCreateAirspaceTimePeriodVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AirspaceControlMeans_FullStartAirspaceControlPointVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceControlMeans_FullCreateAirspaceControlPointVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AirspaceControlMeans_FullStartCtrlAuthFreqsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceControlMeans_FullCreateCtrlAuthFreqsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

