// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class AirspaceTimePeriod_Full

/// /// The timePeriod set describes the effective datetime for a given airspace control means.
class AirspaceTimePeriod_Full : flatbuffers.handle
    /// The airspace time code associated with the ACO. Can be DISCRETE, a fixed time block, or INTERVAL, a repeating time block.
    /// Example: /// Example: DISCRETE
    /// Constraints: Minimum length = 0, Maximum length = 8
    def timeMode() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// The start time designating that the airspace control order is active.
    /// Example: /// Example: 141325ZFEB2002
    /// Constraints: Minimum length = 0, Maximum length = 16
    def timeStart() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// The end time designating that the airspace control order is no longer active. Can contain datetime information or a stop time qualifier code, such as AFTER, NET, UFN, etc.
    /// Example: /// Example: 141325ZFEB2002
    /// Constraints: Minimum length = 0, Maximum length = 16
    def timeEnd() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Mandatory if timeMode is INTERVAL. Can be on of the interval frequency codes, such as BIWEEKLY, DAILY, YEARLY, etc.
    /// Example: /// Example: ['WEEKLY']
    /// Constraints: No constraints specified.
    def intFreq(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 10) + i * 4)
    def intFreq_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 10)
    /// Mandatory if timeMode is INTERVAL. Can be a numerical multiplier on an interval frequency code, a stop time qualifier code such as AFTER, NET, UFN, etc, or a datetime like string.
    /// Example: /// Example: ['65WK']
    /// Constraints: No constraints specified.
    def intDur(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 12) + i * 4)
    def intDur_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 12)

def GetRootAsAirspaceTimePeriod_Full(buf:string): return AirspaceTimePeriod_Full { buf, flatbuffers.indirect(buf, 0) }

struct AirspaceTimePeriod_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(5)
        return this
    def add_timeMode(timeMode:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, timeMode)
        return this
    def add_timeStart(timeStart:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, timeStart)
        return this
    def add_timeEnd(timeEnd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, timeEnd)
        return this
    def add_intFreq(intFreq:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, intFreq)
        return this
    def add_intDur(intDur:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, intDur)
        return this
    def end():
        return b_.EndObject()

def AirspaceTimePeriod_FullStartIntFreqVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceTimePeriod_FullCreateIntFreqVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AirspaceTimePeriod_FullStartIntDurVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AirspaceTimePeriod_FullCreateIntDurVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

