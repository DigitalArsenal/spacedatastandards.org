// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum CollectRequest_Full_dataMode_Enum:
    /// Data collected or produced that pertains to real-world objects, events, and analysis.
    CollectRequest_Full_dataMode_Enum_REAL = 0
    /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    CollectRequest_Full_dataMode_Enum_TEST = 1
    /// Synthetic data generated by a model to mimic real-world datasets.
    CollectRequest_Full_dataMode_Enum_SIMULATED = 2
    /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
    CollectRequest_Full_dataMode_Enum_EXERCISE = 3

class CollectRequest_Full

/// /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
class CollectRequest_Full : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: COLLECTREQUEST-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    def id() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    def classificationMarking() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
    /// Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idParentReq() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// The type of external message from which this request originated.
    /// Example: /// Example: SU67
    /// Constraints: Minimum length = 0, Maximum length = 16
    def msgType() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
    /// Example: /// Example: 2024-04-25T08:17:01.346Z
    /// Constraints: No constraints specified.
    def msgCreateDate() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
    /// Example: /// Example: DWELL
    /// Constraints: Minimum length = 1, Maximum length = 36
    def type() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
    /// Example: /// Example: REF-PLAN-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idPlan() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Index number (integer) for records within a collection plan or schedule.
    /// Example: /// Example: 8
    /// Constraints: No constraints specified.
    def planIndex() -> int:
        return flatbuffers.field_int32(buf_, pos_, 18, 0)
    /// Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
    /// Example: /// Example: TASK-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def taskId() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
    /// Example: /// Example: DWELL-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def dwellId() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
    /// Example: /// Example: EXTERNAL-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def externalId() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
    /// Example: /// Example: REF-SENSOR-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idSensor() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
    /// Example: /// Example: ORIGSENSOR-ID
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origSensorId() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
    /// Example: /// Example: RADAR
    /// Constraints: Minimum length = 0, Maximum length = 24
    def obType() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
    /// Example: /// Example: EMERGENCY
    /// Constraints: Minimum length = 0, Maximum length = 24
    def priority() -> string:
        return flatbuffers.field_string(buf_, pos_, 32)
    /// The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
    /// Example: /// Example: 4
    /// Constraints: No constraints specified.
    def taskCategory() -> int:
        return flatbuffers.field_int32(buf_, pos_, 34, 0)
    /// The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
    /// Example: /// Example: T
    /// Constraints: Minimum length = 0, Maximum length = 1
    def suffix() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)
    /// Boolean indicating that this collect request is UCT follow-up.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def uctFollowUp() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 38, 0))
    /// The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
    /// Example: /// Example: 2018-01-01T16:00:00.123456Z
    /// Constraints: No constraints specified.
    def startTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 40)
    /// The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
    /// Example: /// Example: 2018-01-01T18:00:00.123456Z
    /// Constraints: No constraints specified.
    def endTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 42)
    /// Unique identifier of the target on-orbit object for this request.
    /// Example: /// Example: REF-ONORBIT-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idOnOrbit() -> string:
        return flatbuffers.field_string(buf_, pos_, 44)
    /// Satellite/catalog number of the target on-orbit object for this request.
    /// Example: /// Example: 101
    /// Constraints: No constraints specified.
    def satNo() -> int:
        return flatbuffers.field_int32(buf_, pos_, 46, 0)
    /// Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
    /// Example: /// Example: ORIGOBJECT-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def origObjectId() -> string:
        return flatbuffers.field_string(buf_, pos_, 48)
    /// The tasking group to which the target object is assigned.
    /// Example: /// Example: 729
    /// Constraints: Minimum length = 0, Maximum length = 16
    def taskGroup() -> string:
        return flatbuffers.field_string(buf_, pos_, 50)
    /// Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
    /// Example: /// Example: 3
    /// Constraints: No constraints specified.
    def iron() -> int:
        return flatbuffers.field_int32(buf_, pos_, 52, 0)
    /// The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
    /// Example: /// Example: GEO
    /// Constraints: Minimum length = 0, Maximum length = 12
    def orbitRegime() -> string:
        return flatbuffers.field_string(buf_, pos_, 54)
    /// The minimum object (diameter) size, in meters, to be reported.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def targetSize() -> float:
        return flatbuffers.field_float64(buf_, pos_, 56, 0.0)
    /// The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def rcsMin() -> float:
        return flatbuffers.field_float64(buf_, pos_, 58, 0.0)
    /// The Radar Cross-Section of the target, in m^2.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def rcs() -> float:
        return flatbuffers.field_float64(buf_, pos_, 60, 0.0)
    /// The maximum Radar Cross-Section of the target, in m^2.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def rcsMax() -> float:
        return flatbuffers.field_float64(buf_, pos_, 62, 0.0)
    /// The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def freqMin() -> float:
        return flatbuffers.field_float64(buf_, pos_, 64, 0.0)
    /// The estimated or expected emission frequency of the target, in MHz.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def freq() -> float:
        return flatbuffers.field_float64(buf_, pos_, 66, 0.0)
    /// The maximum frequency of interest, in MHz.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def freqMax() -> float:
        return flatbuffers.field_float64(buf_, pos_, 68, 0.0)
    /// The RF polarization (H, LHC, RHC, V).
    /// Example: /// Example: H
    /// Constraints: Minimum length = 0, Maximum length = 4
    def polarization() -> string:
        return flatbuffers.field_string(buf_, pos_, 70)
    /// The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def visMagMin() -> float:
        return flatbuffers.field_float64(buf_, pos_, 72, 0.0)
    /// The estimated or expected visual magnitude of the target, in Magnitudes (M).
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def visMag() -> float:
        return flatbuffers.field_float64(buf_, pos_, 74, 0.0)
    /// The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def visMagMax() -> float:
        return flatbuffers.field_float64(buf_, pos_, 76, 0.0)
    /// The spectral model used for the irradiance calculation.
    /// Example: /// Example: Example Model
    /// Constraints: Minimum length = 0, Maximum length = 36
    def spectralModel() -> string:
        return flatbuffers.field_string(buf_, pos_, 78)
    /// The fraction of solar energy reflected from target.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def reflectance() -> float:
        return flatbuffers.field_float64(buf_, pos_, 80, 0.0)
    /// The target object irradiance value.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def irradiance() -> float:
        return flatbuffers.field_float64(buf_, pos_, 82, 0.0)
    /// For optical sensors, the requested number of frames to capture at each sensor step.
    /// Example: /// Example: 6
    /// Constraints: No constraints specified.
    def numFrames() -> int:
        return flatbuffers.field_int32(buf_, pos_, 84, 0)
    /// For optical sensors, the frame rate of the camera, in Hz.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def frameRate() -> float:
        return flatbuffers.field_float64(buf_, pos_, 86, 0.0)
    /// For optical sensors, the integration time per camera frame, in milliseconds.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def integrationTime() -> float:
        return flatbuffers.field_float64(buf_, pos_, 88, 0.0)
    /// The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
    /// Example: /// Example: 3
    /// Constraints: No constraints specified.
    def numTracks() -> int:
        return flatbuffers.field_int32(buf_, pos_, 90, 0)
    /// The number of requested observations on the target.
    /// Example: /// Example: 9
    /// Constraints: No constraints specified.
    def numObs() -> int:
        return flatbuffers.field_int32(buf_, pos_, 92, 0)
    /// The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
    /// Example: /// Example: 11
    /// Constraints: No constraints specified.
    def duration() -> int:
        return flatbuffers.field_int32(buf_, pos_, 94, 0)
    /// The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
    /// Example: /// Example: SCAN
    /// Constraints: Minimum length = 0, Maximum length = 24
    def srchPattern() -> string:
        return flatbuffers.field_string(buf_, pos_, 96)
    /// Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
    /// Example: /// Example: Example direction
    /// Constraints: Minimum length = 0, Maximum length = 24
    def scenario() -> string:
        return flatbuffers.field_string(buf_, pos_, 98)
    /// ID of the UDL Elset of the object associated with this request.
    /// Example: /// Example: REF-ELSET-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idElset() -> string:
        return flatbuffers.field_string(buf_, pos_, 100)
    /// ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
    /// Example: /// Example: REF-MANIFOLD-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idManifold() -> string:
        return flatbuffers.field_string(buf_, pos_, 102)
    /// ID of the UDL State Vector of the object or central vector associated with this request.
    /// Example: /// Example: STATEVECTOR-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idStateVector() -> string:
        return flatbuffers.field_string(buf_, pos_, 104)
    /// ID of the UDL Ephemeris Set of the object associated with this request.
    /// Example: /// Example: ES-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def esId() -> string:
        return flatbuffers.field_string(buf_, pos_, 106)
    /// Epoch time, in ISO 8601 UTC format, of the orbital elements.
    /// Example: /// Example: 2018-01-01T16:00:00.123456Z
    /// Constraints: No constraints specified.
    def epoch() -> string:
        return flatbuffers.field_string(buf_, pos_, 108)
    /// The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def semiMajorAxis() -> float:
        return flatbuffers.field_float64(buf_, pos_, 110, 0.0)
    /// The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def eccentricity() -> float:
        return flatbuffers.field_float64(buf_, pos_, 112, 0.0)
    /// The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def inclination() -> float:
        return flatbuffers.field_float64(buf_, pos_, 114, 0.0)
    /// Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def raan() -> float:
        return flatbuffers.field_float64(buf_, pos_, 116, 0.0)
    /// The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def argOfPerigee() -> float:
        return flatbuffers.field_float64(buf_, pos_, 118, 0.0)
    /// The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def trueAnomoly() -> float:
        return flatbuffers.field_float64(buf_, pos_, 120, 0.0)
    /// The expected or directed right ascension angle, in degrees, for search or target acquisition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def ra() -> float:
        return flatbuffers.field_float64(buf_, pos_, 122, 0.0)
    /// The expected or directed declination angle, in degrees, for search or target acquisition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def dec() -> float:
        return flatbuffers.field_float64(buf_, pos_, 124, 0.0)
    /// The expected or directed azimuth angle, in degrees, for search or target acquisition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def az() -> float:
        return flatbuffers.field_float64(buf_, pos_, 126, 0.0)
    /// The expected or directed elevation angle, in degrees, for search or target acquisition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def el() -> float:
        return flatbuffers.field_float64(buf_, pos_, 128, 0.0)
    /// The expected acquisition range or defined center range, in km.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def range() -> float:
        return flatbuffers.field_float64(buf_, pos_, 130, 0.0)
    /// The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def extentAz() -> float:
        return flatbuffers.field_float64(buf_, pos_, 132, 0.0)
    /// The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def extentEl() -> float:
        return flatbuffers.field_float64(buf_, pos_, 134, 0.0)
    /// The extent of the range, in km, from center range to define a spatial volume.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def extentRange() -> float:
        return flatbuffers.field_float64(buf_, pos_, 136, 0.0)
    /// WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def lat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 138, 0.0)
    /// WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def lon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 140, 0.0)
    /// Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def alt() -> float:
        return flatbuffers.field_float64(buf_, pos_, 142, 0.0)
    /// The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def stopLat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 144, 0.0)
    /// The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def stopLon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 146, 0.0)
    /// The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def stopAlt() -> float:
        return flatbuffers.field_float64(buf_, pos_, 148, 0.0)
    /// The maximum inclination, in degrees, to be used in search operations.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def srchInc() -> float:
        return flatbuffers.field_float64(buf_, pos_, 150, 0.0)
    /// The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def xAngle() -> float:
        return flatbuffers.field_float64(buf_, pos_, 152, 0.0)
    /// The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def yAngle() -> float:
        return flatbuffers.field_float64(buf_, pos_, 154, 0.0)
    /// The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
    /// Example: /// Example: 1.1
    /// Constraints: No constraints specified.
    def orientAngle() -> float:
        return flatbuffers.field_float64(buf_, pos_, 156, 0.0)
    /// The customer for this request.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 0, Maximum length = 64
    def customer() -> string:
        return flatbuffers.field_string(buf_, pos_, 158)
    /// Notes or comments associated with this request.
    /// Example: /// Example: Example notes
    /// Constraints: Minimum length = 0, Maximum length = 512
    def notes() -> string:
        return flatbuffers.field_string(buf_, pos_, 160)
    /// Time the row was last updated in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def updatedAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 162)
    /// Application user who updated the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 0, Maximum length = 64
    def updatedBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 164)
    /// Time the row was created in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def createdAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 166)
    /// Application user who created the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    def createdBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 168)
    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 36
    def source() -> string:
        return flatbuffers.field_string(buf_, pos_, 170)
    /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    /// Example: /// Example: Example source
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origin() -> string:
        return flatbuffers.field_string(buf_, pos_, 172)
    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: ORIG
    /// Constraints: Minimum length = 1, Maximum length = 32
    def origNetwork() -> string:
        return flatbuffers.field_string(buf_, pos_, 174)
    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    def dataMode() -> CollectRequest_Full_dataMode_Enum:
        return CollectRequest_Full_dataMode_Enum(flatbuffers.field_int8(buf_, pos_, 176, 0))
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def stateVector() -> string:
        return flatbuffers.field_string(buf_, pos_, 178)
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def elset() -> string:
        return flatbuffers.field_string(buf_, pos_, 180)
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def onOrbit() -> string:
        return flatbuffers.field_string(buf_, pos_, 182)
    /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
    /// Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
    /// Constraints: No constraints specified.
    def tags(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 184) + i * 4)
    def tags_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 184)
    /// CollectResponses associated to request id. Read-only details (only used on detail queries, not to be provided on create/update operations).
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def collectResponse(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 186) + i * 4)
    def collectResponse_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 186)

def GetRootAsCollectRequest_Full(buf:string): return CollectRequest_Full { buf, flatbuffers.indirect(buf, 0) }

struct CollectRequest_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(92)
        return this
    def add_id(id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, id)
        return this
    def add_classificationMarking(classificationMarking:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, classificationMarking)
        return this
    def add_idParentReq(idParentReq:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, idParentReq)
        return this
    def add_msgType(msgType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, msgType)
        return this
    def add_msgCreateDate(msgCreateDate:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, msgCreateDate)
        return this
    def add_type(type:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, type)
        return this
    def add_idPlan(idPlan:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, idPlan)
        return this
    def add_planIndex(planIndex:int):
        b_.PrependInt32Slot(7, planIndex, 0)
        return this
    def add_taskId(taskId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, taskId)
        return this
    def add_dwellId(dwellId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, dwellId)
        return this
    def add_externalId(externalId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, externalId)
        return this
    def add_idSensor(idSensor:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, idSensor)
        return this
    def add_origSensorId(origSensorId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, origSensorId)
        return this
    def add_obType(obType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, obType)
        return this
    def add_priority(priority:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, priority)
        return this
    def add_taskCategory(taskCategory:int):
        b_.PrependInt32Slot(15, taskCategory, 0)
        return this
    def add_suffix(suffix:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, suffix)
        return this
    def add_uctFollowUp(uctFollowUp:bool):
        b_.PrependBoolSlot(17, uctFollowUp, 0)
        return this
    def add_startTime(startTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, startTime)
        return this
    def add_endTime(endTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, endTime)
        return this
    def add_idOnOrbit(idOnOrbit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, idOnOrbit)
        return this
    def add_satNo(satNo:int):
        b_.PrependInt32Slot(21, satNo, 0)
        return this
    def add_origObjectId(origObjectId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, origObjectId)
        return this
    def add_taskGroup(taskGroup:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(23, taskGroup)
        return this
    def add_iron(iron:int):
        b_.PrependInt32Slot(24, iron, 0)
        return this
    def add_orbitRegime(orbitRegime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(25, orbitRegime)
        return this
    def add_targetSize(targetSize:float):
        b_.PrependFloat64Slot(26, targetSize, 0.0)
        return this
    def add_rcsMin(rcsMin:float):
        b_.PrependFloat64Slot(27, rcsMin, 0.0)
        return this
    def add_rcs(rcs:float):
        b_.PrependFloat64Slot(28, rcs, 0.0)
        return this
    def add_rcsMax(rcsMax:float):
        b_.PrependFloat64Slot(29, rcsMax, 0.0)
        return this
    def add_freqMin(freqMin:float):
        b_.PrependFloat64Slot(30, freqMin, 0.0)
        return this
    def add_freq(freq:float):
        b_.PrependFloat64Slot(31, freq, 0.0)
        return this
    def add_freqMax(freqMax:float):
        b_.PrependFloat64Slot(32, freqMax, 0.0)
        return this
    def add_polarization(polarization:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, polarization)
        return this
    def add_visMagMin(visMagMin:float):
        b_.PrependFloat64Slot(34, visMagMin, 0.0)
        return this
    def add_visMag(visMag:float):
        b_.PrependFloat64Slot(35, visMag, 0.0)
        return this
    def add_visMagMax(visMagMax:float):
        b_.PrependFloat64Slot(36, visMagMax, 0.0)
        return this
    def add_spectralModel(spectralModel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(37, spectralModel)
        return this
    def add_reflectance(reflectance:float):
        b_.PrependFloat64Slot(38, reflectance, 0.0)
        return this
    def add_irradiance(irradiance:float):
        b_.PrependFloat64Slot(39, irradiance, 0.0)
        return this
    def add_numFrames(numFrames:int):
        b_.PrependInt32Slot(40, numFrames, 0)
        return this
    def add_frameRate(frameRate:float):
        b_.PrependFloat64Slot(41, frameRate, 0.0)
        return this
    def add_integrationTime(integrationTime:float):
        b_.PrependFloat64Slot(42, integrationTime, 0.0)
        return this
    def add_numTracks(numTracks:int):
        b_.PrependInt32Slot(43, numTracks, 0)
        return this
    def add_numObs(numObs:int):
        b_.PrependInt32Slot(44, numObs, 0)
        return this
    def add_duration(duration:int):
        b_.PrependInt32Slot(45, duration, 0)
        return this
    def add_srchPattern(srchPattern:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(46, srchPattern)
        return this
    def add_scenario(scenario:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(47, scenario)
        return this
    def add_idElset(idElset:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(48, idElset)
        return this
    def add_idManifold(idManifold:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(49, idManifold)
        return this
    def add_idStateVector(idStateVector:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(50, idStateVector)
        return this
    def add_esId(esId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(51, esId)
        return this
    def add_epoch(epoch:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(52, epoch)
        return this
    def add_semiMajorAxis(semiMajorAxis:float):
        b_.PrependFloat64Slot(53, semiMajorAxis, 0.0)
        return this
    def add_eccentricity(eccentricity:float):
        b_.PrependFloat64Slot(54, eccentricity, 0.0)
        return this
    def add_inclination(inclination:float):
        b_.PrependFloat64Slot(55, inclination, 0.0)
        return this
    def add_raan(raan:float):
        b_.PrependFloat64Slot(56, raan, 0.0)
        return this
    def add_argOfPerigee(argOfPerigee:float):
        b_.PrependFloat64Slot(57, argOfPerigee, 0.0)
        return this
    def add_trueAnomoly(trueAnomoly:float):
        b_.PrependFloat64Slot(58, trueAnomoly, 0.0)
        return this
    def add_ra(ra:float):
        b_.PrependFloat64Slot(59, ra, 0.0)
        return this
    def add_dec(dec:float):
        b_.PrependFloat64Slot(60, dec, 0.0)
        return this
    def add_az(az:float):
        b_.PrependFloat64Slot(61, az, 0.0)
        return this
    def add_el(el:float):
        b_.PrependFloat64Slot(62, el, 0.0)
        return this
    def add_range(range:float):
        b_.PrependFloat64Slot(63, range, 0.0)
        return this
    def add_extentAz(extentAz:float):
        b_.PrependFloat64Slot(64, extentAz, 0.0)
        return this
    def add_extentEl(extentEl:float):
        b_.PrependFloat64Slot(65, extentEl, 0.0)
        return this
    def add_extentRange(extentRange:float):
        b_.PrependFloat64Slot(66, extentRange, 0.0)
        return this
    def add_lat(lat:float):
        b_.PrependFloat64Slot(67, lat, 0.0)
        return this
    def add_lon(lon:float):
        b_.PrependFloat64Slot(68, lon, 0.0)
        return this
    def add_alt(alt:float):
        b_.PrependFloat64Slot(69, alt, 0.0)
        return this
    def add_stopLat(stopLat:float):
        b_.PrependFloat64Slot(70, stopLat, 0.0)
        return this
    def add_stopLon(stopLon:float):
        b_.PrependFloat64Slot(71, stopLon, 0.0)
        return this
    def add_stopAlt(stopAlt:float):
        b_.PrependFloat64Slot(72, stopAlt, 0.0)
        return this
    def add_srchInc(srchInc:float):
        b_.PrependFloat64Slot(73, srchInc, 0.0)
        return this
    def add_xAngle(xAngle:float):
        b_.PrependFloat64Slot(74, xAngle, 0.0)
        return this
    def add_yAngle(yAngle:float):
        b_.PrependFloat64Slot(75, yAngle, 0.0)
        return this
    def add_orientAngle(orientAngle:float):
        b_.PrependFloat64Slot(76, orientAngle, 0.0)
        return this
    def add_customer(customer:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(77, customer)
        return this
    def add_notes(notes:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(78, notes)
        return this
    def add_updatedAt(updatedAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(79, updatedAt)
        return this
    def add_updatedBy(updatedBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(80, updatedBy)
        return this
    def add_createdAt(createdAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(81, createdAt)
        return this
    def add_createdBy(createdBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(82, createdBy)
        return this
    def add_source(source:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(83, source)
        return this
    def add_origin(origin:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(84, origin)
        return this
    def add_origNetwork(origNetwork:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(85, origNetwork)
        return this
    def add_dataMode(dataMode:CollectRequest_Full_dataMode_Enum):
        b_.PrependInt8Slot(86, dataMode, 0)
        return this
    def add_stateVector(stateVector:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(87, stateVector)
        return this
    def add_elset(elset:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(88, elset)
        return this
    def add_onOrbit(onOrbit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(89, onOrbit)
        return this
    def add_tags(tags:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(90, tags)
        return this
    def add_collectResponse(collectResponse:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(91, collectResponse)
        return this
    def end():
        return b_.EndObject()

def CollectRequest_FullStartTagsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CollectRequest_FullCreateTagsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def CollectRequest_FullStartCollectResponseVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def CollectRequest_FullCreateCollectResponseVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

