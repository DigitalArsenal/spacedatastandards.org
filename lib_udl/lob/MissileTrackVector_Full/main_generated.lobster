// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

class MissileTrackVector_Full

/// /// Schema for Missile Track Vector data.
class MissileTrackVector_Full : flatbuffers.handle
    /// Type of vector represented (e.g. LOS, PREDICTED, STATE).
    /// Example: /// Example: STATE
    /// Constraints: Minimum length = 0, Maximum length = 16
    def type() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Object to which this vector applies.
    /// Example: /// Example: TARGET
    /// Constraints: Minimum length = 0, Maximum length = 16
    def object() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Vector timestamp in ISO8601 UTC format, with microsecond precision.
    /// Example: /// Example: 2024-03-30T15:02:39.346768Z
    /// Constraints: No constraints specified.
    def epoch() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// Unique identifier of the reporting sensor of the object.
    /// Example: /// Example: a7e99418-b6d6-29ab-e767-440a989cce26
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idSensor() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Optional identifier provided by the source to indicate the reporting sensor of the object. This may be an internal identifier and not necessarily a valid sensor ID.
    /// Example: /// Example: ORIGSENSOR-ID
    /// Constraints: Minimum length = 0, Maximum length = 46
    def origSensorId() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Three element array, expressing the cartesian position vector of the target object, in kilometers, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x, y, z].
    /// Example: /// Example: [-1456.91592, -2883.54041, 6165.55186]
    /// Constraints: No constraints specified.
    def pos(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 14) + i * 4)
    def pos_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 14)
    /// Three element array, expressing the cartesian velocity vector of the target object, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x', y', z'].
    /// Example: /// Example: [-1.21981, -6.60208, -3.36515]
    /// Constraints: No constraints specified.
    def vel(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 16) + i * 4)
    def vel_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 16)
    /// Three element array, expressing the cartesian acceleration vector of the target object, in kilometers/second^2, in the specified referenceFrame. If referenceFrame is null then ECEF should be assumed. The array element order is [x'', y'', z''].
    /// Example: /// Example: [0.59236, -0.03537, 0.35675]
    /// Constraints: No constraints specified.
    def accel(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 18) + i * 4)
    def accel_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 18)
    /// Track object course, in degrees clockwise from true north.
    /// Example: /// Example: 7.3580153
    /// Constraints: No constraints specified.
    def course() -> float:
        return flatbuffers.field_float64(buf_, pos_, 20, 0.0)
    /// Track object speed, in kilometers/sec.
    /// Example: /// Example: 15.03443
    /// Constraints: No constraints specified.
    def spd() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// The reference frame of the cartesian vector (ECEF, J2000). If the referenceFrame is null it is assumed to be ECEF.
    /// Example: /// Example: ECEF
    /// Constraints: Minimum length = 0, Maximum length = 24
    def referenceFrame() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.
    /// If the covReferenceFrame is null it is assumed to be UVW. The array values (1-45) represent the upper triangular half of the position-velocity-acceleration covariance matrix.
    /// The covariance elements are position dependent within the array with values ordered as follows:
    /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x"&nbsp;&nbsp;&nbsp;&nbsp;y"&nbsp;&nbsp;&nbsp;&nbsp;z"
    /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9
    /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;&nbsp;12&nbsp;&nbsp;&nbsp;13&nbsp;&nbsp;&nbsp;14&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;&nbsp;17
    /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;18&nbsp;&nbsp;&nbsp;19&nbsp;&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;24
    /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;25&nbsp;&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;30
    /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;31&nbsp;&nbsp;&nbsp;32&nbsp;&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;35
    /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;&nbsp;38&nbsp;&nbsp;&nbsp;39
    /// x"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;40&nbsp;&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42
    /// y"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;44
    /// z"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45
    /// The cov array should contain only the upper right triangle values from top left down to bottom right, in order.
    /// Example: /// Example: [1.1, 2.2, 3.3]
    /// Constraints: No constraints specified.
    def cov(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 26) + i * 4)
    def cov_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 26)
    /// The reference frame of the covariance elements (ECEF, J2000, UVW). If the referenceFrame is null it is assumed to be UVW.
    /// Example: /// Example: ECEF
    /// Constraints: Minimum length = 0, Maximum length = 24
    def covReferenceFrame() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// WGS-84 object latitude subpoint at epoch, represented as -90 to 90 degrees (negative values south of equator).
    /// Example: /// Example: 45.0
    /// Constraints: No constraints specified.
    def vectorLat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// WGS-84 object longitude subpoint at epoch, represented as -180 to 180 degrees (negative values west of Prime Meridian).
    /// Example: /// Example: 150.0
    /// Constraints: No constraints specified.
    def vectorLon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Object altitude at epoch, expressed in kilometers above WGS-84 ellipsoid.
    /// Example: /// Example: 25.0
    /// Constraints: No constraints specified.
    def vectorAlt() -> float:
        return flatbuffers.field_float64(buf_, pos_, 34, 0.0)
    /// Confidence of the vector, 0-100.
    /// Example: /// Example: 100
    /// Constraints: No constraints specified.
    def confidence() -> int:
        return flatbuffers.field_int32(buf_, pos_, 36, 0)
    /// Status of the vector (e.g. INITIAL, UPDATE).
    /// Example: /// Example: INITIAL
    /// Constraints: Minimum length = 0, Maximum length = 24
    def status() -> string:
        return flatbuffers.field_string(buf_, pos_, 38)
    /// Source of the time value.
    /// Example: /// Example: Sensor 1
    /// Constraints: Minimum length = 0, Maximum length = 24
    def timeSource() -> string:
        return flatbuffers.field_string(buf_, pos_, 40)
    /// The quaternion describing the attitude of the spacecraft with respect to the reference frame listed in the 'referenceFrame' field. The array element order convention is the three vector components, followed by the scalar component.
    /// Example: /// Example: [0.03, 0.02, 0.01, 0.012]
    /// Constraints: No constraints specified.
    def quat(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 42) + i * 4)
    def quat_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 42)
    /// The flight azimuth associated with the current state vector (0-360 degrees).
    /// Example: /// Example: 45.23
    /// Constraints: No constraints specified.
    def flightAz() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)

def GetRootAsMissileTrackVector_Full(buf:string): return MissileTrackVector_Full { buf, flatbuffers.indirect(buf, 0) }

struct MissileTrackVector_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(21)
        return this
    def add_type(type:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, type)
        return this
    def add_object(object:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, object)
        return this
    def add_epoch(epoch:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, epoch)
        return this
    def add_idSensor(idSensor:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, idSensor)
        return this
    def add_origSensorId(origSensorId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, origSensorId)
        return this
    def add_pos(pos:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, pos)
        return this
    def add_vel(vel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, vel)
        return this
    def add_accel(accel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, accel)
        return this
    def add_course(course:float):
        b_.PrependFloat64Slot(8, course, 0.0)
        return this
    def add_spd(spd:float):
        b_.PrependFloat64Slot(9, spd, 0.0)
        return this
    def add_referenceFrame(referenceFrame:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, referenceFrame)
        return this
    def add_cov(cov:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, cov)
        return this
    def add_covReferenceFrame(covReferenceFrame:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, covReferenceFrame)
        return this
    def add_vectorLat(vectorLat:float):
        b_.PrependFloat64Slot(13, vectorLat, 0.0)
        return this
    def add_vectorLon(vectorLon:float):
        b_.PrependFloat64Slot(14, vectorLon, 0.0)
        return this
    def add_vectorAlt(vectorAlt:float):
        b_.PrependFloat64Slot(15, vectorAlt, 0.0)
        return this
    def add_confidence(confidence:int):
        b_.PrependInt32Slot(16, confidence, 0)
        return this
    def add_status(status:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(17, status)
        return this
    def add_timeSource(timeSource:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, timeSource)
        return this
    def add_quat(quat:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, quat)
        return this
    def add_flightAz(flightAz:float):
        b_.PrependFloat64Slot(20, flightAz, 0.0)
        return this
    def end():
        return b_.EndObject()

def MissileTrackVector_FullStartPosVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MissileTrackVector_FullCreatePosVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MissileTrackVector_FullStartVelVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MissileTrackVector_FullCreateVelVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MissileTrackVector_FullStartAccelVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MissileTrackVector_FullCreateAccelVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MissileTrackVector_FullStartCovVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MissileTrackVector_FullCreateCovVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def MissileTrackVector_FullStartQuatVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def MissileTrackVector_FullCreateQuatVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

