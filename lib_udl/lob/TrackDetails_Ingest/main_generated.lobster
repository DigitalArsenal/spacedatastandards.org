// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum TrackDetails_Ingest_env_Enum:
    /// Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
    TrackDetails_Ingest_env_Enum_AIR = 0
    /// On the surface of dry land.
    TrackDetails_Ingest_env_Enum_LAND = 1
    /// Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
    TrackDetails_Ingest_env_Enum_SPACE = 2
    /// On the surface of a body of water.
    TrackDetails_Ingest_env_Enum_SURFACE = 3
    /// Below the surface of a body of water.
    TrackDetails_Ingest_env_Enum_SUBSURFACE = 4
    /// Environment is not known.
    TrackDetails_Ingest_env_Enum_UNKNOWN = 5

enum TrackDetails_Ingest_objIdent_Enum:
    /// Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
    TrackDetails_Ingest_objIdent_Enum_ASSUMED_FRIEND = 0
    /// Track object supporting friendly forces and belonging to a declared friendly nation or entity.
    TrackDetails_Ingest_objIdent_Enum_FRIEND = 1
    /// Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
    TrackDetails_Ingest_objIdent_Enum_HOSTILE = 2
    /// Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
    TrackDetails_Ingest_objIdent_Enum_NEUTRAL = 3
    /// Track object which has not been evaluated.
    TrackDetails_Ingest_objIdent_Enum_PENDING = 4
    /// Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
    TrackDetails_Ingest_objIdent_Enum_SUSPECT = 5
    /// Track object which has been evaluated and does not meet criteria for any standard identity.
    TrackDetails_Ingest_objIdent_Enum_UNKNOWN = 6

enum TrackDetails_Ingest_dataMode_Enum:
    /// Data collected or produced that pertains to real-world objects, events, and analysis.
    TrackDetails_Ingest_dataMode_Enum_REAL = 0
    /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    TrackDetails_Ingest_dataMode_Enum_TEST = 1
    /// Synthetic data generated by a model to mimic real-world datasets.
    TrackDetails_Ingest_dataMode_Enum_SIMULATED = 2
    /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
    TrackDetails_Ingest_dataMode_Enum_EXERCISE = 3

class TrackDetails_Ingest

/// /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
class TrackDetails_Ingest : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: TRACK-DETAILS-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    def id() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    def classificationMarking() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
    ///  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
    ///  LAND: On the surface of dry land.
    ///  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
    ///  SURFACE: On the surface of a body of water.
    ///  SUBSURFACE: Below the surface of a body of water.
    ///  UNKNOWN: Environment is not known.
    /// Example: /// Example: LAND
    /// Constraints: Minimum length = 0, Maximum length = 16
    def env() -> TrackDetails_Ingest_env_Enum:
        return TrackDetails_Ingest_env_Enum(flatbuffers.field_int8(buf_, pos_, 8, 0))
    /// Optional message type designation.
    /// Example: /// Example: PLATFORM
    /// Constraints: Minimum length = 0, Maximum length = 32
    def msgType() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
    /// Example: /// Example: A30081
    /// Constraints: Minimum length = 0, Maximum length = 7
    def hullNum() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
    /// Example: /// Example: 0137
    /// Constraints: Minimum length = 0, Maximum length = 5
    def pif() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
    /// Example: /// Example: B45524
    /// Constraints: Minimum length = 0, Maximum length = 36
    def sconum() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// The Naval Tactical Data System (NTDS) track number assigned to this track.
    /// Example: /// Example: ZZ777
    /// Constraints: Minimum length = 0, Maximum length = 6
    def ntds() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
    /// Example: /// Example: 7670
    /// Constraints: Minimum length = 0, Maximum length = 5
    def disId() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
    /// Example: /// Example: 20345
    /// Constraints: Minimum length = 0, Maximum length = 6
    def midbCat() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// The Basic Encyclopedia (BE) number associated with this installation or area.
    /// Example: /// Example: ENC-123
    /// Constraints: Minimum length = 0, Maximum length = 10
    def beNumber() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
    /// Example: /// Example: AA125
    /// Constraints: Minimum length = 0, Maximum length = 6
    def oSuffix() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// This value represents the site number of a specific electronic site or its associated equipment.
    /// Example: /// Example: E12345012
    /// Constraints: Minimum length = 0, Maximum length = 9
    def pin() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// Flag indicating whether the missile is considered lost, if reporting a missile track.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def lostTrkInd() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 30, 0))
    /// Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
    /// Example: /// Example: MUID-SRC-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def muidSrcTrk() -> string:
        return flatbuffers.field_string(buf_, pos_, 32)
    /// Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
    /// Example: /// Example: MUID-SRC
    /// Constraints: Minimum length = 0, Maximum length = 36
    def muidSrc() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
    /// Example: /// Example: AT LAUNCH
    /// Constraints: Minimum length = 0, Maximum length = 32
    def mslStatus() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)
    /// Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
    /// Example: /// Example: 0.95
    /// Constraints: No constraints specified.
    def trkConf() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
    /// Example: /// Example: 1
    /// Constraints: No constraints specified.
    def trkQual() -> int:
        return flatbuffers.field_int32(buf_, pos_, 40, 0)
    /// A track may be designated as an alert track with the following designations:
    /// HIT - High Interest Track
    /// TGT - Target
    /// SUS - Suspect Carrier
    /// NSP - Cleared Suspect
    /// If alert is null, the track is assumed to be of non-alert status.
    /// Example: /// Example: TGT
    /// Constraints: Minimum length = 0, Maximum length = 3
    def alert() -> string:
        return flatbuffers.field_string(buf_, pos_, 42)
    /// Original source cross-reference code for the Command that originated the report.
    /// Example: /// Example: INT
    /// Constraints: Minimum length = 0, Maximum length = 5
    def origXref() -> string:
        return flatbuffers.field_string(buf_, pos_, 44)
    /// Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
    /// Example: /// Example: A123A
    /// Constraints: Minimum length = 0, Maximum length = 5
    def elnot1() -> string:
        return flatbuffers.field_string(buf_, pos_, 46)
    /// Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
    /// Example: /// Example: A123B
    /// Constraints: Minimum length = 0, Maximum length = 5
    def elnot2() -> string:
        return flatbuffers.field_string(buf_, pos_, 48)
    /// The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
    ///  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
    ///  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
    ///  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
    ///  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
    ///  PENDING: Track object which has not been evaluated.
    ///  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
    ///  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
    /// Example: /// Example: FRIEND
    /// Constraints: Minimum length = 0, Maximum length = 32
    def objIdent() -> TrackDetails_Ingest_objIdent_Enum:
        return TrackDetails_Ingest_objIdent_Enum(flatbuffers.field_int8(buf_, pos_, 50, 0))
    /// The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
    /// Example: /// Example: TRACKED
    /// Constraints: Minimum length = 0, Maximum length = 32
    def objType() -> string:
        return flatbuffers.field_string(buf_, pos_, 52)
    /// The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
    /// Example: /// Example: WEAPON
    /// Constraints: Minimum length = 0, Maximum length = 32
    def objPlat() -> string:
        return flatbuffers.field_string(buf_, pos_, 54)
    /// The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
    /// Example: /// Example: HOLDING
    /// Constraints: Minimum length = 0, Maximum length = 32
    def objAct() -> string:
        return flatbuffers.field_string(buf_, pos_, 56)
    /// Nationality of the tracked object.
    /// Example: /// Example: USA
    /// Constraints: Minimum length = 0, Maximum length = 24
    def objNat() -> string:
        return flatbuffers.field_string(buf_, pos_, 58)
    /// Track name.
    /// Example: /// Example: TRACK-NAME
    /// Constraints: Minimum length = 0, Maximum length = 48
    def name() -> string:
        return flatbuffers.field_string(buf_, pos_, 60)
    /// Abbreviated track name.
    /// Example: /// Example: COMMSCHECK
    /// Constraints: Minimum length = 0, Maximum length = 11
    def shortName() -> string:
        return flatbuffers.field_string(buf_, pos_, 62)
    /// UUID identifying the track, which should remain the same on subsequent tracks of the same object.
    /// Example: /// Example: trkId
    /// Constraints: Minimum length = 0, Maximum length = 36
    def trkId() -> string:
        return flatbuffers.field_string(buf_, pos_, 64)
    /// The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
    /// Example: /// Example: trkNum
    /// Constraints: Minimum length = 0, Maximum length = 32
    def trkNum() -> string:
        return flatbuffers.field_string(buf_, pos_, 66)
    /// Value Indicating the scope of this track:
    /// 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
    /// 2 - LOCAL  (Local) - available only on workstations in the local area network
    /// 3 - OTH  (Over the Horizon) - available to everyone.
    /// Example: /// Example: OTH
    /// Constraints: Minimum length = 0, Maximum length = 12
    def trkScope() -> string:
        return flatbuffers.field_string(buf_, pos_, 68)
    /// The unique identifier of the source node.
    /// Example: /// Example: MCS
    /// Constraints: Minimum length = 0, Maximum length = 4
    def sourceUid() -> string:
        return flatbuffers.field_string(buf_, pos_, 70)
    /// The call sign currently assigned to this track object.
    /// Example: /// Example: Charlie
    /// Constraints: Minimum length = 0, Maximum length = 24
    def callSign() -> string:
        return flatbuffers.field_string(buf_, pos_, 72)
    /// Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
    ///  FAKER: Friendly track, object, or entity acting as an exercise hostile.
    ///  JOKER: Friendly track, object, or entity acting as an exercise suspect.
    ///  KILO: Friendly high-value object.
    ///  TRAVELLER: Suspect land or surface track following a recognized traffic route.
    ///  ZOMBIE: Suspect track, object, or entity of special interest.
    /// Example: /// Example: JOKER
    /// Constraints: Minimum length = 0, Maximum length = 32
    def identAmp() -> string:
        return flatbuffers.field_string(buf_, pos_, 74)
    /// Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
    /// Example: /// Example: NUCLEAR WARHEAD
    /// Constraints: Minimum length = 0, Maximum length = 32
    def spaceAmp() -> string:
        return flatbuffers.field_string(buf_, pos_, 76)
    /// Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
    /// Example: /// Example: 6
    /// Constraints: No constraints specified.
    def spaceAmpConf() -> int:
        return flatbuffers.field_int32(buf_, pos_, 78, 0)
    /// Specific type of point or track with an environment of space.
    /// Example: /// Example: SS-21_MOD_2_CRBM
    /// Constraints: Minimum length = 0, Maximum length = 32
    def spaceSpecType() -> string:
        return flatbuffers.field_string(buf_, pos_, 80)
    /// Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
    /// SRBM - Short-Range Ballistic Missile
    /// MRBM - Medium-Range Ballistic Missile
    /// IRBM - Intermediate-Range Ballistic Missile
    /// LRBM - Long-Range Ballistic Missile
    /// ICBM - Intercontinental Ballistic Missile
    /// SLBM - Submarine-Launched Ballistic Missile.
    /// Example: /// Example: SLBM
    /// Constraints: Minimum length = 0, Maximum length = 16
    def acftSubType() -> string:
        return flatbuffers.field_string(buf_, pos_, 82)
    /// Track timestamp in ISO8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def ts() -> string:
        return flatbuffers.field_string(buf_, pos_, 84)
    /// Missile launch timestamp in ISO8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def launchTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 86)
    /// Missile impact timestamp in ISO8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def impactTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 88)
    /// The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def ftnMsgTs() -> string:
        return flatbuffers.field_string(buf_, pos_, 90)
    /// An ftn used to associate information and directives with the track.
    /// Example: /// Example: FTN
    /// Constraints: Minimum length = 0, Maximum length = 32
    def ftn() -> string:
        return flatbuffers.field_string(buf_, pos_, 92)
    /// The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
    /// Example: /// Example: TRUETT
    /// Constraints: Minimum length = 0, Maximum length = 18
    def ftnCmd() -> string:
        return flatbuffers.field_string(buf_, pos_, 94)
    /// The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
    /// Example: /// Example: ['2021-02-25T12:00:00.123456Z']
    /// Constraints: No constraints specified.
    def rtnMsgTs(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 96) + i * 4)
    def rtnMsgTs_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 96)
    /// A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
    /// Example: /// Example: ['ex-a']
    /// Constraints: No constraints specified.
    def rtn(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 98) + i * 4)
    def rtn_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 98)
    /// Value representing the state of the Received Track.
    /// Example: /// Example: Local_RTN
    /// Constraints: Minimum length = 0, Maximum length = 16
    def rtnTrkState() -> string:
        return flatbuffers.field_string(buf_, pos_, 100)
    /// The name of the Command reporting the Received Track Number (RTN).
    /// Example: /// Example: YORKTOWN
    /// Constraints: Minimum length = 0, Maximum length = 8
    def rtnCmd() -> string:
        return flatbuffers.field_string(buf_, pos_, 102)
    /// Id/name of sensor providing the track data.
    /// Example: /// Example: OTH
    /// Constraints: Minimum length = 0, Maximum length = 32
    def sen() -> string:
        return flatbuffers.field_string(buf_, pos_, 104)
    /// Source cross-reference code for the Command that originated the track report.
    /// Example: /// Example: INT
    /// Constraints: Minimum length = 0, Maximum length = 18
    def rptChxref() -> string:
        return flatbuffers.field_string(buf_, pos_, 106)
    /// Flag indicating whether this track is archived.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def rptArchived() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 108, 0))
    /// Flag indicating that this track is self reported.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def selfReport() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 110, 0))
    /// The MIL-STD-2525B symbology code that applies to the subject of this track.
    /// Example: /// Example: SHP*S----------
    /// Constraints: Minimum length = 0, Maximum length = 16
    def mil2525Bstr() -> string:
        return flatbuffers.field_string(buf_, pos_, 112)
    /// Transponder ID for the track.  This does not correspond to the UDL transponder schema.
    /// Example: /// Example: 11
    /// Constraints: Minimum length = 0, Maximum length = 61
    def trnspdrId() -> string:
        return flatbuffers.field_string(buf_, pos_, 114)
    /// Transponder type for the track.
    /// Example: /// Example: AFTS
    /// Constraints: Minimum length = 0, Maximum length = 51
    def trnspdrType() -> string:
        return flatbuffers.field_string(buf_, pos_, 116)
    /// Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
    /// Example: /// Example: RAY1500
    /// Constraints: Minimum length = 0, Maximum length = 16
    def emitterName() -> string:
        return flatbuffers.field_string(buf_, pos_, 118)
    /// Source code for source of information used to detect track.
    /// Example: /// Example: S1
    /// Constraints: Minimum length = 0, Maximum length = 64
    def infoSource() -> string:
        return flatbuffers.field_string(buf_, pos_, 120)
    /// Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def boosting() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 122, 0))
    /// Frequency, in hertz, for the signature report.
    /// Example: /// Example: 63.65
    /// Constraints: No constraints specified.
    def freq() -> float:
        return flatbuffers.field_float64(buf_, pos_, 124, 0.0)
    /// Maximum frequency, in hertz, reported for this acoustic track.
    /// Example: /// Example: 10324.53
    /// Constraints: No constraints specified.
    def maxFreq() -> float:
        return flatbuffers.field_float64(buf_, pos_, 126, 0.0)
    /// List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
    /// Example: /// Example: 8,12,4
    /// Constraints: Minimum length = 0, Maximum length = 24
    def harmonics() -> string:
        return flatbuffers.field_string(buf_, pos_, 128)
    /// Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
    /// Example: /// Example: 56657.2238
    /// Constraints: No constraints specified.
    def pri() -> float:
        return flatbuffers.field_float64(buf_, pos_, 130, 0.0)
    /// Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
    /// Example: /// Example: 17.65
    /// Constraints: No constraints specified.
    def prf() -> float:
        return flatbuffers.field_float64(buf_, pos_, 132, 0.0)
    /// Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
    /// Example: /// Example: 1347.45
    /// Constraints: No constraints specified.
    def pw() -> float:
        return flatbuffers.field_float64(buf_, pos_, 134, 0.0)
    /// Type of radar scan.
    /// Example: /// Example: UNK
    /// Constraints: Minimum length = 0, Maximum length = 5
    def scanType() -> string:
        return flatbuffers.field_string(buf_, pos_, 136)
    /// Scan rate of the emitter, measured in seconds per rotation (SPR).
    /// Example: /// Example: 12.01
    /// Constraints: No constraints specified.
    def scanRate() -> float:
        return flatbuffers.field_float64(buf_, pos_, 138, 0.0)
    /// The Sequential Contact Number (SCN) for this track.
    /// Example: /// Example: 1474305
    /// Constraints: No constraints specified.
    def scn() -> int:
        return flatbuffers.field_int32(buf_, pos_, 140, 0)
    /// Correlation Index; reference code for the site that originally reported the track.
    /// Example: /// Example: BB
    /// Constraints: Minimum length = 0, Maximum length = 3
    def cI() -> string:
        return flatbuffers.field_string(buf_, pos_, 142)
    /// The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
    /// Example: /// Example: 15.2
    /// Constraints: No constraints specified.
    def angElev() -> float:
        return flatbuffers.field_float64(buf_, pos_, 144, 0.0)
    /// WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
    /// Example: /// Example: 19.88550102
    /// Constraints: No constraints specified.
    def lat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 146, 0.0)
    /// WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
    /// Example: /// Example: 46.74596844
    /// Constraints: No constraints specified.
    def lon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 148, 0.0)
    /// WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
    /// Example: /// Example: 19.88550102
    /// Constraints: No constraints specified.
    def launchLat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 150, 0.0)
    /// WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
    /// Example: /// Example: 46.74550102
    /// Constraints: No constraints specified.
    def launchLon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 152, 0.0)
    /// WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
    /// Example: /// Example: 19.88550102
    /// Constraints: No constraints specified.
    def impactLat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 154, 0.0)
    /// WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
    /// Example: /// Example: 46.74550102
    /// Constraints: No constraints specified.
    def impactLon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 156, 0.0)
    /// WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
    /// Example: /// Example: 19.88550102
    /// Constraints: No constraints specified.
    def polarSingLocLat() -> float:
        return flatbuffers.field_float64(buf_, pos_, 158, 0.0)
    /// WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
    /// Example: /// Example: 46.74550102
    /// Constraints: No constraints specified.
    def polarSingLocLon() -> float:
        return flatbuffers.field_float64(buf_, pos_, 160, 0.0)
    /// The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
    /// Example: /// Example: 12.876
    /// Constraints: No constraints specified.
    def azCorrCenterLine() -> float:
        return flatbuffers.field_float64(buf_, pos_, 162, 0.0)
    /// Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
    /// Example: /// Example: 71.76
    /// Constraints: No constraints specified.
    def azCorrArcWidth() -> float:
        return flatbuffers.field_float64(buf_, pos_, 164, 0.0)
    /// The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
    /// Example: /// Example: 7010.882
    /// Constraints: No constraints specified.
    def errSemiIntAxis() -> float:
        return flatbuffers.field_float64(buf_, pos_, 166, 0.0)
    /// The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
    /// Example: /// Example: 69.6
    /// Constraints: No constraints specified.
    def errAreaOrient() -> float:
        return flatbuffers.field_float64(buf_, pos_, 168, 0.0)
    /// The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
    /// Example: /// Example: 168.8
    /// Constraints: No constraints specified.
    def errSemiMajElev() -> float:
        return flatbuffers.field_float64(buf_, pos_, 170, 0.0)
    /// Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
    /// 0 - SWITCH_TYPE_UNKNOWN
    /// 1 - SQUARE_RECTANGLE
    /// 2 - CIRCLE_ELLIPSE.
    /// Example: /// Example: CIRCLE_ELLIPSE
    /// Constraints: Minimum length = 0, Maximum length = 24
    def errGeoAreaSwitch() -> string:
        return flatbuffers.field_string(buf_, pos_, 172)
    /// Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
    /// Example: /// Example: 30567.452
    /// Constraints: No constraints specified.
    def burnoutAlt() -> float:
        return flatbuffers.field_float64(buf_, pos_, 174, 0.0)
    /// Threat Event System Track ID.
    /// Example: /// Example: 6217
    /// Constraints: Minimum length = 0, Maximum length = 8
    def tesEventId() -> string:
        return flatbuffers.field_string(buf_, pos_, 176)
    /// Track object speed, in meters/sec.
    /// Example: /// Example: 15.03443
    /// Constraints: No constraints specified.
    def spd() -> float:
        return flatbuffers.field_float64(buf_, pos_, 178, 0.0)
    /// The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
    /// Example: /// Example: 18.25
    /// Constraints: No constraints specified.
    def avgSpd() -> float:
        return flatbuffers.field_float64(buf_, pos_, 180, 0.0)
    /// Motion model Time On Leg in hours.
    /// Example: /// Example: 4.1
    /// Constraints: No constraints specified.
    def tol() -> float:
        return flatbuffers.field_float64(buf_, pos_, 182, 0.0)
    /// Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
    /// Example: /// Example: 153.01
    /// Constraints: No constraints specified.
    def alt() -> float:
        return flatbuffers.field_float64(buf_, pos_, 184, 0.0)
    /// Track object heading, in degrees clockwise from true north.
    /// Example: /// Example: 19.7
    /// Constraints: No constraints specified.
    def hdng() -> float:
        return flatbuffers.field_float64(buf_, pos_, 186, 0.0)
    /// The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
    /// Example: /// Example: 4.3580153
    /// Constraints: No constraints specified.
    def course() -> float:
        return flatbuffers.field_float64(buf_, pos_, 188, 0.0)
    /// The number of propeller revolutions per minute for a submarine or ship.
    /// Example: /// Example: 8.2
    /// Constraints: No constraints specified.
    def propRPM() -> float:
        return flatbuffers.field_float64(buf_, pos_, 190, 0.0)
    /// The number of turns of the vessel propellers per knot of forward motion.
    /// Example: /// Example: 2.65
    /// Constraints: No constraints specified.
    def tpk() -> float:
        return flatbuffers.field_float64(buf_, pos_, 192, 0.0)
    /// The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
    /// 0 - COOPERATIVE_LOCATOR_NONE
    /// 1 - SINGLE_PLATFORM
    /// 2 - FRAGMENT
    /// 3 - COOPERATIVE.
    /// Example: /// Example: COOPERATIVE
    /// Constraints: Minimum length = 0, Maximum length = 32
    def coopLocInd() -> string:
        return flatbuffers.field_string(buf_, pos_, 194)
    /// The manuevering indicator specifying the missile boost phase.
    /// 0 - POST_BOOST_NONE
    /// 1 - POST_BOOST_MANUEVER
    /// 2 - POST_BOOST_COMPLETE_MANUEVER.
    /// Example: /// Example: POST_BOOST_NONE
    /// Constraints: Minimum length = 0, Maximum length = 32
    def maneuverInd() -> string:
        return flatbuffers.field_string(buf_, pos_, 196)
    /// The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
    /// Example: /// Example: ELLIPSE
    /// Constraints: Minimum length = 0, Maximum length = 20
    def launchAouType() -> string:
        return flatbuffers.field_string(buf_, pos_, 198)
    /// Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
    ///  ELLIPSE:
    ///    brg - orientation in degrees of the ellipse
    ///    a1 - semi-major axis in meters
    ///    a2 - semi-minor axis in meters
    ///  BEARING (BEARING BOX or MTST BEARING BOX):
    ///    brg - orientation in degrees of the bearing box
    ///    a1 - length of bearing box in meters
    ///    a2 - half-width of bearing box in meters
    ///  OTHER (All other type values):
    ///    brg - line of bearing in degrees true
    ///    a1 - bearing error in degrees
    ///    a2 - estimated range in meters.
    /// Example: /// Example: [34.3, 26.5, 1.2]
    /// Constraints: No constraints specified.
    def launchAouData(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 200) + i * 4)
    def launchAouData_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 200)
    /// The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
    /// Example: /// Example: ELLIPSE
    /// Constraints: Minimum length = 0, Maximum length = 20
    def impactAouType() -> string:
        return flatbuffers.field_string(buf_, pos_, 202)
    /// Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
    ///  ELLIPSE:
    ///    brg - orientation in degrees of the ellipse
    ///    a1 - semi-major axis in meters
    ///    a2 - semi-minor axis in meters
    ///  BEARING (BEARING BOX or MTST BEARING BOX):
    ///    brg - orientation in degrees of the bearing box
    ///    a1 - length of bearing box in meters
    ///    a2 - half-width of bearing box in meters
    ///  OTHER (All other type values):
    ///    brg - line of bearing in degrees true
    ///    a1 - bearing error in degrees
    ///    a2 - estimated range in meters.
    /// Example: /// Example: [34.3, 26.5, 1.2]
    /// Constraints: No constraints specified.
    def impactAouData(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 204) + i * 4)
    def impactAouData_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 204)
    /// The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
    /// Example: /// Example: ELLIPSE
    /// Constraints: Minimum length = 0, Maximum length = 20
    def aouRptType() -> string:
        return flatbuffers.field_string(buf_, pos_, 206)
    /// Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
    ///  ELLIPSE:
    ///    brg - orientation in degrees of the ellipse
    ///    a1 - semi-major axis in meters
    ///    a2 - semi-minor axis in meters
    ///  BEARING (BEARING BOX or MTST BEARING BOX):
    ///    brg - orientation in degrees of the bearing box
    ///    a1 - length of bearing box in meters
    ///    a2 - half-width of bearing box in meters
    ///  OTHER (All other type values):
    ///    brg - line of bearing in degrees true
    ///    a1 - bearing error in degrees
    ///    a2 - estimated range in meters.
    /// Example: /// Example: [34.3, 26.5, 1.2]
    /// Constraints: No constraints specified.
    def aouRptData(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 208) + i * 4)
    def aouRptData_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 208)
    /// Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
    /// Example: /// Example: [1.23, 2.35, 3.42]
    /// Constraints: No constraints specified.
    def ecefPos(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 210) + i * 4)
    def ecefPos_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 210)
    /// Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
    /// Example: /// Example: [1.23, 2.35, 3.42]
    /// Constraints: No constraints specified.
    def ecefVel(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 212) + i * 4)
    def ecefVel_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 212)
    /// The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
    /// Example: /// Example: 97
    /// Constraints: No constraints specified.
    def containment() -> float:
        return flatbuffers.field_float64(buf_, pos_, 214, 0.0)
    /// The distance, in meters, of the closest point of approach between this track to the master reference track.
    /// Example: /// Example: 500
    /// Constraints: No constraints specified.
    def cpa() -> float:
        return flatbuffers.field_float64(buf_, pos_, 216, 0.0)
    /// The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
    /// Example: /// Example: 2021-02-25T12:00:00.123Z
    /// Constraints: No constraints specified.
    def tcpa() -> string:
        return flatbuffers.field_string(buf_, pos_, 218)
    /// The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: Underway Using Engine
    /// Constraints: Minimum length = 0, Maximum length = 64
    def navStatus() -> string:
        return flatbuffers.field_string(buf_, pos_, 220)
    /// The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: GPS
    /// Constraints: Minimum length = 0, Maximum length = 24
    def posDeviceType() -> string:
        return flatbuffers.field_string(buf_, pos_, 222)
    /// Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: Cardinal Mark N
    /// Constraints: Minimum length = 0, Maximum length = 64
    def aton() -> string:
        return flatbuffers.field_string(buf_, pos_, 224)
    /// Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
    /// Example: /// Example: ON
    /// Constraints: Minimum length = 0, Maximum length = 3
    def offPosInd() -> string:
        return flatbuffers.field_string(buf_, pos_, 226)
    /// The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
    /// Example: /// Example: [50.1, 50.1, 20.1, 20.1]
    /// Constraints: No constraints specified.
    def antennaRefDimensions(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 228) + i * 4)
    def antennaRefDimensions_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 228)
    /// The common name for a group of ships with similar design, usually named for the first vessel of the class.
    /// Example: /// Example: Nimitz
    /// Constraints: Minimum length = 0, Maximum length = 64
    def shipClass() -> string:
        return flatbuffers.field_string(buf_, pos_, 230)
    /// The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
    /// Example: /// Example: 9015462
    /// Constraints: No constraints specified.
    def imon() -> int:
        return flatbuffers.field_int32(buf_, pos_, 232, 0)
    /// The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
    /// Example: /// Example: 304010417
    /// Constraints: No constraints specified.
    def mmsi() -> int:
        return flatbuffers.field_int32(buf_, pos_, 234, 0)
    /// The maximum static draught, in meters, of the vessel according to the AIS transmission.
    /// Example: /// Example: 21.1
    /// Constraints: No constraints specified.
    def draught() -> float:
        return flatbuffers.field_float64(buf_, pos_, 236, 0.0)
    /// The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
    /// Example: /// Example: 511.1
    /// Constraints: No constraints specified.
    def length() -> float:
        return flatbuffers.field_float64(buf_, pos_, 238, 0.0)
    /// The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
    /// Example: /// Example: 24.1
    /// Constraints: No constraints specified.
    def width() -> float:
        return flatbuffers.field_float64(buf_, pos_, 240, 0.0)
    /// The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: Freight
    /// Constraints: Minimum length = 0, Maximum length = 48
    def cargoType() -> string:
        return flatbuffers.field_string(buf_, pos_, 242)
    /// Appearance group code.
    /// GP1 - Superstructure exceeds 1/3 of ship length.
    /// GP2 - Superstructure less than 1/3 of ship length.
    /// GP3 - Stack aft.
    /// Example: /// Example: GP1
    /// Constraints: Minimum length = 0, Maximum length = 7
    def appGrp() -> string:
        return flatbuffers.field_string(buf_, pos_, 244)
    /// Hull profile code. Based on GCCS-J hull profiles.
    /// FLUSH           No breaks in Hull Profile.
    /// RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
    /// RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
    /// RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
    /// RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
    /// RAISED 1-2      Raised area at bow and midships with break between.
    /// RAISED 1-3      Raised area at bow and stern with break between.
    /// RAISED 12       Continuous raised area encompassing both bow and midships.
    /// RAISED 23       Continuous raised area encompassing midships and stern.
    /// RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
    /// RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
    /// RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
    /// Example: /// Example: Raised 1-23
    /// Constraints: Minimum length = 0, Maximum length = 16
    def hullProf() -> string:
        return flatbuffers.field_string(buf_, pos_, 246)
    /// The type of propulsion employed by the track object (Diesel, Nuclear).
    /// Example: /// Example: Diesel
    /// Constraints: Minimum length = 0, Maximum length = 6
    def propType() -> string:
        return flatbuffers.field_string(buf_, pos_, 248)
    /// The number of blades per shaft of the track object.  Applicable for maritime vessels.
    /// Example: /// Example: 4
    /// Constraints: No constraints specified.
    def numBlades() -> int:
        return flatbuffers.field_int32(buf_, pos_, 250, 0)
    /// The number of shafts on the track object.  Applicable for maritime vessels.
    /// Example: /// Example: 3
    /// Constraints: No constraints specified.
    def numShafts() -> int:
        return flatbuffers.field_int32(buf_, pos_, 252, 0)
    /// The stern type code (Counter, Cruiser) associated with the track object.
    /// Example: /// Example: Cruiser
    /// Constraints: Minimum length = 0, Maximum length = 16
    def sternType() -> string:
        return flatbuffers.field_string(buf_, pos_, 254)
    /// The weight, in tons, of the vessel associated with this track.
    /// Example: /// Example: 3423.76
    /// Constraints: No constraints specified.
    def vslWt() -> float:
        return flatbuffers.field_float64(buf_, pos_, 256, 0.0)
    /// The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def arrTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 258)
    /// The flag of the arrival port.
    /// Example: /// Example: USA
    /// Constraints: Minimum length = 0, Maximum length = 36
    def arrFlag() -> string:
        return flatbuffers.field_string(buf_, pos_, 260)
    /// The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: Freight
    /// Constraints: Minimum length = 0, Maximum length = 48
    def arrCargo() -> string:
        return flatbuffers.field_string(buf_, pos_, 262)
    /// The Arrival Port of the vessel according to the AIS transmission.
    /// Example: /// Example: Lanshan
    /// Constraints: Minimum length = 0, Maximum length = 20
    def arrPort() -> string:
        return flatbuffers.field_string(buf_, pos_, 264)
    /// The Departure Port of the vessel according to the AIS transmission.
    /// Example: /// Example: Lanshan
    /// Constraints: Minimum length = 0, Maximum length = 20
    def depPort() -> string:
        return flatbuffers.field_string(buf_, pos_, 266)
    /// The flag of the departure port.
    /// Example: /// Example: USA
    /// Constraints: Minimum length = 0, Maximum length = 36
    def depFlag() -> string:
        return flatbuffers.field_string(buf_, pos_, 268)
    /// The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: Freight
    /// Constraints: Minimum length = 0, Maximum length = 48
    def depCargo() -> string:
        return flatbuffers.field_string(buf_, pos_, 270)
    /// The flag of the destination port.
    /// Example: /// Example: USA
    /// Constraints: Minimum length = 0, Maximum length = 36
    def desFlag() -> string:
        return flatbuffers.field_string(buf_, pos_, 272)
    /// The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
    /// Example: /// Example: Freight
    /// Constraints: Minimum length = 0, Maximum length = 48
    def desCargo() -> string:
        return flatbuffers.field_string(buf_, pos_, 274)
    /// The destination of the vessel according to the AIS transmission.
    /// Example: /// Example: USCLE
    /// Constraints: Minimum length = 0, Maximum length = 20
    def destination() -> string:
        return flatbuffers.field_string(buf_, pos_, 276)
    /// The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def eta() -> string:
        return flatbuffers.field_string(buf_, pos_, 278)
    /// The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
    /// Example: /// Example: 2021-02-25T12:00:00.123456Z
    /// Constraints: No constraints specified.
    def etd() -> string:
        return flatbuffers.field_string(buf_, pos_, 280)
    /// A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
    /// Example: /// Example: ID Mode
    /// Constraints: Minimum length = 0, Maximum length = 64
    def iff() -> string:
        return flatbuffers.field_string(buf_, pos_, 282)
    /// Flag indicating that the track object has an emergency.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def emgInd() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 284, 0))
    /// The drop-point indicator setting.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def dropPtInd() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 286, 0))
    /// Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def reinforced() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 288, 0))
    /// Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def reduced() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 290, 0))
    /// Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def hq() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 292, 0))
    /// Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def dummy() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 294, 0))
    /// Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def taskForce() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 296, 0))
    /// Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def feint() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 298, 0))
    /// Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def installation() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 300, 0))
    /// A text amplifier for units, equipment and installations; content is implementation specific.
    /// Example: /// Example: Staff Comments
    /// Constraints: Minimum length = 0, Maximum length = 256
    def staffCmts() -> string:
        return flatbuffers.field_string(buf_, pos_, 302)
    /// A text amplifier for units, equipment and installations; content is implementation specific.
    /// Example: /// Example: Additional information
    /// Constraints: Minimum length = 0, Maximum length = 256
    def addInfo() -> string:
        return flatbuffers.field_string(buf_, pos_, 304)
    /// A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
    ///  Reliability Ratings:
    ///   A-completely reliable
    ///   B-usually reliable
    ///   C-fairly reliable
    ///   D-not usually reliable
    ///   E-unreliable
    ///   F-reliability cannot be judged
    ///  Credibility Ratings:
    ///   1-confirmed by other sources
    ///   2-probably true
    ///   3-possibly true
    ///   4-doubtfully true
    ///   5-improbable
    ///   6-truth cannot be judged.
    /// Example: /// Example: A1
    /// Constraints: Minimum length = 0, Maximum length = 2
    def evalRating() -> string:
        return flatbuffers.field_string(buf_, pos_, 306)
    /// Time the row was created in the database.
    /// Example: /// Example: 2021-02-25T12:00:00.123Z
    /// Constraints: No constraints specified.
    def createdAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 308)
    /// Application user who created the row in the database.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 0, Maximum length = 64
    def createdBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 310)
    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 36
    def source() -> string:
        return flatbuffers.field_string(buf_, pos_, 312)
    /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    /// Example: /// Example: THIRD_PARTY_DATASOURCE
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origin() -> string:
        return flatbuffers.field_string(buf_, pos_, 314)
    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    def dataMode() -> TrackDetails_Ingest_dataMode_Enum:
        return TrackDetails_Ingest_dataMode_Enum(flatbuffers.field_int8(buf_, pos_, 316, 0))
    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: ORIG
    /// Constraints: Minimum length = 0, Maximum length = 32
    def origNetwork() -> string:
        return flatbuffers.field_string(buf_, pos_, 318)

def GetRootAsTrackDetails_Ingest(buf:string): return TrackDetails_Ingest { buf, flatbuffers.indirect(buf, 0) }

struct TrackDetails_IngestBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(158)
        return this
    def add_id(id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, id)
        return this
    def add_classificationMarking(classificationMarking:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, classificationMarking)
        return this
    def add_env(env:TrackDetails_Ingest_env_Enum):
        b_.PrependInt8Slot(2, env, 0)
        return this
    def add_msgType(msgType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, msgType)
        return this
    def add_hullNum(hullNum:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, hullNum)
        return this
    def add_pif(pif:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, pif)
        return this
    def add_sconum(sconum:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, sconum)
        return this
    def add_ntds(ntds:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, ntds)
        return this
    def add_disId(disId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, disId)
        return this
    def add_midbCat(midbCat:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, midbCat)
        return this
    def add_beNumber(beNumber:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, beNumber)
        return this
    def add_oSuffix(oSuffix:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, oSuffix)
        return this
    def add_pin(pin:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, pin)
        return this
    def add_lostTrkInd(lostTrkInd:bool):
        b_.PrependBoolSlot(13, lostTrkInd, 0)
        return this
    def add_muidSrcTrk(muidSrcTrk:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(14, muidSrcTrk)
        return this
    def add_muidSrc(muidSrc:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, muidSrc)
        return this
    def add_mslStatus(mslStatus:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, mslStatus)
        return this
    def add_trkConf(trkConf:float):
        b_.PrependFloat64Slot(17, trkConf, 0.0)
        return this
    def add_trkQual(trkQual:int):
        b_.PrependInt32Slot(18, trkQual, 0)
        return this
    def add_alert(alert:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, alert)
        return this
    def add_origXref(origXref:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, origXref)
        return this
    def add_elnot1(elnot1:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, elnot1)
        return this
    def add_elnot2(elnot2:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, elnot2)
        return this
    def add_objIdent(objIdent:TrackDetails_Ingest_objIdent_Enum):
        b_.PrependInt8Slot(23, objIdent, 0)
        return this
    def add_objType(objType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(24, objType)
        return this
    def add_objPlat(objPlat:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(25, objPlat)
        return this
    def add_objAct(objAct:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(26, objAct)
        return this
    def add_objNat(objNat:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(27, objNat)
        return this
    def add_name(name:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(28, name)
        return this
    def add_shortName(shortName:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(29, shortName)
        return this
    def add_trkId(trkId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(30, trkId)
        return this
    def add_trkNum(trkNum:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(31, trkNum)
        return this
    def add_trkScope(trkScope:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(32, trkScope)
        return this
    def add_sourceUid(sourceUid:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, sourceUid)
        return this
    def add_callSign(callSign:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(34, callSign)
        return this
    def add_identAmp(identAmp:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(35, identAmp)
        return this
    def add_spaceAmp(spaceAmp:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(36, spaceAmp)
        return this
    def add_spaceAmpConf(spaceAmpConf:int):
        b_.PrependInt32Slot(37, spaceAmpConf, 0)
        return this
    def add_spaceSpecType(spaceSpecType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(38, spaceSpecType)
        return this
    def add_acftSubType(acftSubType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(39, acftSubType)
        return this
    def add_ts(ts:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(40, ts)
        return this
    def add_launchTime(launchTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(41, launchTime)
        return this
    def add_impactTime(impactTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(42, impactTime)
        return this
    def add_ftnMsgTs(ftnMsgTs:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(43, ftnMsgTs)
        return this
    def add_ftn(ftn:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(44, ftn)
        return this
    def add_ftnCmd(ftnCmd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(45, ftnCmd)
        return this
    def add_rtnMsgTs(rtnMsgTs:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(46, rtnMsgTs)
        return this
    def add_rtn(rtn:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(47, rtn)
        return this
    def add_rtnTrkState(rtnTrkState:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(48, rtnTrkState)
        return this
    def add_rtnCmd(rtnCmd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(49, rtnCmd)
        return this
    def add_sen(sen:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(50, sen)
        return this
    def add_rptChxref(rptChxref:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(51, rptChxref)
        return this
    def add_rptArchived(rptArchived:bool):
        b_.PrependBoolSlot(52, rptArchived, 0)
        return this
    def add_selfReport(selfReport:bool):
        b_.PrependBoolSlot(53, selfReport, 0)
        return this
    def add_mil2525Bstr(mil2525Bstr:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(54, mil2525Bstr)
        return this
    def add_trnspdrId(trnspdrId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(55, trnspdrId)
        return this
    def add_trnspdrType(trnspdrType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(56, trnspdrType)
        return this
    def add_emitterName(emitterName:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(57, emitterName)
        return this
    def add_infoSource(infoSource:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(58, infoSource)
        return this
    def add_boosting(boosting:bool):
        b_.PrependBoolSlot(59, boosting, 0)
        return this
    def add_freq(freq:float):
        b_.PrependFloat64Slot(60, freq, 0.0)
        return this
    def add_maxFreq(maxFreq:float):
        b_.PrependFloat64Slot(61, maxFreq, 0.0)
        return this
    def add_harmonics(harmonics:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(62, harmonics)
        return this
    def add_pri(pri:float):
        b_.PrependFloat64Slot(63, pri, 0.0)
        return this
    def add_prf(prf:float):
        b_.PrependFloat64Slot(64, prf, 0.0)
        return this
    def add_pw(pw:float):
        b_.PrependFloat64Slot(65, pw, 0.0)
        return this
    def add_scanType(scanType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(66, scanType)
        return this
    def add_scanRate(scanRate:float):
        b_.PrependFloat64Slot(67, scanRate, 0.0)
        return this
    def add_scn(scn:int):
        b_.PrependInt32Slot(68, scn, 0)
        return this
    def add_cI(cI:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(69, cI)
        return this
    def add_angElev(angElev:float):
        b_.PrependFloat64Slot(70, angElev, 0.0)
        return this
    def add_lat(lat:float):
        b_.PrependFloat64Slot(71, lat, 0.0)
        return this
    def add_lon(lon:float):
        b_.PrependFloat64Slot(72, lon, 0.0)
        return this
    def add_launchLat(launchLat:float):
        b_.PrependFloat64Slot(73, launchLat, 0.0)
        return this
    def add_launchLon(launchLon:float):
        b_.PrependFloat64Slot(74, launchLon, 0.0)
        return this
    def add_impactLat(impactLat:float):
        b_.PrependFloat64Slot(75, impactLat, 0.0)
        return this
    def add_impactLon(impactLon:float):
        b_.PrependFloat64Slot(76, impactLon, 0.0)
        return this
    def add_polarSingLocLat(polarSingLocLat:float):
        b_.PrependFloat64Slot(77, polarSingLocLat, 0.0)
        return this
    def add_polarSingLocLon(polarSingLocLon:float):
        b_.PrependFloat64Slot(78, polarSingLocLon, 0.0)
        return this
    def add_azCorrCenterLine(azCorrCenterLine:float):
        b_.PrependFloat64Slot(79, azCorrCenterLine, 0.0)
        return this
    def add_azCorrArcWidth(azCorrArcWidth:float):
        b_.PrependFloat64Slot(80, azCorrArcWidth, 0.0)
        return this
    def add_errSemiIntAxis(errSemiIntAxis:float):
        b_.PrependFloat64Slot(81, errSemiIntAxis, 0.0)
        return this
    def add_errAreaOrient(errAreaOrient:float):
        b_.PrependFloat64Slot(82, errAreaOrient, 0.0)
        return this
    def add_errSemiMajElev(errSemiMajElev:float):
        b_.PrependFloat64Slot(83, errSemiMajElev, 0.0)
        return this
    def add_errGeoAreaSwitch(errGeoAreaSwitch:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(84, errGeoAreaSwitch)
        return this
    def add_burnoutAlt(burnoutAlt:float):
        b_.PrependFloat64Slot(85, burnoutAlt, 0.0)
        return this
    def add_tesEventId(tesEventId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(86, tesEventId)
        return this
    def add_spd(spd:float):
        b_.PrependFloat64Slot(87, spd, 0.0)
        return this
    def add_avgSpd(avgSpd:float):
        b_.PrependFloat64Slot(88, avgSpd, 0.0)
        return this
    def add_tol(tol:float):
        b_.PrependFloat64Slot(89, tol, 0.0)
        return this
    def add_alt(alt:float):
        b_.PrependFloat64Slot(90, alt, 0.0)
        return this
    def add_hdng(hdng:float):
        b_.PrependFloat64Slot(91, hdng, 0.0)
        return this
    def add_course(course:float):
        b_.PrependFloat64Slot(92, course, 0.0)
        return this
    def add_propRPM(propRPM:float):
        b_.PrependFloat64Slot(93, propRPM, 0.0)
        return this
    def add_tpk(tpk:float):
        b_.PrependFloat64Slot(94, tpk, 0.0)
        return this
    def add_coopLocInd(coopLocInd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(95, coopLocInd)
        return this
    def add_maneuverInd(maneuverInd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(96, maneuverInd)
        return this
    def add_launchAouType(launchAouType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(97, launchAouType)
        return this
    def add_launchAouData(launchAouData:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(98, launchAouData)
        return this
    def add_impactAouType(impactAouType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(99, impactAouType)
        return this
    def add_impactAouData(impactAouData:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(100, impactAouData)
        return this
    def add_aouRptType(aouRptType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(101, aouRptType)
        return this
    def add_aouRptData(aouRptData:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(102, aouRptData)
        return this
    def add_ecefPos(ecefPos:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(103, ecefPos)
        return this
    def add_ecefVel(ecefVel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(104, ecefVel)
        return this
    def add_containment(containment:float):
        b_.PrependFloat64Slot(105, containment, 0.0)
        return this
    def add_cpa(cpa:float):
        b_.PrependFloat64Slot(106, cpa, 0.0)
        return this
    def add_tcpa(tcpa:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(107, tcpa)
        return this
    def add_navStatus(navStatus:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(108, navStatus)
        return this
    def add_posDeviceType(posDeviceType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(109, posDeviceType)
        return this
    def add_aton(aton:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(110, aton)
        return this
    def add_offPosInd(offPosInd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(111, offPosInd)
        return this
    def add_antennaRefDimensions(antennaRefDimensions:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(112, antennaRefDimensions)
        return this
    def add_shipClass(shipClass:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(113, shipClass)
        return this
    def add_imon(imon:int):
        b_.PrependInt32Slot(114, imon, 0)
        return this
    def add_mmsi(mmsi:int):
        b_.PrependInt32Slot(115, mmsi, 0)
        return this
    def add_draught(draught:float):
        b_.PrependFloat64Slot(116, draught, 0.0)
        return this
    def add_length(length:float):
        b_.PrependFloat64Slot(117, length, 0.0)
        return this
    def add_width(width:float):
        b_.PrependFloat64Slot(118, width, 0.0)
        return this
    def add_cargoType(cargoType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(119, cargoType)
        return this
    def add_appGrp(appGrp:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(120, appGrp)
        return this
    def add_hullProf(hullProf:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(121, hullProf)
        return this
    def add_propType(propType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(122, propType)
        return this
    def add_numBlades(numBlades:int):
        b_.PrependInt32Slot(123, numBlades, 0)
        return this
    def add_numShafts(numShafts:int):
        b_.PrependInt32Slot(124, numShafts, 0)
        return this
    def add_sternType(sternType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(125, sternType)
        return this
    def add_vslWt(vslWt:float):
        b_.PrependFloat64Slot(126, vslWt, 0.0)
        return this
    def add_arrTime(arrTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(127, arrTime)
        return this
    def add_arrFlag(arrFlag:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(128, arrFlag)
        return this
    def add_arrCargo(arrCargo:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(129, arrCargo)
        return this
    def add_arrPort(arrPort:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(130, arrPort)
        return this
    def add_depPort(depPort:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(131, depPort)
        return this
    def add_depFlag(depFlag:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(132, depFlag)
        return this
    def add_depCargo(depCargo:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(133, depCargo)
        return this
    def add_desFlag(desFlag:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(134, desFlag)
        return this
    def add_desCargo(desCargo:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(135, desCargo)
        return this
    def add_destination(destination:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(136, destination)
        return this
    def add_eta(eta:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(137, eta)
        return this
    def add_etd(etd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(138, etd)
        return this
    def add_iff(iff:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(139, iff)
        return this
    def add_emgInd(emgInd:bool):
        b_.PrependBoolSlot(140, emgInd, 0)
        return this
    def add_dropPtInd(dropPtInd:bool):
        b_.PrependBoolSlot(141, dropPtInd, 0)
        return this
    def add_reinforced(reinforced:bool):
        b_.PrependBoolSlot(142, reinforced, 0)
        return this
    def add_reduced(reduced:bool):
        b_.PrependBoolSlot(143, reduced, 0)
        return this
    def add_hq(hq:bool):
        b_.PrependBoolSlot(144, hq, 0)
        return this
    def add_dummy(dummy:bool):
        b_.PrependBoolSlot(145, dummy, 0)
        return this
    def add_taskForce(taskForce:bool):
        b_.PrependBoolSlot(146, taskForce, 0)
        return this
    def add_feint(feint:bool):
        b_.PrependBoolSlot(147, feint, 0)
        return this
    def add_installation(installation:bool):
        b_.PrependBoolSlot(148, installation, 0)
        return this
    def add_staffCmts(staffCmts:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(149, staffCmts)
        return this
    def add_addInfo(addInfo:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(150, addInfo)
        return this
    def add_evalRating(evalRating:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(151, evalRating)
        return this
    def add_createdAt(createdAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(152, createdAt)
        return this
    def add_createdBy(createdBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(153, createdBy)
        return this
    def add_source(source:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(154, source)
        return this
    def add_origin(origin:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(155, origin)
        return this
    def add_dataMode(dataMode:TrackDetails_Ingest_dataMode_Enum):
        b_.PrependInt8Slot(156, dataMode, 0)
        return this
    def add_origNetwork(origNetwork:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(157, origNetwork)
        return this
    def end():
        return b_.EndObject()

def TrackDetails_IngestStartRtnMsgTsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateRtnMsgTsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartRtnVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateRtnVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartLaunchAouDataVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateLaunchAouDataVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartImpactAouDataVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateImpactAouDataVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartAouRptDataVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateAouRptDataVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartEcefPosVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateEcefPosVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartEcefVelVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateEcefVelVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def TrackDetails_IngestStartAntennaRefDimensionsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def TrackDetails_IngestCreateAntennaRefDimensionsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

