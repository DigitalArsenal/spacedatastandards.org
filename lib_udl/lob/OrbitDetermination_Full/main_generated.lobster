// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum OrbitDetermination_Full_dataMode_Enum:
    /// Data collected or produced that pertains to real-world objects, events, and analysis.
    OrbitDetermination_Full_dataMode_Enum_REAL = 0
    /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    OrbitDetermination_Full_dataMode_Enum_TEST = 1
    /// Synthetic data generated by a model to mimic real-world datasets.
    OrbitDetermination_Full_dataMode_Enum_SIMULATED = 2
    /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
    OrbitDetermination_Full_dataMode_Enum_EXERCISE = 3

class OrbitDetermination_Full

/// /// Model representation of orbit determination algorithm results describing General Perturbations or Special Perturbations orbital updates.
class OrbitDetermination_Full : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
    /// Constraints: Minimum length = 1, Maximum length = 36
    def id() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    def classificationMarking() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Start time for OD solution in ISO 8601 UTC datetime format, with microsecond precision.
    /// Example: /// Example: 2023-08-28T11:20:21.247192Z
    /// Constraints: No constraints specified.
    def startTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// End time for OD solution in ISO 8601 UTC datetime format, with microsecond precision.
    /// Example: /// Example: 2023-08-28T15:20:21.247192Z
    /// Constraints: No constraints specified.
    def endTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Unique identifier of the target satellite on-orbit object. This ID can be used to obtain additional information on an OnOrbit object using the 'get by ID' operation (e.g. /udl/onorbit/{id}). For example, the OnOrbit with idOnOrbit = 25544 would be queried as /udl/onorbit/25544.
    /// Example: /// Example: 54741
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idOnOrbit() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Optional identifier provided by the OD source to indicate the target on-orbit object of this OD solution. This may be an internal identifier and not necessarily map to a valid satellite number.
    /// Example: /// Example: ORIGOBJECT-ID
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origObjectId() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// Satellite/Catalog number of the target on-orbit object.
    /// Example: /// Example: 54741
    /// Constraints: No constraints specified.
    def satNo() -> int:
        return flatbuffers.field_int32(buf_, pos_, 16, 0)
    /// Identifier of the element set used to seed this OD solution. This ID can be used to obtain additional information on an Elset object using the 'get by ID' operation (e.g. /udl/elset/{id}). For example, the Elset with idElset = abc would be queried as /udl/elset/abc.
    /// Example: /// Example: 80e544b7-6a17-4554-8abf-7301e98f8e5d
    /// Constraints: Minimum length = 0, Maximum length = 36
    def aprioriIdElset() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def aprioriElset() -> string:
        return flatbuffers.field_string(buf_, pos_, 20)
    /// Identifier of the state vector used to seed this OD solution. This ID can be used to obtain additional information on a StateVector object using the 'get by ID' operation (e.g. /udl/statevector/{id}). For example, the StateVector with idStateVector = abc would be queried as /udl/statevector/abc.
    /// Example: /// Example: 6e291992-8ae3-4592-bb0f-055715bf4803
    /// Constraints: Minimum length = 0, Maximum length = 36
    def aprioriIdStateVector() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def aprioriStateVector() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// Flag indicating whether this is an initial orbit determination.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def initialOD() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 26, 0))
    /// The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC datetime format with microsecond precision. For an exact observation time, the lastObStart and lastObEnd are the same.
    /// Example: /// Example: 2023-08-28T11:20:21.247192Z
    /// Constraints: No constraints specified.
    def lastObStart() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC datetime format with microsecond precision. For an exact observation time, the lastObStart and lastObEnd are the same.
    /// Example: /// Example: 2023-08-28T11:20:21.247192Z
    /// Constraints: No constraints specified.
    def lastObEnd() -> string:
        return flatbuffers.field_string(buf_, pos_, 30)
    /// The time span used for the OD of the object, in days.
    /// Example: /// Example: 3.5
    /// Constraints: No constraints specified.
    def timeSpan() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// Optional start time at which this OD solution is accurate, in ISO 8601 UTC datetime format with microsecond precision.
    /// Example: /// Example: 2023-08-28T11:20:21.247192Z
    /// Constraints: No constraints specified.
    def effectiveFrom() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// Optional end time at which this OD solution may no longer be accurate, in ISO 8601 UTC datetime format with microsecond precision.
    /// Example: /// Example: 2023-08-30T08:15:00.123456Z
    /// Constraints: No constraints specified.
    def effectiveUntil() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)
    /// The Weighted Root Mean Squared (RMS) of the differential correction of the target object that produced this OD state. WRMS is a quality indicator of the OD update, with a value of 1.00 being optimal. WRMS applies to batch least squares (BLS) processes.
    /// Example: /// Example: 0.991
    /// Constraints: No constraints specified.
    def wrms() -> float:
        return flatbuffers.field_float64(buf_, pos_, 38, 0.0)
    /// The Weighted Root Mean Squared (RMS) of the differential correction from the previous overhead pass of the satellite. Provides a point of comparison for assessing changes in the quality of the OD solution between consecutive passes.
    /// Example: /// Example: 1.02
    /// Constraints: No constraints specified.
    def previousWrms() -> float:
        return flatbuffers.field_float64(buf_, pos_, 40, 0.0)
    /// The Weighted Root Mean Squared (RMS) calculated for the first satellite pass in the observation span. Serves as the initial quality metric for the beginning of the observation period.
    /// Example: /// Example: 0.985
    /// Constraints: No constraints specified.
    def firstPassWrms() -> float:
        return flatbuffers.field_float64(buf_, pos_, 42, 0.0)
    /// Lowest Weighted Root Mean Squared (RMS) value achieved for any single satellite pass during the observation span, indicating the pass with the highest quality OD solution.
    /// Example: /// Example: 0.975
    /// Constraints: No constraints specified.
    def bestPassWrms() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Error growth rate of the OD solution in kilometers per day.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def errorGrowthRate() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)
    /// Model parameter value for energy dissipation rate (EDR) in watts per kilogram.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def edr() -> float:
        return flatbuffers.field_float64(buf_, pos_, 48, 0.0)
    /// Orbit determination method used to produce this record (e.g. BLS, KF, UKF, etc.).
    /// Example: /// Example: BLS
    /// Constraints: Minimum length = 1, Maximum length = 64
    def method() -> string:
        return flatbuffers.field_string(buf_, pos_, 50)
    /// Source of orbit determination method used to produce this record (e.g. ASW, ACTRAC, FreeFlyer, GEODYNE, GDTS, etc.).
    /// Example: /// Example: ASW
    /// Constraints: Minimum length = 0, Maximum length = 64
    def methodSource() -> string:
        return flatbuffers.field_string(buf_, pos_, 52)
    /// The fit span, in days, used in a Batch Least Squares (BLS) OD.
    /// Example: /// Example: 0.6
    /// Constraints: No constraints specified.
    def fitSpan() -> float:
        return flatbuffers.field_float64(buf_, pos_, 54, 0.0)
    /// Flag indicating whether the ballistic coefficient was estimated during this OD solution.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def ballisticCoeffEst() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 56, 0))
    /// Model used to estimate the ballistic coefficient.
    /// Example: /// Example: GaussMarkov
    /// Constraints: Minimum length = 0, Maximum length = 64
    def ballisticCoeffModel() -> string:
        return flatbuffers.field_string(buf_, pos_, 58)
    /// Flag indicating whether the AGOM was estimated during this OD solution.
    /// Example: /// Example: False
    /// Constraints: No constraints specified.
    def agomEst() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 60, 0))
    /// Model used to estimate the AGOM.
    /// Example: /// Example: RandomWalk
    /// Constraints: Minimum length = 0, Maximum length = 64
    def agomModel() -> string:
        return flatbuffers.field_string(buf_, pos_, 62)
    /// OD parameter value for the Root Mean Square (RMS) convergence criteria to successfully close the OD solution.
    /// Example: /// Example: 0.001
    /// Constraints: No constraints specified.
    def rmsConvergenceCriteria() -> float:
        return flatbuffers.field_float64(buf_, pos_, 64, 0.0)
    /// The number of iterations taken for the algorithm to converge on an OD solution.
    /// Example: /// Example: 8
    /// Constraints: No constraints specified.
    def numIterations() -> int:
        return flatbuffers.field_int32(buf_, pos_, 66, 0)
    /// Array of UDL observation types (e.g. DOA, EO, RADAR, RF) of the observations that were accepted in this OD solution. See the associated acceptedObIds array for the records UUID(s), positionally corresponding to the record types in this array. The acceptedObTyps and acceptedObIds arrays must match in size.
    /// Example: /// Example: ['EO', 'RADAR']
    /// Constraints: No constraints specified.
    def acceptedObTyps(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 68) + i * 4)
    def acceptedObTyps_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 68)
    /// Array of UDL data (observation) UUIDs that were accepted in this OD solution. See the associated acceptedObTyps array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
    /// Example: /// Example: ['EOOBSERVATION-ID1', 'RADAROBSERVATION-ID1']
    /// Constraints: No constraints specified.
    def acceptedObIds(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 70) + i * 4)
    def acceptedObIds_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 70)
    /// Array of UDL observation types (e.g. DOA, EO, RADAR, RF) of the observations that were rejected in this OD solution. See the associated rejectedObIds array for the records UUID(s), positionally corresponding to the record types in this array. The rejectedObTyps and rejectedObIds arrays must match in size.
    /// Example: /// Example: ['DOA', 'RF']
    /// Constraints: No constraints specified.
    def rejectedObTyps(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 72) + i * 4)
    def rejectedObTyps_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 72)
    /// Array of UDL data (observation) UUIDs that were rejected in this OD solution. See the associated rejectedObTyps array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
    /// Example: /// Example: ['DIFFOFARRIVAL-ID2', 'RFOBSERVATION-ID2']
    /// Constraints: No constraints specified.
    def rejectedObIds(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 74) + i * 4)
    def rejectedObIds_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 74)
    /// Array of UDL UUIDs (idSensor) of the sensors that contributed observations in this OD solution.
    /// Example: /// Example: ['SENSOR-ID1', 'SENSOR-ID2']
    /// Constraints: No constraints specified.
    def sensorIds(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 76) + i * 4)
    def sensorIds_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 76)
    /// Time the row was created in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def createdAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 78)
    /// Application user who created the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    def createdBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 80)
    /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
    /// Example: /// Example: AXE
    /// Constraints: Minimum length = 0, Maximum length = 64
    def sourceDL() -> string:
        return flatbuffers.field_string(buf_, pos_, 82)
    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 36
    def source() -> string:
        return flatbuffers.field_string(buf_, pos_, 84)
    /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    /// Example: /// Example: THIRD_PARTY_DATASOURCE
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origin() -> string:
        return flatbuffers.field_string(buf_, pos_, 86)
    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: OPS1
    /// Constraints: Minimum length = 0, Maximum length = 32
    def origNetwork() -> string:
        return flatbuffers.field_string(buf_, pos_, 88)
    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    def dataMode() -> OrbitDetermination_Full_dataMode_Enum:
        return OrbitDetermination_Full_dataMode_Enum(flatbuffers.field_int8(buf_, pos_, 90, 0))
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def onOrbit() -> string:
        return flatbuffers.field_string(buf_, pos_, 92)

def GetRootAsOrbitDetermination_Full(buf:string): return OrbitDetermination_Full { buf, flatbuffers.indirect(buf, 0) }

struct OrbitDetermination_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(45)
        return this
    def add_id(id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, id)
        return this
    def add_classificationMarking(classificationMarking:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, classificationMarking)
        return this
    def add_startTime(startTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, startTime)
        return this
    def add_endTime(endTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, endTime)
        return this
    def add_idOnOrbit(idOnOrbit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, idOnOrbit)
        return this
    def add_origObjectId(origObjectId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, origObjectId)
        return this
    def add_satNo(satNo:int):
        b_.PrependInt32Slot(6, satNo, 0)
        return this
    def add_aprioriIdElset(aprioriIdElset:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, aprioriIdElset)
        return this
    def add_aprioriElset(aprioriElset:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(8, aprioriElset)
        return this
    def add_aprioriIdStateVector(aprioriIdStateVector:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, aprioriIdStateVector)
        return this
    def add_aprioriStateVector(aprioriStateVector:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, aprioriStateVector)
        return this
    def add_initialOD(initialOD:bool):
        b_.PrependBoolSlot(11, initialOD, 0)
        return this
    def add_lastObStart(lastObStart:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, lastObStart)
        return this
    def add_lastObEnd(lastObEnd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(13, lastObEnd)
        return this
    def add_timeSpan(timeSpan:float):
        b_.PrependFloat64Slot(14, timeSpan, 0.0)
        return this
    def add_effectiveFrom(effectiveFrom:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, effectiveFrom)
        return this
    def add_effectiveUntil(effectiveUntil:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, effectiveUntil)
        return this
    def add_wrms(wrms:float):
        b_.PrependFloat64Slot(17, wrms, 0.0)
        return this
    def add_previousWrms(previousWrms:float):
        b_.PrependFloat64Slot(18, previousWrms, 0.0)
        return this
    def add_firstPassWrms(firstPassWrms:float):
        b_.PrependFloat64Slot(19, firstPassWrms, 0.0)
        return this
    def add_bestPassWrms(bestPassWrms:float):
        b_.PrependFloat64Slot(20, bestPassWrms, 0.0)
        return this
    def add_errorGrowthRate(errorGrowthRate:float):
        b_.PrependFloat64Slot(21, errorGrowthRate, 0.0)
        return this
    def add_edr(edr:float):
        b_.PrependFloat64Slot(22, edr, 0.0)
        return this
    def add_method(method:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(23, method)
        return this
    def add_methodSource(methodSource:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(24, methodSource)
        return this
    def add_fitSpan(fitSpan:float):
        b_.PrependFloat64Slot(25, fitSpan, 0.0)
        return this
    def add_ballisticCoeffEst(ballisticCoeffEst:bool):
        b_.PrependBoolSlot(26, ballisticCoeffEst, 0)
        return this
    def add_ballisticCoeffModel(ballisticCoeffModel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(27, ballisticCoeffModel)
        return this
    def add_agomEst(agomEst:bool):
        b_.PrependBoolSlot(28, agomEst, 0)
        return this
    def add_agomModel(agomModel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(29, agomModel)
        return this
    def add_rmsConvergenceCriteria(rmsConvergenceCriteria:float):
        b_.PrependFloat64Slot(30, rmsConvergenceCriteria, 0.0)
        return this
    def add_numIterations(numIterations:int):
        b_.PrependInt32Slot(31, numIterations, 0)
        return this
    def add_acceptedObTyps(acceptedObTyps:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(32, acceptedObTyps)
        return this
    def add_acceptedObIds(acceptedObIds:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, acceptedObIds)
        return this
    def add_rejectedObTyps(rejectedObTyps:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(34, rejectedObTyps)
        return this
    def add_rejectedObIds(rejectedObIds:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(35, rejectedObIds)
        return this
    def add_sensorIds(sensorIds:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(36, sensorIds)
        return this
    def add_createdAt(createdAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(37, createdAt)
        return this
    def add_createdBy(createdBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(38, createdBy)
        return this
    def add_sourceDL(sourceDL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(39, sourceDL)
        return this
    def add_source(source:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(40, source)
        return this
    def add_origin(origin:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(41, origin)
        return this
    def add_origNetwork(origNetwork:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(42, origNetwork)
        return this
    def add_dataMode(dataMode:OrbitDetermination_Full_dataMode_Enum):
        b_.PrependInt8Slot(43, dataMode, 0)
        return this
    def add_onOrbit(onOrbit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(44, onOrbit)
        return this
    def end():
        return b_.EndObject()

def OrbitDetermination_FullStartAcceptedObTypsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OrbitDetermination_FullCreateAcceptedObTypsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OrbitDetermination_FullStartAcceptedObIdsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OrbitDetermination_FullCreateAcceptedObIdsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OrbitDetermination_FullStartRejectedObTypsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OrbitDetermination_FullCreateRejectedObTypsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OrbitDetermination_FullStartRejectedObIdsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OrbitDetermination_FullCreateRejectedObIdsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def OrbitDetermination_FullStartSensorIdsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def OrbitDetermination_FullCreateSensorIdsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

