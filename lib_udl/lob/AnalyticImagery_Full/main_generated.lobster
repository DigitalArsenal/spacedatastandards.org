// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum AnalyticImagery_Full_dataMode_Enum:
    /// No description available.
    AnalyticImagery_Full_dataMode_Enum_REAL = 0
    /// No description available.
    AnalyticImagery_Full_dataMode_Enum_TEST = 1
    /// No description available.
    AnalyticImagery_Full_dataMode_Enum_SIMULATED = 2
    /// No description available.
    AnalyticImagery_Full_dataMode_Enum_EXERCISE = 3

class AnalyticImagery_Full

/// /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
class AnalyticImagery_Full : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: ANALYTIC-IMAGERY-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    def id() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    def classificationMarking() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
    /// Example: /// Example: CONTOUR
    /// Constraints: Minimum length = 1, Maximum length = 36
    def content() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// The message time of this image record, in ISO8601 UTC format with millisecond precision.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def msgTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// The type of image associated with this record (GIF, JPG, PNG, TIF).
    /// Example: /// Example: JPG
    /// Constraints: Minimum length = 1, Maximum length = 16
    def imageType() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// The image file name.
    /// Example: /// Example: IMAGE-NAME
    /// Constraints: Minimum length = 1, Maximum length = 128
    def filename() -> string:
        return flatbuffers.field_string(buf_, pos_, 14)
    /// The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
    /// Example: /// Example: 7654321
    /// Constraints: No constraints specified.
    def filesize() -> int:
        return flatbuffers.field_int64(buf_, pos_, 16, 0)
    /// The image width (horizontal), in pixels.
    /// Example: /// Example: 123
    /// Constraints: No constraints specified.
    def imgWidth() -> int:
        return flatbuffers.field_int32(buf_, pos_, 18, 0)
    /// The image height (vertical), in pixels.
    /// Example: /// Example: 123
    /// Constraints: No constraints specified.
    def imgHeight() -> int:
        return flatbuffers.field_int32(buf_, pos_, 20, 0)
    /// Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
    /// Example: /// Example: pixels
    /// Constraints: Minimum length = 0, Maximum length = 36
    def xUnits() -> string:
        return flatbuffers.field_string(buf_, pos_, 22)
    /// Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
    /// Example: /// Example: pixels
    /// Constraints: Minimum length = 0, Maximum length = 36
    def yUnits() -> string:
        return flatbuffers.field_string(buf_, pos_, 24)
    /// Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
    /// Example: /// Example: pixels
    /// Constraints: Minimum length = 0, Maximum length = 36
    def zUnits() -> string:
        return flatbuffers.field_string(buf_, pos_, 26)
    /// User-defined set ID of a sequence of images.  Used to associate related analytic image records.
    /// Example: /// Example: IMAGE-IDS
    /// Constraints: Minimum length = 0, Maximum length = 36
    def imageSetId() -> string:
        return flatbuffers.field_string(buf_, pos_, 28)
    /// The number of images in an image set.
    /// Example: /// Example: 123
    /// Constraints: No constraints specified.
    def imageSetLength() -> int:
        return flatbuffers.field_int32(buf_, pos_, 30, 0)
    /// The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
    /// Example: /// Example: 123
    /// Constraints: No constraints specified.
    def sequenceId() -> int:
        return flatbuffers.field_int32(buf_, pos_, 32, 0)
    /// Description of the image content and utility.
    /// Example: /// Example: Image description
    /// Constraints: Minimum length = 1, Maximum length = 512
    def description() -> string:
        return flatbuffers.field_string(buf_, pos_, 34)
    /// The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def dataStart() -> string:
        return flatbuffers.field_string(buf_, pos_, 36)
    /// The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def dataStop() -> string:
        return flatbuffers.field_string(buf_, pos_, 38)
    /// Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
    /// Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
    /// Constraints: No constraints specified.
    def annLims(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 40) + i * 4)
    def annLims_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 40)
    /// Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
    /// Example: /// Example: ['rec1', 'rec2']
    /// Constraints: No constraints specified.
    def annText(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 42) + i * 4)
    def annText_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 42)
    /// Array of searchable keywords for this analytic imagery record.
    /// Example: /// Example: ['Key1', 'Key2']
    /// Constraints: No constraints specified.
    def keywords(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 44) + i * 4)
    def keywords_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 44)
    /// Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
    /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
    /// Constraints: No constraints specified.
    def area() -> string:
        return flatbuffers.field_string(buf_, pos_, 46)
    /// Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
    /// Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
    /// Constraints: No constraints specified.
    def atext() -> string:
        return flatbuffers.field_string(buf_, pos_, 48)
    /// Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
    /// Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
    /// Constraints: No constraints specified.
    def agjson() -> string:
        return flatbuffers.field_string(buf_, pos_, 50)
    /// Type of region as projected on the ground.
    /// Example: /// Example: POLYGON
    /// Constraints: Minimum length = 0, Maximum length = 128
    def atype() -> string:
        return flatbuffers.field_string(buf_, pos_, 52)
    /// Number of dimensions of the geometry depicted by region.
    /// Example: /// Example: 2
    /// Constraints: No constraints specified.
    def andims() -> int:
        return flatbuffers.field_int32(buf_, pos_, 54, 0)
    /// Geographical spatial_ref_sys for region.
    /// Example: /// Example: 4326
    /// Constraints: No constraints specified.
    def asrid() -> int:
        return flatbuffers.field_int32(buf_, pos_, 56, 0)
    /// Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
    /// Example: /// Example: [12004, 12005]
    /// Constraints: No constraints specified.
    def satId(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 58) + i * 4)
    def satId_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 58)
    /// Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
    /// Example: /// Example: [0.98, 0.22]
    /// Constraints: No constraints specified.
    def satIdConf(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 60) + i * 4)
    def satIdConf_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 60)
    /// Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
    /// Example: /// Example: ['MTI', 'POI']
    /// Constraints: No constraints specified.
    def srcTyps(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 62) + i * 4)
    def srcTyps_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 62)
    /// Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
    /// Example: /// Example: ['DOA_ID', 'DWELL_ID']
    /// Constraints: No constraints specified.
    def srcIds(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 64) + i * 4)
    def srcIds_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 64)
    /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
    /// Example: /// Example: ['TAG1', 'TAG2']
    /// Constraints: No constraints specified.
    def tags(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 66) + i * 4)
    def tags_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 66)
    /// MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
    /// Example: /// Example: 123
    /// Constraints: Minimum length = 0, Maximum length = 256
    def checksumValue() -> string:
        return flatbuffers.field_string(buf_, pos_, 68)
    /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
    /// Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
    /// Constraints: Minimum length = 0, Maximum length = 64
    def transactionId() -> string:
        return flatbuffers.field_string(buf_, pos_, 70)
    /// Time the row was created in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def createdAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 72)
    /// Application user who created the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    def createdBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 74)
    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 36
    def source() -> string:
        return flatbuffers.field_string(buf_, pos_, 76)
    /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    /// Example: /// Example: ORIGIN
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origin() -> string:
        return flatbuffers.field_string(buf_, pos_, 78)
    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: TST1
    /// Constraints: Minimum length = 1, Maximum length = 32
    def origNetwork() -> string:
        return flatbuffers.field_string(buf_, pos_, 80)
    /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
    /// Example: /// Example: AXE
    /// Constraints: Minimum length = 0, Maximum length = 64
    def sourceDL() -> string:
        return flatbuffers.field_string(buf_, pos_, 82)
    /// Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    def dataMode() -> AnalyticImagery_Full_dataMode_Enum:
        return AnalyticImagery_Full_dataMode_Enum(flatbuffers.field_int8(buf_, pos_, 84, 0))

def GetRootAsAnalyticImagery_Full(buf:string): return AnalyticImagery_Full { buf, flatbuffers.indirect(buf, 0) }

struct AnalyticImagery_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(41)
        return this
    def add_id(id:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, id)
        return this
    def add_classificationMarking(classificationMarking:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, classificationMarking)
        return this
    def add_content(content:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, content)
        return this
    def add_msgTime(msgTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, msgTime)
        return this
    def add_imageType(imageType:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, imageType)
        return this
    def add_filename(filename:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(5, filename)
        return this
    def add_filesize(filesize:int):
        b_.PrependInt64Slot(6, filesize, 0)
        return this
    def add_imgWidth(imgWidth:int):
        b_.PrependInt32Slot(7, imgWidth, 0)
        return this
    def add_imgHeight(imgHeight:int):
        b_.PrependInt32Slot(8, imgHeight, 0)
        return this
    def add_xUnits(xUnits:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(9, xUnits)
        return this
    def add_yUnits(yUnits:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(10, yUnits)
        return this
    def add_zUnits(zUnits:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(11, zUnits)
        return this
    def add_imageSetId(imageSetId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(12, imageSetId)
        return this
    def add_imageSetLength(imageSetLength:int):
        b_.PrependInt32Slot(13, imageSetLength, 0)
        return this
    def add_sequenceId(sequenceId:int):
        b_.PrependInt32Slot(14, sequenceId, 0)
        return this
    def add_description(description:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(15, description)
        return this
    def add_dataStart(dataStart:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, dataStart)
        return this
    def add_dataStop(dataStop:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(17, dataStop)
        return this
    def add_annLims(annLims:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, annLims)
        return this
    def add_annText(annText:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, annText)
        return this
    def add_keywords(keywords:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(20, keywords)
        return this
    def add_area(area:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(21, area)
        return this
    def add_atext(atext:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(22, atext)
        return this
    def add_agjson(agjson:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(23, agjson)
        return this
    def add_atype(atype:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(24, atype)
        return this
    def add_andims(andims:int):
        b_.PrependInt32Slot(25, andims, 0)
        return this
    def add_asrid(asrid:int):
        b_.PrependInt32Slot(26, asrid, 0)
        return this
    def add_satId(satId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(27, satId)
        return this
    def add_satIdConf(satIdConf:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(28, satIdConf)
        return this
    def add_srcTyps(srcTyps:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(29, srcTyps)
        return this
    def add_srcIds(srcIds:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(30, srcIds)
        return this
    def add_tags(tags:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(31, tags)
        return this
    def add_checksumValue(checksumValue:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(32, checksumValue)
        return this
    def add_transactionId(transactionId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, transactionId)
        return this
    def add_createdAt(createdAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(34, createdAt)
        return this
    def add_createdBy(createdBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(35, createdBy)
        return this
    def add_source(source:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(36, source)
        return this
    def add_origin(origin:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(37, origin)
        return this
    def add_origNetwork(origNetwork:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(38, origNetwork)
        return this
    def add_sourceDL(sourceDL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(39, sourceDL)
        return this
    def add_dataMode(dataMode:AnalyticImagery_Full_dataMode_Enum):
        b_.PrependInt8Slot(40, dataMode, 0)
        return this
    def end():
        return b_.EndObject()

def AnalyticImagery_FullStartAnnLimsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateAnnLimsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartAnnTextVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateAnnTextVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartKeywordsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateKeywordsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartSatIdVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateSatIdVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartSatIdConfVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateSatIdConfVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartSrcTypsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateSrcTypsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartSrcIdsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateSrcIdsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def AnalyticImagery_FullStartTagsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def AnalyticImagery_FullCreateTagsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

