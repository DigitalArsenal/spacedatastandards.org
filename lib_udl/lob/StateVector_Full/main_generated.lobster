// automatically generated by the FlatBuffers compiler, do not modify
import flatbuffers

enum StateVector_Full_referenceFrame_Enum:
    /// No description available.
    StateVector_Full_referenceFrame_Enum_J2000 = 0
    /// No description available.
    StateVector_Full_referenceFrame_Enum_EFG_TDR = 1
    /// No description available.
    StateVector_Full_referenceFrame_Enum_ECR_ECEF = 2
    /// No description available.
    StateVector_Full_referenceFrame_Enum_TEME = 3
    /// No description available.
    StateVector_Full_referenceFrame_Enum_ITRF = 4
    /// No description available.
    StateVector_Full_referenceFrame_Enum_GCRF = 5

enum StateVector_Full_covReferenceFrame_Enum:
    /// No description available.
    StateVector_Full_covReferenceFrame_Enum_J2000 = 0
    /// No description available.
    StateVector_Full_covReferenceFrame_Enum_UVW = 1

enum StateVector_Full_dataMode_Enum:
    /// Data collected or produced that pertains to real-world objects, events, and analysis.
    StateVector_Full_dataMode_Enum_REAL = 0
    /// Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    StateVector_Full_dataMode_Enum_TEST = 1
    /// Synthetic data generated by a model to mimic real-world datasets.
    StateVector_Full_dataMode_Enum_SIMULATED = 2
    /// Data pertaining to a government or military exercise. The data may include both real and simulated data.
    StateVector_Full_dataMode_Enum_EXERCISE = 3

enum StateVector_Full_sourcedDataTypes_Enum:
    /// No description available.
    StateVector_Full_sourcedDataTypes_Enum_EO = 0
    /// No description available.
    StateVector_Full_sourcedDataTypes_Enum_RADAR = 1
    /// No description available.
    StateVector_Full_sourcedDataTypes_Enum_RF = 2
    /// No description available.
    StateVector_Full_sourcedDataTypes_Enum_DOA = 3
    /// No description available.
    StateVector_Full_sourcedDataTypes_Enum_ELSET = 4
    /// No description available.
    StateVector_Full_sourcedDataTypes_Enum_SV = 5

class StateVector_Full

/// /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
class StateVector_Full : flatbuffers.handle
    /// Unique identifier of the record, auto-generated by the system.
    /// Example: /// Example: STATEVECTOR-ID
    /// Constraints: Minimum length = 1, Maximum length = 36
    def idStateVector() -> string:
        return flatbuffers.field_string(buf_, pos_, 4)
    /// Classification marking of the data in IC/CAPCO Portion-marked format.
    /// Example: /// Example: U
    /// Constraints: Minimum length = 1, Maximum length = 128
    def classificationMarking() -> string:
        return flatbuffers.field_string(buf_, pos_, 6)
    /// Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
    /// Example: /// Example: 2018-01-01T16:00:00.123456Z
    /// Constraints: No constraints specified.
    def epoch() -> string:
        return flatbuffers.field_string(buf_, pos_, 8)
    /// The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
    /// Example: /// Example: CONJUNCTION
    /// Constraints: Minimum length = 0, Maximum length = 32
    def pedigree() -> string:
        return flatbuffers.field_string(buf_, pos_, 10)
    /// Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
    /// Example: /// Example: ONORBIT-ID
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idOnOrbit() -> string:
        return flatbuffers.field_string(buf_, pos_, 12)
    /// Satellite/Catalog number of the target OnOrbit object.
    /// Example: /// Example: 12
    /// Constraints: No constraints specified.
    def satNo() -> int:
        return flatbuffers.field_int32(buf_, pos_, 14, 0)
    /// Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
    /// Example: /// Example: ORIGOBJECT-ID
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origObjectId() -> string:
        return flatbuffers.field_string(buf_, pos_, 16)
    /// Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
    /// Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
    /// Constraints: Minimum length = 0, Maximum length = 36
    def idOrbitDetermination() -> string:
        return flatbuffers.field_string(buf_, pos_, 18)
    /// Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
    /// Example: /// Example: True
    /// Constraints: No constraints specified.
    def uct() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 20, 0))
    /// Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    /// Example: /// Example: -1118.577381
    /// Constraints: No constraints specified.
    def xpos() -> float:
        return flatbuffers.field_float64(buf_, pos_, 22, 0.0)
    /// Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    /// Example: /// Example: 3026.231084
    /// Constraints: No constraints specified.
    def ypos() -> float:
        return flatbuffers.field_float64(buf_, pos_, 24, 0.0)
    /// Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    /// Example: /// Example: 6167.831808
    /// Constraints: No constraints specified.
    def zpos() -> float:
        return flatbuffers.field_float64(buf_, pos_, 26, 0.0)
    /// Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
    /// Example: /// Example: -4.25242784
    /// Constraints: No constraints specified.
    def xvel() -> float:
        return flatbuffers.field_float64(buf_, pos_, 28, 0.0)
    /// Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
    /// Example: /// Example: 5.291107434
    /// Constraints: No constraints specified.
    def yvel() -> float:
        return flatbuffers.field_float64(buf_, pos_, 30, 0.0)
    /// Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
    /// Example: /// Example: -3.356493869
    /// Constraints: No constraints specified.
    def zvel() -> float:
        return flatbuffers.field_float64(buf_, pos_, 32, 0.0)
    /// The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
    /// Example: /// Example: J2000
    /// Constraints: Minimum length = 0, Maximum length = 24
    def referenceFrame() -> StateVector_Full_referenceFrame_Enum:
        return StateVector_Full_referenceFrame_Enum(flatbuffers.field_int8(buf_, pos_, 34, 0))
    /// Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
    /// The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
    /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
    /// x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
    /// y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
    /// z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
    /// x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
    /// y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
    /// z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
    /// The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
    /// If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
    /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
    /// DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
    /// SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
    /// THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
    /// Example: /// Example: [1.1, 2.2]
    /// Constraints: No constraints specified.
    def cov(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 36) + i * 4)
    def cov_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 36)
    /// The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
    /// Example: /// Example: J2000
    /// Constraints: Minimum length = 0, Maximum length = 24
    def covReferenceFrame() -> StateVector_Full_covReferenceFrame_Enum:
        return StateVector_Full_covReferenceFrame_Enum(flatbuffers.field_int8(buf_, pos_, 38, 0))
    /// The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
    /// Example: /// Example: CALCULATED
    /// Constraints: Minimum length = 0, Maximum length = 24
    def covMethod() -> string:
        return flatbuffers.field_string(buf_, pos_, 40)
    /// The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
    /// 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
    /// 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
    /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    /// 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
    /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    /// :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
    /// The ordering of values is as follows:
    /// &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
    /// Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
    /// Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
    /// L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
    /// N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
    /// Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
    /// Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
    /// B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
    /// BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
    /// AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
    /// T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
    /// C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
    /// C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
    /// :
    /// :
    /// where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
    /// Example: /// Example: [1.1, 2.2]
    /// Constraints: No constraints specified.
    def eqCov(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 42) + i * 4)
    def eqCov_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 42)
    /// Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -1145.688502
    /// Constraints: No constraints specified.
    def xposAlt1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 44, 0.0)
    /// Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: 3020.729572
    /// Constraints: No constraints specified.
    def yposAlt1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 46, 0.0)
    /// Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: 6165.55187
    /// Constraints: No constraints specified.
    def zposAlt1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 48, 0.0)
    /// Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -4.270832252
    /// Constraints: No constraints specified.
    def xvelAlt1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 50, 0.0)
    /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: 5.27074276
    /// Constraints: No constraints specified.
    def yvelAlt1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 52, 0.0)
    /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -3.365155181
    /// Constraints: No constraints specified.
    def zvelAlt1() -> float:
        return flatbuffers.field_float64(buf_, pos_, 54, 0.0)
    /// The reference frame of the alternate1 (Alt1) cartesian orbital state.
    /// Example: /// Example: TEME
    /// Constraints: Minimum length = 0, Maximum length = 24
    def alt1ReferenceFrame() -> string:
        return flatbuffers.field_string(buf_, pos_, 56)
    /// Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -1456.915926
    /// Constraints: No constraints specified.
    def xposAlt2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 58, 0.0)
    /// Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -2883.540406
    /// Constraints: No constraints specified.
    def yposAlt2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 60, 0.0)
    /// Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: 6165.55187
    /// Constraints: No constraints specified.
    def zposAlt2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 62, 0.0)
    /// Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -1.219814294
    /// Constraints: No constraints specified.
    def xvelAlt2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 64, 0.0)
    /// Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -6.602080212
    /// Constraints: No constraints specified.
    def yvelAlt2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 66, 0.0)
    /// Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
    /// Example: /// Example: -3.365155181
    /// Constraints: No constraints specified.
    def zvelAlt2() -> float:
        return flatbuffers.field_float64(buf_, pos_, 68, 0.0)
    /// The reference frame of the alternate2 (Alt2) cartesian orbital state.
    /// Example: /// Example: EFG/TDR
    /// Constraints: Minimum length = 0, Maximum length = 24
    def alt2ReferenceFrame() -> string:
        return flatbuffers.field_string(buf_, pos_, 70)
    /// One sigma position uncertainty, in kilometers.
    /// Example: /// Example: 0.333399744452
    /// Constraints: No constraints specified.
    def posUnc() -> float:
        return flatbuffers.field_float64(buf_, pos_, 72, 0.0)
    /// One sigma velocity uncertainty, in kilometers/second.
    /// Example: /// Example: 4e-06
    /// Constraints: No constraints specified.
    def velUnc() -> float:
        return flatbuffers.field_float64(buf_, pos_, 74, 0.0)
    /// The mass of the object, in kilograms.
    /// Example: /// Example: 164.5
    /// Constraints: No constraints specified.
    def mass() -> float:
        return flatbuffers.field_float64(buf_, pos_, 76, 0.0)
    /// The actual area of the object at it's largest cross-section, expressed in meters^2.
    /// Example: /// Example: 5.065
    /// Constraints: No constraints specified.
    def area() -> float:
        return flatbuffers.field_float64(buf_, pos_, 78, 0.0)
    /// Area-to-mass ratio coefficient for solar radiation pressure.
    /// Example: /// Example: 0.0244394
    /// Constraints: No constraints specified.
    def solarRadPressCoeff() -> float:
        return flatbuffers.field_float64(buf_, pos_, 80, 0.0)
    /// Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
    /// Example: /// Example: 0.0224391269775
    /// Constraints: No constraints specified.
    def dragCoeff() -> float:
        return flatbuffers.field_float64(buf_, pos_, 82, 0.0)
    /// The effective area of the object exposed to atmospheric drag, expressed in meters^2.
    /// Example: /// Example: 4.739
    /// Constraints: No constraints specified.
    def dragArea() -> float:
        return flatbuffers.field_float64(buf_, pos_, 84, 0.0)
    /// Epoch revolution number.
    /// Example: /// Example: 7205
    /// Constraints: No constraints specified.
    def revNo() -> int:
        return flatbuffers.field_int32(buf_, pos_, 86, 0)
    /// Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
    /// Example: /// Example: EGM-96
    /// Constraints: Minimum length = 0, Maximum length = 32
    def geopotentialModel() -> string:
        return flatbuffers.field_string(buf_, pos_, 88)
    /// The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
    /// Example: /// Example: JAC70
    /// Constraints: Minimum length = 0, Maximum length = 32
    def dragModel() -> string:
        return flatbuffers.field_string(buf_, pos_, 90)
    /// Boolean indicating use of lunar/solar perturbations for this vector.
    /// Example: /// Example: True
    /// Constraints: No constraints specified.
    def lunarSolar() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 92, 0))
    /// Boolean indicating use of solar radiation pressure perturbations for this vector.
    /// Example: /// Example: True
    /// Constraints: No constraints specified.
    def solarRadPress() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 94, 0))
    /// The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
    /// Example: /// Example: 4.311
    /// Constraints: No constraints specified.
    def srpArea() -> float:
        return flatbuffers.field_float64(buf_, pos_, 96, 0.0)
    /// Boolean indicating use of solid earth tide perturbations for this vector.
    /// Example: /// Example: True
    /// Constraints: No constraints specified.
    def solidEarthTides() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 98, 0))
    /// Boolean indicating use of in-track thrust perturbations for this vector.
    /// Example: /// Example: True
    /// Constraints: No constraints specified.
    def inTrackThrust() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 100, 0))
    /// First derivative of drag/ballistic coefficient (m2/kg-s).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def bDot() -> float:
        return flatbuffers.field_float64(buf_, pos_, 102, 0.0)
    /// Model parameter value for energy dissipation rate (EDR) (w/kg).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def edr() -> float:
        return flatbuffers.field_float64(buf_, pos_, 104, 0.0)
    /// Model parameter value for thrust acceleration (m/s2).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def thrustAccel() -> float:
        return flatbuffers.field_float64(buf_, pos_, 106, 0.0)
    /// Model parameter value for center of mass offset (m).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def cmOffset() -> float:
        return flatbuffers.field_float64(buf_, pos_, 108, 0.0)
    /// The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
    /// Example: /// Example: 2022-11-09T11:20:21.247192Z
    /// Constraints: No constraints specified.
    def lastObStart() -> string:
        return flatbuffers.field_string(buf_, pos_, 110)
    /// The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
    /// Example: /// Example: 2022-11-09T11:20:21.247192Z
    /// Constraints: No constraints specified.
    def lastObEnd() -> string:
        return flatbuffers.field_string(buf_, pos_, 112)
    /// The number of observations available for the OD of the object.
    /// Example: /// Example: 376
    /// Constraints: No constraints specified.
    def obsAvailable() -> int:
        return flatbuffers.field_int32(buf_, pos_, 114, 0)
    /// The number of observations accepted for the OD of the object.
    /// Example: /// Example: 374
    /// Constraints: No constraints specified.
    def obsUsed() -> int:
        return flatbuffers.field_int32(buf_, pos_, 116, 0)
    /// The number of sensor tracks available for the OD of the object.
    /// Example: /// Example: 163
    /// Constraints: No constraints specified.
    def tracksAvail() -> int:
        return flatbuffers.field_int32(buf_, pos_, 118, 0)
    /// The number of sensor tracks accepted for the OD of the object.
    /// Example: /// Example: 163
    /// Constraints: No constraints specified.
    def tracksUsed() -> int:
        return flatbuffers.field_int32(buf_, pos_, 120, 0)
    /// The recommended OD time span calculated for the object, expressed in days.
    /// Example: /// Example: 3.5
    /// Constraints: No constraints specified.
    def recODSpan() -> float:
        return flatbuffers.field_float64(buf_, pos_, 122, 0.0)
    /// The actual time span used for the OD of the object, expressed in days.
    /// Example: /// Example: 3.5
    /// Constraints: No constraints specified.
    def actualODSpan() -> float:
        return flatbuffers.field_float64(buf_, pos_, 124, 0.0)
    /// The percentage of residuals accepted in the OD of the object.
    /// Example: /// Example: 99.5
    /// Constraints: No constraints specified.
    def residualsAcc() -> float:
        return flatbuffers.field_float64(buf_, pos_, 126, 0.0)
    /// F10 (10.7 cm) solar flux value.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def solarFluxF10() -> float:
        return flatbuffers.field_float64(buf_, pos_, 128, 0.0)
    /// F10 (10.7 cm) solar flux 81-day average value.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def solarFluxF10Avg() -> float:
        return flatbuffers.field_float64(buf_, pos_, 130, 0.0)
    /// Average solar flux geomagnetic index.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def solarFluxAPAvg() -> float:
        return flatbuffers.field_float64(buf_, pos_, 132, 0.0)
    /// TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def taiUtc() -> float:
        return flatbuffers.field_float64(buf_, pos_, 134, 0.0)
    /// Universal Time-1 (UT1) minus UTC offset, in seconds.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def ut1Utc() -> float:
        return flatbuffers.field_float64(buf_, pos_, 136, 0.0)
    /// Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def ut1Rate() -> float:
        return flatbuffers.field_float64(buf_, pos_, 138, 0.0)
    /// Polar Wander Motion X (arc seconds).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def polarMotionX() -> float:
        return flatbuffers.field_float64(buf_, pos_, 140, 0.0)
    /// Polar Wander Motion Y (arc seconds).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def polarMotionY() -> float:
        return flatbuffers.field_float64(buf_, pos_, 142, 0.0)
    /// Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
    /// Example: /// Example: 4
    /// Constraints: No constraints specified.
    def iau1980Terms() -> int:
        return flatbuffers.field_int32(buf_, pos_, 144, 0)
    /// Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
    /// Example: /// Example: 2021-01-01T01:01:01.123Z
    /// Constraints: No constraints specified.
    def leapSecondTime() -> string:
        return flatbuffers.field_string(buf_, pos_, 146)
    /// Integrator Mode.
    /// Example: /// Example: integratorMode
    /// Constraints: Minimum length = 0, Maximum length = 32
    def integratorMode() -> string:
        return flatbuffers.field_string(buf_, pos_, 148)
    /// Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
    /// Example: /// Example: ANALYTIC
    /// Constraints: Minimum length = 0, Maximum length = 16
    def partials() -> string:
        return flatbuffers.field_string(buf_, pos_, 150)
    /// Integrator step mode (AUTO, TIME, or S).
    /// Example: /// Example: AUTO
    /// Constraints: Minimum length = 0, Maximum length = 16
    def stepMode() -> string:
        return flatbuffers.field_string(buf_, pos_, 152)
    /// Boolean indicating use of fixed step size for this vector.
    /// Example: /// Example: True
    /// Constraints: No constraints specified.
    def fixedStep() -> bool:
        return bool(flatbuffers.field_int8(buf_, pos_, 154, 0))
    /// Initial step size selection (AUTO or MANUAL).
    /// Example: /// Example: AUTO
    /// Constraints: Minimum length = 0, Maximum length = 16
    def stepSizeSelection() -> string:
        return flatbuffers.field_string(buf_, pos_, 156)
    /// Initial integration step size (seconds).
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def stepSize() -> float:
        return flatbuffers.field_float64(buf_, pos_, 158, 0.0)
    /// Integrator error control.
    /// Example: /// Example: 1.23
    /// Constraints: No constraints specified.
    def errorControl() -> float:
        return flatbuffers.field_float64(buf_, pos_, 160, 0.0)
    /// Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
    /// Example: /// Example: [1.23, 4.56]
    /// Constraints: No constraints specified.
    def sigmaPosUVW(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 162) + i * 4)
    def sigmaPosUVW_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 162)
    /// Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
    /// Example: /// Example: [1.23, 4.56]
    /// Constraints: No constraints specified.
    def sigmaVelUVW(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 164) + i * 4)
    def sigmaVelUVW_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 164)
    /// The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
    /// Example: /// Example: 0.991
    /// Constraints: No constraints specified.
    def rms() -> float:
        return flatbuffers.field_float64(buf_, pos_, 166, 0.0)
    /// Start time at which this state vector was the 'current' state vector for its satellite.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def effectiveFrom() -> string:
        return flatbuffers.field_string(buf_, pos_, 168)
    /// End time at which this state vector was no longer the 'current' state vector for its satellite.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def effectiveUntil() -> string:
        return flatbuffers.field_string(buf_, pos_, 170)
    /// Optional URI location in the document repository of the raw file parsed by the system to produce this record. To download the raw file, prepend https://udl-hostname/scs/download?id= to this value.
    /// Example: /// Example: rawFileURI
    /// Constraints: Minimum length = 0, Maximum length = 256
    def rawFileURI() -> string:
        return flatbuffers.field_string(buf_, pos_, 172)
    /// Source of the data.
    /// Example: /// Example: Bluestaq
    /// Constraints: Minimum length = 1, Maximum length = 64
    def source() -> string:
        return flatbuffers.field_string(buf_, pos_, 174)
    /// Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
    /// Example: /// Example: THIRD_PARTY_DATASOURCE
    /// Constraints: Minimum length = 0, Maximum length = 64
    def origin() -> string:
        return flatbuffers.field_string(buf_, pos_, 176)
    /// Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
    /// EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
    /// REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
    /// SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
    /// TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
    /// Example: /// Example: TEST
    /// Constraints: Minimum length = 1, Maximum length = 32
    def dataMode() -> StateVector_Full_dataMode_Enum:
        return StateVector_Full_dataMode_Enum(flatbuffers.field_int8(buf_, pos_, 178, 0))
    /// Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
    /// Example: /// Example: ['TAG1', 'TAG2']
    /// Constraints: No constraints specified.
    def tags(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 180) + i * 4)
    def tags_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 180)
    /// Optional algorithm used to produce this record.
    /// Example: /// Example: SAMPLE_ALGORITHM
    /// Constraints: Minimum length = 0, Maximum length = 64
    def algorithm() -> string:
        return flatbuffers.field_string(buf_, pos_, 182)
    /// Optional array of UDL data (observation) UUIDs used to build this state vector. See the associated sourcedDataTypes array for the specific types of observations for the positionally corresponding UUIDs in this array (the two arrays must match in size).
    /// Example: /// Example: ['DATA1', 'DATA2']
    /// Constraints: No constraints specified.
    def sourcedData(i:int) -> string:
        return flatbuffers.string(buf_, buf_.flatbuffers.field_vector(pos_, 184) + i * 4)
    def sourcedData_length() -> int:
        return flatbuffers.field_vector_len(buf_, pos_, 184)
    /// Optional array of UDL observation data types used to build this state vector (e.g. EO, RADAR, RF, DOA). See the associated sourcedData array for the specific UUIDs of observations for the positionally corresponding data types in this array (the two arrays must match in size).
    /// Example: /// Example: ['RADAR']
    /// Constraints: No constraints specified.
    def sourcedDataTypes() -> StateVector_Full_sourcedDataTypes_Enum:
        return StateVector_Full_sourcedDataTypes_Enum(flatbuffers.field_int8(buf_, pos_, 186, 0))
    /// Time the row was created in the database, auto-populated by the system.
    /// Example: /// Example: 2018-01-01T16:00:00.123Z
    /// Constraints: No constraints specified.
    def createdAt() -> string:
        return flatbuffers.field_string(buf_, pos_, 188)
    /// Application user who created the row in the database, auto-populated by the system.
    /// Example: /// Example: some.user
    /// Constraints: Minimum length = 1, Maximum length = 64
    def createdBy() -> string:
        return flatbuffers.field_string(buf_, pos_, 190)
    /// No description provided.
    /// Example: /// Example: No example provided.
    /// Constraints: No constraints specified.
    def onOrbit() -> string:
        return flatbuffers.field_string(buf_, pos_, 192)
    /// Optional source-provided and searchable metadata or descriptor of the data.
    /// Example: /// Example: descriptor
    /// Constraints: Minimum length = 0, Maximum length = 64
    def descriptor() -> string:
        return flatbuffers.field_string(buf_, pos_, 194)
    /// Optional identifier to track a commercial or marketplace transaction executed to produce this data.
    /// Example: /// Example: transactionId
    /// Constraints: Minimum length = 0, Maximum length = 64
    def transactionId() -> string:
        return flatbuffers.field_string(buf_, pos_, 196)
    /// The originating source network on which this record was created, auto-populated by the system.
    /// Example: /// Example: ORIG
    /// Constraints: Minimum length = 1, Maximum length = 32
    def origNetwork() -> string:
        return flatbuffers.field_string(buf_, pos_, 198)
    /// The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
    /// Example: /// Example: AXE
    /// Constraints: Minimum length = 0, Maximum length = 64
    def sourceDL() -> string:
        return flatbuffers.field_string(buf_, pos_, 200)

def GetRootAsStateVector_Full(buf:string): return StateVector_Full { buf, flatbuffers.indirect(buf, 0) }

struct StateVector_FullBuilder:
    b_:flatbuffers.builder
    def start():
        b_.StartObject(99)
        return this
    def add_idStateVector(idStateVector:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(0, idStateVector)
        return this
    def add_classificationMarking(classificationMarking:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(1, classificationMarking)
        return this
    def add_epoch(epoch:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(2, epoch)
        return this
    def add_pedigree(pedigree:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(3, pedigree)
        return this
    def add_idOnOrbit(idOnOrbit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(4, idOnOrbit)
        return this
    def add_satNo(satNo:int):
        b_.PrependInt32Slot(5, satNo, 0)
        return this
    def add_origObjectId(origObjectId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(6, origObjectId)
        return this
    def add_idOrbitDetermination(idOrbitDetermination:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(7, idOrbitDetermination)
        return this
    def add_uct(uct:bool):
        b_.PrependBoolSlot(8, uct, 0)
        return this
    def add_xpos(xpos:float):
        b_.PrependFloat64Slot(9, xpos, 0.0)
        return this
    def add_ypos(ypos:float):
        b_.PrependFloat64Slot(10, ypos, 0.0)
        return this
    def add_zpos(zpos:float):
        b_.PrependFloat64Slot(11, zpos, 0.0)
        return this
    def add_xvel(xvel:float):
        b_.PrependFloat64Slot(12, xvel, 0.0)
        return this
    def add_yvel(yvel:float):
        b_.PrependFloat64Slot(13, yvel, 0.0)
        return this
    def add_zvel(zvel:float):
        b_.PrependFloat64Slot(14, zvel, 0.0)
        return this
    def add_referenceFrame(referenceFrame:StateVector_Full_referenceFrame_Enum):
        b_.PrependInt8Slot(15, referenceFrame, 0)
        return this
    def add_cov(cov:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(16, cov)
        return this
    def add_covReferenceFrame(covReferenceFrame:StateVector_Full_covReferenceFrame_Enum):
        b_.PrependInt8Slot(17, covReferenceFrame, 0)
        return this
    def add_covMethod(covMethod:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(18, covMethod)
        return this
    def add_eqCov(eqCov:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(19, eqCov)
        return this
    def add_xposAlt1(xposAlt1:float):
        b_.PrependFloat64Slot(20, xposAlt1, 0.0)
        return this
    def add_yposAlt1(yposAlt1:float):
        b_.PrependFloat64Slot(21, yposAlt1, 0.0)
        return this
    def add_zposAlt1(zposAlt1:float):
        b_.PrependFloat64Slot(22, zposAlt1, 0.0)
        return this
    def add_xvelAlt1(xvelAlt1:float):
        b_.PrependFloat64Slot(23, xvelAlt1, 0.0)
        return this
    def add_yvelAlt1(yvelAlt1:float):
        b_.PrependFloat64Slot(24, yvelAlt1, 0.0)
        return this
    def add_zvelAlt1(zvelAlt1:float):
        b_.PrependFloat64Slot(25, zvelAlt1, 0.0)
        return this
    def add_alt1ReferenceFrame(alt1ReferenceFrame:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(26, alt1ReferenceFrame)
        return this
    def add_xposAlt2(xposAlt2:float):
        b_.PrependFloat64Slot(27, xposAlt2, 0.0)
        return this
    def add_yposAlt2(yposAlt2:float):
        b_.PrependFloat64Slot(28, yposAlt2, 0.0)
        return this
    def add_zposAlt2(zposAlt2:float):
        b_.PrependFloat64Slot(29, zposAlt2, 0.0)
        return this
    def add_xvelAlt2(xvelAlt2:float):
        b_.PrependFloat64Slot(30, xvelAlt2, 0.0)
        return this
    def add_yvelAlt2(yvelAlt2:float):
        b_.PrependFloat64Slot(31, yvelAlt2, 0.0)
        return this
    def add_zvelAlt2(zvelAlt2:float):
        b_.PrependFloat64Slot(32, zvelAlt2, 0.0)
        return this
    def add_alt2ReferenceFrame(alt2ReferenceFrame:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(33, alt2ReferenceFrame)
        return this
    def add_posUnc(posUnc:float):
        b_.PrependFloat64Slot(34, posUnc, 0.0)
        return this
    def add_velUnc(velUnc:float):
        b_.PrependFloat64Slot(35, velUnc, 0.0)
        return this
    def add_mass(mass:float):
        b_.PrependFloat64Slot(36, mass, 0.0)
        return this
    def add_area(area:float):
        b_.PrependFloat64Slot(37, area, 0.0)
        return this
    def add_solarRadPressCoeff(solarRadPressCoeff:float):
        b_.PrependFloat64Slot(38, solarRadPressCoeff, 0.0)
        return this
    def add_dragCoeff(dragCoeff:float):
        b_.PrependFloat64Slot(39, dragCoeff, 0.0)
        return this
    def add_dragArea(dragArea:float):
        b_.PrependFloat64Slot(40, dragArea, 0.0)
        return this
    def add_revNo(revNo:int):
        b_.PrependInt32Slot(41, revNo, 0)
        return this
    def add_geopotentialModel(geopotentialModel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(42, geopotentialModel)
        return this
    def add_dragModel(dragModel:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(43, dragModel)
        return this
    def add_lunarSolar(lunarSolar:bool):
        b_.PrependBoolSlot(44, lunarSolar, 0)
        return this
    def add_solarRadPress(solarRadPress:bool):
        b_.PrependBoolSlot(45, solarRadPress, 0)
        return this
    def add_srpArea(srpArea:float):
        b_.PrependFloat64Slot(46, srpArea, 0.0)
        return this
    def add_solidEarthTides(solidEarthTides:bool):
        b_.PrependBoolSlot(47, solidEarthTides, 0)
        return this
    def add_inTrackThrust(inTrackThrust:bool):
        b_.PrependBoolSlot(48, inTrackThrust, 0)
        return this
    def add_bDot(bDot:float):
        b_.PrependFloat64Slot(49, bDot, 0.0)
        return this
    def add_edr(edr:float):
        b_.PrependFloat64Slot(50, edr, 0.0)
        return this
    def add_thrustAccel(thrustAccel:float):
        b_.PrependFloat64Slot(51, thrustAccel, 0.0)
        return this
    def add_cmOffset(cmOffset:float):
        b_.PrependFloat64Slot(52, cmOffset, 0.0)
        return this
    def add_lastObStart(lastObStart:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(53, lastObStart)
        return this
    def add_lastObEnd(lastObEnd:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(54, lastObEnd)
        return this
    def add_obsAvailable(obsAvailable:int):
        b_.PrependInt32Slot(55, obsAvailable, 0)
        return this
    def add_obsUsed(obsUsed:int):
        b_.PrependInt32Slot(56, obsUsed, 0)
        return this
    def add_tracksAvail(tracksAvail:int):
        b_.PrependInt32Slot(57, tracksAvail, 0)
        return this
    def add_tracksUsed(tracksUsed:int):
        b_.PrependInt32Slot(58, tracksUsed, 0)
        return this
    def add_recODSpan(recODSpan:float):
        b_.PrependFloat64Slot(59, recODSpan, 0.0)
        return this
    def add_actualODSpan(actualODSpan:float):
        b_.PrependFloat64Slot(60, actualODSpan, 0.0)
        return this
    def add_residualsAcc(residualsAcc:float):
        b_.PrependFloat64Slot(61, residualsAcc, 0.0)
        return this
    def add_solarFluxF10(solarFluxF10:float):
        b_.PrependFloat64Slot(62, solarFluxF10, 0.0)
        return this
    def add_solarFluxF10Avg(solarFluxF10Avg:float):
        b_.PrependFloat64Slot(63, solarFluxF10Avg, 0.0)
        return this
    def add_solarFluxAPAvg(solarFluxAPAvg:float):
        b_.PrependFloat64Slot(64, solarFluxAPAvg, 0.0)
        return this
    def add_taiUtc(taiUtc:float):
        b_.PrependFloat64Slot(65, taiUtc, 0.0)
        return this
    def add_ut1Utc(ut1Utc:float):
        b_.PrependFloat64Slot(66, ut1Utc, 0.0)
        return this
    def add_ut1Rate(ut1Rate:float):
        b_.PrependFloat64Slot(67, ut1Rate, 0.0)
        return this
    def add_polarMotionX(polarMotionX:float):
        b_.PrependFloat64Slot(68, polarMotionX, 0.0)
        return this
    def add_polarMotionY(polarMotionY:float):
        b_.PrependFloat64Slot(69, polarMotionY, 0.0)
        return this
    def add_iau1980Terms(iau1980Terms:int):
        b_.PrependInt32Slot(70, iau1980Terms, 0)
        return this
    def add_leapSecondTime(leapSecondTime:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(71, leapSecondTime)
        return this
    def add_integratorMode(integratorMode:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(72, integratorMode)
        return this
    def add_partials(partials:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(73, partials)
        return this
    def add_stepMode(stepMode:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(74, stepMode)
        return this
    def add_fixedStep(fixedStep:bool):
        b_.PrependBoolSlot(75, fixedStep, 0)
        return this
    def add_stepSizeSelection(stepSizeSelection:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(76, stepSizeSelection)
        return this
    def add_stepSize(stepSize:float):
        b_.PrependFloat64Slot(77, stepSize, 0.0)
        return this
    def add_errorControl(errorControl:float):
        b_.PrependFloat64Slot(78, errorControl, 0.0)
        return this
    def add_sigmaPosUVW(sigmaPosUVW:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(79, sigmaPosUVW)
        return this
    def add_sigmaVelUVW(sigmaVelUVW:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(80, sigmaVelUVW)
        return this
    def add_rms(rms:float):
        b_.PrependFloat64Slot(81, rms, 0.0)
        return this
    def add_effectiveFrom(effectiveFrom:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(82, effectiveFrom)
        return this
    def add_effectiveUntil(effectiveUntil:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(83, effectiveUntil)
        return this
    def add_rawFileURI(rawFileURI:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(84, rawFileURI)
        return this
    def add_source(source:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(85, source)
        return this
    def add_origin(origin:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(86, origin)
        return this
    def add_dataMode(dataMode:StateVector_Full_dataMode_Enum):
        b_.PrependInt8Slot(87, dataMode, 0)
        return this
    def add_tags(tags:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(88, tags)
        return this
    def add_algorithm(algorithm:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(89, algorithm)
        return this
    def add_sourcedData(sourcedData:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(90, sourcedData)
        return this
    def add_sourcedDataTypes(sourcedDataTypes:StateVector_Full_sourcedDataTypes_Enum):
        b_.PrependInt8Slot(91, sourcedDataTypes, 0)
        return this
    def add_createdAt(createdAt:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(92, createdAt)
        return this
    def add_createdBy(createdBy:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(93, createdBy)
        return this
    def add_onOrbit(onOrbit:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(94, onOrbit)
        return this
    def add_descriptor(descriptor:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(95, descriptor)
        return this
    def add_transactionId(transactionId:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(96, transactionId)
        return this
    def add_origNetwork(origNetwork:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(97, origNetwork)
        return this
    def add_sourceDL(sourceDL:flatbuffers.offset):
        b_.PrependUOffsetTRelativeSlot(98, sourceDL)
        return this
    def end():
        return b_.EndObject()

def StateVector_FullStartCovVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StateVector_FullCreateCovVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StateVector_FullStartEqCovVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StateVector_FullCreateEqCovVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StateVector_FullStartSigmaPosUVWVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StateVector_FullCreateSigmaPosUVWVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StateVector_FullStartSigmaVelUVWVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StateVector_FullCreateSigmaVelUVWVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StateVector_FullStartTagsVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StateVector_FullCreateTagsVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

def StateVector_FullStartSourcedDataVector(b_:flatbuffers.builder, n_:int):
    b_.StartVector(4, n_, 4)
def StateVector_FullCreateSourcedDataVector(b_:flatbuffers.builder, v_:[flatbuffers.offset]):
    b_.StartVector(4, v_.length, 4)
    reverse(v_) e_: b_.PrependUOffsetTRelative(e_)
    return b_.EndVector(v_.length)

