// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Notification_Ingest_dataMode_Enum } from './notification-ingest-data-mode-enum.js';


/**
 * /// Model representation of client generated notification data.  Contains a message type and message body field to store notification information.
 */
export class Notification_Ingest implements flatbuffers.IUnpackableObject<Notification_IngestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Notification_Ingest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsNotification_Ingest(bb:flatbuffers.ByteBuffer, obj?:Notification_Ingest):Notification_Ingest {
  return (obj || new Notification_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsNotification_Ingest(bb:flatbuffers.ByteBuffer, obj?:Notification_Ingest):Notification_Ingest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Notification_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('NOTI');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: NOTIFICATION-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source provided message type.
 * Example: /// Example: msgType
 * Constraints: Minimum length = 1, Maximum length = 64
 */
msgType():string|null
msgType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
msgType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The message body content as a text string, XML, JSON, etc. If JSON is used for the msgBody, it should be 'inline' with the notification message JSON (without quotation marks or escape characters). Size of the msg body cannot be over 1MB.
 * Example: /// Example: msgBody
 * Constraints: Minimum length = 1, Maximum length = 1000000
 */
msgBody():string|null
msgBody(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
msgBody(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():Notification_Ingest_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : Notification_Ingest_dataMode_Enum.REAL;
}

/**
 * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
 * Example: /// Example: AXE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
sourceDl():string|null
sourceDl(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
sourceDl(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 64
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 * Example: /// Example: THIRD_PARTY_DATASOURCE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional array of provider/source specific tags for this data, used for implementing data owner conditional access controls to restrict access to the data.
 * Example: /// Example: ['TAG1', 'TAG2']
 * Constraints: No constraints specified.
 */
tags(index: number):string
tags(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
tags(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

tagsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The date and time the notification was created, auto-generated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The user that created the notification.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 0, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startNotification_Ingest(builder:flatbuffers.Builder) {
  builder.startObject(12);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationMarkingOffset, 0);
}

static addMsgType(builder:flatbuffers.Builder, msgTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, msgTypeOffset, 0);
}

static addMsgBody(builder:flatbuffers.Builder, msgBodyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, msgBodyOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:Notification_Ingest_dataMode_Enum) {
  builder.addFieldInt8(4, dataMode, Notification_Ingest_dataMode_Enum.REAL);
}

static addSourceDl(builder:flatbuffers.Builder, sourceDlOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, sourceDlOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, originOffset, 0);
}

static addTags(builder:flatbuffers.Builder, tagsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, tagsOffset, 0);
}

static createTagsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTagsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, createdByOffset, 0);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, origNetworkOffset, 0);
}

static endNotification_Ingest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishNotification_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'NOTI');
}

static finishSizePrefixedNotification_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'NOTI', true);
}

static createNotification_Ingest(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, msgTypeOffset:flatbuffers.Offset, msgBodyOffset:flatbuffers.Offset, dataMode:Notification_Ingest_dataMode_Enum, sourceDlOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, tagsOffset:flatbuffers.Offset, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, origNetworkOffset:flatbuffers.Offset):flatbuffers.Offset {
  Notification_Ingest.startNotification_Ingest(builder);
  Notification_Ingest.addId(builder, idOffset);
  Notification_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
  Notification_Ingest.addMsgType(builder, msgTypeOffset);
  Notification_Ingest.addMsgBody(builder, msgBodyOffset);
  Notification_Ingest.addDataMode(builder, dataMode);
  Notification_Ingest.addSourceDl(builder, sourceDlOffset);
  Notification_Ingest.addSource(builder, sourceOffset);
  Notification_Ingest.addOrigin(builder, originOffset);
  Notification_Ingest.addTags(builder, tagsOffset);
  Notification_Ingest.addCreatedAt(builder, createdAtOffset);
  Notification_Ingest.addCreatedBy(builder, createdByOffset);
  Notification_Ingest.addOrigNetwork(builder, origNetworkOffset);
  return Notification_Ingest.endNotification_Ingest(builder);
}

unpack(): Notification_IngestT {
  return new Notification_IngestT(
    this.id(),
    this.classificationMarking(),
    this.msgType(),
    this.msgBody(),
    this.dataMode(),
    this.sourceDl(),
    this.source(),
    this.origin(),
    this.bb!.createScalarList<string>(this.tags.bind(this), this.tags_Length()),
    this.createdAt(),
    this.createdBy(),
    this.origNetwork()
  );
}


unpackTo(_o: Notification_IngestT): void {
  _o.id = this.id();
  _o.classificationMarking = this.classificationMarking();
  _o.msgType = this.msgType();
  _o.msgBody = this.msgBody();
  _o.dataMode = this.dataMode();
  _o.sourceDL = this.sourceDl();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.tags = this.bb!.createScalarList<string>(this.tags.bind(this), this.tags_Length());
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.origNetwork = this.origNetwork();
}
}

export class Notification_IngestT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public msgType: string|Uint8Array|null = null,
  public msgBody: string|Uint8Array|null = null,
  public dataMode: Notification_Ingest_dataMode_Enum = Notification_Ingest_dataMode_Enum.REAL,
  public sourceDL: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public tags: (string)[] = [],
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public origNetwork: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const msgType = (this.msgType !== null ? builder.createString(this.msgType!) : 0);
  const msgBody = (this.msgBody !== null ? builder.createString(this.msgBody!) : 0);
  const sourceDL = (this.sourceDL !== null ? builder.createString(this.sourceDL!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);
  const tags = Notification_Ingest.createTagsVector(builder, builder.createObjectOffsetList(this.tags));
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);

  return Notification_Ingest.createNotification_Ingest(builder,
    id,
    classificationMarking,
    msgType,
    msgBody,
    this.dataMode,
    sourceDL,
    source,
    origin,
    tags,
    createdAt,
    createdBy,
    origNetwork
  );
}
}
