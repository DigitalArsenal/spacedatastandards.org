// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Sensorlimits_Abridged_dataMode_Enum } from './Sensorlimits_Abridged_dataMode_Enum.js';


/**
 * /// Sensorlimits define 0 to many limits of a particular sensor in terms of observation coverage of on-orbit objects.
 */
export class Sensorlimits_Abridged implements flatbuffers.IUnpackableObject<Sensorlimits_AbridgedT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Sensorlimits_Abridged {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsSensorlimits_Abridged(bb:flatbuffers.ByteBuffer, obj?:Sensorlimits_Abridged):Sensorlimits_Abridged {
  return (obj || new Sensorlimits_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsSensorlimits_Abridged(bb:flatbuffers.ByteBuffer, obj?:Sensorlimits_Abridged):Sensorlimits_Abridged {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Sensorlimits_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('SENS');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: SENSORLIMITS-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
idSensorLimits():string|null
idSensorLimits(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensorLimits(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Leftmost or minimum upper azimuth within this sensor limit. Interpreted according to site types as beginning upper azimuth limit, left-hand upper boundary limit. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (in degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
upperLeftAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Rightmost or maximum upper azimuth within this limit. Interpreted according to site types as 2nd azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
upperRightAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Rightmost or maximum lower azimuth within this limit. Interpreted according to site types as 2nd lower azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower right azimuth limits would be equal. (degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
lowerRightAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Leftmost or minimum lower azimuth within this limit. Interpreted according to site types as lower left azimuth limit elevation angle of axis of conical observation pattern. If the limit rectangle is parallel to the horizon, the upper and lower left azimuth limits would be equal. (degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
lowerLeftAzimuthLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Minimum or lower elevation within this limit. Interpreted according to site types as minimum elevation angle, constant elevation or fan beam centerline. (Degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
lowerLeftElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum or upper elevation within this limit. Interpreted according to site types as maximum elevation angle, half the apex of conical observation pattern or star. (Degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
upperLeftElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Minimum or lower right elevation within this limit. Interpreted according to site types as minimum right elevation angle, constant elevation or fan beam centerline. If the limit rectangle is parallel to the horizon, the left and right lower elevation limits would be equal. (Degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
lowerRightElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum or upper right elevation within this limit. Interpreted according to site types as maximum rightmost elevation angle, half the apex of conical observation pattern or star. If the limit rectangle is parallel to the horizon, the left and right upper elevation limits would be equal. (Degrees).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
upperRightElevationLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 64
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():Sensorlimits_Abridged_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : Sensorlimits_Abridged_dataMode_Enum.REAL;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the target sensor object.
 * Example: /// Example: SENSORLIMITS-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idSensor():string|null
idSensor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startSensorlimits_Abridged(builder:flatbuffers.Builder) {
  builder.startObject(16);
}

static addIdSensorLimits(builder:flatbuffers.Builder, idSensorLimitsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idSensorLimitsOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationMarkingOffset, 0);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, origNetworkOffset, 0);
}

static addUpperLeftAzimuthLimit(builder:flatbuffers.Builder, upperLeftAzimuthLimit:number) {
  builder.addFieldFloat64(3, upperLeftAzimuthLimit, 0.0);
}

static addUpperRightAzimuthLimit(builder:flatbuffers.Builder, upperRightAzimuthLimit:number) {
  builder.addFieldFloat64(4, upperRightAzimuthLimit, 0.0);
}

static addLowerRightAzimuthLimit(builder:flatbuffers.Builder, lowerRightAzimuthLimit:number) {
  builder.addFieldFloat64(5, lowerRightAzimuthLimit, 0.0);
}

static addLowerLeftAzimuthLimit(builder:flatbuffers.Builder, lowerLeftAzimuthLimit:number) {
  builder.addFieldFloat64(6, lowerLeftAzimuthLimit, 0.0);
}

static addLowerLeftElevationLimit(builder:flatbuffers.Builder, lowerLeftElevationLimit:number) {
  builder.addFieldFloat64(7, lowerLeftElevationLimit, 0.0);
}

static addUpperLeftElevationLimit(builder:flatbuffers.Builder, upperLeftElevationLimit:number) {
  builder.addFieldFloat64(8, upperLeftElevationLimit, 0.0);
}

static addLowerRightElevationLimit(builder:flatbuffers.Builder, lowerRightElevationLimit:number) {
  builder.addFieldFloat64(9, lowerRightElevationLimit, 0.0);
}

static addUpperRightElevationLimit(builder:flatbuffers.Builder, upperRightElevationLimit:number) {
  builder.addFieldFloat64(10, upperRightElevationLimit, 0.0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, sourceOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:Sensorlimits_Abridged_dataMode_Enum) {
  builder.addFieldInt8(12, dataMode, Sensorlimits_Abridged_dataMode_Enum.REAL);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, createdByOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, idSensorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, idSensorOffset, 0);
}

static endSensorlimits_Abridged(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishSensorlimits_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'SENS');
}

static finishSizePrefixedSensorlimits_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'SENS', true);
}

static createSensorlimits_Abridged(builder:flatbuffers.Builder, idSensorLimitsOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, origNetworkOffset:flatbuffers.Offset, upperLeftAzimuthLimit:number, upperRightAzimuthLimit:number, lowerRightAzimuthLimit:number, lowerLeftAzimuthLimit:number, lowerLeftElevationLimit:number, upperLeftElevationLimit:number, lowerRightElevationLimit:number, upperRightElevationLimit:number, sourceOffset:flatbuffers.Offset, dataMode:Sensorlimits_Abridged_dataMode_Enum, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, idSensorOffset:flatbuffers.Offset):flatbuffers.Offset {
  Sensorlimits_Abridged.startSensorlimits_Abridged(builder);
  Sensorlimits_Abridged.addIdSensorLimits(builder, idSensorLimitsOffset);
  Sensorlimits_Abridged.addClassificationMarking(builder, classificationMarkingOffset);
  Sensorlimits_Abridged.addOrigNetwork(builder, origNetworkOffset);
  Sensorlimits_Abridged.addUpperLeftAzimuthLimit(builder, upperLeftAzimuthLimit);
  Sensorlimits_Abridged.addUpperRightAzimuthLimit(builder, upperRightAzimuthLimit);
  Sensorlimits_Abridged.addLowerRightAzimuthLimit(builder, lowerRightAzimuthLimit);
  Sensorlimits_Abridged.addLowerLeftAzimuthLimit(builder, lowerLeftAzimuthLimit);
  Sensorlimits_Abridged.addLowerLeftElevationLimit(builder, lowerLeftElevationLimit);
  Sensorlimits_Abridged.addUpperLeftElevationLimit(builder, upperLeftElevationLimit);
  Sensorlimits_Abridged.addLowerRightElevationLimit(builder, lowerRightElevationLimit);
  Sensorlimits_Abridged.addUpperRightElevationLimit(builder, upperRightElevationLimit);
  Sensorlimits_Abridged.addSource(builder, sourceOffset);
  Sensorlimits_Abridged.addDataMode(builder, dataMode);
  Sensorlimits_Abridged.addCreatedAt(builder, createdAtOffset);
  Sensorlimits_Abridged.addCreatedBy(builder, createdByOffset);
  Sensorlimits_Abridged.addIdSensor(builder, idSensorOffset);
  return Sensorlimits_Abridged.endSensorlimits_Abridged(builder);
}

unpack(): Sensorlimits_AbridgedT {
  return new Sensorlimits_AbridgedT(
    this.idSensorLimits(),
    this.classificationMarking(),
    this.origNetwork(),
    this.upperLeftAzimuthLimit(),
    this.upperRightAzimuthLimit(),
    this.lowerRightAzimuthLimit(),
    this.lowerLeftAzimuthLimit(),
    this.lowerLeftElevationLimit(),
    this.upperLeftElevationLimit(),
    this.lowerRightElevationLimit(),
    this.upperRightElevationLimit(),
    this.source(),
    this.dataMode(),
    this.createdAt(),
    this.createdBy(),
    this.idSensor()
  );
}


unpackTo(_o: Sensorlimits_AbridgedT): void {
  _o.idSensorLimits = this.idSensorLimits();
  _o.classificationMarking = this.classificationMarking();
  _o.origNetwork = this.origNetwork();
  _o.upperLeftAzimuthLimit = this.upperLeftAzimuthLimit();
  _o.upperRightAzimuthLimit = this.upperRightAzimuthLimit();
  _o.lowerRightAzimuthLimit = this.lowerRightAzimuthLimit();
  _o.lowerLeftAzimuthLimit = this.lowerLeftAzimuthLimit();
  _o.lowerLeftElevationLimit = this.lowerLeftElevationLimit();
  _o.upperLeftElevationLimit = this.upperLeftElevationLimit();
  _o.lowerRightElevationLimit = this.lowerRightElevationLimit();
  _o.upperRightElevationLimit = this.upperRightElevationLimit();
  _o.source = this.source();
  _o.dataMode = this.dataMode();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.idSensor = this.idSensor();
}
}

export class Sensorlimits_AbridgedT implements flatbuffers.IGeneratedObject {
constructor(
  public idSensorLimits: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public origNetwork: string|Uint8Array|null = null,
  public upperLeftAzimuthLimit: number = 0.0,
  public upperRightAzimuthLimit: number = 0.0,
  public lowerRightAzimuthLimit: number = 0.0,
  public lowerLeftAzimuthLimit: number = 0.0,
  public lowerLeftElevationLimit: number = 0.0,
  public upperLeftElevationLimit: number = 0.0,
  public lowerRightElevationLimit: number = 0.0,
  public upperRightElevationLimit: number = 0.0,
  public source: string|Uint8Array|null = null,
  public dataMode: Sensorlimits_Abridged_dataMode_Enum = Sensorlimits_Abridged_dataMode_Enum.REAL,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public idSensor: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const idSensorLimits = (this.idSensorLimits !== null ? builder.createString(this.idSensorLimits!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor!) : 0);

  return Sensorlimits_Abridged.createSensorlimits_Abridged(builder,
    idSensorLimits,
    classificationMarking,
    origNetwork,
    this.upperLeftAzimuthLimit,
    this.upperRightAzimuthLimit,
    this.lowerRightAzimuthLimit,
    this.lowerLeftAzimuthLimit,
    this.lowerLeftElevationLimit,
    this.upperLeftElevationLimit,
    this.lowerRightElevationLimit,
    this.upperRightElevationLimit,
    source,
    this.dataMode,
    createdAt,
    createdBy,
    idSensor
  );
}
}
