// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Sensorcharacteristics_Full_dataMode_Enum } from './sensorcharacteristics-full-data-mode-enum.js';


/**
 * /// Model representation of characteristics and capabilities of a sensor.
 */
export class Sensorcharacteristics_Full implements flatbuffers.IUnpackableObject<Sensorcharacteristics_FullT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Sensorcharacteristics_Full {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsSensorcharacteristics_Full(bb:flatbuffers.ByteBuffer, obj?:Sensorcharacteristics_Full):Sensorcharacteristics_Full {
  return (obj || new Sensorcharacteristics_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsSensorcharacteristics_Full(bb:flatbuffers.ByteBuffer, obj?:Sensorcharacteristics_Full):Sensorcharacteristics_Full {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Sensorcharacteristics_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('SENS');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: SENSORCHARACTERISTICS-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the parent sensor.
 * Example: /// Example: SENSOR-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
idSensor():string|null
idSensor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Azimuth rate acquisition limit (rad/min).
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
azimuthRate():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Elevation rate acquisition limit (rad/min).
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
elevationRateGeolm():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Minimum range measurement capability of the sensor (km).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
minRangeLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum observable range limit (km) -- sensor cannot acquire beyond this range.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
maxRangeLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For Orbiting Sensors, First Card Azimuth limit #1 (left, deg).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
leftClockAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For Orbiting Sensors, First Card Azimuth limit #3 (left, deg).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
rightClockAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angle of the center of a phased array sensor.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
boresight():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The number of degrees off of the boresight for the sensor (degrees).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
boresightOffAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Negative Range-rate/relative velocity limit (km/sec).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
negativeRangeRateLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Positive Range-rate/relative velocity limit (km/sec).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
positiveRangeRateLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Absolute magnitude acquisition limit for optical sensors.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
magnitudeLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Beginning track angle limit (rad). Track angle is the angle between the camera axis and the gimbal plane. Values range from 0 - PI/2.
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
trackAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Signal to Noise Ratio (in db). The values for this range from 0.0 - + 99.99 dB.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
minSignalNoiseRatio():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The beam width of a Sensor's Fan (range). The values for this range from (0.0 to PI).
 * Example: /// Example: 3.1
 * Constraints: No constraints specified.
 */
fanBeamWidth():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum taskable range of the sensor (km).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
taskableRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Maximum observable sensor range (km).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
maxObservableRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Radio frequency (if sensor is RF).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
radioFrequency():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Radar frequency of the sensor (if a radar sensor).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
radarFrequency():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Radar transmit power in Watts.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
transmitPower():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Horizontal field of view.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
hFov():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Vertical field of view.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
vFov():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Horizontal pixel resolution.
 * Example: /// Example: 1000
 * Constraints: No constraints specified.
 */
hResPixels():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Vertical pixel resolution.
 * Example: /// Example: 1000
 * Constraints: No constraints specified.
 */
vResPixels():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Sensor band.
 * Example: /// Example: BAND
 * Constraints: Minimum length = 0, Maximum length = 36
 */
band():string|null
band(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
band(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Max deviation angle of the sensor in degrees.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
maxDeviationAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Optical sensor camera aperture.
 * Example: /// Example: 2.23
 * Constraints: No constraints specified.
 */
aperture():number {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Leftmost GEO belt longitude limit for this sensor (if applicable).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
leftGeoBeltLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Rightmost GEO belt longitude limit for this sensor (if applicable).
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
rightGeoBeltLimit():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For ASR (Air Surveillance Radar) sensors, the scan (360 deg sweep) rate of the radar, in scans/minute.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
asrScanRate():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, K-factor is a relative indicator of refractivity that infers the amount of radar beam bending due to atmosphere. (1<K<2).
 * Example: /// Example: 1.4
 * Constraints: No constraints specified.
 */
k():number {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, the focal point elevation of the radar at the site, in meters.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
focalPoint():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For tower sensors, the physical height of the sensor tower, in meters.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
towerHeight():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * True North correction for the sensor, in ACP (Azimunth Change Pulse) count.
 * Example: /// Example: 10
 * Constraints: No constraints specified.
 */
trueNorthCorrector():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Angle between magnetic north and true north at the sensor site, in degrees.
 * Example: /// Example: 45.23
 * Constraints: No constraints specified.
 */
magDec():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Peformance zone-1 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
z1MinRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Peformance zone-2 minimum range, in km. Note that the zones apply only to the PSR/Search radars.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
z2MinRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Peformance zone-1 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
 * Example: /// Example: 50.23
 * Constraints: No constraints specified.
 */
z1MaxRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Peformance zone-2 maximum range, in km. Note that the zones apply only to the PSR/Search radars.
 * Example: /// Example: 50.23
 * Constraints: No constraints specified.
 */
z2MaxRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, radar maximum unambiguous range, in km.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
radarMur():number {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, probability of the indication of the presence of a radar target due to noise or interference.
 * Example: /// Example: 0.5
 * Constraints: No constraints specified.
 */
probFalseAlarm():number {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, pulse repetition frequency, in Hz. Number of new pulses tranmistted per second.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
prf():number {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, radar pulse width, in microseconds. The transmit time of a pulse.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
radarPulseWidth():number {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For radar based sensors, number of integrated pulses in a transmit cycle.
 * Example: /// Example: 10
 * Constraints: No constraints specified.
 */
numIntegratedPulses():number {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Antenna true tilt, in degrees.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
trueTilt():number {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Message data format transmitted by the sensor digitizer.
 * Example: /// Example: DATA_FORMAT
 * Constraints: Minimum length = 0, Maximum length = 32
 */
radarMessageFormat():string|null
radarMessageFormat(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
radarMessageFormat(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * For radar based sensors, expression of the radar system noise, aggregated as an equivalent thermal noise value, in degrees Kelvin.
 * Example: /// Example: 3.5
 * Constraints: No constraints specified.
 */
systemNoiseTemperature():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 64
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():Sensorcharacteristics_Full_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : Sensorcharacteristics_Full_dataMode_Enum.REAL;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Time the row was last updated in the database, auto-populated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
updatedAt():string|null
updatedAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
updatedAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who updated the row in the database, auto-populated by the system.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 0, Maximum length = 64
 */
updatedBy():string|null
updatedBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
updatedBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startSensorcharacteristics_Full(builder:flatbuffers.Builder) {
  builder.startObject(56);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, idSensorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, idSensorOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, classificationMarkingOffset, 0);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, origNetworkOffset, 0);
}

static addAzimuthRate(builder:flatbuffers.Builder, azimuthRate:number) {
  builder.addFieldFloat64(4, azimuthRate, 0.0);
}

static addElevationRateGeolm(builder:flatbuffers.Builder, elevationRateGeolm:number) {
  builder.addFieldFloat64(5, elevationRateGeolm, 0.0);
}

static addMinRangeLimit(builder:flatbuffers.Builder, minRangeLimit:number) {
  builder.addFieldFloat64(6, minRangeLimit, 0.0);
}

static addMaxRangeLimit(builder:flatbuffers.Builder, maxRangeLimit:number) {
  builder.addFieldFloat64(7, maxRangeLimit, 0.0);
}

static addLeftClockAngle(builder:flatbuffers.Builder, leftClockAngle:number) {
  builder.addFieldFloat64(8, leftClockAngle, 0.0);
}

static addRightClockAngle(builder:flatbuffers.Builder, rightClockAngle:number) {
  builder.addFieldFloat64(9, rightClockAngle, 0.0);
}

static addBoresight(builder:flatbuffers.Builder, boresight:number) {
  builder.addFieldFloat64(10, boresight, 0.0);
}

static addBoresightOffAngle(builder:flatbuffers.Builder, boresightOffAngle:number) {
  builder.addFieldFloat64(11, boresightOffAngle, 0.0);
}

static addNegativeRangeRateLimit(builder:flatbuffers.Builder, negativeRangeRateLimit:number) {
  builder.addFieldFloat64(12, negativeRangeRateLimit, 0.0);
}

static addPositiveRangeRateLimit(builder:flatbuffers.Builder, positiveRangeRateLimit:number) {
  builder.addFieldFloat64(13, positiveRangeRateLimit, 0.0);
}

static addMagnitudeLimit(builder:flatbuffers.Builder, magnitudeLimit:number) {
  builder.addFieldFloat64(14, magnitudeLimit, 0.0);
}

static addTrackAngle(builder:flatbuffers.Builder, trackAngle:number) {
  builder.addFieldFloat64(15, trackAngle, 0.0);
}

static addMinSignalNoiseRatio(builder:flatbuffers.Builder, minSignalNoiseRatio:number) {
  builder.addFieldFloat64(16, minSignalNoiseRatio, 0.0);
}

static addFanBeamWidth(builder:flatbuffers.Builder, fanBeamWidth:number) {
  builder.addFieldFloat64(17, fanBeamWidth, 0.0);
}

static addTaskableRange(builder:flatbuffers.Builder, taskableRange:number) {
  builder.addFieldFloat64(18, taskableRange, 0.0);
}

static addMaxObservableRange(builder:flatbuffers.Builder, maxObservableRange:number) {
  builder.addFieldFloat64(19, maxObservableRange, 0.0);
}

static addRadioFrequency(builder:flatbuffers.Builder, radioFrequency:number) {
  builder.addFieldFloat64(20, radioFrequency, 0.0);
}

static addRadarFrequency(builder:flatbuffers.Builder, radarFrequency:number) {
  builder.addFieldFloat64(21, radarFrequency, 0.0);
}

static addTransmitPower(builder:flatbuffers.Builder, transmitPower:number) {
  builder.addFieldFloat64(22, transmitPower, 0.0);
}

static addHFov(builder:flatbuffers.Builder, hFov:number) {
  builder.addFieldFloat64(23, hFov, 0.0);
}

static addVFov(builder:flatbuffers.Builder, vFov:number) {
  builder.addFieldFloat64(24, vFov, 0.0);
}

static addHResPixels(builder:flatbuffers.Builder, hResPixels:number) {
  builder.addFieldInt32(25, hResPixels, 0);
}

static addVResPixels(builder:flatbuffers.Builder, vResPixels:number) {
  builder.addFieldInt32(26, vResPixels, 0);
}

static addBand(builder:flatbuffers.Builder, bandOffset:flatbuffers.Offset) {
  builder.addFieldOffset(27, bandOffset, 0);
}

static addMaxDeviationAngle(builder:flatbuffers.Builder, maxDeviationAngle:number) {
  builder.addFieldFloat64(28, maxDeviationAngle, 0.0);
}

static addAperture(builder:flatbuffers.Builder, aperture:number) {
  builder.addFieldFloat64(29, aperture, 0.0);
}

static addLeftGeoBeltLimit(builder:flatbuffers.Builder, leftGeoBeltLimit:number) {
  builder.addFieldFloat64(30, leftGeoBeltLimit, 0.0);
}

static addRightGeoBeltLimit(builder:flatbuffers.Builder, rightGeoBeltLimit:number) {
  builder.addFieldFloat64(31, rightGeoBeltLimit, 0.0);
}

static addAsrScanRate(builder:flatbuffers.Builder, asrScanRate:number) {
  builder.addFieldFloat64(32, asrScanRate, 0.0);
}

static addK(builder:flatbuffers.Builder, k:number) {
  builder.addFieldFloat64(33, k, 0.0);
}

static addFocalPoint(builder:flatbuffers.Builder, focalPoint:number) {
  builder.addFieldFloat64(34, focalPoint, 0.0);
}

static addTowerHeight(builder:flatbuffers.Builder, towerHeight:number) {
  builder.addFieldFloat64(35, towerHeight, 0.0);
}

static addTrueNorthCorrector(builder:flatbuffers.Builder, trueNorthCorrector:number) {
  builder.addFieldInt32(36, trueNorthCorrector, 0);
}

static addMagDec(builder:flatbuffers.Builder, magDec:number) {
  builder.addFieldFloat64(37, magDec, 0.0);
}

static addZ1MinRange(builder:flatbuffers.Builder, z1MinRange:number) {
  builder.addFieldFloat64(38, z1MinRange, 0.0);
}

static addZ2MinRange(builder:flatbuffers.Builder, z2MinRange:number) {
  builder.addFieldFloat64(39, z2MinRange, 0.0);
}

static addZ1MaxRange(builder:flatbuffers.Builder, z1MaxRange:number) {
  builder.addFieldFloat64(40, z1MaxRange, 0.0);
}

static addZ2MaxRange(builder:flatbuffers.Builder, z2MaxRange:number) {
  builder.addFieldFloat64(41, z2MaxRange, 0.0);
}

static addRadarMur(builder:flatbuffers.Builder, radarMur:number) {
  builder.addFieldFloat64(42, radarMur, 0.0);
}

static addProbFalseAlarm(builder:flatbuffers.Builder, probFalseAlarm:number) {
  builder.addFieldFloat64(43, probFalseAlarm, 0.0);
}

static addPrf(builder:flatbuffers.Builder, prf:number) {
  builder.addFieldFloat64(44, prf, 0.0);
}

static addRadarPulseWidth(builder:flatbuffers.Builder, radarPulseWidth:number) {
  builder.addFieldFloat64(45, radarPulseWidth, 0.0);
}

static addNumIntegratedPulses(builder:flatbuffers.Builder, numIntegratedPulses:number) {
  builder.addFieldInt32(46, numIntegratedPulses, 0);
}

static addTrueTilt(builder:flatbuffers.Builder, trueTilt:number) {
  builder.addFieldFloat64(47, trueTilt, 0.0);
}

static addRadarMessageFormat(builder:flatbuffers.Builder, radarMessageFormatOffset:flatbuffers.Offset) {
  builder.addFieldOffset(48, radarMessageFormatOffset, 0);
}

static addSystemNoiseTemperature(builder:flatbuffers.Builder, systemNoiseTemperature:number) {
  builder.addFieldFloat64(49, systemNoiseTemperature, 0.0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(50, sourceOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:Sensorcharacteristics_Full_dataMode_Enum) {
  builder.addFieldInt8(51, dataMode, Sensorcharacteristics_Full_dataMode_Enum.REAL);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(52, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(53, createdByOffset, 0);
}

static addUpdatedAt(builder:flatbuffers.Builder, updatedAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(54, updatedAtOffset, 0);
}

static addUpdatedBy(builder:flatbuffers.Builder, updatedByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(55, updatedByOffset, 0);
}

static endSensorcharacteristics_Full(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishSensorcharacteristics_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'SENS');
}

static finishSizePrefixedSensorcharacteristics_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'SENS', true);
}

static createSensorcharacteristics_Full(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, idSensorOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, origNetworkOffset:flatbuffers.Offset, azimuthRate:number, elevationRateGeolm:number, minRangeLimit:number, maxRangeLimit:number, leftClockAngle:number, rightClockAngle:number, boresight:number, boresightOffAngle:number, negativeRangeRateLimit:number, positiveRangeRateLimit:number, magnitudeLimit:number, trackAngle:number, minSignalNoiseRatio:number, fanBeamWidth:number, taskableRange:number, maxObservableRange:number, radioFrequency:number, radarFrequency:number, transmitPower:number, hFov:number, vFov:number, hResPixels:number, vResPixels:number, bandOffset:flatbuffers.Offset, maxDeviationAngle:number, aperture:number, leftGeoBeltLimit:number, rightGeoBeltLimit:number, asrScanRate:number, k:number, focalPoint:number, towerHeight:number, trueNorthCorrector:number, magDec:number, z1MinRange:number, z2MinRange:number, z1MaxRange:number, z2MaxRange:number, radarMur:number, probFalseAlarm:number, prf:number, radarPulseWidth:number, numIntegratedPulses:number, trueTilt:number, radarMessageFormatOffset:flatbuffers.Offset, systemNoiseTemperature:number, sourceOffset:flatbuffers.Offset, dataMode:Sensorcharacteristics_Full_dataMode_Enum, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, updatedAtOffset:flatbuffers.Offset, updatedByOffset:flatbuffers.Offset):flatbuffers.Offset {
  Sensorcharacteristics_Full.startSensorcharacteristics_Full(builder);
  Sensorcharacteristics_Full.addId(builder, idOffset);
  Sensorcharacteristics_Full.addIdSensor(builder, idSensorOffset);
  Sensorcharacteristics_Full.addClassificationMarking(builder, classificationMarkingOffset);
  Sensorcharacteristics_Full.addOrigNetwork(builder, origNetworkOffset);
  Sensorcharacteristics_Full.addAzimuthRate(builder, azimuthRate);
  Sensorcharacteristics_Full.addElevationRateGeolm(builder, elevationRateGeolm);
  Sensorcharacteristics_Full.addMinRangeLimit(builder, minRangeLimit);
  Sensorcharacteristics_Full.addMaxRangeLimit(builder, maxRangeLimit);
  Sensorcharacteristics_Full.addLeftClockAngle(builder, leftClockAngle);
  Sensorcharacteristics_Full.addRightClockAngle(builder, rightClockAngle);
  Sensorcharacteristics_Full.addBoresight(builder, boresight);
  Sensorcharacteristics_Full.addBoresightOffAngle(builder, boresightOffAngle);
  Sensorcharacteristics_Full.addNegativeRangeRateLimit(builder, negativeRangeRateLimit);
  Sensorcharacteristics_Full.addPositiveRangeRateLimit(builder, positiveRangeRateLimit);
  Sensorcharacteristics_Full.addMagnitudeLimit(builder, magnitudeLimit);
  Sensorcharacteristics_Full.addTrackAngle(builder, trackAngle);
  Sensorcharacteristics_Full.addMinSignalNoiseRatio(builder, minSignalNoiseRatio);
  Sensorcharacteristics_Full.addFanBeamWidth(builder, fanBeamWidth);
  Sensorcharacteristics_Full.addTaskableRange(builder, taskableRange);
  Sensorcharacteristics_Full.addMaxObservableRange(builder, maxObservableRange);
  Sensorcharacteristics_Full.addRadioFrequency(builder, radioFrequency);
  Sensorcharacteristics_Full.addRadarFrequency(builder, radarFrequency);
  Sensorcharacteristics_Full.addTransmitPower(builder, transmitPower);
  Sensorcharacteristics_Full.addHFov(builder, hFov);
  Sensorcharacteristics_Full.addVFov(builder, vFov);
  Sensorcharacteristics_Full.addHResPixels(builder, hResPixels);
  Sensorcharacteristics_Full.addVResPixels(builder, vResPixels);
  Sensorcharacteristics_Full.addBand(builder, bandOffset);
  Sensorcharacteristics_Full.addMaxDeviationAngle(builder, maxDeviationAngle);
  Sensorcharacteristics_Full.addAperture(builder, aperture);
  Sensorcharacteristics_Full.addLeftGeoBeltLimit(builder, leftGeoBeltLimit);
  Sensorcharacteristics_Full.addRightGeoBeltLimit(builder, rightGeoBeltLimit);
  Sensorcharacteristics_Full.addAsrScanRate(builder, asrScanRate);
  Sensorcharacteristics_Full.addK(builder, k);
  Sensorcharacteristics_Full.addFocalPoint(builder, focalPoint);
  Sensorcharacteristics_Full.addTowerHeight(builder, towerHeight);
  Sensorcharacteristics_Full.addTrueNorthCorrector(builder, trueNorthCorrector);
  Sensorcharacteristics_Full.addMagDec(builder, magDec);
  Sensorcharacteristics_Full.addZ1MinRange(builder, z1MinRange);
  Sensorcharacteristics_Full.addZ2MinRange(builder, z2MinRange);
  Sensorcharacteristics_Full.addZ1MaxRange(builder, z1MaxRange);
  Sensorcharacteristics_Full.addZ2MaxRange(builder, z2MaxRange);
  Sensorcharacteristics_Full.addRadarMur(builder, radarMur);
  Sensorcharacteristics_Full.addProbFalseAlarm(builder, probFalseAlarm);
  Sensorcharacteristics_Full.addPrf(builder, prf);
  Sensorcharacteristics_Full.addRadarPulseWidth(builder, radarPulseWidth);
  Sensorcharacteristics_Full.addNumIntegratedPulses(builder, numIntegratedPulses);
  Sensorcharacteristics_Full.addTrueTilt(builder, trueTilt);
  Sensorcharacteristics_Full.addRadarMessageFormat(builder, radarMessageFormatOffset);
  Sensorcharacteristics_Full.addSystemNoiseTemperature(builder, systemNoiseTemperature);
  Sensorcharacteristics_Full.addSource(builder, sourceOffset);
  Sensorcharacteristics_Full.addDataMode(builder, dataMode);
  Sensorcharacteristics_Full.addCreatedAt(builder, createdAtOffset);
  Sensorcharacteristics_Full.addCreatedBy(builder, createdByOffset);
  Sensorcharacteristics_Full.addUpdatedAt(builder, updatedAtOffset);
  Sensorcharacteristics_Full.addUpdatedBy(builder, updatedByOffset);
  return Sensorcharacteristics_Full.endSensorcharacteristics_Full(builder);
}

unpack(): Sensorcharacteristics_FullT {
  return new Sensorcharacteristics_FullT(
    this.id(),
    this.idSensor(),
    this.classificationMarking(),
    this.origNetwork(),
    this.azimuthRate(),
    this.elevationRateGeolm(),
    this.minRangeLimit(),
    this.maxRangeLimit(),
    this.leftClockAngle(),
    this.rightClockAngle(),
    this.boresight(),
    this.boresightOffAngle(),
    this.negativeRangeRateLimit(),
    this.positiveRangeRateLimit(),
    this.magnitudeLimit(),
    this.trackAngle(),
    this.minSignalNoiseRatio(),
    this.fanBeamWidth(),
    this.taskableRange(),
    this.maxObservableRange(),
    this.radioFrequency(),
    this.radarFrequency(),
    this.transmitPower(),
    this.hFov(),
    this.vFov(),
    this.hResPixels(),
    this.vResPixels(),
    this.band(),
    this.maxDeviationAngle(),
    this.aperture(),
    this.leftGeoBeltLimit(),
    this.rightGeoBeltLimit(),
    this.asrScanRate(),
    this.k(),
    this.focalPoint(),
    this.towerHeight(),
    this.trueNorthCorrector(),
    this.magDec(),
    this.z1MinRange(),
    this.z2MinRange(),
    this.z1MaxRange(),
    this.z2MaxRange(),
    this.radarMur(),
    this.probFalseAlarm(),
    this.prf(),
    this.radarPulseWidth(),
    this.numIntegratedPulses(),
    this.trueTilt(),
    this.radarMessageFormat(),
    this.systemNoiseTemperature(),
    this.source(),
    this.dataMode(),
    this.createdAt(),
    this.createdBy(),
    this.updatedAt(),
    this.updatedBy()
  );
}


unpackTo(_o: Sensorcharacteristics_FullT): void {
  _o.id = this.id();
  _o.idSensor = this.idSensor();
  _o.classificationMarking = this.classificationMarking();
  _o.origNetwork = this.origNetwork();
  _o.azimuthRate = this.azimuthRate();
  _o.elevationRateGeolm = this.elevationRateGeolm();
  _o.minRangeLimit = this.minRangeLimit();
  _o.maxRangeLimit = this.maxRangeLimit();
  _o.leftClockAngle = this.leftClockAngle();
  _o.rightClockAngle = this.rightClockAngle();
  _o.boresight = this.boresight();
  _o.boresightOffAngle = this.boresightOffAngle();
  _o.negativeRangeRateLimit = this.negativeRangeRateLimit();
  _o.positiveRangeRateLimit = this.positiveRangeRateLimit();
  _o.magnitudeLimit = this.magnitudeLimit();
  _o.trackAngle = this.trackAngle();
  _o.minSignalNoiseRatio = this.minSignalNoiseRatio();
  _o.fanBeamWidth = this.fanBeamWidth();
  _o.taskableRange = this.taskableRange();
  _o.maxObservableRange = this.maxObservableRange();
  _o.radioFrequency = this.radioFrequency();
  _o.radarFrequency = this.radarFrequency();
  _o.transmitPower = this.transmitPower();
  _o.hFOV = this.hFov();
  _o.vFOV = this.vFov();
  _o.hResPixels = this.hResPixels();
  _o.vResPixels = this.vResPixels();
  _o.band = this.band();
  _o.maxDeviationAngle = this.maxDeviationAngle();
  _o.aperture = this.aperture();
  _o.leftGeoBeltLimit = this.leftGeoBeltLimit();
  _o.rightGeoBeltLimit = this.rightGeoBeltLimit();
  _o.asrScanRate = this.asrScanRate();
  _o.k = this.k();
  _o.focalPoint = this.focalPoint();
  _o.towerHeight = this.towerHeight();
  _o.trueNorthCorrector = this.trueNorthCorrector();
  _o.magDec = this.magDec();
  _o.z1MinRange = this.z1MinRange();
  _o.z2MinRange = this.z2MinRange();
  _o.z1MaxRange = this.z1MaxRange();
  _o.z2MaxRange = this.z2MaxRange();
  _o.radarMUR = this.radarMur();
  _o.probFalseAlarm = this.probFalseAlarm();
  _o.prf = this.prf();
  _o.radarPulseWidth = this.radarPulseWidth();
  _o.numIntegratedPulses = this.numIntegratedPulses();
  _o.trueTilt = this.trueTilt();
  _o.radarMessageFormat = this.radarMessageFormat();
  _o.systemNoiseTemperature = this.systemNoiseTemperature();
  _o.source = this.source();
  _o.dataMode = this.dataMode();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.updatedAt = this.updatedAt();
  _o.updatedBy = this.updatedBy();
}
}

export class Sensorcharacteristics_FullT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public idSensor: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public origNetwork: string|Uint8Array|null = null,
  public azimuthRate: number = 0.0,
  public elevationRateGeolm: number = 0.0,
  public minRangeLimit: number = 0.0,
  public maxRangeLimit: number = 0.0,
  public leftClockAngle: number = 0.0,
  public rightClockAngle: number = 0.0,
  public boresight: number = 0.0,
  public boresightOffAngle: number = 0.0,
  public negativeRangeRateLimit: number = 0.0,
  public positiveRangeRateLimit: number = 0.0,
  public magnitudeLimit: number = 0.0,
  public trackAngle: number = 0.0,
  public minSignalNoiseRatio: number = 0.0,
  public fanBeamWidth: number = 0.0,
  public taskableRange: number = 0.0,
  public maxObservableRange: number = 0.0,
  public radioFrequency: number = 0.0,
  public radarFrequency: number = 0.0,
  public transmitPower: number = 0.0,
  public hFOV: number = 0.0,
  public vFOV: number = 0.0,
  public hResPixels: number = 0,
  public vResPixels: number = 0,
  public band: string|Uint8Array|null = null,
  public maxDeviationAngle: number = 0.0,
  public aperture: number = 0.0,
  public leftGeoBeltLimit: number = 0.0,
  public rightGeoBeltLimit: number = 0.0,
  public asrScanRate: number = 0.0,
  public k: number = 0.0,
  public focalPoint: number = 0.0,
  public towerHeight: number = 0.0,
  public trueNorthCorrector: number = 0,
  public magDec: number = 0.0,
  public z1MinRange: number = 0.0,
  public z2MinRange: number = 0.0,
  public z1MaxRange: number = 0.0,
  public z2MaxRange: number = 0.0,
  public radarMUR: number = 0.0,
  public probFalseAlarm: number = 0.0,
  public prf: number = 0.0,
  public radarPulseWidth: number = 0.0,
  public numIntegratedPulses: number = 0,
  public trueTilt: number = 0.0,
  public radarMessageFormat: string|Uint8Array|null = null,
  public systemNoiseTemperature: number = 0.0,
  public source: string|Uint8Array|null = null,
  public dataMode: Sensorcharacteristics_Full_dataMode_Enum = Sensorcharacteristics_Full_dataMode_Enum.REAL,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public updatedAt: string|Uint8Array|null = null,
  public updatedBy: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);
  const band = (this.band !== null ? builder.createString(this.band!) : 0);
  const radarMessageFormat = (this.radarMessageFormat !== null ? builder.createString(this.radarMessageFormat!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const updatedAt = (this.updatedAt !== null ? builder.createString(this.updatedAt!) : 0);
  const updatedBy = (this.updatedBy !== null ? builder.createString(this.updatedBy!) : 0);

  return Sensorcharacteristics_Full.createSensorcharacteristics_Full(builder,
    id,
    idSensor,
    classificationMarking,
    origNetwork,
    this.azimuthRate,
    this.elevationRateGeolm,
    this.minRangeLimit,
    this.maxRangeLimit,
    this.leftClockAngle,
    this.rightClockAngle,
    this.boresight,
    this.boresightOffAngle,
    this.negativeRangeRateLimit,
    this.positiveRangeRateLimit,
    this.magnitudeLimit,
    this.trackAngle,
    this.minSignalNoiseRatio,
    this.fanBeamWidth,
    this.taskableRange,
    this.maxObservableRange,
    this.radioFrequency,
    this.radarFrequency,
    this.transmitPower,
    this.hFOV,
    this.vFOV,
    this.hResPixels,
    this.vResPixels,
    band,
    this.maxDeviationAngle,
    this.aperture,
    this.leftGeoBeltLimit,
    this.rightGeoBeltLimit,
    this.asrScanRate,
    this.k,
    this.focalPoint,
    this.towerHeight,
    this.trueNorthCorrector,
    this.magDec,
    this.z1MinRange,
    this.z2MinRange,
    this.z1MaxRange,
    this.z2MaxRange,
    this.radarMUR,
    this.probFalseAlarm,
    this.prf,
    this.radarPulseWidth,
    this.numIntegratedPulses,
    this.trueTilt,
    radarMessageFormat,
    this.systemNoiseTemperature,
    source,
    this.dataMode,
    createdAt,
    createdBy,
    updatedAt,
    updatedBy
  );
}
}
