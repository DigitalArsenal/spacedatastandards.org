// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * /// Information pertaining to the details of executing the recovery.
 */
export class PersonnelRecoveryExecutionInfo_Full implements flatbuffers.IUnpackableObject<PersonnelRecoveryExecutionInfo_FullT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PersonnelRecoveryExecutionInfo_Full {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPersonnelRecoveryExecutionInfo_Full(bb:flatbuffers.ByteBuffer, obj?:PersonnelRecoveryExecutionInfo_Full):PersonnelRecoveryExecutionInfo_Full {
  return (obj || new PersonnelRecoveryExecutionInfo_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPersonnelRecoveryExecutionInfo_Full(bb:flatbuffers.ByteBuffer, obj?:PersonnelRecoveryExecutionInfo_Full):PersonnelRecoveryExecutionInfo_Full {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PersonnelRecoveryExecutionInfo_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('PERS');
}

/**
 * Array of the WGS-84 latitude (-90 to 90, negative values south of the equator) in degrees, longitude (-180 to 180, negative values west of Prime Meridian) in degrees, and altitude, in meters, of the initial location. This array must contain a minimum of 2 elements (latitude and longitude), and may contain an optional 3rd element (altitude).
 * Example: /// Example: [103.23, 30.445]
 * Constraints: No constraints specified.
 */
initialPoint(index: number):string
initialPoint(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
initialPoint(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

initialPointLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The heading, in degrees clockwise from North, of entering the recovery zone.
 * Example: /// Example: 35.66
 * Constraints: No constraints specified.
 */
ingress():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Description of the objective strategy plan.
 * Example: /// Example: Description of strategy plan.
 * Constraints: Minimum length = 0, Maximum length = 1024
 */
objStrategy():string|null
objStrategy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objStrategy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Array of the WGS-84 latitude (-90 to 90, negative values south of the equator) in degrees, longitude (-180 to 180, negative values west of Prime Meridian) in degrees, and altitude, in meters, of the egress location. This array must contain a minimum of 2 elements (latitude and longitude), and may contain an optional 3rd element (altitude).
 * Example: /// Example: [107.23, 30.455]
 * Constraints: No constraints specified.
 */
egressPoint(index: number):string
egressPoint(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
egressPoint(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

egressPointLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The heading, in degrees, of leaving the recovery zone.
 * Example: /// Example: 66.53
 * Constraints: No constraints specified.
 */
egress():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * No description provided.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
recoveryVehicle():string|null
recoveryVehicle(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
recoveryVehicle(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * No description provided.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
escortVehicle():string|null
escortVehicle(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
escortVehicle(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startPersonnelRecoveryExecutionInfo_Full(builder:flatbuffers.Builder) {
  builder.startObject(7);
}

static addInitialPoint(builder:flatbuffers.Builder, initialPointOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, initialPointOffset, 0);
}

static createInitialPointVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startInitialPointVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addIngress(builder:flatbuffers.Builder, ingress:number) {
  builder.addFieldFloat64(1, ingress, 0.0);
}

static addObjStrategy(builder:flatbuffers.Builder, objStrategyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, objStrategyOffset, 0);
}

static addEgressPoint(builder:flatbuffers.Builder, egressPointOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, egressPointOffset, 0);
}

static createEgressPointVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEgressPointVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEgress(builder:flatbuffers.Builder, egress:number) {
  builder.addFieldFloat64(4, egress, 0.0);
}

static addRecoveryVehicle(builder:flatbuffers.Builder, recoveryVehicleOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, recoveryVehicleOffset, 0);
}

static addEscortVehicle(builder:flatbuffers.Builder, escortVehicleOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, escortVehicleOffset, 0);
}

static endPersonnelRecoveryExecutionInfo_Full(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishPersonnelRecoveryExecutionInfo_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'PERS');
}

static finishSizePrefixedPersonnelRecoveryExecutionInfo_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'PERS', true);
}

static createPersonnelRecoveryExecutionInfo_Full(builder:flatbuffers.Builder, initialPointOffset:flatbuffers.Offset, ingress:number, objStrategyOffset:flatbuffers.Offset, egressPointOffset:flatbuffers.Offset, egress:number, recoveryVehicleOffset:flatbuffers.Offset, escortVehicleOffset:flatbuffers.Offset):flatbuffers.Offset {
  PersonnelRecoveryExecutionInfo_Full.startPersonnelRecoveryExecutionInfo_Full(builder);
  PersonnelRecoveryExecutionInfo_Full.addInitialPoint(builder, initialPointOffset);
  PersonnelRecoveryExecutionInfo_Full.addIngress(builder, ingress);
  PersonnelRecoveryExecutionInfo_Full.addObjStrategy(builder, objStrategyOffset);
  PersonnelRecoveryExecutionInfo_Full.addEgressPoint(builder, egressPointOffset);
  PersonnelRecoveryExecutionInfo_Full.addEgress(builder, egress);
  PersonnelRecoveryExecutionInfo_Full.addRecoveryVehicle(builder, recoveryVehicleOffset);
  PersonnelRecoveryExecutionInfo_Full.addEscortVehicle(builder, escortVehicleOffset);
  return PersonnelRecoveryExecutionInfo_Full.endPersonnelRecoveryExecutionInfo_Full(builder);
}

unpack(): PersonnelRecoveryExecutionInfo_FullT {
  return new PersonnelRecoveryExecutionInfo_FullT(
    this.bb!.createScalarList<string>(this.initialPoint.bind(this), this.initialPoint_Length()),
    this.ingress(),
    this.objStrategy(),
    this.bb!.createScalarList<string>(this.egressPoint.bind(this), this.egressPoint_Length()),
    this.egress(),
    this.recoveryVehicle(),
    this.escortVehicle()
  );
}


unpackTo(_o: PersonnelRecoveryExecutionInfo_FullT): void {
  _o.initialPoint = this.bb!.createScalarList<string>(this.initialPoint.bind(this), this.initialPoint_Length());
  _o.ingress = this.ingress();
  _o.objStrategy = this.objStrategy();
  _o.egressPoint = this.bb!.createScalarList<string>(this.egressPoint.bind(this), this.egressPoint_Length());
  _o.egress = this.egress();
  _o.recoveryVehicle = this.recoveryVehicle();
  _o.escortVehicle = this.escortVehicle();
}
}

export class PersonnelRecoveryExecutionInfo_FullT implements flatbuffers.IGeneratedObject {
constructor(
  public initialPoint: (string)[] = [],
  public ingress: number = 0.0,
  public objStrategy: string|Uint8Array|null = null,
  public egressPoint: (string)[] = [],
  public egress: number = 0.0,
  public recoveryVehicle: string|Uint8Array|null = null,
  public escortVehicle: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const initialPoint = PersonnelRecoveryExecutionInfo_Full.createInitialPointVector(builder, builder.createObjectOffsetList(this.initialPoint));
  const objStrategy = (this.objStrategy !== null ? builder.createString(this.objStrategy!) : 0);
  const egressPoint = PersonnelRecoveryExecutionInfo_Full.createEgressPointVector(builder, builder.createObjectOffsetList(this.egressPoint));
  const recoveryVehicle = (this.recoveryVehicle !== null ? builder.createString(this.recoveryVehicle!) : 0);
  const escortVehicle = (this.escortVehicle !== null ? builder.createString(this.escortVehicle!) : 0);

  return PersonnelRecoveryExecutionInfo_Full.createPersonnelRecoveryExecutionInfo_Full(builder,
    initialPoint,
    this.ingress,
    objStrategy,
    egressPoint,
    this.egress,
    recoveryVehicle,
    escortVehicle
  );
}
}
