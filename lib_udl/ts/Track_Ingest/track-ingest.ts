// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { Track_Ingest_dataMode_Enum } from './track-ingest-data-mode-enum.js';


/**
 * /// A track is a position and optionally a heading/velocity of an object such as an aircraft at a particular timestamp. It also includes optional information regarding the identity/type of the target object, if known.
 */
export class Track_Ingest implements flatbuffers.IUnpackableObject<Track_IngestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):Track_Ingest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsTrack_Ingest(bb:flatbuffers.ByteBuffer, obj?:Track_Ingest):Track_Ingest {
  return (obj || new Track_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsTrack_Ingest(bb:flatbuffers.ByteBuffer, obj?:Track_Ingest):Track_Ingest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new Track_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('TRAC');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: TRACK-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
 * Example: /// Example: Contact Info
 * Constraints: Minimum length = 0, Maximum length = 64
 */
cntct():string|null
cntct(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
cntct(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Message Timestamp.
 * Example: /// Example: 2021-01-01T01:01:01.123456Z
 * Constraints: No constraints specified.
 */
msgTs():string|null
msgTs(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
msgTs(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Mission ID related to the track.
 * Example: /// Example: msnId
 * Constraints: Minimum length = 0, Maximum length = 36
 */
msnId():string|null
msnId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
msnId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Nationality or organization of the tracking/reporting system or platform (e.g. FR, NATO, US, etc.).
 * Example: /// Example: US
 * Constraints: Minimum length = 0, Maximum length = 64
 */
assetNat():string|null
assetNat(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
assetNat(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Id/name of the platform providing the track data (i.e., tail number for air platform, tower ID for tower based sensor, site id for fixed radar).
 * Example: /// Example: asset
 * Constraints: Minimum length = 0, Maximum length = 32
 */
asset():string|null
asset(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
asset(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Id/name of sensor providing the track data.
 * Example: /// Example: sen
 * Constraints: Minimum length = 0, Maximum length = 32
 */
sen():string|null
sen(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
sen(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Sensor quality.
 * Example: /// Example: senQual
 * Constraints: Minimum length = 0, Maximum length = 32
 */
senQual():string|null
senQual(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
senQual(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * UUID identifying the track, which should remain the same on subsequent tracks of the same object.
 * Example: /// Example: trkId
 * Constraints: Minimum length = 0, Maximum length = 36
 */
trkId():string|null
trkId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
trkId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
 * Example: /// Example: trkNum
 * Constraints: Minimum length = 0, Maximum length = 32
 */
trkNum():string|null
trkNum(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
trkNum(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Status of the track (e.g., INITIATING, MAINTAINING, DROPPING, TERMINATED, etc.).
 * Example: /// Example: INITIATING
 * Constraints: Minimum length = 0, Maximum length = 32
 */
trkStat():string|null
trkStat(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
trkStat(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Nationality or organization of the track object (e.g. FR, NATO, US, etc.).
 * Example: /// Example: NATO
 * Constraints: Minimum length = 0, Maximum length = 64
 */
objNat():string|null
objNat(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objNat(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The UID or designation of the tracked object.
 * Example: /// Example: objId
 * Constraints: Minimum length = 0, Maximum length = 36
 */
objId():string|null
objId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
 * Example: /// Example: WATERCRAFT
 * Constraints: Minimum length = 0, Maximum length = 32
 */
objType():string|null
objType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The object specific type. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations. The specific type can be reported as either a combination of the code and environment (e.g. 155/SURFACE) or as the descriptive representation (e.g. AUDACE DDG), which are equivalent.
 * Example: /// Example: LIGHT_TANK
 * Constraints: Minimum length = 0, Maximum length = 32
 */
objSpec():string|null
objSpec(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objSpec(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
 * Example: /// Example: COMBAT_VEHICLE
 * Constraints: Minimum length = 0, Maximum length = 32
 */
objPlat():string|null
objPlat(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objPlat(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
 * Example: /// Example: HOLDING
 * Constraints: Minimum length = 0, Maximum length = 32
 */
objAct():string|null
objAct(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objAct(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The type of source information from which the track was derived. Intended as, but not constrained to, NATO STANAG 4676 modality types (AIS, BFT, BIOMETRIC, COMINT, DOPPLER, ELINT, HRR, HUMINT, IMAGE, MASINT, MIXED, OSINT, OTHER):
 * AIS: Derived from an automated identification system source.
 * BFT: Derived from a blue force tracking source.
 * BIOMETRICS: Derived from a biometrics source.
 * COMINT: Derived from a communications intelligence source.
 * DOPPLER: Derived from a radar doppler source.
 * ELINT: Derived from an electronics intelligence source.
 * HRR: Derived from a radar high range resolution source.
 * HUMINT: Derived from a human intelligence source.
 * IMAGE: Derived from a still or motion imagery source.
 * MASINT: Derived from a measurement and signals intelligence source.
 * MIXED: Derived from a combination of two or more sources.
 * OSINT: Derived from an open source intelligence source.
 * OTHER: Derived from other types of unspecified sources.
 * Example: /// Example: MASINT
 * Constraints: Minimum length = 0, Maximum length = 32
 */
modType():string|null
modType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
modType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * UUID of the track item object, applies to STANAG-4676 messages.
 * Example: /// Example: trkItmId
 * Constraints: Minimum length = 0, Maximum length = 36
 */
trkItmId():string|null
trkItmId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
trkItmId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Track timestamp in ISO8601 UTC format.
 * Example: /// Example: 2021-06-07T14:17:39.653Z
 * Constraints: No constraints specified.
 */
ts():string|null
ts(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ts(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Value indicating track quality (not standardized).
 * Example: /// Example: 0
 * Constraints: No constraints specified.
 */
trkQual():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Means by which the track data was created (e.g., MEASURED, AUTOMATIC PREDICTED, etc.).
 * Example: /// Example: MEASURED
 * Constraints: No constraints specified.
 */
trkPtType():string|null
trkPtType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
trkPtType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
 * ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
 * FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
 * HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
 * NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
 * PENDING: Track object which has not been evaluated.
 * SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
 * UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
 * Example: /// Example: FRIEND
 * Constraints: Minimum length = 0, Maximum length = 32
 */
objIdent():string|null
objIdent(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
objIdent(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Track object identity credibility.
 * Example: /// Example: 0
 * Constraints: No constraints specified.
 */
identCred():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Track object identity reliability.
 * Example: /// Example: 0
 * Constraints: No constraints specified.
 */
identRel():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
 * FAKER: Friendly track, object, or entity acting as an exercise hostile.
 * JOKER: Friendly track, object, or entity acting as an exercise suspect.
 * KILO: Friendly high-value object.
 * TRAVELLER: Suspect land or surface track following a recognized traffic route.
 * ZOMBIE: Suspect track, object, or entity of special interest.
 * Example: /// Example: ZOMBIE
 * Constraints: Minimum length = 0, Maximum length = 32
 */
identAmp():string|null
identAmp(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
identAmp(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
 * AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
 * LAND: On the surface of dry land.
 * SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
 * SURFACE: On the surface of a body of water.
 * SUBSURFACE: Below the surface of a body of water.
 * UNKNOWN: Environment is not known.
 * Example: /// Example: LAND
 * Constraints: Minimum length = 0, Maximum length = 16
 */
env():string|null
env(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
env(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Track environment confidence estimate (not standardized).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
envConf():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
trkConf():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Track object location in ECEF [x, y, z], meters.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
ecefPos(index: number):string
ecefPos(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ecefPos(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

ecefPosLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Track object velocity in ECEF [x', y', z'], meters/sec.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
ecefVel(index: number):string
ecefVel(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ecefVel(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

ecefVelLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Track object acceleration in ECEF [x'', y'', z''], meters/sec^2.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
ecefAcc(index: number):string
ecefAcc(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ecefAcc(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

ecefAccLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
lat():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
lon():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
alt():number {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Track object spd, in meters/sec.
 * Example: /// Example: 1.23
 * Constraints: No constraints specified.
 */
spd():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The track object heading, in degrees clockwise from true North at the object location.
 * Example: /// Example: 19.7
 * Constraints: No constraints specified.
 */
hdng():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
 * Example: /// Example: 88.37
 * Constraints: No constraints specified.
 */
course():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Origin of a local coordinate system [lat, lon, altitude].  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
lco(index: number):string
lco(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
lco(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

lcoLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * x, y, and z-axis rotations about ECEF that define a local cartesian system.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
lcs(index: number):string
lcs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
lcs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

lcsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Estimate of the position, [x, y, z], of the track object in the defined cartesian system, in meters.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
lcPos(index: number):string
lcPos(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
lcPos(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

lcPosLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Estimate of the velocity, [x', y', z'], of the track object in the defined cartesian system, in meters/sec.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
lcVel(index: number):string
lcVel(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
lcVel(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

lcVelLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Estimate of the acceleration, [x'', y'', z''], of the track object in the defined cartesian system, in meters/sec^2.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
lcAcc(index: number):string
lcAcc(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
lcAcc(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

lcAccLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * East, North, Up velocity components, in meters/sec.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
eNuvel(index: number):string
eNuvel(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
eNuvel(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

eNuvelLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * East, North, Up position components, in meters.  When provided, array must always contain 3 values.
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
eNupos(index: number):string
eNupos(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
eNupos(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

eNuposLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Covariance matrix, in meter and second based units, for the defined cartesian system.
 * The array values represent the lower triangular half of the position-velocity covariance matrix.  The size of the covariance matrix is dynamic.  The values are output as an array of values corresponding to the position-velocity covariance element positions, ordered as follows:
 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
 * x&nbsp;&nbsp;&nbsp;&nbsp;1
 * y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
 * z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
 * x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
 * y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
 * z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
 * The covariance matrix will be as large as the last element needed, and with unused values zero-filled to maintain proper element positioning in the array.  For example, for a 2D (x, y) position-only covariance, the covariance matrix will be 2x2 and the array would contain the 3 elements corresponding to the x, and y position.  Another example, now for a 2D (x, y) position-velocity covariance, the covariance matrix will be 5x5 and the array would contain the 15 elements corresponding to the relevant x, y, x', and y' values (with the z-row and z-column being all zeros). The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
 * Example: /// Example: [1.1, 2.2, 3.3]
 * Constraints: No constraints specified.
 */
cov(index: number):string
cov(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
cov(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

covLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Uncertainty ellipsoid [semi-major axis (m), semi-minor axis (m), orientation (deg)].
 * Example: /// Example: [1.23, 2.34, 3.45]
 * Constraints: No constraints specified.
 */
errEllp(index: number):string
errEllp(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
errEllp(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

errEllpLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of UDL record types (POI, MTI, TRACK, GROUNDIMAGE) that contributed to the generation of this fused track.  See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array, used in the track fusion. The 'srcTyps' and 'srcIds' arrays must match in size.
 * Example: /// Example: ['MTI', 'POI']
 * Constraints: No constraints specified.
 */
srcTyps(index: number):string
srcTyps(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
srcTyps(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

srcTypsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of UUIDs of the UDL data records that contributed to the generation of this fused track. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array, used in the track fusion.  The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/poi/{uuid}).
 * Example: /// Example: ['f7c70cc8-f9b7-4467-b4ad-3904e360e842', '1da3fab000014e3133709830937387405']
 * Constraints: No constraints specified.
 */
srcIds(index: number):string
srcIds(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
srcIds(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

srcIdsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The call sign currently assigned to this track object.
 * Example: /// Example: callSign
 * Constraints: Minimum length = 0, Maximum length = 24
 */
callSign():string|null
callSign(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
callSign(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Flag indicating that this track is fused from multiple sensor sources.
 * Example: /// Example: True
 * Constraints: No constraints specified.
 */
multiSource():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The J-series message type, if this track is derived from a J-series message.
 * Example: /// Example: J12.5
 * Constraints: Minimum length = 0, Maximum length = 5
 */
jSeries():string|null
jSeries(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
jSeries(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The number of objects or units moving as a group and represented as a single entity in this track message. If null, the track is assumed to represent a single object. Note that if this track derives from a J-series message then special definitions apply for the following values: 13 indicates an estimated 2-7 units, 14 indicates an estimated more than 7 units, and 15 indicates an estimated more than 12 units.
 * Example: /// Example: 14
 * Constraints: No constraints specified.
 */
strength():number {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Mode-1 interrogation response (mission code), indicating mission or aircraft type.
 * Example: /// Example: 1234
 * Constraints: No constraints specified.
 */
m1():number {
  const offset = this.bb!.__offset(this.bb_pos, 116);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Mode-1 validity status.
 * Example: /// Example: 1
 * Constraints: No constraints specified.
 */
m1v():number {
  const offset = this.bb!.__offset(this.bb_pos, 118);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Mode-2 interrogation response (military identification code).
 * Example: /// Example: 1234
 * Constraints: No constraints specified.
 */
m2():number {
  const offset = this.bb!.__offset(this.bb_pos, 120);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Mode-2 validity status.
 * Example: /// Example: 1
 * Constraints: No constraints specified.
 */
m2v():number {
  const offset = this.bb!.__offset(this.bb_pos, 122);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Mode-3/A interrogation response (aircraft identification), provides a 4-digit octal identification code for the aircraft, assigned by the air traffic controller. Mode-3/A is shared military/civilian use.
 * Example: /// Example: 2636
 * Constraints: No constraints specified.
 */
m3a():number {
  const offset = this.bb!.__offset(this.bb_pos, 124);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Mode-3/A validity status.
 * Example: /// Example: 1
 * Constraints: No constraints specified.
 */
m3av():number {
  const offset = this.bb!.__offset(this.bb_pos, 126);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
 * Example: /// Example: ['TAG1', 'TAG2']
 * Constraints: No constraints specified.
 */
tags(index: number):string
tags(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
tags(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

tagsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
 * Example: /// Example: AXE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
sourceDl():string|null
sourceDl(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
sourceDl(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 130);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 64
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 132);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 * Example: /// Example: THIRD_PARTY_DATASOURCE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 134);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():Track_Ingest_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 136);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : Track_Ingest_dataMode_Enum.REAL;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 138);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startTrack_Ingest(builder:flatbuffers.Builder) {
  builder.startObject(68);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationMarkingOffset, 0);
}

static addCntct(builder:flatbuffers.Builder, cntctOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, cntctOffset, 0);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, createdByOffset, 0);
}

static addMsgTs(builder:flatbuffers.Builder, msgTsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, msgTsOffset, 0);
}

static addMsnId(builder:flatbuffers.Builder, msnIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, msnIdOffset, 0);
}

static addAssetNat(builder:flatbuffers.Builder, assetNatOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, assetNatOffset, 0);
}

static addAsset(builder:flatbuffers.Builder, assetOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, assetOffset, 0);
}

static addSen(builder:flatbuffers.Builder, senOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, senOffset, 0);
}

static addSenQual(builder:flatbuffers.Builder, senQualOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, senQualOffset, 0);
}

static addTrkId(builder:flatbuffers.Builder, trkIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, trkIdOffset, 0);
}

static addTrkNum(builder:flatbuffers.Builder, trkNumOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, trkNumOffset, 0);
}

static addTrkStat(builder:flatbuffers.Builder, trkStatOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, trkStatOffset, 0);
}

static addObjNat(builder:flatbuffers.Builder, objNatOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, objNatOffset, 0);
}

static addObjId(builder:flatbuffers.Builder, objIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, objIdOffset, 0);
}

static addObjType(builder:flatbuffers.Builder, objTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, objTypeOffset, 0);
}

static addObjSpec(builder:flatbuffers.Builder, objSpecOffset:flatbuffers.Offset) {
  builder.addFieldOffset(17, objSpecOffset, 0);
}

static addObjPlat(builder:flatbuffers.Builder, objPlatOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, objPlatOffset, 0);
}

static addObjAct(builder:flatbuffers.Builder, objActOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, objActOffset, 0);
}

static addModType(builder:flatbuffers.Builder, modTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, modTypeOffset, 0);
}

static addTrkItmId(builder:flatbuffers.Builder, trkItmIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, trkItmIdOffset, 0);
}

static addTs(builder:flatbuffers.Builder, tsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(22, tsOffset, 0);
}

static addTrkQual(builder:flatbuffers.Builder, trkQual:number) {
  builder.addFieldInt32(23, trkQual, 0);
}

static addTrkPtType(builder:flatbuffers.Builder, trkPtTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(24, trkPtTypeOffset, 0);
}

static addObjIdent(builder:flatbuffers.Builder, objIdentOffset:flatbuffers.Offset) {
  builder.addFieldOffset(25, objIdentOffset, 0);
}

static addIdentCred(builder:flatbuffers.Builder, identCred:number) {
  builder.addFieldInt32(26, identCred, 0);
}

static addIdentRel(builder:flatbuffers.Builder, identRel:number) {
  builder.addFieldInt32(27, identRel, 0);
}

static addIdentAmp(builder:flatbuffers.Builder, identAmpOffset:flatbuffers.Offset) {
  builder.addFieldOffset(28, identAmpOffset, 0);
}

static addEnv(builder:flatbuffers.Builder, envOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, envOffset, 0);
}

static addEnvConf(builder:flatbuffers.Builder, envConf:number) {
  builder.addFieldFloat64(30, envConf, 0.0);
}

static addTrkConf(builder:flatbuffers.Builder, trkConf:number) {
  builder.addFieldFloat64(31, trkConf, 0.0);
}

static addEcefPos(builder:flatbuffers.Builder, ecefPosOffset:flatbuffers.Offset) {
  builder.addFieldOffset(32, ecefPosOffset, 0);
}

static createEcefPosVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEcefPosVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEcefVel(builder:flatbuffers.Builder, ecefVelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(33, ecefVelOffset, 0);
}

static createEcefVelVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEcefVelVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addEcefAcc(builder:flatbuffers.Builder, ecefAccOffset:flatbuffers.Offset) {
  builder.addFieldOffset(34, ecefAccOffset, 0);
}

static createEcefAccVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEcefAccVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLat(builder:flatbuffers.Builder, lat:number) {
  builder.addFieldFloat64(35, lat, 0.0);
}

static addLon(builder:flatbuffers.Builder, lon:number) {
  builder.addFieldFloat64(36, lon, 0.0);
}

static addAlt(builder:flatbuffers.Builder, alt:number) {
  builder.addFieldFloat64(37, alt, 0.0);
}

static addSpd(builder:flatbuffers.Builder, spd:number) {
  builder.addFieldFloat64(38, spd, 0.0);
}

static addHdng(builder:flatbuffers.Builder, hdng:number) {
  builder.addFieldFloat64(39, hdng, 0.0);
}

static addCourse(builder:flatbuffers.Builder, course:number) {
  builder.addFieldFloat64(40, course, 0.0);
}

static addLco(builder:flatbuffers.Builder, lcoOffset:flatbuffers.Offset) {
  builder.addFieldOffset(41, lcoOffset, 0);
}

static createLcoVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLcoVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLcs(builder:flatbuffers.Builder, lcsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(42, lcsOffset, 0);
}

static createLcsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLcsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLcPos(builder:flatbuffers.Builder, lcPosOffset:flatbuffers.Offset) {
  builder.addFieldOffset(43, lcPosOffset, 0);
}

static createLcPosVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLcPosVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLcVel(builder:flatbuffers.Builder, lcVelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(44, lcVelOffset, 0);
}

static createLcVelVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLcVelVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addLcAcc(builder:flatbuffers.Builder, lcAccOffset:flatbuffers.Offset) {
  builder.addFieldOffset(45, lcAccOffset, 0);
}

static createLcAccVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLcAccVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addENuvel(builder:flatbuffers.Builder, eNuvelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(46, eNuvelOffset, 0);
}

static createENuvelVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startENuvelVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addENupos(builder:flatbuffers.Builder, eNuposOffset:flatbuffers.Offset) {
  builder.addFieldOffset(47, eNuposOffset, 0);
}

static createENuposVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startENuposVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCov(builder:flatbuffers.Builder, covOffset:flatbuffers.Offset) {
  builder.addFieldOffset(48, covOffset, 0);
}

static createCovVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startCovVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addErrEllp(builder:flatbuffers.Builder, errEllpOffset:flatbuffers.Offset) {
  builder.addFieldOffset(49, errEllpOffset, 0);
}

static createErrEllpVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startErrEllpVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSrcTyps(builder:flatbuffers.Builder, srcTypsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(50, srcTypsOffset, 0);
}

static createSrcTypsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSrcTypsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSrcIds(builder:flatbuffers.Builder, srcIdsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(51, srcIdsOffset, 0);
}

static createSrcIdsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSrcIdsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCallSign(builder:flatbuffers.Builder, callSignOffset:flatbuffers.Offset) {
  builder.addFieldOffset(52, callSignOffset, 0);
}

static addMultiSource(builder:flatbuffers.Builder, multiSource:boolean) {
  builder.addFieldInt8(53, +multiSource, +false);
}

static addJSeries(builder:flatbuffers.Builder, jSeriesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(54, jSeriesOffset, 0);
}

static addStrength(builder:flatbuffers.Builder, strength:number) {
  builder.addFieldInt32(55, strength, 0);
}

static addM1(builder:flatbuffers.Builder, m1:number) {
  builder.addFieldInt32(56, m1, 0);
}

static addM1v(builder:flatbuffers.Builder, m1v:number) {
  builder.addFieldInt32(57, m1v, 0);
}

static addM2(builder:flatbuffers.Builder, m2:number) {
  builder.addFieldInt32(58, m2, 0);
}

static addM2v(builder:flatbuffers.Builder, m2v:number) {
  builder.addFieldInt32(59, m2v, 0);
}

static addM3a(builder:flatbuffers.Builder, m3a:number) {
  builder.addFieldInt32(60, m3a, 0);
}

static addM3av(builder:flatbuffers.Builder, m3av:number) {
  builder.addFieldInt32(61, m3av, 0);
}

static addTags(builder:flatbuffers.Builder, tagsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(62, tagsOffset, 0);
}

static createTagsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTagsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSourceDl(builder:flatbuffers.Builder, sourceDlOffset:flatbuffers.Offset) {
  builder.addFieldOffset(63, sourceDlOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(64, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(65, originOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:Track_Ingest_dataMode_Enum) {
  builder.addFieldInt8(66, dataMode, Track_Ingest_dataMode_Enum.REAL);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(67, origNetworkOffset, 0);
}

static endTrack_Ingest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishTrack_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'TRAC');
}

static finishSizePrefixedTrack_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'TRAC', true);
}

static createTrack_Ingest(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, cntctOffset:flatbuffers.Offset, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, msgTsOffset:flatbuffers.Offset, msnIdOffset:flatbuffers.Offset, assetNatOffset:flatbuffers.Offset, assetOffset:flatbuffers.Offset, senOffset:flatbuffers.Offset, senQualOffset:flatbuffers.Offset, trkIdOffset:flatbuffers.Offset, trkNumOffset:flatbuffers.Offset, trkStatOffset:flatbuffers.Offset, objNatOffset:flatbuffers.Offset, objIdOffset:flatbuffers.Offset, objTypeOffset:flatbuffers.Offset, objSpecOffset:flatbuffers.Offset, objPlatOffset:flatbuffers.Offset, objActOffset:flatbuffers.Offset, modTypeOffset:flatbuffers.Offset, trkItmIdOffset:flatbuffers.Offset, tsOffset:flatbuffers.Offset, trkQual:number, trkPtTypeOffset:flatbuffers.Offset, objIdentOffset:flatbuffers.Offset, identCred:number, identRel:number, identAmpOffset:flatbuffers.Offset, envOffset:flatbuffers.Offset, envConf:number, trkConf:number, ecefPosOffset:flatbuffers.Offset, ecefVelOffset:flatbuffers.Offset, ecefAccOffset:flatbuffers.Offset, lat:number, lon:number, alt:number, spd:number, hdng:number, course:number, lcoOffset:flatbuffers.Offset, lcsOffset:flatbuffers.Offset, lcPosOffset:flatbuffers.Offset, lcVelOffset:flatbuffers.Offset, lcAccOffset:flatbuffers.Offset, eNuvelOffset:flatbuffers.Offset, eNuposOffset:flatbuffers.Offset, covOffset:flatbuffers.Offset, errEllpOffset:flatbuffers.Offset, srcTypsOffset:flatbuffers.Offset, srcIdsOffset:flatbuffers.Offset, callSignOffset:flatbuffers.Offset, multiSource:boolean, jSeriesOffset:flatbuffers.Offset, strength:number, m1:number, m1v:number, m2:number, m2v:number, m3a:number, m3av:number, tagsOffset:flatbuffers.Offset, sourceDlOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, dataMode:Track_Ingest_dataMode_Enum, origNetworkOffset:flatbuffers.Offset):flatbuffers.Offset {
  Track_Ingest.startTrack_Ingest(builder);
  Track_Ingest.addId(builder, idOffset);
  Track_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
  Track_Ingest.addCntct(builder, cntctOffset);
  Track_Ingest.addCreatedAt(builder, createdAtOffset);
  Track_Ingest.addCreatedBy(builder, createdByOffset);
  Track_Ingest.addMsgTs(builder, msgTsOffset);
  Track_Ingest.addMsnId(builder, msnIdOffset);
  Track_Ingest.addAssetNat(builder, assetNatOffset);
  Track_Ingest.addAsset(builder, assetOffset);
  Track_Ingest.addSen(builder, senOffset);
  Track_Ingest.addSenQual(builder, senQualOffset);
  Track_Ingest.addTrkId(builder, trkIdOffset);
  Track_Ingest.addTrkNum(builder, trkNumOffset);
  Track_Ingest.addTrkStat(builder, trkStatOffset);
  Track_Ingest.addObjNat(builder, objNatOffset);
  Track_Ingest.addObjId(builder, objIdOffset);
  Track_Ingest.addObjType(builder, objTypeOffset);
  Track_Ingest.addObjSpec(builder, objSpecOffset);
  Track_Ingest.addObjPlat(builder, objPlatOffset);
  Track_Ingest.addObjAct(builder, objActOffset);
  Track_Ingest.addModType(builder, modTypeOffset);
  Track_Ingest.addTrkItmId(builder, trkItmIdOffset);
  Track_Ingest.addTs(builder, tsOffset);
  Track_Ingest.addTrkQual(builder, trkQual);
  Track_Ingest.addTrkPtType(builder, trkPtTypeOffset);
  Track_Ingest.addObjIdent(builder, objIdentOffset);
  Track_Ingest.addIdentCred(builder, identCred);
  Track_Ingest.addIdentRel(builder, identRel);
  Track_Ingest.addIdentAmp(builder, identAmpOffset);
  Track_Ingest.addEnv(builder, envOffset);
  Track_Ingest.addEnvConf(builder, envConf);
  Track_Ingest.addTrkConf(builder, trkConf);
  Track_Ingest.addEcefPos(builder, ecefPosOffset);
  Track_Ingest.addEcefVel(builder, ecefVelOffset);
  Track_Ingest.addEcefAcc(builder, ecefAccOffset);
  Track_Ingest.addLat(builder, lat);
  Track_Ingest.addLon(builder, lon);
  Track_Ingest.addAlt(builder, alt);
  Track_Ingest.addSpd(builder, spd);
  Track_Ingest.addHdng(builder, hdng);
  Track_Ingest.addCourse(builder, course);
  Track_Ingest.addLco(builder, lcoOffset);
  Track_Ingest.addLcs(builder, lcsOffset);
  Track_Ingest.addLcPos(builder, lcPosOffset);
  Track_Ingest.addLcVel(builder, lcVelOffset);
  Track_Ingest.addLcAcc(builder, lcAccOffset);
  Track_Ingest.addENuvel(builder, eNuvelOffset);
  Track_Ingest.addENupos(builder, eNuposOffset);
  Track_Ingest.addCov(builder, covOffset);
  Track_Ingest.addErrEllp(builder, errEllpOffset);
  Track_Ingest.addSrcTyps(builder, srcTypsOffset);
  Track_Ingest.addSrcIds(builder, srcIdsOffset);
  Track_Ingest.addCallSign(builder, callSignOffset);
  Track_Ingest.addMultiSource(builder, multiSource);
  Track_Ingest.addJSeries(builder, jSeriesOffset);
  Track_Ingest.addStrength(builder, strength);
  Track_Ingest.addM1(builder, m1);
  Track_Ingest.addM1v(builder, m1v);
  Track_Ingest.addM2(builder, m2);
  Track_Ingest.addM2v(builder, m2v);
  Track_Ingest.addM3a(builder, m3a);
  Track_Ingest.addM3av(builder, m3av);
  Track_Ingest.addTags(builder, tagsOffset);
  Track_Ingest.addSourceDl(builder, sourceDlOffset);
  Track_Ingest.addSource(builder, sourceOffset);
  Track_Ingest.addOrigin(builder, originOffset);
  Track_Ingest.addDataMode(builder, dataMode);
  Track_Ingest.addOrigNetwork(builder, origNetworkOffset);
  return Track_Ingest.endTrack_Ingest(builder);
}

unpack(): Track_IngestT {
  return new Track_IngestT(
    this.id(),
    this.classificationMarking(),
    this.cntct(),
    this.createdAt(),
    this.createdBy(),
    this.msgTs(),
    this.msnId(),
    this.assetNat(),
    this.asset(),
    this.sen(),
    this.senQual(),
    this.trkId(),
    this.trkNum(),
    this.trkStat(),
    this.objNat(),
    this.objId(),
    this.objType(),
    this.objSpec(),
    this.objPlat(),
    this.objAct(),
    this.modType(),
    this.trkItmId(),
    this.ts(),
    this.trkQual(),
    this.trkPtType(),
    this.objIdent(),
    this.identCred(),
    this.identRel(),
    this.identAmp(),
    this.env(),
    this.envConf(),
    this.trkConf(),
    this.bb!.createScalarList<string>(this.ecefPos.bind(this), this.ecefPos_Length()),
    this.bb!.createScalarList<string>(this.ecefVel.bind(this), this.ecefVel_Length()),
    this.bb!.createScalarList<string>(this.ecefAcc.bind(this), this.ecefAcc_Length()),
    this.lat(),
    this.lon(),
    this.alt(),
    this.spd(),
    this.hdng(),
    this.course(),
    this.bb!.createScalarList<string>(this.lco.bind(this), this.lco_Length()),
    this.bb!.createScalarList<string>(this.lcs.bind(this), this.lcs_Length()),
    this.bb!.createScalarList<string>(this.lcPos.bind(this), this.lcPos_Length()),
    this.bb!.createScalarList<string>(this.lcVel.bind(this), this.lcVel_Length()),
    this.bb!.createScalarList<string>(this.lcAcc.bind(this), this.lcAcc_Length()),
    this.bb!.createScalarList<string>(this.eNuvel.bind(this), this.eNUVel_Length()),
    this.bb!.createScalarList<string>(this.eNupos.bind(this), this.eNUPos_Length()),
    this.bb!.createScalarList<string>(this.cov.bind(this), this.cov_Length()),
    this.bb!.createScalarList<string>(this.errEllp.bind(this), this.errEllp_Length()),
    this.bb!.createScalarList<string>(this.srcTyps.bind(this), this.srcTyps_Length()),
    this.bb!.createScalarList<string>(this.srcIds.bind(this), this.srcIds_Length()),
    this.callSign(),
    this.multiSource(),
    this.jSeries(),
    this.strength(),
    this.m1(),
    this.m1v(),
    this.m2(),
    this.m2v(),
    this.m3a(),
    this.m3av(),
    this.bb!.createScalarList<string>(this.tags.bind(this), this.tags_Length()),
    this.sourceDl(),
    this.source(),
    this.origin(),
    this.dataMode(),
    this.origNetwork()
  );
}


unpackTo(_o: Track_IngestT): void {
  _o.id = this.id();
  _o.classificationMarking = this.classificationMarking();
  _o.cntct = this.cntct();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.msgTs = this.msgTs();
  _o.msnId = this.msnId();
  _o.assetNat = this.assetNat();
  _o.asset = this.asset();
  _o.sen = this.sen();
  _o.senQual = this.senQual();
  _o.trkId = this.trkId();
  _o.trkNum = this.trkNum();
  _o.trkStat = this.trkStat();
  _o.objNat = this.objNat();
  _o.objId = this.objId();
  _o.objType = this.objType();
  _o.objSpec = this.objSpec();
  _o.objPlat = this.objPlat();
  _o.objAct = this.objAct();
  _o.modType = this.modType();
  _o.trkItmId = this.trkItmId();
  _o.ts = this.ts();
  _o.trkQual = this.trkQual();
  _o.trkPtType = this.trkPtType();
  _o.objIdent = this.objIdent();
  _o.identCred = this.identCred();
  _o.identRel = this.identRel();
  _o.identAmp = this.identAmp();
  _o.env = this.env();
  _o.envConf = this.envConf();
  _o.trkConf = this.trkConf();
  _o.ecefPos = this.bb!.createScalarList<string>(this.ecefPos.bind(this), this.ecefPos_Length());
  _o.ecefVel = this.bb!.createScalarList<string>(this.ecefVel.bind(this), this.ecefVel_Length());
  _o.ecefAcc = this.bb!.createScalarList<string>(this.ecefAcc.bind(this), this.ecefAcc_Length());
  _o.lat = this.lat();
  _o.lon = this.lon();
  _o.alt = this.alt();
  _o.spd = this.spd();
  _o.hdng = this.hdng();
  _o.course = this.course();
  _o.lco = this.bb!.createScalarList<string>(this.lco.bind(this), this.lco_Length());
  _o.lcs = this.bb!.createScalarList<string>(this.lcs.bind(this), this.lcs_Length());
  _o.lcPos = this.bb!.createScalarList<string>(this.lcPos.bind(this), this.lcPos_Length());
  _o.lcVel = this.bb!.createScalarList<string>(this.lcVel.bind(this), this.lcVel_Length());
  _o.lcAcc = this.bb!.createScalarList<string>(this.lcAcc.bind(this), this.lcAcc_Length());
  _o.eNUVel = this.bb!.createScalarList<string>(this.eNuvel.bind(this), this.eNUVel_Length());
  _o.eNUPos = this.bb!.createScalarList<string>(this.eNupos.bind(this), this.eNUPos_Length());
  _o.cov = this.bb!.createScalarList<string>(this.cov.bind(this), this.cov_Length());
  _o.errEllp = this.bb!.createScalarList<string>(this.errEllp.bind(this), this.errEllp_Length());
  _o.srcTyps = this.bb!.createScalarList<string>(this.srcTyps.bind(this), this.srcTyps_Length());
  _o.srcIds = this.bb!.createScalarList<string>(this.srcIds.bind(this), this.srcIds_Length());
  _o.callSign = this.callSign();
  _o.multiSource = this.multiSource();
  _o.jSeries = this.jSeries();
  _o.strength = this.strength();
  _o.m1 = this.m1();
  _o.m1v = this.m1v();
  _o.m2 = this.m2();
  _o.m2v = this.m2v();
  _o.m3a = this.m3a();
  _o.m3av = this.m3av();
  _o.tags = this.bb!.createScalarList<string>(this.tags.bind(this), this.tags_Length());
  _o.sourceDL = this.sourceDl();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.dataMode = this.dataMode();
  _o.origNetwork = this.origNetwork();
}
}

export class Track_IngestT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public cntct: string|Uint8Array|null = null,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public msgTs: string|Uint8Array|null = null,
  public msnId: string|Uint8Array|null = null,
  public assetNat: string|Uint8Array|null = null,
  public asset: string|Uint8Array|null = null,
  public sen: string|Uint8Array|null = null,
  public senQual: string|Uint8Array|null = null,
  public trkId: string|Uint8Array|null = null,
  public trkNum: string|Uint8Array|null = null,
  public trkStat: string|Uint8Array|null = null,
  public objNat: string|Uint8Array|null = null,
  public objId: string|Uint8Array|null = null,
  public objType: string|Uint8Array|null = null,
  public objSpec: string|Uint8Array|null = null,
  public objPlat: string|Uint8Array|null = null,
  public objAct: string|Uint8Array|null = null,
  public modType: string|Uint8Array|null = null,
  public trkItmId: string|Uint8Array|null = null,
  public ts: string|Uint8Array|null = null,
  public trkQual: number = 0,
  public trkPtType: string|Uint8Array|null = null,
  public objIdent: string|Uint8Array|null = null,
  public identCred: number = 0,
  public identRel: number = 0,
  public identAmp: string|Uint8Array|null = null,
  public env: string|Uint8Array|null = null,
  public envConf: number = 0.0,
  public trkConf: number = 0.0,
  public ecefPos: (string)[] = [],
  public ecefVel: (string)[] = [],
  public ecefAcc: (string)[] = [],
  public lat: number = 0.0,
  public lon: number = 0.0,
  public alt: number = 0.0,
  public spd: number = 0.0,
  public hdng: number = 0.0,
  public course: number = 0.0,
  public lco: (string)[] = [],
  public lcs: (string)[] = [],
  public lcPos: (string)[] = [],
  public lcVel: (string)[] = [],
  public lcAcc: (string)[] = [],
  public eNUVel: (string)[] = [],
  public eNUPos: (string)[] = [],
  public cov: (string)[] = [],
  public errEllp: (string)[] = [],
  public srcTyps: (string)[] = [],
  public srcIds: (string)[] = [],
  public callSign: string|Uint8Array|null = null,
  public multiSource: boolean = false,
  public jSeries: string|Uint8Array|null = null,
  public strength: number = 0,
  public m1: number = 0,
  public m1v: number = 0,
  public m2: number = 0,
  public m2v: number = 0,
  public m3a: number = 0,
  public m3av: number = 0,
  public tags: (string)[] = [],
  public sourceDL: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public dataMode: Track_Ingest_dataMode_Enum = Track_Ingest_dataMode_Enum.REAL,
  public origNetwork: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const cntct = (this.cntct !== null ? builder.createString(this.cntct!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const msgTs = (this.msgTs !== null ? builder.createString(this.msgTs!) : 0);
  const msnId = (this.msnId !== null ? builder.createString(this.msnId!) : 0);
  const assetNat = (this.assetNat !== null ? builder.createString(this.assetNat!) : 0);
  const asset = (this.asset !== null ? builder.createString(this.asset!) : 0);
  const sen = (this.sen !== null ? builder.createString(this.sen!) : 0);
  const senQual = (this.senQual !== null ? builder.createString(this.senQual!) : 0);
  const trkId = (this.trkId !== null ? builder.createString(this.trkId!) : 0);
  const trkNum = (this.trkNum !== null ? builder.createString(this.trkNum!) : 0);
  const trkStat = (this.trkStat !== null ? builder.createString(this.trkStat!) : 0);
  const objNat = (this.objNat !== null ? builder.createString(this.objNat!) : 0);
  const objId = (this.objId !== null ? builder.createString(this.objId!) : 0);
  const objType = (this.objType !== null ? builder.createString(this.objType!) : 0);
  const objSpec = (this.objSpec !== null ? builder.createString(this.objSpec!) : 0);
  const objPlat = (this.objPlat !== null ? builder.createString(this.objPlat!) : 0);
  const objAct = (this.objAct !== null ? builder.createString(this.objAct!) : 0);
  const modType = (this.modType !== null ? builder.createString(this.modType!) : 0);
  const trkItmId = (this.trkItmId !== null ? builder.createString(this.trkItmId!) : 0);
  const ts = (this.ts !== null ? builder.createString(this.ts!) : 0);
  const trkPtType = (this.trkPtType !== null ? builder.createString(this.trkPtType!) : 0);
  const objIdent = (this.objIdent !== null ? builder.createString(this.objIdent!) : 0);
  const identAmp = (this.identAmp !== null ? builder.createString(this.identAmp!) : 0);
  const env = (this.env !== null ? builder.createString(this.env!) : 0);
  const ecefPos = Track_Ingest.createEcefPosVector(builder, builder.createObjectOffsetList(this.ecefPos));
  const ecefVel = Track_Ingest.createEcefVelVector(builder, builder.createObjectOffsetList(this.ecefVel));
  const ecefAcc = Track_Ingest.createEcefAccVector(builder, builder.createObjectOffsetList(this.ecefAcc));
  const lco = Track_Ingest.createLcoVector(builder, builder.createObjectOffsetList(this.lco));
  const lcs = Track_Ingest.createLcsVector(builder, builder.createObjectOffsetList(this.lcs));
  const lcPos = Track_Ingest.createLcPosVector(builder, builder.createObjectOffsetList(this.lcPos));
  const lcVel = Track_Ingest.createLcVelVector(builder, builder.createObjectOffsetList(this.lcVel));
  const lcAcc = Track_Ingest.createLcAccVector(builder, builder.createObjectOffsetList(this.lcAcc));
  const eNUVel = Track_Ingest.createENuvelVector(builder, builder.createObjectOffsetList(this.eNUVel));
  const eNUPos = Track_Ingest.createENuposVector(builder, builder.createObjectOffsetList(this.eNUPos));
  const cov = Track_Ingest.createCovVector(builder, builder.createObjectOffsetList(this.cov));
  const errEllp = Track_Ingest.createErrEllpVector(builder, builder.createObjectOffsetList(this.errEllp));
  const srcTyps = Track_Ingest.createSrcTypsVector(builder, builder.createObjectOffsetList(this.srcTyps));
  const srcIds = Track_Ingest.createSrcIdsVector(builder, builder.createObjectOffsetList(this.srcIds));
  const callSign = (this.callSign !== null ? builder.createString(this.callSign!) : 0);
  const jSeries = (this.jSeries !== null ? builder.createString(this.jSeries!) : 0);
  const tags = Track_Ingest.createTagsVector(builder, builder.createObjectOffsetList(this.tags));
  const sourceDL = (this.sourceDL !== null ? builder.createString(this.sourceDL!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);

  return Track_Ingest.createTrack_Ingest(builder,
    id,
    classificationMarking,
    cntct,
    createdAt,
    createdBy,
    msgTs,
    msnId,
    assetNat,
    asset,
    sen,
    senQual,
    trkId,
    trkNum,
    trkStat,
    objNat,
    objId,
    objType,
    objSpec,
    objPlat,
    objAct,
    modType,
    trkItmId,
    ts,
    this.trkQual,
    trkPtType,
    objIdent,
    this.identCred,
    this.identRel,
    identAmp,
    env,
    this.envConf,
    this.trkConf,
    ecefPos,
    ecefVel,
    ecefAcc,
    this.lat,
    this.lon,
    this.alt,
    this.spd,
    this.hdng,
    this.course,
    lco,
    lcs,
    lcPos,
    lcVel,
    lcAcc,
    eNUVel,
    eNUPos,
    cov,
    errEllp,
    srcTyps,
    srcIds,
    callSign,
    this.multiSource,
    jSeries,
    this.strength,
    this.m1,
    this.m1v,
    this.m2,
    this.m2v,
    this.m3a,
    this.m3av,
    tags,
    sourceDL,
    source,
    origin,
    this.dataMode,
    origNetwork
  );
}
}
