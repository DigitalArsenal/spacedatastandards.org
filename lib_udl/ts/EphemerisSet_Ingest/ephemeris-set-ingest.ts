// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { EphemerisSet_Ingest_covReferenceFrame_Enum } from './ephemeris-set-ingest-cov-reference-frame-enum.js';
import { EphemerisSet_Ingest_dataMode_Enum } from './ephemeris-set-ingest-data-mode-enum.js';
import { EphemerisSet_Ingest_referenceFrame_Enum } from './ephemeris-set-ingest-reference-frame-enum.js';


/**
 * /// EphemerisSet represents a wrapper or collection of Ephemeris 'points' and meta data indicating the specifics of the propagation of an on-orbit object. Ephemeris is typically distributed in a flat file containing details of the ephemeris generation as well as a large collection of individual points at varying time steps. EphemerisSet is analogous to this flat file.
 */
export class EphemerisSet_Ingest implements flatbuffers.IUnpackableObject<EphemerisSet_IngestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):EphemerisSet_Ingest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsEphemerisSet_Ingest(bb:flatbuffers.ByteBuffer, obj?:EphemerisSet_Ingest):EphemerisSet_Ingest {
  return (obj || new EphemerisSet_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsEphemerisSet_Ingest(bb:flatbuffers.ByteBuffer, obj?:EphemerisSet_Ingest):EphemerisSet_Ingest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new EphemerisSet_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('EPHE');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: EPHEMERISSET-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the primary satellite on-orbit object.
 * Example: /// Example: ONORBIT-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idOnOrbit():string|null
idOnOrbit(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idOnOrbit(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
 * Example: /// Example: ORIGOBJECT-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
origObjectId():string|null
origObjectId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origObjectId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Start time/first time point of the ephemeris, in ISO 8601 UTC format.
 * Example: /// Example: 2018-01-01T16:00:00.123456Z
 * Constraints: No constraints specified.
 */
pointStartTime():string|null
pointStartTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
pointStartTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional start time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
 * Example: /// Example: 2018-01-01T16:10:00.123456Z
 * Constraints: No constraints specified.
 */
usableStartTime():string|null
usableStartTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
usableStartTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * End time/last time point of the ephemeris, in ISO 8601 UTC format.
 * Example: /// Example: 2018-01-01T16:00:00.123456Z
 * Constraints: No constraints specified.
 */
pointEndTime():string|null
pointEndTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
pointEndTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional end time of the usable time span for the ephemeris data, in ISO 8601 UTC format with microsecond precision.
 * Example: /// Example: 2018-01-01T20:50:00.123456Z
 * Constraints: No constraints specified.
 */
usableEndTime():string|null
usableEndTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
usableEndTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Ephemeris step size, in seconds.
 * Example: /// Example: 1
 * Constraints: No constraints specified.
 */
stepSize():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Number of points contained in the ephemeris.
 * Example: /// Example: 1
 * Constraints: No constraints specified.
 */
numPoints():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The type/purpose of the ephemeris (e.g., CALIBRATION, LAUNCH, MNVR_PLAN, ROUTINE, SCREENING).
 * Example: /// Example: LAUNCH
 * Constraints: Minimum length = 1, Maximum length = 24
 */
type():string|null
type(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
type(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The pedigree of the ephemeris or source data used for ephemeris generation (e.g.  GPS, SLR, RANGING, PROPAGATED, HYBRID).
 * Example: /// Example: PROPAGATED
 * Constraints: Minimum length = 0, Maximum length = 24
 */
pedigree():string|null
pedigree(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
pedigree(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The source category of the ephemeris (e.g. OWNER_OPERATOR, ANALYST, EXTERNAL).
 * Example: /// Example: ANALYST
 * Constraints: Minimum length = 1, Maximum length = 24
 */
category():string|null
category(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
category(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the State Vector used to generate the ephemeris.
 * Example: /// Example: STATEVECTOR-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idStateVector():string|null
idStateVector(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idStateVector(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Boolean indicating whether maneuver(s) are incorporated into the ephemeris.
 * Example: /// Example: False
 * Constraints: No constraints specified.
 */
hasMnvr():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Array of the maneuver IDs of all maneuvers incorporated in the ephemeris.
 * Example: /// Example: ['EXAMPLE_ID1', 'EXAMPLE_ID2']
 * Constraints: No constraints specified.
 */
idManeuvers(index: number):string
idManeuvers(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
idManeuvers(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

idManeuversLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Boolean indicating whether covariance data is provided with the ephemeris.
 * Example: /// Example: False
 * Constraints: No constraints specified.
 */
hasCov():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Boolean indicating whether acceleration data is provided with the ephemeris.
 * Example: /// Example: False
 * Constraints: No constraints specified.
 */
hasAccel():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The Central Body of the ephemeris.  Assumed to be Earth, unless otherwise indicated.
 * Example: /// Example: Earth
 * Constraints: Minimum length = 0, Maximum length = 32
 */
centBody():string|null
centBody(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
centBody(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Integrator used in ephemeris generation (e.g. RK7(8), RK8(9), COWELL, TWO-BODY).
 * Example: /// Example: COWELL
 * Constraints: Minimum length = 0, Maximum length = 24
 */
integrator():string|null
integrator(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
integrator(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Geopotential model used in ephemeris generation (e.g. EGM-96, WGS-84, WGS-72, JGM-2, GEM-T3), including mm degree zonals, nn degree/order tesserals (e.g. EGM-96 24Z,24T).
 * Example: /// Example: GEM-T3
 * Constraints: Minimum length = 0, Maximum length = 32
 */
geopotentialModel():string|null
geopotentialModel(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
geopotentialModel(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Drag model used in ephemeris generation (e.g. JAC70, MSIS90, NONE, etc.).
 * Example: /// Example: JAC70
 * Constraints: Minimum length = 0, Maximum length = 32
 */
dragModel():string|null
dragModel(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
dragModel(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Boolean indicating use of lunar/solar data in ephemeris generation.
 * Example: /// Example: False
 * Constraints: No constraints specified.
 */
lunarSolar():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * Boolean indicating use of solid earth tide data in ephemeris generation.
 * Example: /// Example: False
 * Constraints: No constraints specified.
 */
solidEarthTides():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * First derivative of ballistic coefficient (m^2/kg-s).
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
bDot():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Model parameter value for energy dissipation rate (EDR), expressed in w/kg.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
edr():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The recommended interpolation method for the ephemeris data.
 * Example: /// Example: LINEAR
 * Constraints: Minimum length = 0, Maximum length = 16
 */
interpolation():string|null
interpolation(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
interpolation(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The recommended interpolation degree for the ephemeris data.
 * Example: /// Example: 5
 * Constraints: No constraints specified.
 */
interpolationDegree():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Filename of the raw file used to provide the ephemeris data including filetype extension, if applicable. This file may be retrieved using the 'getFile' operation as specified in the 'EphemerisSet' OpenAPI docs.
 * Example: /// Example: Example file name
 * Constraints: Minimum length = 0, Maximum length = 128
 */
filename():string|null
filename(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
filename(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Additional source provided comments associated with the ephemeris.
 * Example: /// Example: Example notes
 * Constraints: Minimum length = 0, Maximum length = 512
 */
comments():string|null
comments(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
comments(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Notes/description of the provided ephemeris. A value of DSTOP signifies the ephemeris were generated using the last observation available.
 * Example: /// Example: Example notes
 * Constraints: Minimum length = 0, Maximum length = 512
 */
description():string|null
description(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
description(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional source-provided and searchable metadata or descriptor of the data.
 * Example: /// Example: Example descriptor
 * Constraints: Minimum length = 0, Maximum length = 64
 */
descriptor():string|null
descriptor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
descriptor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
 * Example: /// Example: J2000
 * Constraints: Minimum length = 0, Maximum length = 24
 */
referenceFrame():EphemerisSet_Ingest_referenceFrame_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : EphemerisSet_Ingest_referenceFrame_Enum.J2000;
}

/**
 * The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
 * Example: /// Example: J2000
 * Constraints: Minimum length = 0, Maximum length = 24
 */
covReferenceFrame():EphemerisSet_Ingest_covReferenceFrame_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : EphemerisSet_Ingest_covReferenceFrame_Enum.J2000;
}

/**
 * Time the row was created in the database, in UTC.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 64
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 * Example: /// Example: THIRD_PARTY_DATASOURCE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():EphemerisSet_Ingest_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : EphemerisSet_Ingest_dataMode_Enum.REAL;
}

/**
 * Satellite/catalog number of the target on-orbit object.
 * Example: /// Example: 2
 * Constraints: No constraints specified.
 */
satNo():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The list of ephemeris states belonging to the EphemerisSet. Each ephemeris point is associated with a parent Ephemeris Set via the EphemerisSet ID (esId).
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
ephemerisList(index: number):string
ephemerisList(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ephemerisList(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

ephemerisListLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
 * Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
 * Constraints: No constraints specified.
 */
tags(index: number):string
tags(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
tags(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

tagsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Optional identifier to track a commercial or marketplace transaction executed to produce this data.
 * Example: /// Example: TRANSACTION-ID
 * Constraints: Minimum length = 0, Maximum length = 64
 */
transactionId():string|null
transactionId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
transactionId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startEphemerisSet_Ingest(builder:flatbuffers.Builder) {
  builder.startObject(44);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationMarkingOffset, 0);
}

static addIdOnOrbit(builder:flatbuffers.Builder, idOnOrbitOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, idOnOrbitOffset, 0);
}

static addOrigObjectId(builder:flatbuffers.Builder, origObjectIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, origObjectIdOffset, 0);
}

static addPointStartTime(builder:flatbuffers.Builder, pointStartTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, pointStartTimeOffset, 0);
}

static addUsableStartTime(builder:flatbuffers.Builder, usableStartTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, usableStartTimeOffset, 0);
}

static addPointEndTime(builder:flatbuffers.Builder, pointEndTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, pointEndTimeOffset, 0);
}

static addUsableEndTime(builder:flatbuffers.Builder, usableEndTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, usableEndTimeOffset, 0);
}

static addStepSize(builder:flatbuffers.Builder, stepSize:number) {
  builder.addFieldInt32(8, stepSize, 0);
}

static addNumPoints(builder:flatbuffers.Builder, numPoints:number) {
  builder.addFieldInt32(9, numPoints, 0);
}

static addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, typeOffset, 0);
}

static addPedigree(builder:flatbuffers.Builder, pedigreeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, pedigreeOffset, 0);
}

static addCategory(builder:flatbuffers.Builder, categoryOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, categoryOffset, 0);
}

static addIdStateVector(builder:flatbuffers.Builder, idStateVectorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, idStateVectorOffset, 0);
}

static addHasMnvr(builder:flatbuffers.Builder, hasMnvr:boolean) {
  builder.addFieldInt8(14, +hasMnvr, +false);
}

static addIdManeuvers(builder:flatbuffers.Builder, idManeuversOffset:flatbuffers.Offset) {
  builder.addFieldOffset(15, idManeuversOffset, 0);
}

static createIdManeuversVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startIdManeuversVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addHasCov(builder:flatbuffers.Builder, hasCov:boolean) {
  builder.addFieldInt8(16, +hasCov, +false);
}

static addHasAccel(builder:flatbuffers.Builder, hasAccel:boolean) {
  builder.addFieldInt8(17, +hasAccel, +false);
}

static addCentBody(builder:flatbuffers.Builder, centBodyOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, centBodyOffset, 0);
}

static addIntegrator(builder:flatbuffers.Builder, integratorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, integratorOffset, 0);
}

static addGeopotentialModel(builder:flatbuffers.Builder, geopotentialModelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, geopotentialModelOffset, 0);
}

static addDragModel(builder:flatbuffers.Builder, dragModelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, dragModelOffset, 0);
}

static addLunarSolar(builder:flatbuffers.Builder, lunarSolar:boolean) {
  builder.addFieldInt8(22, +lunarSolar, +false);
}

static addSolidEarthTides(builder:flatbuffers.Builder, solidEarthTides:boolean) {
  builder.addFieldInt8(23, +solidEarthTides, +false);
}

static addBDot(builder:flatbuffers.Builder, bDot:number) {
  builder.addFieldFloat64(24, bDot, 0.0);
}

static addEdr(builder:flatbuffers.Builder, edr:number) {
  builder.addFieldFloat64(25, edr, 0.0);
}

static addInterpolation(builder:flatbuffers.Builder, interpolationOffset:flatbuffers.Offset) {
  builder.addFieldOffset(26, interpolationOffset, 0);
}

static addInterpolationDegree(builder:flatbuffers.Builder, interpolationDegree:number) {
  builder.addFieldInt32(27, interpolationDegree, 0);
}

static addFilename(builder:flatbuffers.Builder, filenameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(28, filenameOffset, 0);
}

static addComments(builder:flatbuffers.Builder, commentsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, commentsOffset, 0);
}

static addDescription(builder:flatbuffers.Builder, descriptionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(30, descriptionOffset, 0);
}

static addDescriptor(builder:flatbuffers.Builder, descriptorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(31, descriptorOffset, 0);
}

static addReferenceFrame(builder:flatbuffers.Builder, referenceFrame:EphemerisSet_Ingest_referenceFrame_Enum) {
  builder.addFieldInt8(32, referenceFrame, EphemerisSet_Ingest_referenceFrame_Enum.J2000);
}

static addCovReferenceFrame(builder:flatbuffers.Builder, covReferenceFrame:EphemerisSet_Ingest_covReferenceFrame_Enum) {
  builder.addFieldInt8(33, covReferenceFrame, EphemerisSet_Ingest_covReferenceFrame_Enum.J2000);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(34, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(35, createdByOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(36, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(37, originOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:EphemerisSet_Ingest_dataMode_Enum) {
  builder.addFieldInt8(38, dataMode, EphemerisSet_Ingest_dataMode_Enum.REAL);
}

static addSatNo(builder:flatbuffers.Builder, satNo:number) {
  builder.addFieldInt32(39, satNo, 0);
}

static addEphemerisList(builder:flatbuffers.Builder, ephemerisListOffset:flatbuffers.Offset) {
  builder.addFieldOffset(40, ephemerisListOffset, 0);
}

static createEphemerisListVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEphemerisListVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTags(builder:flatbuffers.Builder, tagsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(41, tagsOffset, 0);
}

static createTagsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTagsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTransactionId(builder:flatbuffers.Builder, transactionIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(42, transactionIdOffset, 0);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(43, origNetworkOffset, 0);
}

static endEphemerisSet_Ingest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishEphemerisSet_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'EPHE');
}

static finishSizePrefixedEphemerisSet_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'EPHE', true);
}

static createEphemerisSet_Ingest(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, idOnOrbitOffset:flatbuffers.Offset, origObjectIdOffset:flatbuffers.Offset, pointStartTimeOffset:flatbuffers.Offset, usableStartTimeOffset:flatbuffers.Offset, pointEndTimeOffset:flatbuffers.Offset, usableEndTimeOffset:flatbuffers.Offset, stepSize:number, numPoints:number, typeOffset:flatbuffers.Offset, pedigreeOffset:flatbuffers.Offset, categoryOffset:flatbuffers.Offset, idStateVectorOffset:flatbuffers.Offset, hasMnvr:boolean, idManeuversOffset:flatbuffers.Offset, hasCov:boolean, hasAccel:boolean, centBodyOffset:flatbuffers.Offset, integratorOffset:flatbuffers.Offset, geopotentialModelOffset:flatbuffers.Offset, dragModelOffset:flatbuffers.Offset, lunarSolar:boolean, solidEarthTides:boolean, bDot:number, edr:number, interpolationOffset:flatbuffers.Offset, interpolationDegree:number, filenameOffset:flatbuffers.Offset, commentsOffset:flatbuffers.Offset, descriptionOffset:flatbuffers.Offset, descriptorOffset:flatbuffers.Offset, referenceFrame:EphemerisSet_Ingest_referenceFrame_Enum, covReferenceFrame:EphemerisSet_Ingest_covReferenceFrame_Enum, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, dataMode:EphemerisSet_Ingest_dataMode_Enum, satNo:number, ephemerisListOffset:flatbuffers.Offset, tagsOffset:flatbuffers.Offset, transactionIdOffset:flatbuffers.Offset, origNetworkOffset:flatbuffers.Offset):flatbuffers.Offset {
  EphemerisSet_Ingest.startEphemerisSet_Ingest(builder);
  EphemerisSet_Ingest.addId(builder, idOffset);
  EphemerisSet_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
  EphemerisSet_Ingest.addIdOnOrbit(builder, idOnOrbitOffset);
  EphemerisSet_Ingest.addOrigObjectId(builder, origObjectIdOffset);
  EphemerisSet_Ingest.addPointStartTime(builder, pointStartTimeOffset);
  EphemerisSet_Ingest.addUsableStartTime(builder, usableStartTimeOffset);
  EphemerisSet_Ingest.addPointEndTime(builder, pointEndTimeOffset);
  EphemerisSet_Ingest.addUsableEndTime(builder, usableEndTimeOffset);
  EphemerisSet_Ingest.addStepSize(builder, stepSize);
  EphemerisSet_Ingest.addNumPoints(builder, numPoints);
  EphemerisSet_Ingest.addType(builder, typeOffset);
  EphemerisSet_Ingest.addPedigree(builder, pedigreeOffset);
  EphemerisSet_Ingest.addCategory(builder, categoryOffset);
  EphemerisSet_Ingest.addIdStateVector(builder, idStateVectorOffset);
  EphemerisSet_Ingest.addHasMnvr(builder, hasMnvr);
  EphemerisSet_Ingest.addIdManeuvers(builder, idManeuversOffset);
  EphemerisSet_Ingest.addHasCov(builder, hasCov);
  EphemerisSet_Ingest.addHasAccel(builder, hasAccel);
  EphemerisSet_Ingest.addCentBody(builder, centBodyOffset);
  EphemerisSet_Ingest.addIntegrator(builder, integratorOffset);
  EphemerisSet_Ingest.addGeopotentialModel(builder, geopotentialModelOffset);
  EphemerisSet_Ingest.addDragModel(builder, dragModelOffset);
  EphemerisSet_Ingest.addLunarSolar(builder, lunarSolar);
  EphemerisSet_Ingest.addSolidEarthTides(builder, solidEarthTides);
  EphemerisSet_Ingest.addBDot(builder, bDot);
  EphemerisSet_Ingest.addEdr(builder, edr);
  EphemerisSet_Ingest.addInterpolation(builder, interpolationOffset);
  EphemerisSet_Ingest.addInterpolationDegree(builder, interpolationDegree);
  EphemerisSet_Ingest.addFilename(builder, filenameOffset);
  EphemerisSet_Ingest.addComments(builder, commentsOffset);
  EphemerisSet_Ingest.addDescription(builder, descriptionOffset);
  EphemerisSet_Ingest.addDescriptor(builder, descriptorOffset);
  EphemerisSet_Ingest.addReferenceFrame(builder, referenceFrame);
  EphemerisSet_Ingest.addCovReferenceFrame(builder, covReferenceFrame);
  EphemerisSet_Ingest.addCreatedAt(builder, createdAtOffset);
  EphemerisSet_Ingest.addCreatedBy(builder, createdByOffset);
  EphemerisSet_Ingest.addSource(builder, sourceOffset);
  EphemerisSet_Ingest.addOrigin(builder, originOffset);
  EphemerisSet_Ingest.addDataMode(builder, dataMode);
  EphemerisSet_Ingest.addSatNo(builder, satNo);
  EphemerisSet_Ingest.addEphemerisList(builder, ephemerisListOffset);
  EphemerisSet_Ingest.addTags(builder, tagsOffset);
  EphemerisSet_Ingest.addTransactionId(builder, transactionIdOffset);
  EphemerisSet_Ingest.addOrigNetwork(builder, origNetworkOffset);
  return EphemerisSet_Ingest.endEphemerisSet_Ingest(builder);
}

unpack(): EphemerisSet_IngestT {
  return new EphemerisSet_IngestT(
    this.id(),
    this.classificationMarking(),
    this.idOnOrbit(),
    this.origObjectId(),
    this.pointStartTime(),
    this.usableStartTime(),
    this.pointEndTime(),
    this.usableEndTime(),
    this.stepSize(),
    this.numPoints(),
    this.type(),
    this.pedigree(),
    this.category(),
    this.idStateVector(),
    this.hasMnvr(),
    this.bb!.createScalarList<string>(this.idManeuvers.bind(this), this.idManeuvers_Length()),
    this.hasCov(),
    this.hasAccel(),
    this.centBody(),
    this.integrator(),
    this.geopotentialModel(),
    this.dragModel(),
    this.lunarSolar(),
    this.solidEarthTides(),
    this.bDot(),
    this.edr(),
    this.interpolation(),
    this.interpolationDegree(),
    this.filename(),
    this.comments(),
    this.description(),
    this.descriptor(),
    this.referenceFrame(),
    this.covReferenceFrame(),
    this.createdAt(),
    this.createdBy(),
    this.source(),
    this.origin(),
    this.dataMode(),
    this.satNo(),
    this.bb!.createScalarList<string>(this.ephemerisList.bind(this), this.ephemerisList_Length()),
    this.bb!.createScalarList<string>(this.tags.bind(this), this.tags_Length()),
    this.transactionId(),
    this.origNetwork()
  );
}


unpackTo(_o: EphemerisSet_IngestT): void {
  _o.id = this.id();
  _o.classificationMarking = this.classificationMarking();
  _o.idOnOrbit = this.idOnOrbit();
  _o.origObjectId = this.origObjectId();
  _o.pointStartTime = this.pointStartTime();
  _o.usableStartTime = this.usableStartTime();
  _o.pointEndTime = this.pointEndTime();
  _o.usableEndTime = this.usableEndTime();
  _o.stepSize = this.stepSize();
  _o.numPoints = this.numPoints();
  _o.type = this.type();
  _o.pedigree = this.pedigree();
  _o.category = this.category();
  _o.idStateVector = this.idStateVector();
  _o.hasMnvr = this.hasMnvr();
  _o.idManeuvers = this.bb!.createScalarList<string>(this.idManeuvers.bind(this), this.idManeuvers_Length());
  _o.hasCov = this.hasCov();
  _o.hasAccel = this.hasAccel();
  _o.centBody = this.centBody();
  _o.integrator = this.integrator();
  _o.geopotentialModel = this.geopotentialModel();
  _o.dragModel = this.dragModel();
  _o.lunarSolar = this.lunarSolar();
  _o.solidEarthTides = this.solidEarthTides();
  _o.bDot = this.bDot();
  _o.edr = this.edr();
  _o.interpolation = this.interpolation();
  _o.interpolationDegree = this.interpolationDegree();
  _o.filename = this.filename();
  _o.comments = this.comments();
  _o.description = this.description();
  _o.descriptor = this.descriptor();
  _o.referenceFrame = this.referenceFrame();
  _o.covReferenceFrame = this.covReferenceFrame();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.dataMode = this.dataMode();
  _o.satNo = this.satNo();
  _o.ephemerisList = this.bb!.createScalarList<string>(this.ephemerisList.bind(this), this.ephemerisList_Length());
  _o.tags = this.bb!.createScalarList<string>(this.tags.bind(this), this.tags_Length());
  _o.transactionId = this.transactionId();
  _o.origNetwork = this.origNetwork();
}
}

export class EphemerisSet_IngestT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public idOnOrbit: string|Uint8Array|null = null,
  public origObjectId: string|Uint8Array|null = null,
  public pointStartTime: string|Uint8Array|null = null,
  public usableStartTime: string|Uint8Array|null = null,
  public pointEndTime: string|Uint8Array|null = null,
  public usableEndTime: string|Uint8Array|null = null,
  public stepSize: number = 0,
  public numPoints: number = 0,
  public type: string|Uint8Array|null = null,
  public pedigree: string|Uint8Array|null = null,
  public category: string|Uint8Array|null = null,
  public idStateVector: string|Uint8Array|null = null,
  public hasMnvr: boolean = false,
  public idManeuvers: (string)[] = [],
  public hasCov: boolean = false,
  public hasAccel: boolean = false,
  public centBody: string|Uint8Array|null = null,
  public integrator: string|Uint8Array|null = null,
  public geopotentialModel: string|Uint8Array|null = null,
  public dragModel: string|Uint8Array|null = null,
  public lunarSolar: boolean = false,
  public solidEarthTides: boolean = false,
  public bDot: number = 0.0,
  public edr: number = 0.0,
  public interpolation: string|Uint8Array|null = null,
  public interpolationDegree: number = 0,
  public filename: string|Uint8Array|null = null,
  public comments: string|Uint8Array|null = null,
  public description: string|Uint8Array|null = null,
  public descriptor: string|Uint8Array|null = null,
  public referenceFrame: EphemerisSet_Ingest_referenceFrame_Enum = EphemerisSet_Ingest_referenceFrame_Enum.J2000,
  public covReferenceFrame: EphemerisSet_Ingest_covReferenceFrame_Enum = EphemerisSet_Ingest_covReferenceFrame_Enum.J2000,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public dataMode: EphemerisSet_Ingest_dataMode_Enum = EphemerisSet_Ingest_dataMode_Enum.REAL,
  public satNo: number = 0,
  public ephemerisList: (string)[] = [],
  public tags: (string)[] = [],
  public transactionId: string|Uint8Array|null = null,
  public origNetwork: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const idOnOrbit = (this.idOnOrbit !== null ? builder.createString(this.idOnOrbit!) : 0);
  const origObjectId = (this.origObjectId !== null ? builder.createString(this.origObjectId!) : 0);
  const pointStartTime = (this.pointStartTime !== null ? builder.createString(this.pointStartTime!) : 0);
  const usableStartTime = (this.usableStartTime !== null ? builder.createString(this.usableStartTime!) : 0);
  const pointEndTime = (this.pointEndTime !== null ? builder.createString(this.pointEndTime!) : 0);
  const usableEndTime = (this.usableEndTime !== null ? builder.createString(this.usableEndTime!) : 0);
  const type = (this.type !== null ? builder.createString(this.type!) : 0);
  const pedigree = (this.pedigree !== null ? builder.createString(this.pedigree!) : 0);
  const category = (this.category !== null ? builder.createString(this.category!) : 0);
  const idStateVector = (this.idStateVector !== null ? builder.createString(this.idStateVector!) : 0);
  const idManeuvers = EphemerisSet_Ingest.createIdManeuversVector(builder, builder.createObjectOffsetList(this.idManeuvers));
  const centBody = (this.centBody !== null ? builder.createString(this.centBody!) : 0);
  const integrator = (this.integrator !== null ? builder.createString(this.integrator!) : 0);
  const geopotentialModel = (this.geopotentialModel !== null ? builder.createString(this.geopotentialModel!) : 0);
  const dragModel = (this.dragModel !== null ? builder.createString(this.dragModel!) : 0);
  const interpolation = (this.interpolation !== null ? builder.createString(this.interpolation!) : 0);
  const filename = (this.filename !== null ? builder.createString(this.filename!) : 0);
  const comments = (this.comments !== null ? builder.createString(this.comments!) : 0);
  const description = (this.description !== null ? builder.createString(this.description!) : 0);
  const descriptor = (this.descriptor !== null ? builder.createString(this.descriptor!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);
  const ephemerisList = EphemerisSet_Ingest.createEphemerisListVector(builder, builder.createObjectOffsetList(this.ephemerisList));
  const tags = EphemerisSet_Ingest.createTagsVector(builder, builder.createObjectOffsetList(this.tags));
  const transactionId = (this.transactionId !== null ? builder.createString(this.transactionId!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);

  return EphemerisSet_Ingest.createEphemerisSet_Ingest(builder,
    id,
    classificationMarking,
    idOnOrbit,
    origObjectId,
    pointStartTime,
    usableStartTime,
    pointEndTime,
    usableEndTime,
    this.stepSize,
    this.numPoints,
    type,
    pedigree,
    category,
    idStateVector,
    this.hasMnvr,
    idManeuvers,
    this.hasCov,
    this.hasAccel,
    centBody,
    integrator,
    geopotentialModel,
    dragModel,
    this.lunarSolar,
    this.solidEarthTides,
    this.bDot,
    this.edr,
    interpolation,
    this.interpolationDegree,
    filename,
    comments,
    description,
    descriptor,
    this.referenceFrame,
    this.covReferenceFrame,
    createdAt,
    createdBy,
    source,
    origin,
    this.dataMode,
    this.satNo,
    ephemerisList,
    tags,
    transactionId,
    origNetwork
  );
}
}
