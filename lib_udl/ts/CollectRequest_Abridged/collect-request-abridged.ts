// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { CollectRequest_Abridged_dataMode_Enum } from './collect-request-abridged-data-mode-enum.js';


/**
 * /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
 */
export class CollectRequest_Abridged implements flatbuffers.IUnpackableObject<CollectRequest_AbridgedT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):CollectRequest_Abridged {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsCollectRequest_Abridged(bb:flatbuffers.ByteBuffer, obj?:CollectRequest_Abridged):CollectRequest_Abridged {
  return (obj || new CollectRequest_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsCollectRequest_Abridged(bb:flatbuffers.ByteBuffer, obj?:CollectRequest_Abridged):CollectRequest_Abridged {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new CollectRequest_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('COLL');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: COLLECTREQUEST-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
 * Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idParentReq():string|null
idParentReq(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idParentReq(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The type of external message from which this request originated.
 * Example: /// Example: SU67
 * Constraints: Minimum length = 0, Maximum length = 16
 */
msgType():string|null
msgType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
msgType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
 * Example: /// Example: 2024-04-25T08:17:01.346Z
 * Constraints: No constraints specified.
 */
msgCreateDate():string|null
msgCreateDate(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
msgCreateDate(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
 * Example: /// Example: DWELL
 * Constraints: Minimum length = 1, Maximum length = 36
 */
type():string|null
type(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
type(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
 * Example: /// Example: REF-PLAN-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idPlan():string|null
idPlan(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idPlan(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Index number (integer) for records within a collection plan or schedule.
 * Example: /// Example: 8
 * Constraints: No constraints specified.
 */
planIndex():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
 * Example: /// Example: TASK-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
taskId():string|null
taskId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
taskId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
 * Example: /// Example: DWELL-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
dwellId():string|null
dwellId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
dwellId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
 * Example: /// Example: EXTERNAL-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
externalId():string|null
externalId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
externalId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
 * Example: /// Example: REF-SENSOR-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idSensor():string|null
idSensor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
 * Example: /// Example: ORIGSENSOR-ID
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origSensorId():string|null
origSensorId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origSensorId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
 * Example: /// Example: RADAR
 * Constraints: Minimum length = 0, Maximum length = 24
 */
obType():string|null
obType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
obType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
 * Example: /// Example: EMERGENCY
 * Constraints: Minimum length = 0, Maximum length = 24
 */
priority():string|null
priority(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
priority(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
 * Example: /// Example: 4
 * Constraints: No constraints specified.
 */
taskCategory():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
 * Example: /// Example: T
 * Constraints: Minimum length = 0, Maximum length = 1
 */
suffix():string|null
suffix(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
suffix(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Boolean indicating that this collect request is UCT follow-up.
 * Example: /// Example: False
 * Constraints: No constraints specified.
 */
uctFollowUp():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
 * Example: /// Example: 2018-01-01T16:00:00.123456Z
 * Constraints: No constraints specified.
 */
startTime():string|null
startTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
startTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
 * Example: /// Example: 2018-01-01T18:00:00.123456Z
 * Constraints: No constraints specified.
 */
endTime():string|null
endTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
endTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the target on-orbit object for this request.
 * Example: /// Example: REF-ONORBIT-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idOnOrbit():string|null
idOnOrbit(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idOnOrbit(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Satellite/catalog number of the target on-orbit object for this request.
 * Example: /// Example: 101
 * Constraints: No constraints specified.
 */
satNo():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
 * Example: /// Example: ORIGOBJECT-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
origObjectId():string|null
origObjectId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origObjectId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The tasking group to which the target object is assigned.
 * Example: /// Example: 729
 * Constraints: Minimum length = 0, Maximum length = 16
 */
taskGroup():string|null
taskGroup(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
taskGroup(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
 * Example: /// Example: 3
 * Constraints: No constraints specified.
 */
iron():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
 * Example: /// Example: GEO
 * Constraints: Minimum length = 0, Maximum length = 12
 */
orbitRegime():string|null
orbitRegime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
orbitRegime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The minimum object (diameter) size, in meters, to be reported.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
targetSize():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
rcsMin():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The Radar Cross-Section of the target, in m^2.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
rcs():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum Radar Cross-Section of the target, in m^2.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
rcsMax():number {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
freqMin():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The estimated or expected emission frequency of the target, in MHz.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
freq():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum frequency of interest, in MHz.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
freqMax():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The RF polarization (H, LHC, RHC, V).
 * Example: /// Example: H
 * Constraints: Minimum length = 0, Maximum length = 4
 */
polarization():string|null
polarization(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
polarization(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
visMagMin():number {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The estimated or expected visual magnitude of the target, in Magnitudes (M).
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
visMag():number {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
visMagMax():number {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The spectral model used for the irradiance calculation.
 * Example: /// Example: Example Model
 * Constraints: Minimum length = 0, Maximum length = 36
 */
spectralModel():string|null
spectralModel(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
spectralModel(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The fraction of solar energy reflected from target.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
reflectance():number {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The target object irradiance value.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
irradiance():number {
  const offset = this.bb!.__offset(this.bb_pos, 82);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For optical sensors, the requested number of frames to capture at each sensor step.
 * Example: /// Example: 6
 * Constraints: No constraints specified.
 */
numFrames():number {
  const offset = this.bb!.__offset(this.bb_pos, 84);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * For optical sensors, the frame rate of the camera, in Hz.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
frameRate():number {
  const offset = this.bb!.__offset(this.bb_pos, 86);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * For optical sensors, the integration time per camera frame, in milliseconds.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
integrationTime():number {
  const offset = this.bb!.__offset(this.bb_pos, 88);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
 * Example: /// Example: 3
 * Constraints: No constraints specified.
 */
numTracks():number {
  const offset = this.bb!.__offset(this.bb_pos, 90);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The number of requested observations on the target.
 * Example: /// Example: 9
 * Constraints: No constraints specified.
 */
numObs():number {
  const offset = this.bb!.__offset(this.bb_pos, 92);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
 * Example: /// Example: 11
 * Constraints: No constraints specified.
 */
duration():number {
  const offset = this.bb!.__offset(this.bb_pos, 94);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
 * Example: /// Example: SCAN
 * Constraints: Minimum length = 0, Maximum length = 24
 */
srchPattern():string|null
srchPattern(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
srchPattern(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 96);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
 * Example: /// Example: Example direction
 * Constraints: Minimum length = 0, Maximum length = 24
 */
scenario():string|null
scenario(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
scenario(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 98);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the UDL Elset of the object associated with this request.
 * Example: /// Example: REF-ELSET-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idElset():string|null
idElset(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idElset(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 100);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
 * Example: /// Example: REF-MANIFOLD-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idManifold():string|null
idManifold(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idManifold(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 102);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the UDL State Vector of the object or central vector associated with this request.
 * Example: /// Example: STATEVECTOR-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idStateVector():string|null
idStateVector(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idStateVector(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 104);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * ID of the UDL Ephemeris Set of the object associated with this request.
 * Example: /// Example: ES-ID
 * Constraints: Minimum length = 0, Maximum length = 36
 */
esId():string|null
esId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
esId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 106);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Epoch time, in ISO 8601 UTC format, of the orbital elements.
 * Example: /// Example: 2018-01-01T16:00:00.123456Z
 * Constraints: No constraints specified.
 */
epoch():string|null
epoch(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
epoch(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 108);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
semiMajorAxis():number {
  const offset = this.bb!.__offset(this.bb_pos, 110);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
eccentricity():number {
  const offset = this.bb!.__offset(this.bb_pos, 112);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
inclination():number {
  const offset = this.bb!.__offset(this.bb_pos, 114);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
raan():number {
  const offset = this.bb!.__offset(this.bb_pos, 116);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
argOfPerigee():number {
  const offset = this.bb!.__offset(this.bb_pos, 118);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
trueAnomoly():number {
  const offset = this.bb!.__offset(this.bb_pos, 120);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed right ascension angle, in degrees, for search or target acquisition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
ra():number {
  const offset = this.bb!.__offset(this.bb_pos, 122);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed declination angle, in degrees, for search or target acquisition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
dec():number {
  const offset = this.bb!.__offset(this.bb_pos, 124);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed azimuth angle, in degrees, for search or target acquisition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
az():number {
  const offset = this.bb!.__offset(this.bb_pos, 126);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected or directed elevation angle, in degrees, for search or target acquisition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
el():number {
  const offset = this.bb!.__offset(this.bb_pos, 128);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The expected acquisition range or defined center range, in km.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
range():number {
  const offset = this.bb!.__offset(this.bb_pos, 130);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
extentAz():number {
  const offset = this.bb!.__offset(this.bb_pos, 132);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
extentEl():number {
  const offset = this.bb!.__offset(this.bb_pos, 134);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The extent of the range, in km, from center range to define a spatial volume.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
extentRange():number {
  const offset = this.bb!.__offset(this.bb_pos, 136);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
lat():number {
  const offset = this.bb!.__offset(this.bb_pos, 138);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
lon():number {
  const offset = this.bb!.__offset(this.bb_pos, 140);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
alt():number {
  const offset = this.bb!.__offset(this.bb_pos, 142);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
stopLat():number {
  const offset = this.bb!.__offset(this.bb_pos, 144);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
stopLon():number {
  const offset = this.bb!.__offset(this.bb_pos, 146);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
stopAlt():number {
  const offset = this.bb!.__offset(this.bb_pos, 148);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The maximum inclination, in degrees, to be used in search operations.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
srchInc():number {
  const offset = this.bb!.__offset(this.bb_pos, 150);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
xAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 152);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
yAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 154);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
 * Example: /// Example: 1.1
 * Constraints: No constraints specified.
 */
orientAngle():number {
  const offset = this.bb!.__offset(this.bb_pos, 156);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The customer for this request.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 0, Maximum length = 64
 */
customer():string|null
customer(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
customer(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 158);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Notes or comments associated with this request.
 * Example: /// Example: Example notes
 * Constraints: Minimum length = 0, Maximum length = 512
 */
notes():string|null
notes(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
notes(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 160);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 162);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 164);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 36
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 166);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 * Example: /// Example: Example source
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 168);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 170);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():CollectRequest_Abridged_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 172);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : CollectRequest_Abridged_dataMode_Enum.REAL;
}

/**
 * No description provided.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
stateVector():string|null
stateVector(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
stateVector(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 174);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * No description provided.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
elset():string|null
elset(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
elset(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 176);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startCollectRequest_Abridged(builder:flatbuffers.Builder) {
  builder.startObject(87);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationMarkingOffset, 0);
}

static addIdParentReq(builder:flatbuffers.Builder, idParentReqOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, idParentReqOffset, 0);
}

static addMsgType(builder:flatbuffers.Builder, msgTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, msgTypeOffset, 0);
}

static addMsgCreateDate(builder:flatbuffers.Builder, msgCreateDateOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, msgCreateDateOffset, 0);
}

static addType(builder:flatbuffers.Builder, typeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, typeOffset, 0);
}

static addIdPlan(builder:flatbuffers.Builder, idPlanOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, idPlanOffset, 0);
}

static addPlanIndex(builder:flatbuffers.Builder, planIndex:number) {
  builder.addFieldInt32(7, planIndex, 0);
}

static addTaskId(builder:flatbuffers.Builder, taskIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, taskIdOffset, 0);
}

static addDwellId(builder:flatbuffers.Builder, dwellIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, dwellIdOffset, 0);
}

static addExternalId(builder:flatbuffers.Builder, externalIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, externalIdOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, idSensorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, idSensorOffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, origSensorIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, origSensorIdOffset, 0);
}

static addObType(builder:flatbuffers.Builder, obTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, obTypeOffset, 0);
}

static addPriority(builder:flatbuffers.Builder, priorityOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, priorityOffset, 0);
}

static addTaskCategory(builder:flatbuffers.Builder, taskCategory:number) {
  builder.addFieldInt32(15, taskCategory, 0);
}

static addSuffix(builder:flatbuffers.Builder, suffixOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, suffixOffset, 0);
}

static addUctFollowUp(builder:flatbuffers.Builder, uctFollowUp:boolean) {
  builder.addFieldInt8(17, +uctFollowUp, +false);
}

static addStartTime(builder:flatbuffers.Builder, startTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, startTimeOffset, 0);
}

static addEndTime(builder:flatbuffers.Builder, endTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, endTimeOffset, 0);
}

static addIdOnOrbit(builder:flatbuffers.Builder, idOnOrbitOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, idOnOrbitOffset, 0);
}

static addSatNo(builder:flatbuffers.Builder, satNo:number) {
  builder.addFieldInt32(21, satNo, 0);
}

static addOrigObjectId(builder:flatbuffers.Builder, origObjectIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(22, origObjectIdOffset, 0);
}

static addTaskGroup(builder:flatbuffers.Builder, taskGroupOffset:flatbuffers.Offset) {
  builder.addFieldOffset(23, taskGroupOffset, 0);
}

static addIron(builder:flatbuffers.Builder, iron:number) {
  builder.addFieldInt32(24, iron, 0);
}

static addOrbitRegime(builder:flatbuffers.Builder, orbitRegimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(25, orbitRegimeOffset, 0);
}

static addTargetSize(builder:flatbuffers.Builder, targetSize:number) {
  builder.addFieldFloat64(26, targetSize, 0.0);
}

static addRcsMin(builder:flatbuffers.Builder, rcsMin:number) {
  builder.addFieldFloat64(27, rcsMin, 0.0);
}

static addRcs(builder:flatbuffers.Builder, rcs:number) {
  builder.addFieldFloat64(28, rcs, 0.0);
}

static addRcsMax(builder:flatbuffers.Builder, rcsMax:number) {
  builder.addFieldFloat64(29, rcsMax, 0.0);
}

static addFreqMin(builder:flatbuffers.Builder, freqMin:number) {
  builder.addFieldFloat64(30, freqMin, 0.0);
}

static addFreq(builder:flatbuffers.Builder, freq:number) {
  builder.addFieldFloat64(31, freq, 0.0);
}

static addFreqMax(builder:flatbuffers.Builder, freqMax:number) {
  builder.addFieldFloat64(32, freqMax, 0.0);
}

static addPolarization(builder:flatbuffers.Builder, polarizationOffset:flatbuffers.Offset) {
  builder.addFieldOffset(33, polarizationOffset, 0);
}

static addVisMagMin(builder:flatbuffers.Builder, visMagMin:number) {
  builder.addFieldFloat64(34, visMagMin, 0.0);
}

static addVisMag(builder:flatbuffers.Builder, visMag:number) {
  builder.addFieldFloat64(35, visMag, 0.0);
}

static addVisMagMax(builder:flatbuffers.Builder, visMagMax:number) {
  builder.addFieldFloat64(36, visMagMax, 0.0);
}

static addSpectralModel(builder:flatbuffers.Builder, spectralModelOffset:flatbuffers.Offset) {
  builder.addFieldOffset(37, spectralModelOffset, 0);
}

static addReflectance(builder:flatbuffers.Builder, reflectance:number) {
  builder.addFieldFloat64(38, reflectance, 0.0);
}

static addIrradiance(builder:flatbuffers.Builder, irradiance:number) {
  builder.addFieldFloat64(39, irradiance, 0.0);
}

static addNumFrames(builder:flatbuffers.Builder, numFrames:number) {
  builder.addFieldInt32(40, numFrames, 0);
}

static addFrameRate(builder:flatbuffers.Builder, frameRate:number) {
  builder.addFieldFloat64(41, frameRate, 0.0);
}

static addIntegrationTime(builder:flatbuffers.Builder, integrationTime:number) {
  builder.addFieldFloat64(42, integrationTime, 0.0);
}

static addNumTracks(builder:flatbuffers.Builder, numTracks:number) {
  builder.addFieldInt32(43, numTracks, 0);
}

static addNumObs(builder:flatbuffers.Builder, numObs:number) {
  builder.addFieldInt32(44, numObs, 0);
}

static addDuration(builder:flatbuffers.Builder, duration:number) {
  builder.addFieldInt32(45, duration, 0);
}

static addSrchPattern(builder:flatbuffers.Builder, srchPatternOffset:flatbuffers.Offset) {
  builder.addFieldOffset(46, srchPatternOffset, 0);
}

static addScenario(builder:flatbuffers.Builder, scenarioOffset:flatbuffers.Offset) {
  builder.addFieldOffset(47, scenarioOffset, 0);
}

static addIdElset(builder:flatbuffers.Builder, idElsetOffset:flatbuffers.Offset) {
  builder.addFieldOffset(48, idElsetOffset, 0);
}

static addIdManifold(builder:flatbuffers.Builder, idManifoldOffset:flatbuffers.Offset) {
  builder.addFieldOffset(49, idManifoldOffset, 0);
}

static addIdStateVector(builder:flatbuffers.Builder, idStateVectorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(50, idStateVectorOffset, 0);
}

static addEsId(builder:flatbuffers.Builder, esIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(51, esIdOffset, 0);
}

static addEpoch(builder:flatbuffers.Builder, epochOffset:flatbuffers.Offset) {
  builder.addFieldOffset(52, epochOffset, 0);
}

static addSemiMajorAxis(builder:flatbuffers.Builder, semiMajorAxis:number) {
  builder.addFieldFloat64(53, semiMajorAxis, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, eccentricity:number) {
  builder.addFieldFloat64(54, eccentricity, 0.0);
}

static addInclination(builder:flatbuffers.Builder, inclination:number) {
  builder.addFieldFloat64(55, inclination, 0.0);
}

static addRaan(builder:flatbuffers.Builder, raan:number) {
  builder.addFieldFloat64(56, raan, 0.0);
}

static addArgOfPerigee(builder:flatbuffers.Builder, argOfPerigee:number) {
  builder.addFieldFloat64(57, argOfPerigee, 0.0);
}

static addTrueAnomoly(builder:flatbuffers.Builder, trueAnomoly:number) {
  builder.addFieldFloat64(58, trueAnomoly, 0.0);
}

static addRa(builder:flatbuffers.Builder, ra:number) {
  builder.addFieldFloat64(59, ra, 0.0);
}

static addDec(builder:flatbuffers.Builder, dec:number) {
  builder.addFieldFloat64(60, dec, 0.0);
}

static addAz(builder:flatbuffers.Builder, az:number) {
  builder.addFieldFloat64(61, az, 0.0);
}

static addEl(builder:flatbuffers.Builder, el:number) {
  builder.addFieldFloat64(62, el, 0.0);
}

static addRange(builder:flatbuffers.Builder, range:number) {
  builder.addFieldFloat64(63, range, 0.0);
}

static addExtentAz(builder:flatbuffers.Builder, extentAz:number) {
  builder.addFieldFloat64(64, extentAz, 0.0);
}

static addExtentEl(builder:flatbuffers.Builder, extentEl:number) {
  builder.addFieldFloat64(65, extentEl, 0.0);
}

static addExtentRange(builder:flatbuffers.Builder, extentRange:number) {
  builder.addFieldFloat64(66, extentRange, 0.0);
}

static addLat(builder:flatbuffers.Builder, lat:number) {
  builder.addFieldFloat64(67, lat, 0.0);
}

static addLon(builder:flatbuffers.Builder, lon:number) {
  builder.addFieldFloat64(68, lon, 0.0);
}

static addAlt(builder:flatbuffers.Builder, alt:number) {
  builder.addFieldFloat64(69, alt, 0.0);
}

static addStopLat(builder:flatbuffers.Builder, stopLat:number) {
  builder.addFieldFloat64(70, stopLat, 0.0);
}

static addStopLon(builder:flatbuffers.Builder, stopLon:number) {
  builder.addFieldFloat64(71, stopLon, 0.0);
}

static addStopAlt(builder:flatbuffers.Builder, stopAlt:number) {
  builder.addFieldFloat64(72, stopAlt, 0.0);
}

static addSrchInc(builder:flatbuffers.Builder, srchInc:number) {
  builder.addFieldFloat64(73, srchInc, 0.0);
}

static addXAngle(builder:flatbuffers.Builder, xAngle:number) {
  builder.addFieldFloat64(74, xAngle, 0.0);
}

static addYAngle(builder:flatbuffers.Builder, yAngle:number) {
  builder.addFieldFloat64(75, yAngle, 0.0);
}

static addOrientAngle(builder:flatbuffers.Builder, orientAngle:number) {
  builder.addFieldFloat64(76, orientAngle, 0.0);
}

static addCustomer(builder:flatbuffers.Builder, customerOffset:flatbuffers.Offset) {
  builder.addFieldOffset(77, customerOffset, 0);
}

static addNotes(builder:flatbuffers.Builder, notesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(78, notesOffset, 0);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(79, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(80, createdByOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(81, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(82, originOffset, 0);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(83, origNetworkOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:CollectRequest_Abridged_dataMode_Enum) {
  builder.addFieldInt8(84, dataMode, CollectRequest_Abridged_dataMode_Enum.REAL);
}

static addStateVector(builder:flatbuffers.Builder, stateVectorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(85, stateVectorOffset, 0);
}

static addElset(builder:flatbuffers.Builder, elsetOffset:flatbuffers.Offset) {
  builder.addFieldOffset(86, elsetOffset, 0);
}

static endCollectRequest_Abridged(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishCollectRequest_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'COLL');
}

static finishSizePrefixedCollectRequest_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'COLL', true);
}

static createCollectRequest_Abridged(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, idParentReqOffset:flatbuffers.Offset, msgTypeOffset:flatbuffers.Offset, msgCreateDateOffset:flatbuffers.Offset, typeOffset:flatbuffers.Offset, idPlanOffset:flatbuffers.Offset, planIndex:number, taskIdOffset:flatbuffers.Offset, dwellIdOffset:flatbuffers.Offset, externalIdOffset:flatbuffers.Offset, idSensorOffset:flatbuffers.Offset, origSensorIdOffset:flatbuffers.Offset, obTypeOffset:flatbuffers.Offset, priorityOffset:flatbuffers.Offset, taskCategory:number, suffixOffset:flatbuffers.Offset, uctFollowUp:boolean, startTimeOffset:flatbuffers.Offset, endTimeOffset:flatbuffers.Offset, idOnOrbitOffset:flatbuffers.Offset, satNo:number, origObjectIdOffset:flatbuffers.Offset, taskGroupOffset:flatbuffers.Offset, iron:number, orbitRegimeOffset:flatbuffers.Offset, targetSize:number, rcsMin:number, rcs:number, rcsMax:number, freqMin:number, freq:number, freqMax:number, polarizationOffset:flatbuffers.Offset, visMagMin:number, visMag:number, visMagMax:number, spectralModelOffset:flatbuffers.Offset, reflectance:number, irradiance:number, numFrames:number, frameRate:number, integrationTime:number, numTracks:number, numObs:number, duration:number, srchPatternOffset:flatbuffers.Offset, scenarioOffset:flatbuffers.Offset, idElsetOffset:flatbuffers.Offset, idManifoldOffset:flatbuffers.Offset, idStateVectorOffset:flatbuffers.Offset, esIdOffset:flatbuffers.Offset, epochOffset:flatbuffers.Offset, semiMajorAxis:number, eccentricity:number, inclination:number, raan:number, argOfPerigee:number, trueAnomoly:number, ra:number, dec:number, az:number, el:number, range:number, extentAz:number, extentEl:number, extentRange:number, lat:number, lon:number, alt:number, stopLat:number, stopLon:number, stopAlt:number, srchInc:number, xAngle:number, yAngle:number, orientAngle:number, customerOffset:flatbuffers.Offset, notesOffset:flatbuffers.Offset, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, origNetworkOffset:flatbuffers.Offset, dataMode:CollectRequest_Abridged_dataMode_Enum, stateVectorOffset:flatbuffers.Offset, elsetOffset:flatbuffers.Offset):flatbuffers.Offset {
  CollectRequest_Abridged.startCollectRequest_Abridged(builder);
  CollectRequest_Abridged.addId(builder, idOffset);
  CollectRequest_Abridged.addClassificationMarking(builder, classificationMarkingOffset);
  CollectRequest_Abridged.addIdParentReq(builder, idParentReqOffset);
  CollectRequest_Abridged.addMsgType(builder, msgTypeOffset);
  CollectRequest_Abridged.addMsgCreateDate(builder, msgCreateDateOffset);
  CollectRequest_Abridged.addType(builder, typeOffset);
  CollectRequest_Abridged.addIdPlan(builder, idPlanOffset);
  CollectRequest_Abridged.addPlanIndex(builder, planIndex);
  CollectRequest_Abridged.addTaskId(builder, taskIdOffset);
  CollectRequest_Abridged.addDwellId(builder, dwellIdOffset);
  CollectRequest_Abridged.addExternalId(builder, externalIdOffset);
  CollectRequest_Abridged.addIdSensor(builder, idSensorOffset);
  CollectRequest_Abridged.addOrigSensorId(builder, origSensorIdOffset);
  CollectRequest_Abridged.addObType(builder, obTypeOffset);
  CollectRequest_Abridged.addPriority(builder, priorityOffset);
  CollectRequest_Abridged.addTaskCategory(builder, taskCategory);
  CollectRequest_Abridged.addSuffix(builder, suffixOffset);
  CollectRequest_Abridged.addUctFollowUp(builder, uctFollowUp);
  CollectRequest_Abridged.addStartTime(builder, startTimeOffset);
  CollectRequest_Abridged.addEndTime(builder, endTimeOffset);
  CollectRequest_Abridged.addIdOnOrbit(builder, idOnOrbitOffset);
  CollectRequest_Abridged.addSatNo(builder, satNo);
  CollectRequest_Abridged.addOrigObjectId(builder, origObjectIdOffset);
  CollectRequest_Abridged.addTaskGroup(builder, taskGroupOffset);
  CollectRequest_Abridged.addIron(builder, iron);
  CollectRequest_Abridged.addOrbitRegime(builder, orbitRegimeOffset);
  CollectRequest_Abridged.addTargetSize(builder, targetSize);
  CollectRequest_Abridged.addRcsMin(builder, rcsMin);
  CollectRequest_Abridged.addRcs(builder, rcs);
  CollectRequest_Abridged.addRcsMax(builder, rcsMax);
  CollectRequest_Abridged.addFreqMin(builder, freqMin);
  CollectRequest_Abridged.addFreq(builder, freq);
  CollectRequest_Abridged.addFreqMax(builder, freqMax);
  CollectRequest_Abridged.addPolarization(builder, polarizationOffset);
  CollectRequest_Abridged.addVisMagMin(builder, visMagMin);
  CollectRequest_Abridged.addVisMag(builder, visMag);
  CollectRequest_Abridged.addVisMagMax(builder, visMagMax);
  CollectRequest_Abridged.addSpectralModel(builder, spectralModelOffset);
  CollectRequest_Abridged.addReflectance(builder, reflectance);
  CollectRequest_Abridged.addIrradiance(builder, irradiance);
  CollectRequest_Abridged.addNumFrames(builder, numFrames);
  CollectRequest_Abridged.addFrameRate(builder, frameRate);
  CollectRequest_Abridged.addIntegrationTime(builder, integrationTime);
  CollectRequest_Abridged.addNumTracks(builder, numTracks);
  CollectRequest_Abridged.addNumObs(builder, numObs);
  CollectRequest_Abridged.addDuration(builder, duration);
  CollectRequest_Abridged.addSrchPattern(builder, srchPatternOffset);
  CollectRequest_Abridged.addScenario(builder, scenarioOffset);
  CollectRequest_Abridged.addIdElset(builder, idElsetOffset);
  CollectRequest_Abridged.addIdManifold(builder, idManifoldOffset);
  CollectRequest_Abridged.addIdStateVector(builder, idStateVectorOffset);
  CollectRequest_Abridged.addEsId(builder, esIdOffset);
  CollectRequest_Abridged.addEpoch(builder, epochOffset);
  CollectRequest_Abridged.addSemiMajorAxis(builder, semiMajorAxis);
  CollectRequest_Abridged.addEccentricity(builder, eccentricity);
  CollectRequest_Abridged.addInclination(builder, inclination);
  CollectRequest_Abridged.addRaan(builder, raan);
  CollectRequest_Abridged.addArgOfPerigee(builder, argOfPerigee);
  CollectRequest_Abridged.addTrueAnomoly(builder, trueAnomoly);
  CollectRequest_Abridged.addRa(builder, ra);
  CollectRequest_Abridged.addDec(builder, dec);
  CollectRequest_Abridged.addAz(builder, az);
  CollectRequest_Abridged.addEl(builder, el);
  CollectRequest_Abridged.addRange(builder, range);
  CollectRequest_Abridged.addExtentAz(builder, extentAz);
  CollectRequest_Abridged.addExtentEl(builder, extentEl);
  CollectRequest_Abridged.addExtentRange(builder, extentRange);
  CollectRequest_Abridged.addLat(builder, lat);
  CollectRequest_Abridged.addLon(builder, lon);
  CollectRequest_Abridged.addAlt(builder, alt);
  CollectRequest_Abridged.addStopLat(builder, stopLat);
  CollectRequest_Abridged.addStopLon(builder, stopLon);
  CollectRequest_Abridged.addStopAlt(builder, stopAlt);
  CollectRequest_Abridged.addSrchInc(builder, srchInc);
  CollectRequest_Abridged.addXAngle(builder, xAngle);
  CollectRequest_Abridged.addYAngle(builder, yAngle);
  CollectRequest_Abridged.addOrientAngle(builder, orientAngle);
  CollectRequest_Abridged.addCustomer(builder, customerOffset);
  CollectRequest_Abridged.addNotes(builder, notesOffset);
  CollectRequest_Abridged.addCreatedAt(builder, createdAtOffset);
  CollectRequest_Abridged.addCreatedBy(builder, createdByOffset);
  CollectRequest_Abridged.addSource(builder, sourceOffset);
  CollectRequest_Abridged.addOrigin(builder, originOffset);
  CollectRequest_Abridged.addOrigNetwork(builder, origNetworkOffset);
  CollectRequest_Abridged.addDataMode(builder, dataMode);
  CollectRequest_Abridged.addStateVector(builder, stateVectorOffset);
  CollectRequest_Abridged.addElset(builder, elsetOffset);
  return CollectRequest_Abridged.endCollectRequest_Abridged(builder);
}

unpack(): CollectRequest_AbridgedT {
  return new CollectRequest_AbridgedT(
    this.id(),
    this.classificationMarking(),
    this.idParentReq(),
    this.msgType(),
    this.msgCreateDate(),
    this.type(),
    this.idPlan(),
    this.planIndex(),
    this.taskId(),
    this.dwellId(),
    this.externalId(),
    this.idSensor(),
    this.origSensorId(),
    this.obType(),
    this.priority(),
    this.taskCategory(),
    this.suffix(),
    this.uctFollowUp(),
    this.startTime(),
    this.endTime(),
    this.idOnOrbit(),
    this.satNo(),
    this.origObjectId(),
    this.taskGroup(),
    this.iron(),
    this.orbitRegime(),
    this.targetSize(),
    this.rcsMin(),
    this.rcs(),
    this.rcsMax(),
    this.freqMin(),
    this.freq(),
    this.freqMax(),
    this.polarization(),
    this.visMagMin(),
    this.visMag(),
    this.visMagMax(),
    this.spectralModel(),
    this.reflectance(),
    this.irradiance(),
    this.numFrames(),
    this.frameRate(),
    this.integrationTime(),
    this.numTracks(),
    this.numObs(),
    this.duration(),
    this.srchPattern(),
    this.scenario(),
    this.idElset(),
    this.idManifold(),
    this.idStateVector(),
    this.esId(),
    this.epoch(),
    this.semiMajorAxis(),
    this.eccentricity(),
    this.inclination(),
    this.raan(),
    this.argOfPerigee(),
    this.trueAnomoly(),
    this.ra(),
    this.dec(),
    this.az(),
    this.el(),
    this.range(),
    this.extentAz(),
    this.extentEl(),
    this.extentRange(),
    this.lat(),
    this.lon(),
    this.alt(),
    this.stopLat(),
    this.stopLon(),
    this.stopAlt(),
    this.srchInc(),
    this.xAngle(),
    this.yAngle(),
    this.orientAngle(),
    this.customer(),
    this.notes(),
    this.createdAt(),
    this.createdBy(),
    this.source(),
    this.origin(),
    this.origNetwork(),
    this.dataMode(),
    this.stateVector(),
    this.elset()
  );
}


unpackTo(_o: CollectRequest_AbridgedT): void {
  _o.id = this.id();
  _o.classificationMarking = this.classificationMarking();
  _o.idParentReq = this.idParentReq();
  _o.msgType = this.msgType();
  _o.msgCreateDate = this.msgCreateDate();
  _o.type = this.type();
  _o.idPlan = this.idPlan();
  _o.planIndex = this.planIndex();
  _o.taskId = this.taskId();
  _o.dwellId = this.dwellId();
  _o.externalId = this.externalId();
  _o.idSensor = this.idSensor();
  _o.origSensorId = this.origSensorId();
  _o.obType = this.obType();
  _o.priority = this.priority();
  _o.taskCategory = this.taskCategory();
  _o.suffix = this.suffix();
  _o.uctFollowUp = this.uctFollowUp();
  _o.startTime = this.startTime();
  _o.endTime = this.endTime();
  _o.idOnOrbit = this.idOnOrbit();
  _o.satNo = this.satNo();
  _o.origObjectId = this.origObjectId();
  _o.taskGroup = this.taskGroup();
  _o.iron = this.iron();
  _o.orbitRegime = this.orbitRegime();
  _o.targetSize = this.targetSize();
  _o.rcsMin = this.rcsMin();
  _o.rcs = this.rcs();
  _o.rcsMax = this.rcsMax();
  _o.freqMin = this.freqMin();
  _o.freq = this.freq();
  _o.freqMax = this.freqMax();
  _o.polarization = this.polarization();
  _o.visMagMin = this.visMagMin();
  _o.visMag = this.visMag();
  _o.visMagMax = this.visMagMax();
  _o.spectralModel = this.spectralModel();
  _o.reflectance = this.reflectance();
  _o.irradiance = this.irradiance();
  _o.numFrames = this.numFrames();
  _o.frameRate = this.frameRate();
  _o.integrationTime = this.integrationTime();
  _o.numTracks = this.numTracks();
  _o.numObs = this.numObs();
  _o.duration = this.duration();
  _o.srchPattern = this.srchPattern();
  _o.scenario = this.scenario();
  _o.idElset = this.idElset();
  _o.idManifold = this.idManifold();
  _o.idStateVector = this.idStateVector();
  _o.esId = this.esId();
  _o.epoch = this.epoch();
  _o.semiMajorAxis = this.semiMajorAxis();
  _o.eccentricity = this.eccentricity();
  _o.inclination = this.inclination();
  _o.raan = this.raan();
  _o.argOfPerigee = this.argOfPerigee();
  _o.trueAnomoly = this.trueAnomoly();
  _o.ra = this.ra();
  _o.dec = this.dec();
  _o.az = this.az();
  _o.el = this.el();
  _o.range = this.range();
  _o.extentAz = this.extentAz();
  _o.extentEl = this.extentEl();
  _o.extentRange = this.extentRange();
  _o.lat = this.lat();
  _o.lon = this.lon();
  _o.alt = this.alt();
  _o.stopLat = this.stopLat();
  _o.stopLon = this.stopLon();
  _o.stopAlt = this.stopAlt();
  _o.srchInc = this.srchInc();
  _o.xAngle = this.xAngle();
  _o.yAngle = this.yAngle();
  _o.orientAngle = this.orientAngle();
  _o.customer = this.customer();
  _o.notes = this.notes();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.origNetwork = this.origNetwork();
  _o.dataMode = this.dataMode();
  _o.stateVector = this.stateVector();
  _o.elset = this.elset();
}
}

export class CollectRequest_AbridgedT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public idParentReq: string|Uint8Array|null = null,
  public msgType: string|Uint8Array|null = null,
  public msgCreateDate: string|Uint8Array|null = null,
  public type: string|Uint8Array|null = null,
  public idPlan: string|Uint8Array|null = null,
  public planIndex: number = 0,
  public taskId: string|Uint8Array|null = null,
  public dwellId: string|Uint8Array|null = null,
  public externalId: string|Uint8Array|null = null,
  public idSensor: string|Uint8Array|null = null,
  public origSensorId: string|Uint8Array|null = null,
  public obType: string|Uint8Array|null = null,
  public priority: string|Uint8Array|null = null,
  public taskCategory: number = 0,
  public suffix: string|Uint8Array|null = null,
  public uctFollowUp: boolean = false,
  public startTime: string|Uint8Array|null = null,
  public endTime: string|Uint8Array|null = null,
  public idOnOrbit: string|Uint8Array|null = null,
  public satNo: number = 0,
  public origObjectId: string|Uint8Array|null = null,
  public taskGroup: string|Uint8Array|null = null,
  public iron: number = 0,
  public orbitRegime: string|Uint8Array|null = null,
  public targetSize: number = 0.0,
  public rcsMin: number = 0.0,
  public rcs: number = 0.0,
  public rcsMax: number = 0.0,
  public freqMin: number = 0.0,
  public freq: number = 0.0,
  public freqMax: number = 0.0,
  public polarization: string|Uint8Array|null = null,
  public visMagMin: number = 0.0,
  public visMag: number = 0.0,
  public visMagMax: number = 0.0,
  public spectralModel: string|Uint8Array|null = null,
  public reflectance: number = 0.0,
  public irradiance: number = 0.0,
  public numFrames: number = 0,
  public frameRate: number = 0.0,
  public integrationTime: number = 0.0,
  public numTracks: number = 0,
  public numObs: number = 0,
  public duration: number = 0,
  public srchPattern: string|Uint8Array|null = null,
  public scenario: string|Uint8Array|null = null,
  public idElset: string|Uint8Array|null = null,
  public idManifold: string|Uint8Array|null = null,
  public idStateVector: string|Uint8Array|null = null,
  public esId: string|Uint8Array|null = null,
  public epoch: string|Uint8Array|null = null,
  public semiMajorAxis: number = 0.0,
  public eccentricity: number = 0.0,
  public inclination: number = 0.0,
  public raan: number = 0.0,
  public argOfPerigee: number = 0.0,
  public trueAnomoly: number = 0.0,
  public ra: number = 0.0,
  public dec: number = 0.0,
  public az: number = 0.0,
  public el: number = 0.0,
  public range: number = 0.0,
  public extentAz: number = 0.0,
  public extentEl: number = 0.0,
  public extentRange: number = 0.0,
  public lat: number = 0.0,
  public lon: number = 0.0,
  public alt: number = 0.0,
  public stopLat: number = 0.0,
  public stopLon: number = 0.0,
  public stopAlt: number = 0.0,
  public srchInc: number = 0.0,
  public xAngle: number = 0.0,
  public yAngle: number = 0.0,
  public orientAngle: number = 0.0,
  public customer: string|Uint8Array|null = null,
  public notes: string|Uint8Array|null = null,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public origNetwork: string|Uint8Array|null = null,
  public dataMode: CollectRequest_Abridged_dataMode_Enum = CollectRequest_Abridged_dataMode_Enum.REAL,
  public stateVector: string|Uint8Array|null = null,
  public elset: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const idParentReq = (this.idParentReq !== null ? builder.createString(this.idParentReq!) : 0);
  const msgType = (this.msgType !== null ? builder.createString(this.msgType!) : 0);
  const msgCreateDate = (this.msgCreateDate !== null ? builder.createString(this.msgCreateDate!) : 0);
  const type = (this.type !== null ? builder.createString(this.type!) : 0);
  const idPlan = (this.idPlan !== null ? builder.createString(this.idPlan!) : 0);
  const taskId = (this.taskId !== null ? builder.createString(this.taskId!) : 0);
  const dwellId = (this.dwellId !== null ? builder.createString(this.dwellId!) : 0);
  const externalId = (this.externalId !== null ? builder.createString(this.externalId!) : 0);
  const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor!) : 0);
  const origSensorId = (this.origSensorId !== null ? builder.createString(this.origSensorId!) : 0);
  const obType = (this.obType !== null ? builder.createString(this.obType!) : 0);
  const priority = (this.priority !== null ? builder.createString(this.priority!) : 0);
  const suffix = (this.suffix !== null ? builder.createString(this.suffix!) : 0);
  const startTime = (this.startTime !== null ? builder.createString(this.startTime!) : 0);
  const endTime = (this.endTime !== null ? builder.createString(this.endTime!) : 0);
  const idOnOrbit = (this.idOnOrbit !== null ? builder.createString(this.idOnOrbit!) : 0);
  const origObjectId = (this.origObjectId !== null ? builder.createString(this.origObjectId!) : 0);
  const taskGroup = (this.taskGroup !== null ? builder.createString(this.taskGroup!) : 0);
  const orbitRegime = (this.orbitRegime !== null ? builder.createString(this.orbitRegime!) : 0);
  const polarization = (this.polarization !== null ? builder.createString(this.polarization!) : 0);
  const spectralModel = (this.spectralModel !== null ? builder.createString(this.spectralModel!) : 0);
  const srchPattern = (this.srchPattern !== null ? builder.createString(this.srchPattern!) : 0);
  const scenario = (this.scenario !== null ? builder.createString(this.scenario!) : 0);
  const idElset = (this.idElset !== null ? builder.createString(this.idElset!) : 0);
  const idManifold = (this.idManifold !== null ? builder.createString(this.idManifold!) : 0);
  const idStateVector = (this.idStateVector !== null ? builder.createString(this.idStateVector!) : 0);
  const esId = (this.esId !== null ? builder.createString(this.esId!) : 0);
  const epoch = (this.epoch !== null ? builder.createString(this.epoch!) : 0);
  const customer = (this.customer !== null ? builder.createString(this.customer!) : 0);
  const notes = (this.notes !== null ? builder.createString(this.notes!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);
  const stateVector = (this.stateVector !== null ? builder.createString(this.stateVector!) : 0);
  const elset = (this.elset !== null ? builder.createString(this.elset!) : 0);

  return CollectRequest_Abridged.createCollectRequest_Abridged(builder,
    id,
    classificationMarking,
    idParentReq,
    msgType,
    msgCreateDate,
    type,
    idPlan,
    this.planIndex,
    taskId,
    dwellId,
    externalId,
    idSensor,
    origSensorId,
    obType,
    priority,
    this.taskCategory,
    suffix,
    this.uctFollowUp,
    startTime,
    endTime,
    idOnOrbit,
    this.satNo,
    origObjectId,
    taskGroup,
    this.iron,
    orbitRegime,
    this.targetSize,
    this.rcsMin,
    this.rcs,
    this.rcsMax,
    this.freqMin,
    this.freq,
    this.freqMax,
    polarization,
    this.visMagMin,
    this.visMag,
    this.visMagMax,
    spectralModel,
    this.reflectance,
    this.irradiance,
    this.numFrames,
    this.frameRate,
    this.integrationTime,
    this.numTracks,
    this.numObs,
    this.duration,
    srchPattern,
    scenario,
    idElset,
    idManifold,
    idStateVector,
    esId,
    epoch,
    this.semiMajorAxis,
    this.eccentricity,
    this.inclination,
    this.raan,
    this.argOfPerigee,
    this.trueAnomoly,
    this.ra,
    this.dec,
    this.az,
    this.el,
    this.range,
    this.extentAz,
    this.extentEl,
    this.extentRange,
    this.lat,
    this.lon,
    this.alt,
    this.stopLat,
    this.stopLon,
    this.stopAlt,
    this.srchInc,
    this.xAngle,
    this.yAngle,
    this.orientAngle,
    customer,
    notes,
    createdAt,
    createdBy,
    source,
    origin,
    origNetwork,
    this.dataMode,
    stateVector,
    elset
  );
}
}
