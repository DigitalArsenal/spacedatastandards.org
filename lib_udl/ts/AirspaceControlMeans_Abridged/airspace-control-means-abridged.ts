// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { AirspaceControlMeans_Abridged_cmShape_Enum } from './airspace-control-means-abridged-cm-shape-enum.js';


/**
 * /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
 */
export class AirspaceControlMeans_Abridged implements flatbuffers.IUnpackableObject<AirspaceControlMeans_AbridgedT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):AirspaceControlMeans_Abridged {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsAirspaceControlMeans_Abridged(bb:flatbuffers.ByteBuffer, obj?:AirspaceControlMeans_Abridged):AirspaceControlMeans_Abridged {
  return (obj || new AirspaceControlMeans_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsAirspaceControlMeans_Abridged(bb:flatbuffers.ByteBuffer, obj?:AirspaceControlMeans_Abridged):AirspaceControlMeans_Abridged {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new AirspaceControlMeans_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('AIRS');
}

/**
 * The code for the type of airspace control means.
 * Example: /// Example: ACM:ADAREA
 * Constraints: Minimum length = 0, Maximum length = 8
 */
cmType():string|null
cmType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
cmType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Airspace control means name or designator.
 * Example: /// Example: DESIG:C34
 * Constraints: Minimum length = 0, Maximum length = 32
 */
cmId():string|null
cmId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
cmId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
 * Example: /// Example: POLYARC
 * Constraints: Minimum length = 0, Maximum length = 8
 */
cmShape():AirspaceControlMeans_Abridged_cmShape_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : AirspaceControlMeans_Abridged_cmShape_Enum.POLYARC;
}

/**
 * Designates the means by which a defined airspace control means is to be used.
 * Example: /// Example: USE:AIRCOR
 * Constraints: Minimum length = 0, Maximum length = 8
 */
usage():string|null
usage(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
usage(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique Link 16 identifier assigned to the airspace control means.
 * Example: /// Example: F3356
 * Constraints: Minimum length = 0, Maximum length = 8
 */
link16Id():string|null
link16Id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
link16Id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
 * Example: /// Example: 18000FT
 * Constraints: Minimum length = 0, Maximum length = 8
 */
transAltitude():string|null
transAltitude(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
transAltitude(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
 * Example: /// Example: NAR
 * Constraints: Minimum length = 0, Maximum length = 8
 */
geoDatumAlt():string|null
geoDatumAlt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
geoDatumAlt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
 * Example: /// Example: 152345N0505657E
 * Constraints: Minimum length = 0, Maximum length = 16
 */
coord0():string|null
coord0(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
coord0(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
 * Example: /// Example: 1523N05057E
 * Constraints: Minimum length = 0, Maximum length = 16
 */
coord1():string|null
coord1(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
coord1(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
 * Example: /// Example: 330
 * Constraints: No constraints specified.
 */
bearing0():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
 * Example: /// Example: 160
 * Constraints: No constraints specified.
 */
bearing1():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
 * Example: /// Example: 30.04
 * Constraints: No constraints specified.
 */
radMag0():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
 * Example: /// Example: 50.12
 * Constraints: No constraints specified.
 */
radMag1():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
 * Example: /// Example: NM
 * Constraints: Minimum length = 0, Maximum length = 8
 */
radMagUnit():string|null
radMagUnit(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
radMagUnit(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
 * Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
 * Constraints: No constraints specified.
 */
polyCoord(index: number):string
polyCoord(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
polyCoord(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

polyCoordLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Index of a segment in an airtrack, which is defined by an ordered set of points.
 * Example: /// Example: 99
 * Constraints: No constraints specified.
 */
trackLeg():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
 * Example: /// Example: 5.2
 * Constraints: No constraints specified.
 */
widthLeft():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
 * Example: /// Example: 10.4
 * Constraints: No constraints specified.
 */
widthRight():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
 * Example: /// Example: 15.6
 * Constraints: No constraints specified.
 */
width():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
 * Example: /// Example: KM
 * Constraints: Minimum length = 0, Maximum length = 8
 */
widthUnit():string|null
widthUnit(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
widthUnit(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
 * Example: /// Example: ['POB', 'RDU', 'IAD']
 * Constraints: No constraints specified.
 */
corrWayPoints(index: number):string
corrWayPoints(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
corrWayPoints(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

corrWayPointsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
 * Example: /// Example: C
 * Constraints: Minimum length = 0, Maximum length = 1
 */
orbitAlignment():string|null
orbitAlignment(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
orbitAlignment(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Description of the airspace vertical dimension.
 * Example: /// Example: BRRA:GL-100AGL
 * Constraints: Minimum length = 0, Maximum length = 16
 */
effVdim():string|null
effVdim(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
effVdim(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The timePeriod set describes the effective datetime for a given airspace control means.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
airspaceTimePeriod(index: number):string
airspaceTimePeriod(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
airspaceTimePeriod(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

airspaceTimePeriodLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
airspaceControlPoint(index: number):string
airspaceControlPoint(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
airspaceControlPoint(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

airspaceControlPointLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The commander responsible within a specified geographical area for the airspace control operation assigned to him.
 * Example: /// Example: RHEIN MAIN CP
 * Constraints: Minimum length = 0, Maximum length = 36
 */
ctrlAuth():string|null
ctrlAuth(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ctrlAuth(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
 * Example: /// Example: ['125.25MHZ']
 * Constraints: No constraints specified.
 */
ctrlAuthFreqs(index: number):string
ctrlAuthFreqs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
ctrlAuthFreqs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

ctrlAuthFreqsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Used to provide transit intstructions for the airspace control means.
 * Example: /// Example: SITUATION
 * Constraints: Minimum length = 0, Maximum length = 64
 */
genTextInd():string|null
genTextInd(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
genTextInd(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * General informat detailing the transit instruction for the airspace control means.
 * Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
 * Constraints: Minimum length = 0, Maximum length = 128
 */
freeText():string|null
freeText(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
freeText(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startAirspaceControlMeans_Abridged(builder:flatbuffers.Builder) {
  builder.startObject(29);
}

static addCmType(builder:flatbuffers.Builder, cmTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, cmTypeOffset, 0);
}

static addCmId(builder:flatbuffers.Builder, cmIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, cmIdOffset, 0);
}

static addCmShape(builder:flatbuffers.Builder, cmShape:AirspaceControlMeans_Abridged_cmShape_Enum) {
  builder.addFieldInt8(2, cmShape, AirspaceControlMeans_Abridged_cmShape_Enum.POLYARC);
}

static addUsage(builder:flatbuffers.Builder, usageOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, usageOffset, 0);
}

static addLink16Id(builder:flatbuffers.Builder, link16IdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, link16IdOffset, 0);
}

static addTransAltitude(builder:flatbuffers.Builder, transAltitudeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, transAltitudeOffset, 0);
}

static addGeoDatumAlt(builder:flatbuffers.Builder, geoDatumAltOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, geoDatumAltOffset, 0);
}

static addCoord0(builder:flatbuffers.Builder, coord0Offset:flatbuffers.Offset) {
  builder.addFieldOffset(7, coord0Offset, 0);
}

static addCoord1(builder:flatbuffers.Builder, coord1Offset:flatbuffers.Offset) {
  builder.addFieldOffset(8, coord1Offset, 0);
}

static addBearing0(builder:flatbuffers.Builder, bearing0:number) {
  builder.addFieldFloat64(9, bearing0, 0.0);
}

static addBearing1(builder:flatbuffers.Builder, bearing1:number) {
  builder.addFieldFloat64(10, bearing1, 0.0);
}

static addRadMag0(builder:flatbuffers.Builder, radMag0:number) {
  builder.addFieldFloat64(11, radMag0, 0.0);
}

static addRadMag1(builder:flatbuffers.Builder, radMag1:number) {
  builder.addFieldFloat64(12, radMag1, 0.0);
}

static addRadMagUnit(builder:flatbuffers.Builder, radMagUnitOffset:flatbuffers.Offset) {
  builder.addFieldOffset(13, radMagUnitOffset, 0);
}

static addPolyCoord(builder:flatbuffers.Builder, polyCoordOffset:flatbuffers.Offset) {
  builder.addFieldOffset(14, polyCoordOffset, 0);
}

static createPolyCoordVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startPolyCoordVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addTrackLeg(builder:flatbuffers.Builder, trackLeg:number) {
  builder.addFieldInt32(15, trackLeg, 0);
}

static addWidthLeft(builder:flatbuffers.Builder, widthLeft:number) {
  builder.addFieldFloat64(16, widthLeft, 0.0);
}

static addWidthRight(builder:flatbuffers.Builder, widthRight:number) {
  builder.addFieldFloat64(17, widthRight, 0.0);
}

static addWidth(builder:flatbuffers.Builder, width:number) {
  builder.addFieldFloat64(18, width, 0.0);
}

static addWidthUnit(builder:flatbuffers.Builder, widthUnitOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, widthUnitOffset, 0);
}

static addCorrWayPoints(builder:flatbuffers.Builder, corrWayPointsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, corrWayPointsOffset, 0);
}

static createCorrWayPointsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startCorrWayPointsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addOrbitAlignment(builder:flatbuffers.Builder, orbitAlignmentOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, orbitAlignmentOffset, 0);
}

static addEffVdim(builder:flatbuffers.Builder, effVdimOffset:flatbuffers.Offset) {
  builder.addFieldOffset(22, effVdimOffset, 0);
}

static addAirspaceTimePeriod(builder:flatbuffers.Builder, airspaceTimePeriodOffset:flatbuffers.Offset) {
  builder.addFieldOffset(23, airspaceTimePeriodOffset, 0);
}

static createAirspaceTimePeriodVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAirspaceTimePeriodVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addAirspaceControlPoint(builder:flatbuffers.Builder, airspaceControlPointOffset:flatbuffers.Offset) {
  builder.addFieldOffset(24, airspaceControlPointOffset, 0);
}

static createAirspaceControlPointVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startAirspaceControlPointVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addCtrlAuth(builder:flatbuffers.Builder, ctrlAuthOffset:flatbuffers.Offset) {
  builder.addFieldOffset(25, ctrlAuthOffset, 0);
}

static addCtrlAuthFreqs(builder:flatbuffers.Builder, ctrlAuthFreqsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(26, ctrlAuthFreqsOffset, 0);
}

static createCtrlAuthFreqsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startCtrlAuthFreqsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addGenTextInd(builder:flatbuffers.Builder, genTextIndOffset:flatbuffers.Offset) {
  builder.addFieldOffset(27, genTextIndOffset, 0);
}

static addFreeText(builder:flatbuffers.Builder, freeTextOffset:flatbuffers.Offset) {
  builder.addFieldOffset(28, freeTextOffset, 0);
}

static endAirspaceControlMeans_Abridged(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishAirspaceControlMeans_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'AIRS');
}

static finishSizePrefixedAirspaceControlMeans_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'AIRS', true);
}

static createAirspaceControlMeans_Abridged(builder:flatbuffers.Builder, cmTypeOffset:flatbuffers.Offset, cmIdOffset:flatbuffers.Offset, cmShape:AirspaceControlMeans_Abridged_cmShape_Enum, usageOffset:flatbuffers.Offset, link16IdOffset:flatbuffers.Offset, transAltitudeOffset:flatbuffers.Offset, geoDatumAltOffset:flatbuffers.Offset, coord0Offset:flatbuffers.Offset, coord1Offset:flatbuffers.Offset, bearing0:number, bearing1:number, radMag0:number, radMag1:number, radMagUnitOffset:flatbuffers.Offset, polyCoordOffset:flatbuffers.Offset, trackLeg:number, widthLeft:number, widthRight:number, width:number, widthUnitOffset:flatbuffers.Offset, corrWayPointsOffset:flatbuffers.Offset, orbitAlignmentOffset:flatbuffers.Offset, effVdimOffset:flatbuffers.Offset, airspaceTimePeriodOffset:flatbuffers.Offset, airspaceControlPointOffset:flatbuffers.Offset, ctrlAuthOffset:flatbuffers.Offset, ctrlAuthFreqsOffset:flatbuffers.Offset, genTextIndOffset:flatbuffers.Offset, freeTextOffset:flatbuffers.Offset):flatbuffers.Offset {
  AirspaceControlMeans_Abridged.startAirspaceControlMeans_Abridged(builder);
  AirspaceControlMeans_Abridged.addCmType(builder, cmTypeOffset);
  AirspaceControlMeans_Abridged.addCmId(builder, cmIdOffset);
  AirspaceControlMeans_Abridged.addCmShape(builder, cmShape);
  AirspaceControlMeans_Abridged.addUsage(builder, usageOffset);
  AirspaceControlMeans_Abridged.addLink16Id(builder, link16IdOffset);
  AirspaceControlMeans_Abridged.addTransAltitude(builder, transAltitudeOffset);
  AirspaceControlMeans_Abridged.addGeoDatumAlt(builder, geoDatumAltOffset);
  AirspaceControlMeans_Abridged.addCoord0(builder, coord0Offset);
  AirspaceControlMeans_Abridged.addCoord1(builder, coord1Offset);
  AirspaceControlMeans_Abridged.addBearing0(builder, bearing0);
  AirspaceControlMeans_Abridged.addBearing1(builder, bearing1);
  AirspaceControlMeans_Abridged.addRadMag0(builder, radMag0);
  AirspaceControlMeans_Abridged.addRadMag1(builder, radMag1);
  AirspaceControlMeans_Abridged.addRadMagUnit(builder, radMagUnitOffset);
  AirspaceControlMeans_Abridged.addPolyCoord(builder, polyCoordOffset);
  AirspaceControlMeans_Abridged.addTrackLeg(builder, trackLeg);
  AirspaceControlMeans_Abridged.addWidthLeft(builder, widthLeft);
  AirspaceControlMeans_Abridged.addWidthRight(builder, widthRight);
  AirspaceControlMeans_Abridged.addWidth(builder, width);
  AirspaceControlMeans_Abridged.addWidthUnit(builder, widthUnitOffset);
  AirspaceControlMeans_Abridged.addCorrWayPoints(builder, corrWayPointsOffset);
  AirspaceControlMeans_Abridged.addOrbitAlignment(builder, orbitAlignmentOffset);
  AirspaceControlMeans_Abridged.addEffVdim(builder, effVdimOffset);
  AirspaceControlMeans_Abridged.addAirspaceTimePeriod(builder, airspaceTimePeriodOffset);
  AirspaceControlMeans_Abridged.addAirspaceControlPoint(builder, airspaceControlPointOffset);
  AirspaceControlMeans_Abridged.addCtrlAuth(builder, ctrlAuthOffset);
  AirspaceControlMeans_Abridged.addCtrlAuthFreqs(builder, ctrlAuthFreqsOffset);
  AirspaceControlMeans_Abridged.addGenTextInd(builder, genTextIndOffset);
  AirspaceControlMeans_Abridged.addFreeText(builder, freeTextOffset);
  return AirspaceControlMeans_Abridged.endAirspaceControlMeans_Abridged(builder);
}

unpack(): AirspaceControlMeans_AbridgedT {
  return new AirspaceControlMeans_AbridgedT(
    this.cmType(),
    this.cmId(),
    this.cmShape(),
    this.usage(),
    this.link16Id(),
    this.transAltitude(),
    this.geoDatumAlt(),
    this.coord0(),
    this.coord1(),
    this.bearing0(),
    this.bearing1(),
    this.radMag0(),
    this.radMag1(),
    this.radMagUnit(),
    this.bb!.createScalarList<string>(this.polyCoord.bind(this), this.polyCoord_Length()),
    this.trackLeg(),
    this.widthLeft(),
    this.widthRight(),
    this.width(),
    this.widthUnit(),
    this.bb!.createScalarList<string>(this.corrWayPoints.bind(this), this.corrWayPoints_Length()),
    this.orbitAlignment(),
    this.effVdim(),
    this.bb!.createScalarList<string>(this.airspaceTimePeriod.bind(this), this.airspaceTimePeriod_Length()),
    this.bb!.createScalarList<string>(this.airspaceControlPoint.bind(this), this.airspaceControlPoint_Length()),
    this.ctrlAuth(),
    this.bb!.createScalarList<string>(this.ctrlAuthFreqs.bind(this), this.ctrlAuthFreqs_Length()),
    this.genTextInd(),
    this.freeText()
  );
}


unpackTo(_o: AirspaceControlMeans_AbridgedT): void {
  _o.cmType = this.cmType();
  _o.cmId = this.cmId();
  _o.cmShape = this.cmShape();
  _o.usage = this.usage();
  _o.link16Id = this.link16Id();
  _o.transAltitude = this.transAltitude();
  _o.geoDatumAlt = this.geoDatumAlt();
  _o.coord0 = this.coord0();
  _o.coord1 = this.coord1();
  _o.bearing0 = this.bearing0();
  _o.bearing1 = this.bearing1();
  _o.radMag0 = this.radMag0();
  _o.radMag1 = this.radMag1();
  _o.radMagUnit = this.radMagUnit();
  _o.polyCoord = this.bb!.createScalarList<string>(this.polyCoord.bind(this), this.polyCoord_Length());
  _o.trackLeg = this.trackLeg();
  _o.widthLeft = this.widthLeft();
  _o.widthRight = this.widthRight();
  _o.width = this.width();
  _o.widthUnit = this.widthUnit();
  _o.corrWayPoints = this.bb!.createScalarList<string>(this.corrWayPoints.bind(this), this.corrWayPoints_Length());
  _o.orbitAlignment = this.orbitAlignment();
  _o.effVDim = this.effVdim();
  _o.airspaceTimePeriod = this.bb!.createScalarList<string>(this.airspaceTimePeriod.bind(this), this.airspaceTimePeriod_Length());
  _o.airspaceControlPoint = this.bb!.createScalarList<string>(this.airspaceControlPoint.bind(this), this.airspaceControlPoint_Length());
  _o.ctrlAuth = this.ctrlAuth();
  _o.ctrlAuthFreqs = this.bb!.createScalarList<string>(this.ctrlAuthFreqs.bind(this), this.ctrlAuthFreqs_Length());
  _o.genTextInd = this.genTextInd();
  _o.freeText = this.freeText();
}
}

export class AirspaceControlMeans_AbridgedT implements flatbuffers.IGeneratedObject {
constructor(
  public cmType: string|Uint8Array|null = null,
  public cmId: string|Uint8Array|null = null,
  public cmShape: AirspaceControlMeans_Abridged_cmShape_Enum = AirspaceControlMeans_Abridged_cmShape_Enum.POLYARC,
  public usage: string|Uint8Array|null = null,
  public link16Id: string|Uint8Array|null = null,
  public transAltitude: string|Uint8Array|null = null,
  public geoDatumAlt: string|Uint8Array|null = null,
  public coord0: string|Uint8Array|null = null,
  public coord1: string|Uint8Array|null = null,
  public bearing0: number = 0.0,
  public bearing1: number = 0.0,
  public radMag0: number = 0.0,
  public radMag1: number = 0.0,
  public radMagUnit: string|Uint8Array|null = null,
  public polyCoord: (string)[] = [],
  public trackLeg: number = 0,
  public widthLeft: number = 0.0,
  public widthRight: number = 0.0,
  public width: number = 0.0,
  public widthUnit: string|Uint8Array|null = null,
  public corrWayPoints: (string)[] = [],
  public orbitAlignment: string|Uint8Array|null = null,
  public effVDim: string|Uint8Array|null = null,
  public airspaceTimePeriod: (string)[] = [],
  public airspaceControlPoint: (string)[] = [],
  public ctrlAuth: string|Uint8Array|null = null,
  public ctrlAuthFreqs: (string)[] = [],
  public genTextInd: string|Uint8Array|null = null,
  public freeText: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const cmType = (this.cmType !== null ? builder.createString(this.cmType!) : 0);
  const cmId = (this.cmId !== null ? builder.createString(this.cmId!) : 0);
  const usage = (this.usage !== null ? builder.createString(this.usage!) : 0);
  const link16Id = (this.link16Id !== null ? builder.createString(this.link16Id!) : 0);
  const transAltitude = (this.transAltitude !== null ? builder.createString(this.transAltitude!) : 0);
  const geoDatumAlt = (this.geoDatumAlt !== null ? builder.createString(this.geoDatumAlt!) : 0);
  const coord0 = (this.coord0 !== null ? builder.createString(this.coord0!) : 0);
  const coord1 = (this.coord1 !== null ? builder.createString(this.coord1!) : 0);
  const radMagUnit = (this.radMagUnit !== null ? builder.createString(this.radMagUnit!) : 0);
  const polyCoord = AirspaceControlMeans_Abridged.createPolyCoordVector(builder, builder.createObjectOffsetList(this.polyCoord));
  const widthUnit = (this.widthUnit !== null ? builder.createString(this.widthUnit!) : 0);
  const corrWayPoints = AirspaceControlMeans_Abridged.createCorrWayPointsVector(builder, builder.createObjectOffsetList(this.corrWayPoints));
  const orbitAlignment = (this.orbitAlignment !== null ? builder.createString(this.orbitAlignment!) : 0);
  const effVDim = (this.effVDim !== null ? builder.createString(this.effVDim!) : 0);
  const airspaceTimePeriod = AirspaceControlMeans_Abridged.createAirspaceTimePeriodVector(builder, builder.createObjectOffsetList(this.airspaceTimePeriod));
  const airspaceControlPoint = AirspaceControlMeans_Abridged.createAirspaceControlPointVector(builder, builder.createObjectOffsetList(this.airspaceControlPoint));
  const ctrlAuth = (this.ctrlAuth !== null ? builder.createString(this.ctrlAuth!) : 0);
  const ctrlAuthFreqs = AirspaceControlMeans_Abridged.createCtrlAuthFreqsVector(builder, builder.createObjectOffsetList(this.ctrlAuthFreqs));
  const genTextInd = (this.genTextInd !== null ? builder.createString(this.genTextInd!) : 0);
  const freeText = (this.freeText !== null ? builder.createString(this.freeText!) : 0);

  return AirspaceControlMeans_Abridged.createAirspaceControlMeans_Abridged(builder,
    cmType,
    cmId,
    this.cmShape,
    usage,
    link16Id,
    transAltitude,
    geoDatumAlt,
    coord0,
    coord1,
    this.bearing0,
    this.bearing1,
    this.radMag0,
    this.radMag1,
    radMagUnit,
    polyCoord,
    this.trackLeg,
    this.widthLeft,
    this.widthRight,
    this.width,
    widthUnit,
    corrWayPoints,
    orbitAlignment,
    effVDim,
    airspaceTimePeriod,
    airspaceControlPoint,
    ctrlAuth,
    ctrlAuthFreqs,
    genTextInd,
    freeText
  );
}
}
