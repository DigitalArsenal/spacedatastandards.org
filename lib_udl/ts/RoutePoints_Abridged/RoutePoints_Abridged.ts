// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * /// Points identified within the route.
 */
export class RoutePoints_Abridged implements flatbuffers.IUnpackableObject<RoutePoints_AbridgedT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):RoutePoints_Abridged {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsRoutePoints_Abridged(bb:flatbuffers.ByteBuffer, obj?:RoutePoints_Abridged):RoutePoints_Abridged {
  return (obj || new RoutePoints_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsRoutePoints_Abridged(bb:flatbuffers.ByteBuffer, obj?:RoutePoints_Abridged):RoutePoints_Abridged {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new RoutePoints_Abridged()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('ROUT');
}

/**
 * Sequencing field for the track route. This is the identifier representing the sequence of waypoints associated to the track route.
 * Example: /// Example: 1
 * Constraints: No constraints specified.
 */
ptSequenceId():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Code representation of the point within the track route (ex. EP, EX, CP, IP, etc.).
 * Example: /// Example: EP
 * Constraints: Minimum length = 0, Maximum length = 16
 */
ptTypeCode():string|null
ptTypeCode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ptTypeCode(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The name that represents the point within the track route (ex. ENTRY POINT, EXIT POINT, CONTROL POINT, INITIAL POINT, etc.).
 * Example: /// Example: ENTRY POINT
 * Constraints: Minimum length = 0, Maximum length = 36
 */
ptTypeName():string|null
ptTypeName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
ptTypeName(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Name of a waypoint which identifies the location of the point.
 * Example: /// Example: KCHS
 * Constraints: Minimum length = 0, Maximum length = 32
 */
waypointName():string|null
waypointName(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
waypointName(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Flag indicating this is a Digital Aeronautical Flight Information File (DAFIF) point.
 * Example: /// Example: True
 * Constraints: No constraints specified.
 */
dafifPt():boolean {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
}

/**
 * WGS84 latitude of the point location, in degrees. -90 to 90 degrees (negative values south of equator).
 * Example: /// Example: 45.23
 * Constraints: No constraints specified.
 */
ptLat():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * WGS84 longitude of the point location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
 * Example: /// Example: 179.1
 * Constraints: No constraints specified.
 */
ptLon():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The magnetic declination/variation of the route point location from true north, in degrees. Positive values east of true north and negative values west of true north.
 * Example: /// Example: 7.35
 * Constraints: No constraints specified.
 */
magDec():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The length of the course from the Navigational Aid (NAVAID) in nautical miles.
 * Example: /// Example: 100.2
 * Constraints: No constraints specified.
 */
navaidLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Navigational Aid (NAVAID) identification code.
 * Example: /// Example: HTO
 * Constraints: Minimum length = 0, Maximum length = 16
 */
navaid():string|null
navaid(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
navaid(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The DoD Standard Country Code designator for the country where the route point resides. This field should be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
 * Example: /// Example: NL
 * Constraints: Minimum length = 0, Maximum length = 4
 */
countryCode():string|null
countryCode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
countryCode(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Specifies an alternate country code if the data provider code is not part of an official NAVAID Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
 * Example: /// Example: IZ
 * Constraints: Minimum length = 0, Maximum length = 16
 */
altCountryCode():string|null
altCountryCode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
altCountryCode(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The NAVAID type of this route point (ex. VOR, VORTAC, TACAN, etc.).
 * Example: /// Example: VORTAC
 * Constraints: Minimum length = 0, Maximum length = 12
 */
navaidType():string|null
navaidType(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
navaidType(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startRoutePoints_Abridged(builder:flatbuffers.Builder) {
  builder.startObject(13);
}

static addPtSequenceId(builder:flatbuffers.Builder, ptSequenceId:number) {
  builder.addFieldInt32(0, ptSequenceId, 0);
}

static addPtTypeCode(builder:flatbuffers.Builder, ptTypeCodeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, ptTypeCodeOffset, 0);
}

static addPtTypeName(builder:flatbuffers.Builder, ptTypeNameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, ptTypeNameOffset, 0);
}

static addWaypointName(builder:flatbuffers.Builder, waypointNameOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, waypointNameOffset, 0);
}

static addDafifPt(builder:flatbuffers.Builder, dafifPt:boolean) {
  builder.addFieldInt8(4, +dafifPt, +false);
}

static addPtLat(builder:flatbuffers.Builder, ptLat:number) {
  builder.addFieldFloat64(5, ptLat, 0.0);
}

static addPtLon(builder:flatbuffers.Builder, ptLon:number) {
  builder.addFieldFloat64(6, ptLon, 0.0);
}

static addMagDec(builder:flatbuffers.Builder, magDec:number) {
  builder.addFieldFloat64(7, magDec, 0.0);
}

static addNavaidLength(builder:flatbuffers.Builder, navaidLength:number) {
  builder.addFieldFloat64(8, navaidLength, 0.0);
}

static addNavaid(builder:flatbuffers.Builder, navaidOffset:flatbuffers.Offset) {
  builder.addFieldOffset(9, navaidOffset, 0);
}

static addCountryCode(builder:flatbuffers.Builder, countryCodeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, countryCodeOffset, 0);
}

static addAltCountryCode(builder:flatbuffers.Builder, altCountryCodeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(11, altCountryCodeOffset, 0);
}

static addNavaidType(builder:flatbuffers.Builder, navaidTypeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(12, navaidTypeOffset, 0);
}

static endRoutePoints_Abridged(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishRoutePoints_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'ROUT');
}

static finishSizePrefixedRoutePoints_AbridgedBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'ROUT', true);
}

static createRoutePoints_Abridged(builder:flatbuffers.Builder, ptSequenceId:number, ptTypeCodeOffset:flatbuffers.Offset, ptTypeNameOffset:flatbuffers.Offset, waypointNameOffset:flatbuffers.Offset, dafifPt:boolean, ptLat:number, ptLon:number, magDec:number, navaidLength:number, navaidOffset:flatbuffers.Offset, countryCodeOffset:flatbuffers.Offset, altCountryCodeOffset:flatbuffers.Offset, navaidTypeOffset:flatbuffers.Offset):flatbuffers.Offset {
  RoutePoints_Abridged.startRoutePoints_Abridged(builder);
  RoutePoints_Abridged.addPtSequenceId(builder, ptSequenceId);
  RoutePoints_Abridged.addPtTypeCode(builder, ptTypeCodeOffset);
  RoutePoints_Abridged.addPtTypeName(builder, ptTypeNameOffset);
  RoutePoints_Abridged.addWaypointName(builder, waypointNameOffset);
  RoutePoints_Abridged.addDafifPt(builder, dafifPt);
  RoutePoints_Abridged.addPtLat(builder, ptLat);
  RoutePoints_Abridged.addPtLon(builder, ptLon);
  RoutePoints_Abridged.addMagDec(builder, magDec);
  RoutePoints_Abridged.addNavaidLength(builder, navaidLength);
  RoutePoints_Abridged.addNavaid(builder, navaidOffset);
  RoutePoints_Abridged.addCountryCode(builder, countryCodeOffset);
  RoutePoints_Abridged.addAltCountryCode(builder, altCountryCodeOffset);
  RoutePoints_Abridged.addNavaidType(builder, navaidTypeOffset);
  return RoutePoints_Abridged.endRoutePoints_Abridged(builder);
}

unpack(): RoutePoints_AbridgedT {
  return new RoutePoints_AbridgedT(
    this.ptSequenceId(),
    this.ptTypeCode(),
    this.ptTypeName(),
    this.waypointName(),
    this.dafifPt(),
    this.ptLat(),
    this.ptLon(),
    this.magDec(),
    this.navaidLength(),
    this.navaid(),
    this.countryCode(),
    this.altCountryCode(),
    this.navaidType()
  );
}


unpackTo(_o: RoutePoints_AbridgedT): void {
  _o.ptSequenceId = this.ptSequenceId();
  _o.ptTypeCode = this.ptTypeCode();
  _o.ptTypeName = this.ptTypeName();
  _o.waypointName = this.waypointName();
  _o.dafifPt = this.dafifPt();
  _o.ptLat = this.ptLat();
  _o.ptLon = this.ptLon();
  _o.magDec = this.magDec();
  _o.navaidLength = this.navaidLength();
  _o.navaid = this.navaid();
  _o.countryCode = this.countryCode();
  _o.altCountryCode = this.altCountryCode();
  _o.navaidType = this.navaidType();
}
}

export class RoutePoints_AbridgedT implements flatbuffers.IGeneratedObject {
constructor(
  public ptSequenceId: number = 0,
  public ptTypeCode: string|Uint8Array|null = null,
  public ptTypeName: string|Uint8Array|null = null,
  public waypointName: string|Uint8Array|null = null,
  public dafifPt: boolean = false,
  public ptLat: number = 0.0,
  public ptLon: number = 0.0,
  public magDec: number = 0.0,
  public navaidLength: number = 0.0,
  public navaid: string|Uint8Array|null = null,
  public countryCode: string|Uint8Array|null = null,
  public altCountryCode: string|Uint8Array|null = null,
  public navaidType: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const ptTypeCode = (this.ptTypeCode !== null ? builder.createString(this.ptTypeCode!) : 0);
  const ptTypeName = (this.ptTypeName !== null ? builder.createString(this.ptTypeName!) : 0);
  const waypointName = (this.waypointName !== null ? builder.createString(this.waypointName!) : 0);
  const navaid = (this.navaid !== null ? builder.createString(this.navaid!) : 0);
  const countryCode = (this.countryCode !== null ? builder.createString(this.countryCode!) : 0);
  const altCountryCode = (this.altCountryCode !== null ? builder.createString(this.altCountryCode!) : 0);
  const navaidType = (this.navaidType !== null ? builder.createString(this.navaidType!) : 0);

  return RoutePoints_Abridged.createRoutePoints_Abridged(builder,
    this.ptSequenceId,
    ptTypeCode,
    ptTypeName,
    waypointName,
    this.dafifPt,
    this.ptLat,
    this.ptLon,
    this.magDec,
    this.navaidLength,
    navaid,
    countryCode,
    altCountryCode,
    navaidType
  );
}
}
