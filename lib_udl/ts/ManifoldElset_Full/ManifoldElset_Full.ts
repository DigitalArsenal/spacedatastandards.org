// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { ManifoldElset_Full_dataMode_Enum } from './ManifoldElset_Full_dataMode_Enum.js';


/**
 * /// Theoretical Keplarian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
 */
export class ManifoldElset_Full implements flatbuffers.IUnpackableObject<ManifoldElset_FullT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):ManifoldElset_Full {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsManifoldElset_Full(bb:flatbuffers.ByteBuffer, obj?:ManifoldElset_Full):ManifoldElset_Full {
  return (obj || new ManifoldElset_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsManifoldElset_Full(bb:flatbuffers.ByteBuffer, obj?:ManifoldElset_Full):ManifoldElset_Full {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new ManifoldElset_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('MANI');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: MANIFOLDELSET-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Identifier of the parent Manifold record.
 * Example: /// Example: REF-MANIFOLD-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
idManifold():string|null
idManifold(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idManifold(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * A placeholder satellite number and not a true NORAD catalog number.
 * Example: /// Example: 10
 * Constraints: No constraints specified.
 */
tmpSatNo():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Elset epoch time in ISO 8601 UTC format, with microsecond precision.
 * Example: /// Example: 2021-01-01T01:01:01.123456Z
 * Constraints: No constraints specified.
 */
epoch():string|null
epoch(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
epoch(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The constant angular speed required for the body to complete one circular orbit in the same amount of time as the actual elliptical orbit with variable speed. Measured in revolutions per day.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
meanMotion():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle. A value of 0 is a circular orbit, values between 0 and 1 form an elliptic orbit, 1 is a parabolic escape orbit, and greater than 1 is a hyperbolic escape orbit.
 * Example: /// Example: 0.5
 * Constraints: No constraints specified.
 */
eccentricity():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The angle between the equator and the orbit when looking from the center of the Earth. If the orbit went exactly around the equator from left to right, then the inclination would be 0. The inclination ranges from 0 to 180 degrees.
 * Example: /// Example: 90.23
 * Constraints: No constraints specified.
 */
inclination():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node, which is where the orbit crosses the equator when traveling north.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
raan():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The argument of perigee is the angle in degrees formed between the perigee and the ascending node. If the perigee would occur at the ascending node, the argument of perigee would be 0.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
argOfPerigee():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Where the satellite is in its orbital path. The mean anomaly ranges from 0 to 360 degrees. The mean anomaly is referenced to the perigee. If the satellite were at the perigee, the mean anomaly would be 0.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
meanAnomaly():number {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The current revolution number. The value is incremented when a satellite crosses the equator on an ascending pass.
 * Example: /// Example: 123
 * Constraints: No constraints specified.
 */
revNo():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * The drag term for SGP4 orbital model, used for calculating decay constants for altitude, eccentricity etc, measured in inverse earth radii.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
bStar():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * 1st derivative of the mean motion with respect to time. Units are revolutions per day squared.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
meanMotionDot():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * 2nd derivative of the mean motion with respect to time. Units are revolutions per day cubed.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
meanMotionDdot():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The sum of the periapsis and apoapsis distances divided by two. For circular orbits, the semimajor axis is the distance between the centers of the bodies, not the distance of the bodies from the center of mass.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
semiMajorAxis():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Period of the orbit equal to inverse of mean motion.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
period():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The Orbit point furthest from the center of the earth in kilometers.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
apogee():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * The orbit point nearest to the center of the earth in kilometers.
 * Example: /// Example: 10.23
 * Constraints: No constraints specified.
 */
perigee():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Read only derived/generated line1 of a legacy TLE (two line element set) format, ignored on create/edit operations.
 * Example: /// Example: No example provided.
 * Constraints: Minimum length = 0, Maximum length = 69
 */
line1():string|null
line1(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
line1(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Read only derived/generated line2 of a legacy TLE (two line element set) format, ignored on create/edit operations.
 * Example: /// Example: No example provided.
 * Constraints: Minimum length = 0, Maximum length = 69
 */
line2():string|null
line2(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
line2(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Time the row was created in the database, auto-populated by the system.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database, auto-populated by the system.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Read-only time the row was updated in the database, set automatically by the system on update.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
updatedAt():string|null
updatedAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
updatedAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who last updated the row in the database, set by the system automatically and ignored on create/edit operations.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 0, Maximum length = 64
 */
updatedBy():string|null
updatedBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
updatedBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 64
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 * Example: /// Example: THIRD_PARTY_DATASOURCE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():ManifoldElset_Full_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : ManifoldElset_Full_dataMode_Enum.REAL;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: ORIG
 * Constraints: Minimum length = 0, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

static startManifoldElset_Full(builder:flatbuffers.Builder) {
  builder.startObject(29);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addIdManifold(builder:flatbuffers.Builder, idManifoldOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, idManifoldOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, classificationMarkingOffset, 0);
}

static addTmpSatNo(builder:flatbuffers.Builder, tmpSatNo:number) {
  builder.addFieldInt32(3, tmpSatNo, 0);
}

static addEpoch(builder:flatbuffers.Builder, epochOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, epochOffset, 0);
}

static addMeanMotion(builder:flatbuffers.Builder, meanMotion:number) {
  builder.addFieldFloat64(5, meanMotion, 0.0);
}

static addEccentricity(builder:flatbuffers.Builder, eccentricity:number) {
  builder.addFieldFloat64(6, eccentricity, 0.0);
}

static addInclination(builder:flatbuffers.Builder, inclination:number) {
  builder.addFieldFloat64(7, inclination, 0.0);
}

static addRaan(builder:flatbuffers.Builder, raan:number) {
  builder.addFieldFloat64(8, raan, 0.0);
}

static addArgOfPerigee(builder:flatbuffers.Builder, argOfPerigee:number) {
  builder.addFieldFloat64(9, argOfPerigee, 0.0);
}

static addMeanAnomaly(builder:flatbuffers.Builder, meanAnomaly:number) {
  builder.addFieldFloat64(10, meanAnomaly, 0.0);
}

static addRevNo(builder:flatbuffers.Builder, revNo:number) {
  builder.addFieldInt32(11, revNo, 0);
}

static addBStar(builder:flatbuffers.Builder, bStar:number) {
  builder.addFieldFloat64(12, bStar, 0.0);
}

static addMeanMotionDot(builder:flatbuffers.Builder, meanMotionDot:number) {
  builder.addFieldFloat64(13, meanMotionDot, 0.0);
}

static addMeanMotionDdot(builder:flatbuffers.Builder, meanMotionDdot:number) {
  builder.addFieldFloat64(14, meanMotionDdot, 0.0);
}

static addSemiMajorAxis(builder:flatbuffers.Builder, semiMajorAxis:number) {
  builder.addFieldFloat64(15, semiMajorAxis, 0.0);
}

static addPeriod(builder:flatbuffers.Builder, period:number) {
  builder.addFieldFloat64(16, period, 0.0);
}

static addApogee(builder:flatbuffers.Builder, apogee:number) {
  builder.addFieldFloat64(17, apogee, 0.0);
}

static addPerigee(builder:flatbuffers.Builder, perigee:number) {
  builder.addFieldFloat64(18, perigee, 0.0);
}

static addLine1(builder:flatbuffers.Builder, line1Offset:flatbuffers.Offset) {
  builder.addFieldOffset(19, line1Offset, 0);
}

static addLine2(builder:flatbuffers.Builder, line2Offset:flatbuffers.Offset) {
  builder.addFieldOffset(20, line2Offset, 0);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(22, createdByOffset, 0);
}

static addUpdatedAt(builder:flatbuffers.Builder, updatedAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(23, updatedAtOffset, 0);
}

static addUpdatedBy(builder:flatbuffers.Builder, updatedByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(24, updatedByOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(25, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(26, originOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:ManifoldElset_Full_dataMode_Enum) {
  builder.addFieldInt8(27, dataMode, ManifoldElset_Full_dataMode_Enum.REAL);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(28, origNetworkOffset, 0);
}

static endManifoldElset_Full(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishManifoldElset_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'MANI');
}

static finishSizePrefixedManifoldElset_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'MANI', true);
}

static createManifoldElset_Full(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, idManifoldOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, tmpSatNo:number, epochOffset:flatbuffers.Offset, meanMotion:number, eccentricity:number, inclination:number, raan:number, argOfPerigee:number, meanAnomaly:number, revNo:number, bStar:number, meanMotionDot:number, meanMotionDdot:number, semiMajorAxis:number, period:number, apogee:number, perigee:number, line1Offset:flatbuffers.Offset, line2Offset:flatbuffers.Offset, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, updatedAtOffset:flatbuffers.Offset, updatedByOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, dataMode:ManifoldElset_Full_dataMode_Enum, origNetworkOffset:flatbuffers.Offset):flatbuffers.Offset {
  ManifoldElset_Full.startManifoldElset_Full(builder);
  ManifoldElset_Full.addId(builder, idOffset);
  ManifoldElset_Full.addIdManifold(builder, idManifoldOffset);
  ManifoldElset_Full.addClassificationMarking(builder, classificationMarkingOffset);
  ManifoldElset_Full.addTmpSatNo(builder, tmpSatNo);
  ManifoldElset_Full.addEpoch(builder, epochOffset);
  ManifoldElset_Full.addMeanMotion(builder, meanMotion);
  ManifoldElset_Full.addEccentricity(builder, eccentricity);
  ManifoldElset_Full.addInclination(builder, inclination);
  ManifoldElset_Full.addRaan(builder, raan);
  ManifoldElset_Full.addArgOfPerigee(builder, argOfPerigee);
  ManifoldElset_Full.addMeanAnomaly(builder, meanAnomaly);
  ManifoldElset_Full.addRevNo(builder, revNo);
  ManifoldElset_Full.addBStar(builder, bStar);
  ManifoldElset_Full.addMeanMotionDot(builder, meanMotionDot);
  ManifoldElset_Full.addMeanMotionDdot(builder, meanMotionDdot);
  ManifoldElset_Full.addSemiMajorAxis(builder, semiMajorAxis);
  ManifoldElset_Full.addPeriod(builder, period);
  ManifoldElset_Full.addApogee(builder, apogee);
  ManifoldElset_Full.addPerigee(builder, perigee);
  ManifoldElset_Full.addLine1(builder, line1Offset);
  ManifoldElset_Full.addLine2(builder, line2Offset);
  ManifoldElset_Full.addCreatedAt(builder, createdAtOffset);
  ManifoldElset_Full.addCreatedBy(builder, createdByOffset);
  ManifoldElset_Full.addUpdatedAt(builder, updatedAtOffset);
  ManifoldElset_Full.addUpdatedBy(builder, updatedByOffset);
  ManifoldElset_Full.addSource(builder, sourceOffset);
  ManifoldElset_Full.addOrigin(builder, originOffset);
  ManifoldElset_Full.addDataMode(builder, dataMode);
  ManifoldElset_Full.addOrigNetwork(builder, origNetworkOffset);
  return ManifoldElset_Full.endManifoldElset_Full(builder);
}

unpack(): ManifoldElset_FullT {
  return new ManifoldElset_FullT(
    this.id(),
    this.idManifold(),
    this.classificationMarking(),
    this.tmpSatNo(),
    this.epoch(),
    this.meanMotion(),
    this.eccentricity(),
    this.inclination(),
    this.raan(),
    this.argOfPerigee(),
    this.meanAnomaly(),
    this.revNo(),
    this.bStar(),
    this.meanMotionDot(),
    this.meanMotionDdot(),
    this.semiMajorAxis(),
    this.period(),
    this.apogee(),
    this.perigee(),
    this.line1(),
    this.line2(),
    this.createdAt(),
    this.createdBy(),
    this.updatedAt(),
    this.updatedBy(),
    this.source(),
    this.origin(),
    this.dataMode(),
    this.origNetwork()
  );
}


unpackTo(_o: ManifoldElset_FullT): void {
  _o.id = this.id();
  _o.idManifold = this.idManifold();
  _o.classificationMarking = this.classificationMarking();
  _o.tmpSatNo = this.tmpSatNo();
  _o.epoch = this.epoch();
  _o.meanMotion = this.meanMotion();
  _o.eccentricity = this.eccentricity();
  _o.inclination = this.inclination();
  _o.raan = this.raan();
  _o.argOfPerigee = this.argOfPerigee();
  _o.meanAnomaly = this.meanAnomaly();
  _o.revNo = this.revNo();
  _o.bStar = this.bStar();
  _o.meanMotionDot = this.meanMotionDot();
  _o.meanMotionDdot = this.meanMotionDdot();
  _o.semiMajorAxis = this.semiMajorAxis();
  _o.period = this.period();
  _o.apogee = this.apogee();
  _o.perigee = this.perigee();
  _o.line1 = this.line1();
  _o.line2 = this.line2();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.updatedAt = this.updatedAt();
  _o.updatedBy = this.updatedBy();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.dataMode = this.dataMode();
  _o.origNetwork = this.origNetwork();
}
}

export class ManifoldElset_FullT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public idManifold: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public tmpSatNo: number = 0,
  public epoch: string|Uint8Array|null = null,
  public meanMotion: number = 0.0,
  public eccentricity: number = 0.0,
  public inclination: number = 0.0,
  public raan: number = 0.0,
  public argOfPerigee: number = 0.0,
  public meanAnomaly: number = 0.0,
  public revNo: number = 0,
  public bStar: number = 0.0,
  public meanMotionDot: number = 0.0,
  public meanMotionDdot: number = 0.0,
  public semiMajorAxis: number = 0.0,
  public period: number = 0.0,
  public apogee: number = 0.0,
  public perigee: number = 0.0,
  public line1: string|Uint8Array|null = null,
  public line2: string|Uint8Array|null = null,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public updatedAt: string|Uint8Array|null = null,
  public updatedBy: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public dataMode: ManifoldElset_Full_dataMode_Enum = ManifoldElset_Full_dataMode_Enum.REAL,
  public origNetwork: string|Uint8Array|null = null
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const idManifold = (this.idManifold !== null ? builder.createString(this.idManifold!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const epoch = (this.epoch !== null ? builder.createString(this.epoch!) : 0);
  const line1 = (this.line1 !== null ? builder.createString(this.line1!) : 0);
  const line2 = (this.line2 !== null ? builder.createString(this.line2!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const updatedAt = (this.updatedAt !== null ? builder.createString(this.updatedAt!) : 0);
  const updatedBy = (this.updatedBy !== null ? builder.createString(this.updatedBy!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);

  return ManifoldElset_Full.createManifoldElset_Full(builder,
    id,
    idManifold,
    classificationMarking,
    this.tmpSatNo,
    epoch,
    this.meanMotion,
    this.eccentricity,
    this.inclination,
    this.raan,
    this.argOfPerigee,
    this.meanAnomaly,
    this.revNo,
    this.bStar,
    this.meanMotionDot,
    this.meanMotionDdot,
    this.semiMajorAxis,
    this.period,
    this.apogee,
    this.perigee,
    line1,
    line2,
    createdAt,
    createdBy,
    updatedAt,
    updatedBy,
    source,
    origin,
    this.dataMode,
    origNetwork
  );
}
}
