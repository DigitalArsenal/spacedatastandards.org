// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * /// Objective Area Information.
 */
export class PersonnelRecoveryObjectiveAreaInfo_Full implements flatbuffers.IUnpackableObject<PersonnelRecoveryObjectiveAreaInfo_FullT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):PersonnelRecoveryObjectiveAreaInfo_Full {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsPersonnelRecoveryObjectiveAreaInfo_Full(bb:flatbuffers.ByteBuffer, obj?:PersonnelRecoveryObjectiveAreaInfo_Full):PersonnelRecoveryObjectiveAreaInfo_Full {
  return (obj || new PersonnelRecoveryObjectiveAreaInfo_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsPersonnelRecoveryObjectiveAreaInfo_Full(bb:flatbuffers.ByteBuffer, obj?:PersonnelRecoveryObjectiveAreaInfo_Full):PersonnelRecoveryObjectiveAreaInfo_Full {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new PersonnelRecoveryObjectiveAreaInfo_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('PERS');
}

/**
 * Array of the WGS-84 latitude (-90 to 90, negative values south of the equator) in degrees, longitude (-180 to 180, negative values west of Prime Meridian) in degrees, and altitude, in meters, of the pz location.  This array must contain a minimum of 2 elements (latitude and longitude), and may contain an optional 3rd element (altitude).
 * Example: /// Example: [103.23, 30.445]
 * Constraints: No constraints specified.
 */
pzLocation(index: number):string
pzLocation(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
pzLocation(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

pzLocationLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Description of the pickup zone location.
 * Example: /// Example: Near the lake.
 * Constraints: Minimum length = 0, Maximum length = 1024
 */
pzDesc():string|null
pzDesc(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
pzDesc(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The call sign of the on-scene commander.
 * Example: /// Example: STARFOX
 * Constraints: Minimum length = 0, Maximum length = 128
 */
oscCallSign():string|null
oscCallSign(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
oscCallSign(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The radio frequency of the on-scene commander.
 * Example: /// Example: 12.55
 * Constraints: No constraints specified.
 */
oscFreq():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Information detailing knowledge of enemies in the area.
 * Example: /// Example: No example provided.
 * Constraints: No constraints specified.
 */
enemyData(index: number):string
enemyData(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
enemyData(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

enemyDataLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startPersonnelRecoveryObjectiveAreaInfo_Full(builder:flatbuffers.Builder) {
  builder.startObject(5);
}

static addPzLocation(builder:flatbuffers.Builder, pzLocationOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, pzLocationOffset, 0);
}

static createPzLocationVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startPzLocationVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addPzDesc(builder:flatbuffers.Builder, pzDescOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, pzDescOffset, 0);
}

static addOscCallSign(builder:flatbuffers.Builder, oscCallSignOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, oscCallSignOffset, 0);
}

static addOscFreq(builder:flatbuffers.Builder, oscFreq:number) {
  builder.addFieldFloat64(3, oscFreq, 0.0);
}

static addEnemyData(builder:flatbuffers.Builder, enemyDataOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, enemyDataOffset, 0);
}

static createEnemyDataVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startEnemyDataVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endPersonnelRecoveryObjectiveAreaInfo_Full(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishPersonnelRecoveryObjectiveAreaInfo_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'PERS');
}

static finishSizePrefixedPersonnelRecoveryObjectiveAreaInfo_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'PERS', true);
}

static createPersonnelRecoveryObjectiveAreaInfo_Full(builder:flatbuffers.Builder, pzLocationOffset:flatbuffers.Offset, pzDescOffset:flatbuffers.Offset, oscCallSignOffset:flatbuffers.Offset, oscFreq:number, enemyDataOffset:flatbuffers.Offset):flatbuffers.Offset {
  PersonnelRecoveryObjectiveAreaInfo_Full.startPersonnelRecoveryObjectiveAreaInfo_Full(builder);
  PersonnelRecoveryObjectiveAreaInfo_Full.addPzLocation(builder, pzLocationOffset);
  PersonnelRecoveryObjectiveAreaInfo_Full.addPzDesc(builder, pzDescOffset);
  PersonnelRecoveryObjectiveAreaInfo_Full.addOscCallSign(builder, oscCallSignOffset);
  PersonnelRecoveryObjectiveAreaInfo_Full.addOscFreq(builder, oscFreq);
  PersonnelRecoveryObjectiveAreaInfo_Full.addEnemyData(builder, enemyDataOffset);
  return PersonnelRecoveryObjectiveAreaInfo_Full.endPersonnelRecoveryObjectiveAreaInfo_Full(builder);
}

unpack(): PersonnelRecoveryObjectiveAreaInfo_FullT {
  return new PersonnelRecoveryObjectiveAreaInfo_FullT(
    this.bb!.createScalarList<string>(this.pzLocation.bind(this), this.pzLocationLength()),
    this.pzDesc(),
    this.oscCallSign(),
    this.oscFreq(),
    this.bb!.createScalarList<string>(this.enemyData.bind(this), this.enemyDataLength())
  );
}


unpackTo(_o: PersonnelRecoveryObjectiveAreaInfo_FullT): void {
  _o.pzLocation = this.bb!.createScalarList<string>(this.pzLocation.bind(this), this.pzLocationLength());
  _o.pzDesc = this.pzDesc();
  _o.oscCallSign = this.oscCallSign();
  _o.oscFreq = this.oscFreq();
  _o.enemyData = this.bb!.createScalarList<string>(this.enemyData.bind(this), this.enemyDataLength());
}
}

export class PersonnelRecoveryObjectiveAreaInfo_FullT implements flatbuffers.IGeneratedObject {
constructor(
  public pzLocation: (string)[] = [],
  public pzDesc: string|Uint8Array|null = null,
  public oscCallSign: string|Uint8Array|null = null,
  public oscFreq: number = 0.0,
  public enemyData: (string)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const pzLocation = PersonnelRecoveryObjectiveAreaInfo_Full.createPzLocationVector(builder, builder.createObjectOffsetList(this.pzLocation));
  const pzDesc = (this.pzDesc !== null ? builder.createString(this.pzDesc!) : 0);
  const oscCallSign = (this.oscCallSign !== null ? builder.createString(this.oscCallSign!) : 0);
  const enemyData = PersonnelRecoveryObjectiveAreaInfo_Full.createEnemyDataVector(builder, builder.createObjectOffsetList(this.enemyData));

  return PersonnelRecoveryObjectiveAreaInfo_Full.createPersonnelRecoveryObjectiveAreaInfo_Full(builder,
    pzLocation,
    pzDesc,
    oscCallSign,
    this.oscFreq,
    enemyData
  );
}
}
