// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { WeatherData_Ingest_dataMode_Enum } from './WeatherData_Ingest_dataMode_Enum.js';


/**
 * /// These services provide for posting and querying Weather Data. Weather Data integrates dynamic data measured by Doppler/CG such as signal power and noise levels, to produce useful weather information.
 */
export class WeatherData_Ingest implements flatbuffers.IUnpackableObject<WeatherData_IngestT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):WeatherData_Ingest {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsWeatherData_Ingest(bb:flatbuffers.ByteBuffer, obj?:WeatherData_Ingest):WeatherData_Ingest {
  return (obj || new WeatherData_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsWeatherData_Ingest(bb:flatbuffers.ByteBuffer, obj?:WeatherData_Ingest):WeatherData_Ingest {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new WeatherData_Ingest()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('WEAT');
}

/**
 * Unique identifier of the record, auto-generated by the system.
 * Example: /// Example: WEATHER-DATA-ID
 * Constraints: Minimum length = 1, Maximum length = 36
 */
id():string|null
id(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
id(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Classification marking of the data in IC/CAPCO Portion-marked format.
 * Example: /// Example: U
 * Constraints: Minimum length = 1, Maximum length = 128
 */
classificationMarking():string|null
classificationMarking(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
classificationMarking(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Unique identifier of the sensor making the weather measurement.
 * Example: /// Example: 0129f577-e04c-441e-65ca-0a04a750bed9
 * Constraints: Minimum length = 0, Maximum length = 36
 */
idSensor():string|null
idSensor(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
idSensor(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Optional identifier provided by the record source. This may be an internal identifier and not necessarily a valid sensor ID.
 * Example: /// Example: ORIGSENSOR-ID
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origSensorId():string|null
origSensorId(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origSensorId(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Datetime of the weather observation in ISO 8601 UTC datetime format with microsecond precision.
 * Example: /// Example: 2018-01-01T16:00:00.123456Z
 * Constraints: No constraints specified.
 */
obTime():string|null
obTime(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
obTime(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Array of signal power(s) measured by the sensor, in decibels. Users should consult the data provider for information on the signal powers array structure.
 * Example: /// Example: [116.5, 121.6]
 * Constraints: No constraints specified.
 */
sigPwrs(index: number):string
sigPwrs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
sigPwrs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

sigPwrsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of noise level(s) measured by radar, in decibels. Users should consult the data provider for information on the noise levels array structure.
 * Example: /// Example: [58.2, 58.3]
 * Constraints: No constraints specified.
 */
noiseLvls(index: number):string
noiseLvls(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
noiseLvls(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

noiseLvlsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of width(s) of the distribution in Doppler velocity measured by radar, in meters/second. Spectral width depends on the particle size distribution, the wind shear across the radar beam, and turbulence. Users should consult the data provider for information on the spectral widths array structure.
 * Example: /// Example: [0.3, 0.6]
 * Constraints: No constraints specified.
 */
specWidths(index: number):string
specWidths(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
specWidths(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

specWidthsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 18);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of average maximum number(s) of consecutive instances in which the same first guess velocity is used in radar data processing to estimate wind speed. Users should consult the data provider for information on the first guess averages array structure.
 * Example: /// Example: [16, 1]
 * Constraints: No constraints specified.
 */
firstGuessAvgs(index: number):string
firstGuessAvgs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
firstGuessAvgs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

firstGuessAvgsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 20);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Quality control flag value, as defined by the data provider.
 * Example: /// Example: 4
 * Constraints: No constraints specified.
 */
qcValue():number {
  const offset = this.bb!.__offset(this.bb_pos, 22);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Datetime the system files were created.
 * Example: /// Example: 2018-01-01T16:00:00.123456Z
 * Constraints: No constraints specified.
 */
fileCreation():string|null
fileCreation(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
fileCreation(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 24);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Last altitude with recorded measurements in this record, in meters.
 * Example: /// Example: 19505.1
 * Constraints: No constraints specified.
 */
termAlt():number {
  const offset = this.bb!.__offset(this.bb_pos, 26);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Average transmitted power of the radar, in kilowatts.
 * Example: /// Example: 20.23
 * Constraints: No constraints specified.
 */
avgTxPwr():number {
  const offset = this.bb!.__offset(this.bb_pos, 28);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Average power of the reflected signal received by the radar, in Watts.
 * Example: /// Example: 714.9
 * Constraints: No constraints specified.
 */
avgRefPwr():number {
  const offset = this.bb!.__offset(this.bb_pos, 30);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Number of sectors within the radar coverage area, each containing a number of antennas.
 * Example: /// Example: 20
 * Constraints: No constraints specified.
 */
sectorNum():number {
  const offset = this.bb!.__offset(this.bb_pos, 32);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Number of antennas across all sectors within the radar coverage area.
 * Example: /// Example: 640
 * Constraints: No constraints specified.
 */
numElements():number {
  const offset = this.bb!.__offset(this.bb_pos, 34);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Array of the number(s) of radar samples used in time domain averaging for radar data processing. Time domain averaging improves the quality of the measured signal by reducing random noise and enhancing the signal-to-noise ratio. Users should consult the data provider for information on the time domain sample numbers array structure.
 * Example: /// Example: [32, 30]
 * Constraints: No constraints specified.
 */
tdAvgSampleNums(index: number):string
tdAvgSampleNums(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
tdAvgSampleNums(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

tdAvgSampleNumsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 36);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Checksum value for the data.
 * Example: /// Example: 133
 * Constraints: No constraints specified.
 */
checksum():number {
  const offset = this.bb!.__offset(this.bb_pos, 38);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Array of the number(s) of measurements used in coherent integrations used for radar data processing. Users should consult the data provider for information on the coherent integrations array structure.
 * Example: /// Example: [4, 3]
 * Constraints: No constraints specified.
 */
coIntegs(index: number):string
coIntegs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
coIntegs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

coIntegsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 40);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of the number(s) of spectral averages used in radar data processing. Users should consult the data provider for information on the spectral averages array structure.
 * Example: /// Example: [4, 3]
 * Constraints: No constraints specified.
 */
specAvgs(index: number):string
specAvgs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
specAvgs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

specAvgsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 42);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of the elapsed time(s) from the beginning of one pulse to the beginning of the next pulse for a radar beam, in microseconds. Users should consult the data provider for information on the interpulse periods array structure.
 * Example: /// Example: [1000.3, 1000.2]
 * Constraints: No constraints specified.
 */
interpulsePeriods(index: number):string
interpulsePeriods(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
interpulsePeriods(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

interpulsePeriodsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 44);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of full scale Nyquist Doppler velocities measured by radar, in meters per second. Nyquist velocity refers to the maximum velocity magnitude that the radar system can unambiguously detect. Doppler velocities with absolute values exceeding the Nyquist threshold suffer from aliasing at the time of collection. Users should consult the data provider for information on the doppler velocities array structure.
 * Example: /// Example: [44.4, 467.3]
 * Constraints: No constraints specified.
 */
doppVels(index: number):string
doppVels(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
doppVels(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

doppVelsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 46);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of the number(s) of records in consensus for a radar beam. Users should consult the data provider for information on the consensus records array structure.
 * Example: /// Example: [5, 2]
 * Constraints: No constraints specified.
 */
consRecs(index: number):string
consRecs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
consRecs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

consRecsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 48);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of signal to noise ratio(s) for a radar beam, in decibels. Users should consult the data provider for information on the signal to noise ratios array structure.
 * Example: /// Example: [14.5, -16.2]
 * Constraints: No constraints specified.
 */
snrs(index: number):string
snrs(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
snrs(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

snrsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 50);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Signal strength of the electromagnetic energy received due to a lightning event, in kiloamps.
 * Example: /// Example: 163.7
 * Constraints: No constraints specified.
 */
sigStrength():number {
  const offset = this.bb!.__offset(this.bb_pos, 52);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Semi-major axis of the 50% positional confidence ellipse, in kilometers.
 * Example: /// Example: 3.4
 * Constraints: No constraints specified.
 */
semiMajorAxis():number {
  const offset = this.bb!.__offset(this.bb_pos, 54);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Semi-minor axis of the 50% positional confidence ellipse, in kilometers.
 * Example: /// Example: 0.3
 * Constraints: No constraints specified.
 */
semiMinorAxis():number {
  const offset = this.bb!.__offset(this.bb_pos, 56);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Angle of orientation of the 50% positional confidence ellipse, in degrees clockwise from true north.
 * Example: /// Example: 75.7
 * Constraints: No constraints specified.
 */
angleOrientation():number {
  const offset = this.bb!.__offset(this.bb_pos, 58);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Number of sensors used in the lightning event location solution.
 * Example: /// Example: 9
 * Constraints: No constraints specified.
 */
lightEventNum():number {
  const offset = this.bb!.__offset(this.bb_pos, 60);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

/**
 * Array of sensor(s) that participated in the lightning event location determination.
 * Example: /// Example: [11, 28, 190]
 * Constraints: No constraints specified.
 */
lightDetSensors(index: number):string
lightDetSensors(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
lightDetSensors(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

lightDetSensorsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 62);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The positional confidence of the calculated lightning event location using the chi-square statistical method.
 * Example: /// Example: 0.1
 * Constraints: No constraints specified.
 */
posConfidence():number {
  const offset = this.bb!.__offset(this.bb_pos, 64);
  return offset ? this.bb!.readFloat64(this.bb_pos + offset) : 0.0;
}

/**
 * Array of UDL record types (SENSOR, WEATHERREPORT) that are related to this WeatherData record. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
 * Example: /// Example: ['SENSOR', 'WEATHERREPORT']
 * Constraints: No constraints specified.
 */
srcTyps(index: number):string
srcTyps(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
srcTyps(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

srcTypsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 66);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Array of UUID(s) of the UDL data record(s) that are related to this WeatherData record. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
 * Example: /// Example: ['1b23ba93-0957-4654-b5ca-8c3703f3ec57', '32944ee4-0437-4d94-95ce-2f2823ffa001']
 * Constraints: No constraints specified.
 */
srcIds(index: number):string
srcIds(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
srcIds(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

srcIdsLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 68);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * The originating source network on which this record was created, auto-populated by the system.
 * Example: /// Example: OPS1
 * Constraints: Minimum length = 1, Maximum length = 32
 */
origNetwork():string|null
origNetwork(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origNetwork(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 70);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Time the row was created in the database.
 * Example: /// Example: 2018-01-01T16:00:00.123Z
 * Constraints: No constraints specified.
 */
createdAt():string|null
createdAt(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdAt(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 72);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Application user who created the row in the database.
 * Example: /// Example: some.user
 * Constraints: Minimum length = 1, Maximum length = 64
 */
createdBy():string|null
createdBy(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
createdBy(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 74);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Source of the data.
 * Example: /// Example: Bluestaq
 * Constraints: Minimum length = 1, Maximum length = 36
 */
source():string|null
source(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
source(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 76);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
 * Example: /// Example: THIRD_PARTY_DATASOURCE
 * Constraints: Minimum length = 0, Maximum length = 64
 */
origin():string|null
origin(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
origin(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 78);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
 * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
 * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
 * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
 * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
 * Example: /// Example: TEST
 * Constraints: Minimum length = 1, Maximum length = 32
 */
dataMode():WeatherData_Ingest_dataMode_Enum {
  const offset = this.bb!.__offset(this.bb_pos, 80);
  return offset ? this.bb!.readInt8(this.bb_pos + offset) : WeatherData_Ingest_dataMode_Enum.REAL;
}

static startWeatherData_Ingest(builder:flatbuffers.Builder) {
  builder.startObject(39);
}

static addId(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, idOffset, 0);
}

static addClassificationMarking(builder:flatbuffers.Builder, classificationMarkingOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, classificationMarkingOffset, 0);
}

static addIdSensor(builder:flatbuffers.Builder, idSensorOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, idSensorOffset, 0);
}

static addOrigSensorId(builder:flatbuffers.Builder, origSensorIdOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, origSensorIdOffset, 0);
}

static addObTime(builder:flatbuffers.Builder, obTimeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, obTimeOffset, 0);
}

static addSigPwrs(builder:flatbuffers.Builder, sigPwrsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, sigPwrsOffset, 0);
}

static createSigPwrsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSigPwrsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addNoiseLvls(builder:flatbuffers.Builder, noiseLvlsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(6, noiseLvlsOffset, 0);
}

static createNoiseLvlsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startNoiseLvlsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSpecWidths(builder:flatbuffers.Builder, specWidthsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(7, specWidthsOffset, 0);
}

static createSpecWidthsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSpecWidthsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addFirstGuessAvgs(builder:flatbuffers.Builder, firstGuessAvgsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(8, firstGuessAvgsOffset, 0);
}

static createFirstGuessAvgsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startFirstGuessAvgsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addQcValue(builder:flatbuffers.Builder, qcValue:number) {
  builder.addFieldInt32(9, qcValue, 0);
}

static addFileCreation(builder:flatbuffers.Builder, fileCreationOffset:flatbuffers.Offset) {
  builder.addFieldOffset(10, fileCreationOffset, 0);
}

static addTermAlt(builder:flatbuffers.Builder, termAlt:number) {
  builder.addFieldFloat64(11, termAlt, 0.0);
}

static addAvgTxPwr(builder:flatbuffers.Builder, avgTxPwr:number) {
  builder.addFieldFloat64(12, avgTxPwr, 0.0);
}

static addAvgRefPwr(builder:flatbuffers.Builder, avgRefPwr:number) {
  builder.addFieldFloat64(13, avgRefPwr, 0.0);
}

static addSectorNum(builder:flatbuffers.Builder, sectorNum:number) {
  builder.addFieldInt32(14, sectorNum, 0);
}

static addNumElements(builder:flatbuffers.Builder, numElements:number) {
  builder.addFieldInt32(15, numElements, 0);
}

static addTdAvgSampleNums(builder:flatbuffers.Builder, tdAvgSampleNumsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(16, tdAvgSampleNumsOffset, 0);
}

static createTdAvgSampleNumsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startTdAvgSampleNumsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addChecksum(builder:flatbuffers.Builder, checksum:number) {
  builder.addFieldInt32(17, checksum, 0);
}

static addCoIntegs(builder:flatbuffers.Builder, coIntegsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(18, coIntegsOffset, 0);
}

static createCoIntegsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startCoIntegsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSpecAvgs(builder:flatbuffers.Builder, specAvgsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(19, specAvgsOffset, 0);
}

static createSpecAvgsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSpecAvgsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addInterpulsePeriods(builder:flatbuffers.Builder, interpulsePeriodsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(20, interpulsePeriodsOffset, 0);
}

static createInterpulsePeriodsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startInterpulsePeriodsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addDoppVels(builder:flatbuffers.Builder, doppVelsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(21, doppVelsOffset, 0);
}

static createDoppVelsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startDoppVelsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addConsRecs(builder:flatbuffers.Builder, consRecsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(22, consRecsOffset, 0);
}

static createConsRecsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startConsRecsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSnrs(builder:flatbuffers.Builder, snrsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(23, snrsOffset, 0);
}

static createSnrsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSnrsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSigStrength(builder:flatbuffers.Builder, sigStrength:number) {
  builder.addFieldFloat64(24, sigStrength, 0.0);
}

static addSemiMajorAxis(builder:flatbuffers.Builder, semiMajorAxis:number) {
  builder.addFieldFloat64(25, semiMajorAxis, 0.0);
}

static addSemiMinorAxis(builder:flatbuffers.Builder, semiMinorAxis:number) {
  builder.addFieldFloat64(26, semiMinorAxis, 0.0);
}

static addAngleOrientation(builder:flatbuffers.Builder, angleOrientation:number) {
  builder.addFieldFloat64(27, angleOrientation, 0.0);
}

static addLightEventNum(builder:flatbuffers.Builder, lightEventNum:number) {
  builder.addFieldInt32(28, lightEventNum, 0);
}

static addLightDetSensors(builder:flatbuffers.Builder, lightDetSensorsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(29, lightDetSensorsOffset, 0);
}

static createLightDetSensorsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startLightDetSensorsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addPosConfidence(builder:flatbuffers.Builder, posConfidence:number) {
  builder.addFieldFloat64(30, posConfidence, 0.0);
}

static addSrcTyps(builder:flatbuffers.Builder, srcTypsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(31, srcTypsOffset, 0);
}

static createSrcTypsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSrcTypsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addSrcIds(builder:flatbuffers.Builder, srcIdsOffset:flatbuffers.Offset) {
  builder.addFieldOffset(32, srcIdsOffset, 0);
}

static createSrcIdsVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startSrcIdsVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addOrigNetwork(builder:flatbuffers.Builder, origNetworkOffset:flatbuffers.Offset) {
  builder.addFieldOffset(33, origNetworkOffset, 0);
}

static addCreatedAt(builder:flatbuffers.Builder, createdAtOffset:flatbuffers.Offset) {
  builder.addFieldOffset(34, createdAtOffset, 0);
}

static addCreatedBy(builder:flatbuffers.Builder, createdByOffset:flatbuffers.Offset) {
  builder.addFieldOffset(35, createdByOffset, 0);
}

static addSource(builder:flatbuffers.Builder, sourceOffset:flatbuffers.Offset) {
  builder.addFieldOffset(36, sourceOffset, 0);
}

static addOrigin(builder:flatbuffers.Builder, originOffset:flatbuffers.Offset) {
  builder.addFieldOffset(37, originOffset, 0);
}

static addDataMode(builder:flatbuffers.Builder, dataMode:WeatherData_Ingest_dataMode_Enum) {
  builder.addFieldInt8(38, dataMode, WeatherData_Ingest_dataMode_Enum.REAL);
}

static endWeatherData_Ingest(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishWeatherData_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'WEAT');
}

static finishSizePrefixedWeatherData_IngestBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'WEAT', true);
}

static createWeatherData_Ingest(builder:flatbuffers.Builder, idOffset:flatbuffers.Offset, classificationMarkingOffset:flatbuffers.Offset, idSensorOffset:flatbuffers.Offset, origSensorIdOffset:flatbuffers.Offset, obTimeOffset:flatbuffers.Offset, sigPwrsOffset:flatbuffers.Offset, noiseLvlsOffset:flatbuffers.Offset, specWidthsOffset:flatbuffers.Offset, firstGuessAvgsOffset:flatbuffers.Offset, qcValue:number, fileCreationOffset:flatbuffers.Offset, termAlt:number, avgTxPwr:number, avgRefPwr:number, sectorNum:number, numElements:number, tdAvgSampleNumsOffset:flatbuffers.Offset, checksum:number, coIntegsOffset:flatbuffers.Offset, specAvgsOffset:flatbuffers.Offset, interpulsePeriodsOffset:flatbuffers.Offset, doppVelsOffset:flatbuffers.Offset, consRecsOffset:flatbuffers.Offset, snrsOffset:flatbuffers.Offset, sigStrength:number, semiMajorAxis:number, semiMinorAxis:number, angleOrientation:number, lightEventNum:number, lightDetSensorsOffset:flatbuffers.Offset, posConfidence:number, srcTypsOffset:flatbuffers.Offset, srcIdsOffset:flatbuffers.Offset, origNetworkOffset:flatbuffers.Offset, createdAtOffset:flatbuffers.Offset, createdByOffset:flatbuffers.Offset, sourceOffset:flatbuffers.Offset, originOffset:flatbuffers.Offset, dataMode:WeatherData_Ingest_dataMode_Enum):flatbuffers.Offset {
  WeatherData_Ingest.startWeatherData_Ingest(builder);
  WeatherData_Ingest.addId(builder, idOffset);
  WeatherData_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
  WeatherData_Ingest.addIdSensor(builder, idSensorOffset);
  WeatherData_Ingest.addOrigSensorId(builder, origSensorIdOffset);
  WeatherData_Ingest.addObTime(builder, obTimeOffset);
  WeatherData_Ingest.addSigPwrs(builder, sigPwrsOffset);
  WeatherData_Ingest.addNoiseLvls(builder, noiseLvlsOffset);
  WeatherData_Ingest.addSpecWidths(builder, specWidthsOffset);
  WeatherData_Ingest.addFirstGuessAvgs(builder, firstGuessAvgsOffset);
  WeatherData_Ingest.addQcValue(builder, qcValue);
  WeatherData_Ingest.addFileCreation(builder, fileCreationOffset);
  WeatherData_Ingest.addTermAlt(builder, termAlt);
  WeatherData_Ingest.addAvgTxPwr(builder, avgTxPwr);
  WeatherData_Ingest.addAvgRefPwr(builder, avgRefPwr);
  WeatherData_Ingest.addSectorNum(builder, sectorNum);
  WeatherData_Ingest.addNumElements(builder, numElements);
  WeatherData_Ingest.addTdAvgSampleNums(builder, tdAvgSampleNumsOffset);
  WeatherData_Ingest.addChecksum(builder, checksum);
  WeatherData_Ingest.addCoIntegs(builder, coIntegsOffset);
  WeatherData_Ingest.addSpecAvgs(builder, specAvgsOffset);
  WeatherData_Ingest.addInterpulsePeriods(builder, interpulsePeriodsOffset);
  WeatherData_Ingest.addDoppVels(builder, doppVelsOffset);
  WeatherData_Ingest.addConsRecs(builder, consRecsOffset);
  WeatherData_Ingest.addSnrs(builder, snrsOffset);
  WeatherData_Ingest.addSigStrength(builder, sigStrength);
  WeatherData_Ingest.addSemiMajorAxis(builder, semiMajorAxis);
  WeatherData_Ingest.addSemiMinorAxis(builder, semiMinorAxis);
  WeatherData_Ingest.addAngleOrientation(builder, angleOrientation);
  WeatherData_Ingest.addLightEventNum(builder, lightEventNum);
  WeatherData_Ingest.addLightDetSensors(builder, lightDetSensorsOffset);
  WeatherData_Ingest.addPosConfidence(builder, posConfidence);
  WeatherData_Ingest.addSrcTyps(builder, srcTypsOffset);
  WeatherData_Ingest.addSrcIds(builder, srcIdsOffset);
  WeatherData_Ingest.addOrigNetwork(builder, origNetworkOffset);
  WeatherData_Ingest.addCreatedAt(builder, createdAtOffset);
  WeatherData_Ingest.addCreatedBy(builder, createdByOffset);
  WeatherData_Ingest.addSource(builder, sourceOffset);
  WeatherData_Ingest.addOrigin(builder, originOffset);
  WeatherData_Ingest.addDataMode(builder, dataMode);
  return WeatherData_Ingest.endWeatherData_Ingest(builder);
}

unpack(): WeatherData_IngestT {
  return new WeatherData_IngestT(
    this.id(),
    this.classificationMarking(),
    this.idSensor(),
    this.origSensorId(),
    this.obTime(),
    this.bb!.createScalarList<string>(this.sigPwrs.bind(this), this.sigPwrsLength()),
    this.bb!.createScalarList<string>(this.noiseLvls.bind(this), this.noiseLvlsLength()),
    this.bb!.createScalarList<string>(this.specWidths.bind(this), this.specWidthsLength()),
    this.bb!.createScalarList<string>(this.firstGuessAvgs.bind(this), this.firstGuessAvgsLength()),
    this.qcValue(),
    this.fileCreation(),
    this.termAlt(),
    this.avgTxPwr(),
    this.avgRefPwr(),
    this.sectorNum(),
    this.numElements(),
    this.bb!.createScalarList<string>(this.tdAvgSampleNums.bind(this), this.tdAvgSampleNumsLength()),
    this.checksum(),
    this.bb!.createScalarList<string>(this.coIntegs.bind(this), this.coIntegsLength()),
    this.bb!.createScalarList<string>(this.specAvgs.bind(this), this.specAvgsLength()),
    this.bb!.createScalarList<string>(this.interpulsePeriods.bind(this), this.interpulsePeriodsLength()),
    this.bb!.createScalarList<string>(this.doppVels.bind(this), this.doppVelsLength()),
    this.bb!.createScalarList<string>(this.consRecs.bind(this), this.consRecsLength()),
    this.bb!.createScalarList<string>(this.snrs.bind(this), this.snrsLength()),
    this.sigStrength(),
    this.semiMajorAxis(),
    this.semiMinorAxis(),
    this.angleOrientation(),
    this.lightEventNum(),
    this.bb!.createScalarList<string>(this.lightDetSensors.bind(this), this.lightDetSensorsLength()),
    this.posConfidence(),
    this.bb!.createScalarList<string>(this.srcTyps.bind(this), this.srcTypsLength()),
    this.bb!.createScalarList<string>(this.srcIds.bind(this), this.srcIdsLength()),
    this.origNetwork(),
    this.createdAt(),
    this.createdBy(),
    this.source(),
    this.origin(),
    this.dataMode()
  );
}


unpackTo(_o: WeatherData_IngestT): void {
  _o.id = this.id();
  _o.classificationMarking = this.classificationMarking();
  _o.idSensor = this.idSensor();
  _o.origSensorId = this.origSensorId();
  _o.obTime = this.obTime();
  _o.sigPwrs = this.bb!.createScalarList<string>(this.sigPwrs.bind(this), this.sigPwrsLength());
  _o.noiseLvls = this.bb!.createScalarList<string>(this.noiseLvls.bind(this), this.noiseLvlsLength());
  _o.specWidths = this.bb!.createScalarList<string>(this.specWidths.bind(this), this.specWidthsLength());
  _o.firstGuessAvgs = this.bb!.createScalarList<string>(this.firstGuessAvgs.bind(this), this.firstGuessAvgsLength());
  _o.qcValue = this.qcValue();
  _o.fileCreation = this.fileCreation();
  _o.termAlt = this.termAlt();
  _o.avgTxPwr = this.avgTxPwr();
  _o.avgRefPwr = this.avgRefPwr();
  _o.sectorNum = this.sectorNum();
  _o.numElements = this.numElements();
  _o.tdAvgSampleNums = this.bb!.createScalarList<string>(this.tdAvgSampleNums.bind(this), this.tdAvgSampleNumsLength());
  _o.checksum = this.checksum();
  _o.coIntegs = this.bb!.createScalarList<string>(this.coIntegs.bind(this), this.coIntegsLength());
  _o.specAvgs = this.bb!.createScalarList<string>(this.specAvgs.bind(this), this.specAvgsLength());
  _o.interpulsePeriods = this.bb!.createScalarList<string>(this.interpulsePeriods.bind(this), this.interpulsePeriodsLength());
  _o.doppVels = this.bb!.createScalarList<string>(this.doppVels.bind(this), this.doppVelsLength());
  _o.consRecs = this.bb!.createScalarList<string>(this.consRecs.bind(this), this.consRecsLength());
  _o.snrs = this.bb!.createScalarList<string>(this.snrs.bind(this), this.snrsLength());
  _o.sigStrength = this.sigStrength();
  _o.semiMajorAxis = this.semiMajorAxis();
  _o.semiMinorAxis = this.semiMinorAxis();
  _o.angleOrientation = this.angleOrientation();
  _o.lightEventNum = this.lightEventNum();
  _o.lightDetSensors = this.bb!.createScalarList<string>(this.lightDetSensors.bind(this), this.lightDetSensorsLength());
  _o.posConfidence = this.posConfidence();
  _o.srcTyps = this.bb!.createScalarList<string>(this.srcTyps.bind(this), this.srcTypsLength());
  _o.srcIds = this.bb!.createScalarList<string>(this.srcIds.bind(this), this.srcIdsLength());
  _o.origNetwork = this.origNetwork();
  _o.createdAt = this.createdAt();
  _o.createdBy = this.createdBy();
  _o.source = this.source();
  _o.origin = this.origin();
  _o.dataMode = this.dataMode();
}
}

export class WeatherData_IngestT implements flatbuffers.IGeneratedObject {
constructor(
  public id: string|Uint8Array|null = null,
  public classificationMarking: string|Uint8Array|null = null,
  public idSensor: string|Uint8Array|null = null,
  public origSensorId: string|Uint8Array|null = null,
  public obTime: string|Uint8Array|null = null,
  public sigPwrs: (string)[] = [],
  public noiseLvls: (string)[] = [],
  public specWidths: (string)[] = [],
  public firstGuessAvgs: (string)[] = [],
  public qcValue: number = 0,
  public fileCreation: string|Uint8Array|null = null,
  public termAlt: number = 0.0,
  public avgTxPwr: number = 0.0,
  public avgRefPwr: number = 0.0,
  public sectorNum: number = 0,
  public numElements: number = 0,
  public tdAvgSampleNums: (string)[] = [],
  public checksum: number = 0,
  public coIntegs: (string)[] = [],
  public specAvgs: (string)[] = [],
  public interpulsePeriods: (string)[] = [],
  public doppVels: (string)[] = [],
  public consRecs: (string)[] = [],
  public snrs: (string)[] = [],
  public sigStrength: number = 0.0,
  public semiMajorAxis: number = 0.0,
  public semiMinorAxis: number = 0.0,
  public angleOrientation: number = 0.0,
  public lightEventNum: number = 0,
  public lightDetSensors: (string)[] = [],
  public posConfidence: number = 0.0,
  public srcTyps: (string)[] = [],
  public srcIds: (string)[] = [],
  public origNetwork: string|Uint8Array|null = null,
  public createdAt: string|Uint8Array|null = null,
  public createdBy: string|Uint8Array|null = null,
  public source: string|Uint8Array|null = null,
  public origin: string|Uint8Array|null = null,
  public dataMode: WeatherData_Ingest_dataMode_Enum = WeatherData_Ingest_dataMode_Enum.REAL
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const id = (this.id !== null ? builder.createString(this.id!) : 0);
  const classificationMarking = (this.classificationMarking !== null ? builder.createString(this.classificationMarking!) : 0);
  const idSensor = (this.idSensor !== null ? builder.createString(this.idSensor!) : 0);
  const origSensorId = (this.origSensorId !== null ? builder.createString(this.origSensorId!) : 0);
  const obTime = (this.obTime !== null ? builder.createString(this.obTime!) : 0);
  const sigPwrs = WeatherData_Ingest.createSigPwrsVector(builder, builder.createObjectOffsetList(this.sigPwrs));
  const noiseLvls = WeatherData_Ingest.createNoiseLvlsVector(builder, builder.createObjectOffsetList(this.noiseLvls));
  const specWidths = WeatherData_Ingest.createSpecWidthsVector(builder, builder.createObjectOffsetList(this.specWidths));
  const firstGuessAvgs = WeatherData_Ingest.createFirstGuessAvgsVector(builder, builder.createObjectOffsetList(this.firstGuessAvgs));
  const fileCreation = (this.fileCreation !== null ? builder.createString(this.fileCreation!) : 0);
  const tdAvgSampleNums = WeatherData_Ingest.createTdAvgSampleNumsVector(builder, builder.createObjectOffsetList(this.tdAvgSampleNums));
  const coIntegs = WeatherData_Ingest.createCoIntegsVector(builder, builder.createObjectOffsetList(this.coIntegs));
  const specAvgs = WeatherData_Ingest.createSpecAvgsVector(builder, builder.createObjectOffsetList(this.specAvgs));
  const interpulsePeriods = WeatherData_Ingest.createInterpulsePeriodsVector(builder, builder.createObjectOffsetList(this.interpulsePeriods));
  const doppVels = WeatherData_Ingest.createDoppVelsVector(builder, builder.createObjectOffsetList(this.doppVels));
  const consRecs = WeatherData_Ingest.createConsRecsVector(builder, builder.createObjectOffsetList(this.consRecs));
  const snrs = WeatherData_Ingest.createSnrsVector(builder, builder.createObjectOffsetList(this.snrs));
  const lightDetSensors = WeatherData_Ingest.createLightDetSensorsVector(builder, builder.createObjectOffsetList(this.lightDetSensors));
  const srcTyps = WeatherData_Ingest.createSrcTypsVector(builder, builder.createObjectOffsetList(this.srcTyps));
  const srcIds = WeatherData_Ingest.createSrcIdsVector(builder, builder.createObjectOffsetList(this.srcIds));
  const origNetwork = (this.origNetwork !== null ? builder.createString(this.origNetwork!) : 0);
  const createdAt = (this.createdAt !== null ? builder.createString(this.createdAt!) : 0);
  const createdBy = (this.createdBy !== null ? builder.createString(this.createdBy!) : 0);
  const source = (this.source !== null ? builder.createString(this.source!) : 0);
  const origin = (this.origin !== null ? builder.createString(this.origin!) : 0);

  return WeatherData_Ingest.createWeatherData_Ingest(builder,
    id,
    classificationMarking,
    idSensor,
    origSensorId,
    obTime,
    sigPwrs,
    noiseLvls,
    specWidths,
    firstGuessAvgs,
    this.qcValue,
    fileCreation,
    this.termAlt,
    this.avgTxPwr,
    this.avgRefPwr,
    this.sectorNum,
    this.numElements,
    tdAvgSampleNums,
    this.checksum,
    coIntegs,
    specAvgs,
    interpulsePeriods,
    doppVels,
    consRecs,
    snrs,
    this.sigStrength,
    this.semiMajorAxis,
    this.semiMinorAxis,
    this.angleOrientation,
    this.lightEventNum,
    lightDetSensors,
    this.posConfidence,
    srcTyps,
    srcIds,
    origNetwork,
    createdAt,
    createdBy,
    source,
    origin,
    this.dataMode
  );
}
}
