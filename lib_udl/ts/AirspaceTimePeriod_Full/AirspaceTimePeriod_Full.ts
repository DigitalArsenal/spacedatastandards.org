// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';



/**
 * /// The timePeriod set describes the effective datetime for a given airspace control means.
 */
export class AirspaceTimePeriod_Full implements flatbuffers.IUnpackableObject<AirspaceTimePeriod_FullT> {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):AirspaceTimePeriod_Full {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsAirspaceTimePeriod_Full(bb:flatbuffers.ByteBuffer, obj?:AirspaceTimePeriod_Full):AirspaceTimePeriod_Full {
  return (obj || new AirspaceTimePeriod_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsAirspaceTimePeriod_Full(bb:flatbuffers.ByteBuffer, obj?:AirspaceTimePeriod_Full):AirspaceTimePeriod_Full {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new AirspaceTimePeriod_Full()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static bufferHasIdentifier(bb:flatbuffers.ByteBuffer):boolean {
  return bb.__has_identifier('AIRS');
}

/**
 * The airspace time code associated with the ACO. Can be DISCRETE, a fixed time block, or INTERVAL, a repeating time block.
 * Example: /// Example: DISCRETE
 * Constraints: Minimum length = 0, Maximum length = 8
 */
timeMode():string|null
timeMode(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
timeMode(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The start time designating that the airspace control order is active.
 * Example: /// Example: 141325ZFEB2002
 * Constraints: Minimum length = 0, Maximum length = 16
 */
timeStart():string|null
timeStart(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
timeStart(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * The end time designating that the airspace control order is no longer active. Can contain datetime information or a stop time qualifier code, such as AFTER, NET, UFN, etc.
 * Example: /// Example: 141325ZFEB2002
 * Constraints: Minimum length = 0, Maximum length = 16
 */
timeEnd():string|null
timeEnd(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
timeEnd(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

/**
 * Mandatory if timeMode is INTERVAL. Can be on of the interval frequency codes, such as BIWEEKLY, DAILY, YEARLY, etc.
 * Example: /// Example: ['WEEKLY']
 * Constraints: No constraints specified.
 */
intFreq(index: number):string
intFreq(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
intFreq(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

intFreqLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

/**
 * Mandatory if timeMode is INTERVAL. Can be a numerical multiplier on an interval frequency code, a stop time qualifier code such as AFTER, NET, UFN, etc, or a datetime like string.
 * Example: /// Example: ['65WK']
 * Constraints: No constraints specified.
 */
intDur(index: number):string
intDur(index: number,optionalEncoding:flatbuffers.Encoding):string|Uint8Array
intDur(index: number,optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__string(this.bb!.__vector(this.bb_pos + offset) + index * 4, optionalEncoding) : null;
}

intDurLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

static startAirspaceTimePeriod_Full(builder:flatbuffers.Builder) {
  builder.startObject(5);
}

static addTimeMode(builder:flatbuffers.Builder, timeModeOffset:flatbuffers.Offset) {
  builder.addFieldOffset(0, timeModeOffset, 0);
}

static addTimeStart(builder:flatbuffers.Builder, timeStartOffset:flatbuffers.Offset) {
  builder.addFieldOffset(1, timeStartOffset, 0);
}

static addTimeEnd(builder:flatbuffers.Builder, timeEndOffset:flatbuffers.Offset) {
  builder.addFieldOffset(2, timeEndOffset, 0);
}

static addIntFreq(builder:flatbuffers.Builder, intFreqOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, intFreqOffset, 0);
}

static createIntFreqVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startIntFreqVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addIntDur(builder:flatbuffers.Builder, intDurOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, intDurOffset, 0);
}

static createIntDurVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startIntDurVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static endAirspaceTimePeriod_Full(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static finishAirspaceTimePeriod_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'AIRS');
}

static finishSizePrefixedAirspaceTimePeriod_FullBuffer(builder:flatbuffers.Builder, offset:flatbuffers.Offset) {
  builder.finish(offset, 'AIRS', true);
}

static createAirspaceTimePeriod_Full(builder:flatbuffers.Builder, timeModeOffset:flatbuffers.Offset, timeStartOffset:flatbuffers.Offset, timeEndOffset:flatbuffers.Offset, intFreqOffset:flatbuffers.Offset, intDurOffset:flatbuffers.Offset):flatbuffers.Offset {
  AirspaceTimePeriod_Full.startAirspaceTimePeriod_Full(builder);
  AirspaceTimePeriod_Full.addTimeMode(builder, timeModeOffset);
  AirspaceTimePeriod_Full.addTimeStart(builder, timeStartOffset);
  AirspaceTimePeriod_Full.addTimeEnd(builder, timeEndOffset);
  AirspaceTimePeriod_Full.addIntFreq(builder, intFreqOffset);
  AirspaceTimePeriod_Full.addIntDur(builder, intDurOffset);
  return AirspaceTimePeriod_Full.endAirspaceTimePeriod_Full(builder);
}

unpack(): AirspaceTimePeriod_FullT {
  return new AirspaceTimePeriod_FullT(
    this.timeMode(),
    this.timeStart(),
    this.timeEnd(),
    this.bb!.createScalarList<string>(this.intFreq.bind(this), this.intFreqLength()),
    this.bb!.createScalarList<string>(this.intDur.bind(this), this.intDurLength())
  );
}


unpackTo(_o: AirspaceTimePeriod_FullT): void {
  _o.timeMode = this.timeMode();
  _o.timeStart = this.timeStart();
  _o.timeEnd = this.timeEnd();
  _o.intFreq = this.bb!.createScalarList<string>(this.intFreq.bind(this), this.intFreqLength());
  _o.intDur = this.bb!.createScalarList<string>(this.intDur.bind(this), this.intDurLength());
}
}

export class AirspaceTimePeriod_FullT implements flatbuffers.IGeneratedObject {
constructor(
  public timeMode: string|Uint8Array|null = null,
  public timeStart: string|Uint8Array|null = null,
  public timeEnd: string|Uint8Array|null = null,
  public intFreq: (string)[] = [],
  public intDur: (string)[] = []
){}


pack(builder:flatbuffers.Builder): flatbuffers.Offset {
  const timeMode = (this.timeMode !== null ? builder.createString(this.timeMode!) : 0);
  const timeStart = (this.timeStart !== null ? builder.createString(this.timeStart!) : 0);
  const timeEnd = (this.timeEnd !== null ? builder.createString(this.timeEnd!) : 0);
  const intFreq = AirspaceTimePeriod_Full.createIntFreqVector(builder, builder.createObjectOffsetList(this.intFreq));
  const intDur = AirspaceTimePeriod_Full.createIntDurVector(builder, builder.createObjectOffsetList(this.intDur));

  return AirspaceTimePeriod_Full.createAirspaceTimePeriod_Full(builder,
    timeMode,
    timeStart,
    timeEnd,
    intFreq,
    intDur
  );
}
}
