// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// These services provide operations for querying of all available track details and amplifying track data. A track is a position and optionally a heading/velocity of an object such as an aircraft, marine vessel, etc at a particular timestamp. It also includes optional information regarding the identity/type of the target object and other amplifying object data, if known.
 */
@SuppressWarnings("unused")
public final class TrackDetails_Abridged extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static TrackDetails_Abridged getRootAsTrackDetails_Abridged(ByteBuffer _bb) { return getRootAsTrackDetails_Abridged(_bb, new TrackDetails_Abridged()); }
  public static TrackDetails_Abridged getRootAsTrackDetails_Abridged(ByteBuffer _bb, TrackDetails_Abridged obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean TrackDetails_AbridgedBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "TRAC"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public TrackDetails_Abridged __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: TRACK-DETAILS-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
   *  AIR: Between sea level and the K치rm치n line, which has an altitude of 100 kilometers (62 miles).
   *  LAND: On the surface of dry land.
   *  SPACE: Above the K치rm치n line, which has an altitude of 100 kilometers (62 miles).
   *  SURFACE: On the surface of a body of water.
   *  SUBSURFACE: Below the surface of a body of water.
   *  UNKNOWN: Environment is not known.
   * Example: /// Example: LAND
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public byte env() { int o = __offset(8); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Optional message type designation.
   * Example: /// Example: PLATFORM
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String msgType() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgTypeAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer msgTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * The vessel hull number designation of this maritime vessel.  The hull number is a 1-6 character alphanumeric entry assigned to a ship and painted on the hull.
   * Example: /// Example: A30081
   * Constraints: Minimum length = 0, Maximum length = 7
   */
  public String hullNum() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer hullNumAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer hullNumInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The Pseudo Identification Feature (PIF) number is a four digit code that provides an exact ID for the ship or aircraft. Friendly military only.
   * Example: /// Example: 0137
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String pif() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer pifAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer pifInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * The Ship Control Number (SCONUM) is a naval vessel identification number (alphanumeric code) assigned by the Office of Naval Intelligence. SCONUM is sometimes referred to as NOIC ID. SCONUMs are typically of the form A#####, where A is an alpha character and # is numerical.
   * Example: /// Example: B45524
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String sconum() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sconumAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer sconumInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * The Naval Tactical Data System (NTDS) track number assigned to this track.
   * Example: /// Example: ZZ777
   * Constraints: Minimum length = 0, Maximum length = 6
   */
  public String ntds() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ntdsAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer ntdsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * The Intel Discrete Identifier (IDI) code assigned to this track.  The IDI is a four-digit code representing hostile or unknown tracks.
   * Example: /// Example: 7670
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String disId() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer disIdAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer disIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * The category code that represents the associated facility purpose within the target system.  This value is the category code in the MIDB (Modernized Intelligence Database).
   * Example: /// Example: 20345
   * Constraints: Minimum length = 0, Maximum length = 6
   */
  public String midbCat() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer midbCatAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer midbCatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * The Basic Encyclopedia (BE) number associated with this installation or area.
   * Example: /// Example: ENC-123
   * Constraints: Minimum length = 0, Maximum length = 10
   */
  public String beNumber() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer beNumberAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer beNumberInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * The O-suffix associated with this facility.  The O-suffix is a five-character alpha/numeric system used to identify a facility, or demographic area, within an installation. The Installation Basic Encyclopedia (beNumber), in conjunction with the O-suffix, uniquely identifies the facility within the Modernized Integrated Database (MIDB).  The Installation beNumber and oSuffix are also used in conjunction with the midbCat code to classify the function or purpose of the facility.
   * Example: /// Example: AA125
   * Constraints: Minimum length = 0, Maximum length = 6
   */
  public String oSuffix() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer oSuffixAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer oSuffixInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * This value represents the site number of a specific electronic site or its associated equipment.
   * Example: /// Example: E12345012
   * Constraints: Minimum length = 0, Maximum length = 9
   */
  public String pin() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer pinAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer pinInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * Flag indicating whether the missile is considered lost, if reporting a missile track.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean lostTrkInd() { int o = __offset(30); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Track ID for the source of the Missile-Unique Identifier (MUID), if reporting a missile track.
   * Example: /// Example: MUID-SRC-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String muidSrcTrk() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer muidSrcTrkAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer muidSrcTrkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * Source of the Missile-Unique Identifier (MUID), if reporting a missile track.
   * Example: /// Example: MUID-SRC
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String muidSrc() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer muidSrcAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer muidSrcInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * The status of the missile track in this record, if reporting a missile track (e.g. AT LAUNCH, AT OBSERVATION, FLYING, IMPACTED, LOST, STALE, DEBRIS).
   * Example: /// Example: AT LAUNCH
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String mslStatus() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer mslStatusAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer mslStatusInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
   * Example: /// Example: 0.95
   * Constraints: No constraints specified.
   */
  public double trkConf() { int o = __offset(38); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track; Higher values indicate higher track quality, i.e., lower errors in reported position.
   * Example: /// Example: 1
   * Constraints: No constraints specified.
   */
  public int trkQual() { int o = __offset(40); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * A track may be designated as an alert track with the following designations:
   * HIT - High Interest Track
   * TGT - Target
   * SUS - Suspect Carrier
   * NSP - Cleared Suspect
   * If alert is null, the track is assumed to be of non-alert status.
   * Example: /// Example: TGT
   * Constraints: Minimum length = 0, Maximum length = 3
   */
  public String alert() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer alertAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer alertInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * Original source cross-reference code for the Command that originated the report.
   * Example: /// Example: INT
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String origXref() { int o = __offset(44); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origXrefAsByteBuffer() { return __vector_as_bytebuffer(44, 1); }
  public ByteBuffer origXrefInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 44, 1); }
  /**
   * Primary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
   * Example: /// Example: A123A
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String elnot1() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer elnot1AsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer elnot1InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * Secondary ELINT Notification (ELNOT), a five character identifier assigned to each non-communication emission for collection and reporting purposes.  This five-digit field begins with an alpha character, followed by three numbers, ending with another alpha character.
   * Example: /// Example: A123B
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String elnot2() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer elnot2AsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer elnot2InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
   *  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
   *  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
   *  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
   *  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
   *  PENDING: Track object which has not been evaluated.
   *  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
   *  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
   * Example: /// Example: FRIEND
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public byte objIdent() { int o = __offset(50); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * The generic classification of the track object/group (e.g., BALLISTIC, HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
   * Example: /// Example: TRACKED
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objType() { int o = __offset(52); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objTypeAsByteBuffer() { return __vector_as_bytebuffer(52, 1); }
  public ByteBuffer objTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 52, 1); }
  /**
   * The object platform type is intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. SATELLITE).
   * Example: /// Example: WEAPON
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objPlat() { int o = __offset(54); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objPlatAsByteBuffer() { return __vector_as_bytebuffer(54, 1); }
  public ByteBuffer objPlatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 54, 1); }
  /**
   * The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.  For cases in which no MIl-STD-6016 designation exists, a general description can be used (e.g. ANTISPACE WARFARE).
   * Example: /// Example: HOLDING
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objAct() { int o = __offset(56); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objActAsByteBuffer() { return __vector_as_bytebuffer(56, 1); }
  public ByteBuffer objActInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 56, 1); }
  /**
   * Nationality of the tracked object.
   * Example: /// Example: USA
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String objNat() { int o = __offset(58); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objNatAsByteBuffer() { return __vector_as_bytebuffer(58, 1); }
  public ByteBuffer objNatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 58, 1); }
  /**
   * Track name.
   * Example: /// Example: TRACK-NAME
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String name() { int o = __offset(60); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer nameAsByteBuffer() { return __vector_as_bytebuffer(60, 1); }
  public ByteBuffer nameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 60, 1); }
  /**
   * Abbreviated track name.
   * Example: /// Example: COMMSCHECK
   * Constraints: Minimum length = 0, Maximum length = 11
   */
  public String shortName() { int o = __offset(62); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer shortNameAsByteBuffer() { return __vector_as_bytebuffer(62, 1); }
  public ByteBuffer shortNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 62, 1); }
  /**
   * UUID identifying the track, which should remain the same on subsequent tracks of the same object.
   * Example: /// Example: trkId
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String trkId() { int o = __offset(64); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkIdAsByteBuffer() { return __vector_as_bytebuffer(64, 1); }
  public ByteBuffer trkIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 64, 1); }
  /**
   * The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
   * Example: /// Example: trkNum
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String trkNum() { int o = __offset(66); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkNumAsByteBuffer() { return __vector_as_bytebuffer(66, 1); }
  public ByteBuffer trkNumInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 66, 1); }
  /**
   * Value Indicating the scope of this track:
   * 1 - TERMINAL  (Terminal) - available only on the workstation where they were created.
   * 2 - LOCAL  (Local) - available only on workstations in the local area network
   * 3 - OTH  (Over the Horizon) - available to everyone.
   * Example: /// Example: OTH
   * Constraints: Minimum length = 0, Maximum length = 12
   */
  public String trkScope() { int o = __offset(68); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkScopeAsByteBuffer() { return __vector_as_bytebuffer(68, 1); }
  public ByteBuffer trkScopeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 68, 1); }
  /**
   * The unique identifier of the source node.
   * Example: /// Example: MCS
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String sourceUid() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceUidAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer sourceUidInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * The call sign currently assigned to this track object.
   * Example: /// Example: Charlie
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String callSign() { int o = __offset(72); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer callSignAsByteBuffer() { return __vector_as_bytebuffer(72, 1); }
  public ByteBuffer callSignInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 72, 1); }
  /**
   * Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
   *  FAKER: Friendly track, object, or entity acting as an exercise hostile.
   *  JOKER: Friendly track, object, or entity acting as an exercise suspect.
   *  KILO: Friendly high-value object.
   *  TRAVELLER: Suspect land or surface track following a recognized traffic route.
   *  ZOMBIE: Suspect track, object, or entity of special interest.
   * Example: /// Example: JOKER
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String identAmp() { int o = __offset(74); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer identAmpAsByteBuffer() { return __vector_as_bytebuffer(74, 1); }
  public ByteBuffer identAmpInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 74, 1); }
  /**
   * Space amplification indicates additional information on the space environment object being reported (e.g. DEBRIS, FUEL-AIR EXPLOSIVE, NUCLEAR WARHEAD).
   * Example: /// Example: NUCLEAR WARHEAD
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String spaceAmp() { int o = __offset(76); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer spaceAmpAsByteBuffer() { return __vector_as_bytebuffer(76, 1); }
  public ByteBuffer spaceAmpInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 76, 1); }
  /**
   * Confidence level of the amplifying characteristics.  Values range from 0 to 6, with 0 indicating the lowest confidence and 6 indicating the highest.
   * Example: /// Example: 6
   * Constraints: No constraints specified.
   */
  public int spaceAmpConf() { int o = __offset(78); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Specific type of point or track with an environment of space.
   * Example: /// Example: SS-21_MOD_2_CRBM
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String spaceSpecType() { int o = __offset(80); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer spaceSpecTypeAsByteBuffer() { return __vector_as_bytebuffer(80, 1); }
  public ByteBuffer spaceSpecTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 80, 1); }
  /**
   * Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM:
   * SRBM - Short-Range Ballistic Missile
   * MRBM - Medium-Range Ballistic Missile
   * IRBM - Intermediate-Range Ballistic Missile
   * LRBM - Long-Range Ballistic Missile
   * ICBM - Intercontinental Ballistic Missile
   * SLBM - Submarine-Launched Ballistic Missile.
   * Example: /// Example: SLBM
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String acftSubType() { int o = __offset(82); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer acftSubTypeAsByteBuffer() { return __vector_as_bytebuffer(82, 1); }
  public ByteBuffer acftSubTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 82, 1); }
  /**
   * Track timestamp in ISO8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String ts() { int o = __offset(84); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tsAsByteBuffer() { return __vector_as_bytebuffer(84, 1); }
  public ByteBuffer tsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 84, 1); }
  /**
   * Missile launch timestamp in ISO8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String launchTime() { int o = __offset(86); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer launchTimeAsByteBuffer() { return __vector_as_bytebuffer(86, 1); }
  public ByteBuffer launchTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 86, 1); }
  /**
   * Missile impact timestamp in ISO8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String impactTime() { int o = __offset(88); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer impactTimeAsByteBuffer() { return __vector_as_bytebuffer(88, 1); }
  public ByteBuffer impactTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 88, 1); }
  /**
   * The message timestamp that the ftn track position was recorded, in ISO 8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String ftnMsgTs() { int o = __offset(90); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ftnMsgTsAsByteBuffer() { return __vector_as_bytebuffer(90, 1); }
  public ByteBuffer ftnMsgTsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 90, 1); }
  /**
   * An ftn used to associate information and directives with the track.
   * Example: /// Example: FTN
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String ftn() { int o = __offset(92); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ftnAsByteBuffer() { return __vector_as_bytebuffer(92, 1); }
  public ByteBuffer ftnInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 92, 1); }
  /**
   * The name of the Command reporting the Force Over-The-Horizon Track Coordinator (FOTC) track number.
   * Example: /// Example: TRUETT
   * Constraints: Minimum length = 0, Maximum length = 18
   */
  public String ftnCmd() { int o = __offset(94); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ftnCmdAsByteBuffer() { return __vector_as_bytebuffer(94, 1); }
  public ByteBuffer ftnCmdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 94, 1); }
  /**
   * The message timestamp that the reference track position was recorded, in ISO 8601 UTC format with microsecond precision. The 'rtnMsgTs' and 'rtn' arrays must match in size.
   * Example: /// Example: ['2021-02-25T12:00:00.123456Z']
   * Constraints: No constraints specified.
   */
  public String rtnMsgTs(int j) { int o = __offset(96); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int rtnMsgTsLength() { int o = __offset(96); return o != 0 ? __vector_len(o) : 0; }
  public StringVector rtnMsgTsVector() { return rtnMsgTsVector(new StringVector()); }
  public StringVector rtnMsgTsVector(StringVector obj) { int o = __offset(96); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * A Reference Track Number used to associate information and directives with the track.  Referenced, but not constrained to, MIL-STD-6016F Reference Track Number. The 'rtnMsgTs' and 'rtn' arrays must match in size.
   * Example: /// Example: ['ex-a']
   * Constraints: No constraints specified.
   */
  public String rtn(int j) { int o = __offset(98); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int rtnLength() { int o = __offset(98); return o != 0 ? __vector_len(o) : 0; }
  public StringVector rtnVector() { return rtnVector(new StringVector()); }
  public StringVector rtnVector(StringVector obj) { int o = __offset(98); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Value representing the state of the Received Track.
   * Example: /// Example: Local_RTN
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String rtnTrkState() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer rtnTrkStateAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer rtnTrkStateInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * The name of the Command reporting the Received Track Number (RTN).
   * Example: /// Example: YORKTOWN
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String rtnCmd() { int o = __offset(102); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer rtnCmdAsByteBuffer() { return __vector_as_bytebuffer(102, 1); }
  public ByteBuffer rtnCmdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 102, 1); }
  /**
   * Id/name of sensor providing the track data.
   * Example: /// Example: OTH
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String sen() { int o = __offset(104); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer senAsByteBuffer() { return __vector_as_bytebuffer(104, 1); }
  public ByteBuffer senInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 104, 1); }
  /**
   * Source cross-reference code for the Command that originated the track report.
   * Example: /// Example: INT
   * Constraints: Minimum length = 0, Maximum length = 18
   */
  public String rptChxref() { int o = __offset(106); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer rptChxrefAsByteBuffer() { return __vector_as_bytebuffer(106, 1); }
  public ByteBuffer rptChxrefInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 106, 1); }
  /**
   * Flag indicating whether this track is archived.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean rptArchived() { int o = __offset(108); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track is self reported.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean selfReport() { int o = __offset(110); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The MIL-STD-2525B symbology code that applies to the subject of this track.
   * Example: /// Example: SHP*S----------
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String mil2525Bstr() { int o = __offset(112); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer mil2525BstrAsByteBuffer() { return __vector_as_bytebuffer(112, 1); }
  public ByteBuffer mil2525BstrInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 112, 1); }
  /**
   * Transponder ID for the track.  This does not correspond to the UDL transponder schema.
   * Example: /// Example: 11
   * Constraints: Minimum length = 0, Maximum length = 61
   */
  public String trnspdrId() { int o = __offset(114); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trnspdrIdAsByteBuffer() { return __vector_as_bytebuffer(114, 1); }
  public ByteBuffer trnspdrIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 114, 1); }
  /**
   * Transponder type for the track.
   * Example: /// Example: AFTS
   * Constraints: Minimum length = 0, Maximum length = 51
   */
  public String trnspdrType() { int o = __offset(116); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trnspdrTypeAsByteBuffer() { return __vector_as_bytebuffer(116, 1); }
  public ByteBuffer trnspdrTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 116, 1); }
  /**
   * Radar name of the sensor tracking this object (e.g., RAY1500, SPN-43, HEADNET).
   * Example: /// Example: RAY1500
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String emitterName() { int o = __offset(118); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer emitterNameAsByteBuffer() { return __vector_as_bytebuffer(118, 1); }
  public ByteBuffer emitterNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 118, 1); }
  /**
   * Source code for source of information used to detect track.
   * Example: /// Example: S1
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String infoSource() { int o = __offset(120); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer infoSourceAsByteBuffer() { return __vector_as_bytebuffer(120, 1); }
  public ByteBuffer infoSourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 120, 1); }
  /**
   * Flag indicating that the missile is currently in a state of boosting, if reporting a missile track.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean boosting() { int o = __offset(122); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Frequency, in hertz, for the signature report.
   * Example: /// Example: 63.65
   * Constraints: No constraints specified.
   */
  public double freq() { int o = __offset(124); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Maximum frequency, in hertz, reported for this acoustic track.
   * Example: /// Example: 10324.53
   * Constraints: No constraints specified.
   */
  public double maxFreq() { int o = __offset(126); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * List of harmonics of the signature report in descending order of predominance using 1-2 digit combinations separated by commas, e.g., 8,12,4. (1-22NS).
   * Example: /// Example: 8,12,4
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String harmonics() { int o = __offset(128); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer harmonicsAsByteBuffer() { return __vector_as_bytebuffer(128, 1); }
  public ByteBuffer harmonicsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 128, 1); }
  /**
   * Pulse repetition interval of the emitter, measured in microseconds.  The interval between the start of one pulse and the start of another.
   * Example: /// Example: 56657.2238
   * Constraints: No constraints specified.
   */
  public double pri() { int o = __offset(130); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Pulse repetition frequency of the emitter, measured in pulses per second.  PRF is the number of pulses transmitted per second. This is the reciprocal of the pri value.
   * Example: /// Example: 17.65
   * Constraints: No constraints specified.
   */
  public double prf() { int o = __offset(132); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Pulse width of the emitter, measured in microseconds.  This is the duration of the pulse.
   * Example: /// Example: 1347.45
   * Constraints: No constraints specified.
   */
  public double pw() { int o = __offset(134); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Type of radar scan.
   * Example: /// Example: UNK
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String scanType() { int o = __offset(136); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer scanTypeAsByteBuffer() { return __vector_as_bytebuffer(136, 1); }
  public ByteBuffer scanTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 136, 1); }
  /**
   * Scan rate of the emitter, measured in seconds per rotation (SPR).
   * Example: /// Example: 12.01
   * Constraints: No constraints specified.
   */
  public double scanRate() { int o = __offset(138); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Sequential Contact Number (SCN) for this track.
   * Example: /// Example: 1474305
   * Constraints: No constraints specified.
   */
  public int scn() { int o = __offset(140); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Correlation Index; reference code for the site that originally reported the track.
   * Example: /// Example: BB
   * Constraints: Minimum length = 0, Maximum length = 3
   */
  public String cI() { int o = __offset(142); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer cIAsByteBuffer() { return __vector_as_bytebuffer(142, 1); }
  public ByteBuffer cIInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 142, 1); }
  /**
   * The angle formed between the line of sight of the observer and the horizon, in degrees.  The angular range is -90 to 90, with negative values representing angle of depression.
   * Example: /// Example: 15.2
   * Constraints: No constraints specified.
   */
  public double angElev() { int o = __offset(144); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double lat() { int o = __offset(146); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 46.74596844
   * Constraints: No constraints specified.
   */
  public double lon() { int o = __offset(148); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double launchLat() { int o = __offset(150); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 46.74550102
   * Constraints: No constraints specified.
   */
  public double launchLon() { int o = __offset(152); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 latitude of the missile impact point, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double impactLat() { int o = __offset(154); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the missile impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 46.74550102
   * Constraints: No constraints specified.
   */
  public double impactLon() { int o = __offset(156); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 azimuth corridor reference point latitude, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double polarSingLocLat() { int o = __offset(158); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 azimuth corridor reference point longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 46.74550102
   * Constraints: No constraints specified.
   */
  public double polarSingLocLon() { int o = __offset(160); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The azimuth corridor centerline angle measured in degrees clockwise from true north, of the center line of an azimuth corridor. The center line extends from the referenced corridor origin location.
   * Example: /// Example: 12.876
   * Constraints: No constraints specified.
   */
  public double azCorrCenterLine() { int o = __offset(162); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Azimuth corridor arc distance measured in meters from reference point of azimuth corridor to far edge of bounded azimuth corridor wedge, measured along azimuth corridor center line.
   * Example: /// Example: 71.76
   * Constraints: No constraints specified.
   */
  public double azCorrArcWidth() { int o = __offset(164); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The error in the semi-intermediate axis.  The semi-intermediate axis is intermediate in length between semi-major and semi-minor axes. This field is doubled and centered on intersection of area semi-major axis and area semi-minor axis at 90 degrees to the plane defined by those axes. For these shapes, the volume is defined as having a 50-percent probability of containing the true location of the referenced entity.
   * Example: /// Example: 7010.882
   * Constraints: No constraints specified.
   */
  public double errSemiIntAxis() { int o = __offset(166); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The error in the Area Orientation.  Area Orientation is the angle or roll in degrees, between area semi-minor axis and plane defined by local vertical and area semi-major axis. When reported without major and minor axis, it is angle between an axis perpendicular to a 2D true north axis and plane defined by local vertical and a 2D true north axis.
   * Example: /// Example: 69.6
   * Constraints: No constraints specified.
   */
  public double errAreaOrient() { int o = __offset(168); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The error in the Semi-major elevation axis. Semi-major elevation axis is the elevation of the cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical semi-major axis, in degrees, measured from local horizontal.
   * Example: /// Example: 168.8
   * Constraints: No constraints specified.
   */
  public double errSemiMajElev() { int o = __offset(170); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Geometric area switch identifies the 3D shape of the error volume by providing the 2D shape for the 3D plane. The 3D plane is the plane orthogonal to the area semi-major axis and area semi-minor axis. Depending on whether the 2D plane is reported as an error ellipse 2D or as an error rectangle 2D, this switch reports a complete error volume that is cubical, 3D rectangular, cylindrical, 3D ellipsoidal, or spherical.
   * 0 - SWITCH_TYPE_UNKNOWN
   * 1 - SQUARE_RECTANGLE
   * 2 - CIRCLE_ELLIPSE.
   * Example: /// Example: CIRCLE_ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String errGeoAreaSwitch() { int o = __offset(172); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer errGeoAreaSwitchAsByteBuffer() { return __vector_as_bytebuffer(172, 1); }
  public ByteBuffer errGeoAreaSwitchInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 172, 1); }
  /**
   * Track point burnout altitude relative to WGS-84 ellipsoid, in meters.
   * Example: /// Example: 30567.452
   * Constraints: No constraints specified.
   */
  public double burnoutAlt() { int o = __offset(174); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Threat Event System Track ID.
   * Example: /// Example: 6217
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String tesEventId() { int o = __offset(176); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tesEventIdAsByteBuffer() { return __vector_as_bytebuffer(176, 1); }
  public ByteBuffer tesEventIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 176, 1); }
  /**
   * Track object speed, in meters/sec.
   * Example: /// Example: 15.03443
   * Constraints: No constraints specified.
   */
  public double spd() { int o = __offset(178); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The average speed, in kilometers/hour, calculated for the subject during the latest voyage/excursion.
   * Example: /// Example: 18.25
   * Constraints: No constraints specified.
   */
  public double avgSpd() { int o = __offset(180); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Motion model Time On Leg in hours.
   * Example: /// Example: 4.1
   * Constraints: No constraints specified.
   */
  public double tol() { int o = __offset(182); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
   * Example: /// Example: 153.01
   * Constraints: No constraints specified.
   */
  public double alt() { int o = __offset(184); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track object heading, in degrees clockwise from true north.
   * Example: /// Example: 19.7
   * Constraints: No constraints specified.
   */
  public double hdng() { int o = __offset(186); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
   * Example: /// Example: 4.3580153
   * Constraints: No constraints specified.
   */
  public double course() { int o = __offset(188); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The number of propeller revolutions per minute for a submarine or ship.
   * Example: /// Example: 8.2
   * Constraints: No constraints specified.
   */
  public double propRpm() { int o = __offset(190); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The number of turns of the vessel propellers per knot of forward motion.
   * Example: /// Example: 2.65
   * Constraints: No constraints specified.
   */
  public double tpk() { int o = __offset(192); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Cooperative Location Indicator specifies whether the reported entity location was derived using reported locations from sensors on more than one platform.
   * 0 - COOPERATIVE_LOCATOR_NONE
   * 1 - SINGLE_PLATFORM
   * 2 - FRAGMENT
   * 3 - COOPERATIVE.
   * Example: /// Example: COOPERATIVE
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String coopLocInd() { int o = __offset(194); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer coopLocIndAsByteBuffer() { return __vector_as_bytebuffer(194, 1); }
  public ByteBuffer coopLocIndInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 194, 1); }
  /**
   * The manuevering indicator specifying the missile boost phase.
   * 0 - POST_BOOST_NONE
   * 1 - POST_BOOST_MANUEVER
   * 2 - POST_BOOST_COMPLETE_MANUEVER.
   * Example: /// Example: POST_BOOST_NONE
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String maneuverInd() { int o = __offset(196); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer maneuverIndAsByteBuffer() { return __vector_as_bytebuffer(196, 1); }
  public ByteBuffer maneuverIndInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 196, 1); }
  /**
   * The launch location Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the launchAouData array and is required if launchAouData is not null. See the launchAouData field definition for specific information.
   * Example: /// Example: ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String launchAouType() { int o = __offset(198); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer launchAouTypeAsByteBuffer() { return __vector_as_bytebuffer(198, 1); }
  public ByteBuffer launchAouTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 198, 1); }
  /**
   * Three element array representing the launch location Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the launchAouType specified in this record:
   *  ELLIPSE:
   *    brg - orientation in degrees of the ellipse
   *    a1 - semi-major axis in meters
   *    a2 - semi-minor axis in meters
   *  BEARING (BEARING BOX or MTST BEARING BOX):
   *    brg - orientation in degrees of the bearing box
   *    a1 - length of bearing box in meters
   *    a2 - half-width of bearing box in meters
   *  OTHER (All other type values):
   *    brg - line of bearing in degrees true
   *    a1 - bearing error in degrees
   *    a2 - estimated range in meters.
   * Example: /// Example: [34.3, 26.5, 1.2]
   * Constraints: No constraints specified.
   */
  public String launchAouData(int j) { int o = __offset(200); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int launchAouDataLength() { int o = __offset(200); return o != 0 ? __vector_len(o) : 0; }
  public StringVector launchAouDataVector() { return launchAouDataVector(new StringVector()); }
  public StringVector launchAouDataVector(StringVector obj) { int o = __offset(200); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The impact point Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the impactAouData array and is required if impactAouData is not null. See the impactAouData field definition for specific information.
   * Example: /// Example: ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String impactAouType() { int o = __offset(202); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer impactAouTypeAsByteBuffer() { return __vector_as_bytebuffer(202, 1); }
  public ByteBuffer impactAouTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 202, 1); }
  /**
   * Three element array representing the impact point Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the impactAouType specified in this record:
   *  ELLIPSE:
   *    brg - orientation in degrees of the ellipse
   *    a1 - semi-major axis in meters
   *    a2 - semi-minor axis in meters
   *  BEARING (BEARING BOX or MTST BEARING BOX):
   *    brg - orientation in degrees of the bearing box
   *    a1 - length of bearing box in meters
   *    a2 - half-width of bearing box in meters
   *  OTHER (All other type values):
   *    brg - line of bearing in degrees true
   *    a1 - bearing error in degrees
   *    a2 - estimated range in meters.
   * Example: /// Example: [34.3, 26.5, 1.2]
   * Constraints: No constraints specified.
   */
  public String impactAouData(int j) { int o = __offset(204); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int impactAouDataLength() { int o = __offset(204); return o != 0 ? __vector_len(o) : 0; }
  public StringVector impactAouDataVector() { return impactAouDataVector(new StringVector()); }
  public StringVector impactAouDataVector(StringVector obj) { int o = __offset(204); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The track Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouRptData array and is required if aouRptData is not null. See the aouRptData field definition for specific information.
   * Example: /// Example: ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String aouRptType() { int o = __offset(206); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer aouRptTypeAsByteBuffer() { return __vector_as_bytebuffer(206, 1); }
  public ByteBuffer aouRptTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 206, 1); }
  /**
   * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouRptType specified in this record:
   *  ELLIPSE:
   *    brg - orientation in degrees of the ellipse
   *    a1 - semi-major axis in meters
   *    a2 - semi-minor axis in meters
   *  BEARING (BEARING BOX or MTST BEARING BOX):
   *    brg - orientation in degrees of the bearing box
   *    a1 - length of bearing box in meters
   *    a2 - half-width of bearing box in meters
   *  OTHER (All other type values):
   *    brg - line of bearing in degrees true
   *    a1 - bearing error in degrees
   *    a2 - estimated range in meters.
   * Example: /// Example: [34.3, 26.5, 1.2]
   * Constraints: No constraints specified.
   */
  public String aouRptData(int j) { int o = __offset(208); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int aouRptDataLength() { int o = __offset(208); return o != 0 ? __vector_len(o) : 0; }
  public StringVector aouRptDataVector() { return aouRptDataVector(new StringVector()); }
  public StringVector aouRptDataVector(StringVector obj) { int o = __offset(208); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Track object location in ECEF [x, y, z], meters. When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.35, 3.42]
   * Constraints: No constraints specified.
   */
  public String ecefPos(int j) { int o = __offset(210); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int ecefPosLength() { int o = __offset(210); return o != 0 ? __vector_len(o) : 0; }
  public StringVector ecefPosVector() { return ecefPosVector(new StringVector()); }
  public StringVector ecefPosVector(StringVector obj) { int o = __offset(210); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Track object velocity in ECEF [x', y', z'], meters/sec. When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.35, 3.42]
   * Constraints: No constraints specified.
   */
  public String ecefVel(int j) { int o = __offset(212); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int ecefVelLength() { int o = __offset(212); return o != 0 ? __vector_len(o) : 0; }
  public StringVector ecefVelVector() { return ecefVelVector(new StringVector()); }
  public StringVector ecefVelVector(StringVector obj) { int o = __offset(212); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The Area Of Uncertainty (AOU) percentage (0 - 100) containment value. The percentage of time (90%) that the estimated area of uncertainty will cover the true position of the track object.
   * Example: /// Example: 97
   * Constraints: No constraints specified.
   */
  public double containment() { int o = __offset(214); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The distance, in meters, of the closest point of approach between this track to the master reference track.
   * Example: /// Example: 500
   * Constraints: No constraints specified.
   */
  public double cpa() { int o = __offset(216); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The time, in ISO 8601 UTC format with millisecond precision, of the  closest point of approach between this track and the master reference track.
   * Example: /// Example: 2021-02-25T12:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String tcpa() { int o = __offset(218); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tcpaAsByteBuffer() { return __vector_as_bytebuffer(218, 1); }
  public ByteBuffer tcpaInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 218, 1); }
  /**
   * The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Underway Using Engine
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String navStatus() { int o = __offset(220); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer navStatusAsByteBuffer() { return __vector_as_bytebuffer(220, 1); }
  public ByteBuffer navStatusInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 220, 1); }
  /**
   * The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: GPS
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String posDeviceType() { int o = __offset(222); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer posDeviceTypeAsByteBuffer() { return __vector_as_bytebuffer(222, 1); }
  public ByteBuffer posDeviceTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 222, 1); }
  /**
   * Type of Aid to Navigation. Intended as, but not constrained to, the USCG NAVCEN  aids to navigation. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Cardinal Mark N
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String aton() { int o = __offset(224); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer atonAsByteBuffer() { return __vector_as_bytebuffer(224, 1); }
  public ByteBuffer atonInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 224, 1); }
  /**
   * Indicator position (OFF, ON, UNK) for optional floating navigational aids only.
   * Example: /// Example: ON
   * Constraints: Minimum length = 0, Maximum length = 3
   */
  public String offPosInd() { int o = __offset(226); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer offPosIndAsByteBuffer() { return __vector_as_bytebuffer(226, 1); }
  public ByteBuffer offPosIndInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 226, 1); }
  /**
   * The reference dimensions of the vessel, reported as [A, B, C, D], in meters. Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna. Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
   * Example: /// Example: [50.1, 50.1, 20.1, 20.1]
   * Constraints: No constraints specified.
   */
  public String antennaRefDimensions(int j) { int o = __offset(228); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int antennaRefDimensionsLength() { int o = __offset(228); return o != 0 ? __vector_len(o) : 0; }
  public StringVector antennaRefDimensionsVector() { return antennaRefDimensionsVector(new StringVector()); }
  public StringVector antennaRefDimensionsVector(StringVector obj) { int o = __offset(228); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The common name for a group of ships with similar design, usually named for the first vessel of the class.
   * Example: /// Example: Nimitz
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String shipClass() { int o = __offset(230); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer shipClassAsByteBuffer() { return __vector_as_bytebuffer(230, 1); }
  public ByteBuffer shipClassInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 230, 1); }
  /**
   * The International Maritime Organization Number of the vessel. IMON is a seven-digit number that uniquely identifies the vessel.
   * Example: /// Example: 9015462
   * Constraints: No constraints specified.
   */
  public int imon() { int o = __offset(232); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The Maritime Mobile Service Identity of the vessel. MMSI is a nine-digit number that identifies the transmitter station of the vessel.
   * Example: /// Example: 304010417
   * Constraints: No constraints specified.
   */
  public int mmsi() { int o = __offset(234); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The maximum static draught, in meters, of the vessel according to the AIS transmission.
   * Example: /// Example: 21.1
   * Constraints: No constraints specified.
   */
  public double draught() { int o = __offset(236); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The overall length of the vessel, in meters. A value of 511 indicates a vessel length of 511 meters or greater.
   * Example: /// Example: 511.1
   * Constraints: No constraints specified.
   */
  public double length() { int o = __offset(238); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The breadth of the vessel, in meters. A value of 63 indicates a vessel breadth of 63 meters or greater.
   * Example: /// Example: 24.1
   * Constraints: No constraints specified.
   */
  public double width() { int o = __offset(240); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Freight
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String cargoType() { int o = __offset(242); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer cargoTypeAsByteBuffer() { return __vector_as_bytebuffer(242, 1); }
  public ByteBuffer cargoTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 242, 1); }
  /**
   * Appearance group code.
   * GP1 - Superstructure exceeds 1/3 of ship length.
   * GP2 - Superstructure less than 1/3 of ship length.
   * GP3 - Stack aft.
   * Example: /// Example: GP1
   * Constraints: Minimum length = 0, Maximum length = 7
   */
  public String appGrp() { int o = __offset(244); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer appGrpAsByteBuffer() { return __vector_as_bytebuffer(244, 1); }
  public ByteBuffer appGrpInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 244, 1); }
  /**
   * Hull profile code. Based on GCCS-J hull profiles.
   * FLUSH           No breaks in Hull Profile.
   * RAISED 1        Hull Profile shows distinct raised area at bow. Remainder of deck is flush.
   * RAISED 2        Hull Profile shows distinct raised area amidships. Bow and stern are flush.
   * RAISED 3        Hull Profile shows distinct raised area at stern. Remainder of deck is flush.
   * RAISED 1-2-3    Distinct raised areas at bow, midships, and stern with breaks between each raise.
   * RAISED 1-2      Raised area at bow and midships with break between.
   * RAISED 1-3      Raised area at bow and stern with break between.
   * RAISED 12       Continuous raised area encompassing both bow and midships.
   * RAISED 23       Continuous raised area encompassing midships and stern.
   * RAISED 12-3     Raised areas at bow, midships and stern. Bow and midship raises are continuous. Break between midship and stern raises.
   * RAISED 1-23     Raised areas at bow, midships, and stern. Midship and stern raises are continuous with break between bow and midship raises.
   * RAISED 1-L2-3   Raised areas at bow, midships, and stern with break between each raise. Midships raise is longer than that associated with raised 1-2-3.
   * Example: /// Example: Raised 1-23
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String hullProf() { int o = __offset(246); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer hullProfAsByteBuffer() { return __vector_as_bytebuffer(246, 1); }
  public ByteBuffer hullProfInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 246, 1); }
  /**
   * The type of propulsion employed by the track object (Diesel, Nuclear).
   * Example: /// Example: Diesel
   * Constraints: Minimum length = 0, Maximum length = 6
   */
  public String propType() { int o = __offset(248); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer propTypeAsByteBuffer() { return __vector_as_bytebuffer(248, 1); }
  public ByteBuffer propTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 248, 1); }
  /**
   * The number of blades per shaft of the track object.  Applicable for maritime vessels.
   * Example: /// Example: 4
   * Constraints: No constraints specified.
   */
  public int numBlades() { int o = __offset(250); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of shafts on the track object.  Applicable for maritime vessels.
   * Example: /// Example: 3
   * Constraints: No constraints specified.
   */
  public int numShafts() { int o = __offset(252); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The stern type code (Counter, Cruiser) associated with the track object.
   * Example: /// Example: Cruiser
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String sternType() { int o = __offset(254); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sternTypeAsByteBuffer() { return __vector_as_bytebuffer(254, 1); }
  public ByteBuffer sternTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 254, 1); }
  /**
   * The weight, in tons, of the vessel associated with this track.
   * Example: /// Example: 3423.76
   * Constraints: No constraints specified.
   */
  public double vslWt() { int o = __offset(256); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Arrival Time of the vessel at the destination, in ISO 8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String arrTime() { int o = __offset(258); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer arrTimeAsByteBuffer() { return __vector_as_bytebuffer(258, 1); }
  public ByteBuffer arrTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 258, 1); }
  /**
   * The flag of the arrival port.
   * Example: /// Example: USA
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String arrFlag() { int o = __offset(260); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer arrFlagAsByteBuffer() { return __vector_as_bytebuffer(260, 1); }
  public ByteBuffer arrFlagInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 260, 1); }
  /**
   * The reported arrival cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Freight
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String arrCargo() { int o = __offset(262); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer arrCargoAsByteBuffer() { return __vector_as_bytebuffer(262, 1); }
  public ByteBuffer arrCargoInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 262, 1); }
  /**
   * The Arrival Port of the vessel according to the AIS transmission.
   * Example: /// Example: Lanshan
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String arrPort() { int o = __offset(264); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer arrPortAsByteBuffer() { return __vector_as_bytebuffer(264, 1); }
  public ByteBuffer arrPortInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 264, 1); }
  /**
   * The Departure Port of the vessel according to the AIS transmission.
   * Example: /// Example: Lanshan
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String depPort() { int o = __offset(266); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer depPortAsByteBuffer() { return __vector_as_bytebuffer(266, 1); }
  public ByteBuffer depPortInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 266, 1); }
  /**
   * The flag of the departure port.
   * Example: /// Example: USA
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String depFlag() { int o = __offset(268); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer depFlagAsByteBuffer() { return __vector_as_bytebuffer(268, 1); }
  public ByteBuffer depFlagInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 268, 1); }
  /**
   * The reported departure cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Freight
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String depCargo() { int o = __offset(270); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer depCargoAsByteBuffer() { return __vector_as_bytebuffer(270, 1); }
  public ByteBuffer depCargoInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 270, 1); }
  /**
   * The flag of the destination port.
   * Example: /// Example: USA
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String desFlag() { int o = __offset(272); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer desFlagAsByteBuffer() { return __vector_as_bytebuffer(272, 1); }
  public ByteBuffer desFlagInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 272, 1); }
  /**
   * The reported destination cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Freight
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String desCargo() { int o = __offset(274); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer desCargoAsByteBuffer() { return __vector_as_bytebuffer(274, 1); }
  public ByteBuffer desCargoInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 274, 1); }
  /**
   * The destination of the vessel according to the AIS transmission.
   * Example: /// Example: USCLE
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String destination() { int o = __offset(276); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer destinationAsByteBuffer() { return __vector_as_bytebuffer(276, 1); }
  public ByteBuffer destinationInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 276, 1); }
  /**
   * The Estimated Time of Arrival of the vessel at the destination port, in ISO 8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String eta() { int o = __offset(278); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer etaAsByteBuffer() { return __vector_as_bytebuffer(278, 1); }
  public ByteBuffer etaInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 278, 1); }
  /**
   * The Estimated Time of Departure of the vessel from the departure port (depPort), according to Marine Traffic calculations, in ISO 8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String etd() { int o = __offset(280); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer etdAsByteBuffer() { return __vector_as_bytebuffer(280, 1); }
  public ByteBuffer etdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 280, 1); }
  /**
   * A text amplifier displaying IFF/SIF/AIS Identification modes and codes.
   * Example: /// Example: ID Mode
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String iff() { int o = __offset(282); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer iffAsByteBuffer() { return __vector_as_bytebuffer(282, 1); }
  public ByteBuffer iffInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 282, 1); }
  /**
   * Flag indicating that the track object has an emergency.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean emgInd() { int o = __offset(284); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The drop-point indicator setting.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean dropPtInd() { int o = __offset(286); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track represents a reinforced object or group.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean reinforced() { int o = __offset(288); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating for the track represents a reduced force object or group.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean reduced() { int o = __offset(290); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track represents a headquarters object.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean hq() { int o = __offset(292); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track represents a dummy object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean dummy() { int o = __offset(294); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track represents a task force.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean taskForce() { int o = __offset(296); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track represents a feint object or group.  Identifies offensive or defensive units, equipment, and/or installations intended to draw the enemy's attention away from the area of the main attack.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean feint() { int o = __offset(298); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating that this track represents an installation.  Based on MIL-STD-2525 symbology definitions.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean installation() { int o = __offset(300); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * A text amplifier for units, equipment and installations; content is implementation specific.
   * Example: /// Example: Staff Comments
   * Constraints: Minimum length = 0, Maximum length = 256
   */
  public String staffCmts() { int o = __offset(302); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer staffCmtsAsByteBuffer() { return __vector_as_bytebuffer(302, 1); }
  public ByteBuffer staffCmtsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 302, 1); }
  /**
   * A text amplifier for units, equipment and installations; content is implementation specific.
   * Example: /// Example: Additional information
   * Constraints: Minimum length = 0, Maximum length = 256
   */
  public String addInfo() { int o = __offset(304); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer addInfoAsByteBuffer() { return __vector_as_bytebuffer(304, 1); }
  public ByteBuffer addInfoInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 304, 1); }
  /**
   * A text amplifier code for units, equipment, and installations that consists of a one-letter reliability rating and a one-number credibility rating based on the following definitions of each:
   *  Reliability Ratings:
   *   A-completely reliable
   *   B-usually reliable
   *   C-fairly reliable
   *   D-not usually reliable
   *   E-unreliable
   *   F-reliability cannot be judged
   *  Credibility Ratings:
   *   1-confirmed by other sources
   *   2-probably true
   *   3-possibly true
   *   4-doubtfully true
   *   5-improbable
   *   6-truth cannot be judged.
   * Example: /// Example: A1
   * Constraints: Minimum length = 0, Maximum length = 2
   */
  public String evalRating() { int o = __offset(306); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer evalRatingAsByteBuffer() { return __vector_as_bytebuffer(306, 1); }
  public ByteBuffer evalRatingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 306, 1); }
  /**
   * Time the row was created in the database.
   * Example: /// Example: 2021-02-25T12:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(308); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(308, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 308, 1); }
  /**
   * Application user who created the row in the database.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String createdBy() { int o = __offset(310); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(310, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 310, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String source() { int o = __offset(312); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(312, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 312, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(314); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(314, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 314, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(316); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: ORIG
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(318); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(318, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 318, 1); }

  public static void startTrackDetails_Abridged(FlatBufferBuilder builder) { builder.startTable(158); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addEnv(FlatBufferBuilder builder, byte env) { builder.addByte(2, env, 0); }
  public static void addMsgType(FlatBufferBuilder builder, int msgTypeOffset) { builder.addOffset(3, msgTypeOffset, 0); }
  public static void addHullNum(FlatBufferBuilder builder, int hullNumOffset) { builder.addOffset(4, hullNumOffset, 0); }
  public static void addPif(FlatBufferBuilder builder, int pifOffset) { builder.addOffset(5, pifOffset, 0); }
  public static void addSconum(FlatBufferBuilder builder, int sconumOffset) { builder.addOffset(6, sconumOffset, 0); }
  public static void addNtds(FlatBufferBuilder builder, int ntdsOffset) { builder.addOffset(7, ntdsOffset, 0); }
  public static void addDisId(FlatBufferBuilder builder, int disIdOffset) { builder.addOffset(8, disIdOffset, 0); }
  public static void addMidbCat(FlatBufferBuilder builder, int midbCatOffset) { builder.addOffset(9, midbCatOffset, 0); }
  public static void addBeNumber(FlatBufferBuilder builder, int beNumberOffset) { builder.addOffset(10, beNumberOffset, 0); }
  public static void addOSuffix(FlatBufferBuilder builder, int oSuffixOffset) { builder.addOffset(11, oSuffixOffset, 0); }
  public static void addPin(FlatBufferBuilder builder, int pinOffset) { builder.addOffset(12, pinOffset, 0); }
  public static void addLostTrkInd(FlatBufferBuilder builder, boolean lostTrkInd) { builder.addBoolean(13, lostTrkInd, false); }
  public static void addMuidSrcTrk(FlatBufferBuilder builder, int muidSrcTrkOffset) { builder.addOffset(14, muidSrcTrkOffset, 0); }
  public static void addMuidSrc(FlatBufferBuilder builder, int muidSrcOffset) { builder.addOffset(15, muidSrcOffset, 0); }
  public static void addMslStatus(FlatBufferBuilder builder, int mslStatusOffset) { builder.addOffset(16, mslStatusOffset, 0); }
  public static void addTrkConf(FlatBufferBuilder builder, double trkConf) { builder.addDouble(17, trkConf, 0.0); }
  public static void addTrkQual(FlatBufferBuilder builder, int trkQual) { builder.addInt(18, trkQual, 0); }
  public static void addAlert(FlatBufferBuilder builder, int alertOffset) { builder.addOffset(19, alertOffset, 0); }
  public static void addOrigXref(FlatBufferBuilder builder, int origXrefOffset) { builder.addOffset(20, origXrefOffset, 0); }
  public static void addElnot1(FlatBufferBuilder builder, int elnot1Offset) { builder.addOffset(21, elnot1Offset, 0); }
  public static void addElnot2(FlatBufferBuilder builder, int elnot2Offset) { builder.addOffset(22, elnot2Offset, 0); }
  public static void addObjIdent(FlatBufferBuilder builder, byte objIdent) { builder.addByte(23, objIdent, 0); }
  public static void addObjType(FlatBufferBuilder builder, int objTypeOffset) { builder.addOffset(24, objTypeOffset, 0); }
  public static void addObjPlat(FlatBufferBuilder builder, int objPlatOffset) { builder.addOffset(25, objPlatOffset, 0); }
  public static void addObjAct(FlatBufferBuilder builder, int objActOffset) { builder.addOffset(26, objActOffset, 0); }
  public static void addObjNat(FlatBufferBuilder builder, int objNatOffset) { builder.addOffset(27, objNatOffset, 0); }
  public static void addName(FlatBufferBuilder builder, int nameOffset) { builder.addOffset(28, nameOffset, 0); }
  public static void addShortName(FlatBufferBuilder builder, int shortNameOffset) { builder.addOffset(29, shortNameOffset, 0); }
  public static void addTrkId(FlatBufferBuilder builder, int trkIdOffset) { builder.addOffset(30, trkIdOffset, 0); }
  public static void addTrkNum(FlatBufferBuilder builder, int trkNumOffset) { builder.addOffset(31, trkNumOffset, 0); }
  public static void addTrkScope(FlatBufferBuilder builder, int trkScopeOffset) { builder.addOffset(32, trkScopeOffset, 0); }
  public static void addSourceUid(FlatBufferBuilder builder, int sourceUidOffset) { builder.addOffset(33, sourceUidOffset, 0); }
  public static void addCallSign(FlatBufferBuilder builder, int callSignOffset) { builder.addOffset(34, callSignOffset, 0); }
  public static void addIdentAmp(FlatBufferBuilder builder, int identAmpOffset) { builder.addOffset(35, identAmpOffset, 0); }
  public static void addSpaceAmp(FlatBufferBuilder builder, int spaceAmpOffset) { builder.addOffset(36, spaceAmpOffset, 0); }
  public static void addSpaceAmpConf(FlatBufferBuilder builder, int spaceAmpConf) { builder.addInt(37, spaceAmpConf, 0); }
  public static void addSpaceSpecType(FlatBufferBuilder builder, int spaceSpecTypeOffset) { builder.addOffset(38, spaceSpecTypeOffset, 0); }
  public static void addAcftSubType(FlatBufferBuilder builder, int acftSubTypeOffset) { builder.addOffset(39, acftSubTypeOffset, 0); }
  public static void addTs(FlatBufferBuilder builder, int tsOffset) { builder.addOffset(40, tsOffset, 0); }
  public static void addLaunchTime(FlatBufferBuilder builder, int launchTimeOffset) { builder.addOffset(41, launchTimeOffset, 0); }
  public static void addImpactTime(FlatBufferBuilder builder, int impactTimeOffset) { builder.addOffset(42, impactTimeOffset, 0); }
  public static void addFtnMsgTs(FlatBufferBuilder builder, int ftnMsgTsOffset) { builder.addOffset(43, ftnMsgTsOffset, 0); }
  public static void addFtn(FlatBufferBuilder builder, int ftnOffset) { builder.addOffset(44, ftnOffset, 0); }
  public static void addFtnCmd(FlatBufferBuilder builder, int ftnCmdOffset) { builder.addOffset(45, ftnCmdOffset, 0); }
  public static void addRtnMsgTs(FlatBufferBuilder builder, int rtnMsgTsOffset) { builder.addOffset(46, rtnMsgTsOffset, 0); }
  public static int createRtnMsgTsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startRtnMsgTsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addRtn(FlatBufferBuilder builder, int rtnOffset) { builder.addOffset(47, rtnOffset, 0); }
  public static int createRtnVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startRtnVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addRtnTrkState(FlatBufferBuilder builder, int rtnTrkStateOffset) { builder.addOffset(48, rtnTrkStateOffset, 0); }
  public static void addRtnCmd(FlatBufferBuilder builder, int rtnCmdOffset) { builder.addOffset(49, rtnCmdOffset, 0); }
  public static void addSen(FlatBufferBuilder builder, int senOffset) { builder.addOffset(50, senOffset, 0); }
  public static void addRptChxref(FlatBufferBuilder builder, int rptChxrefOffset) { builder.addOffset(51, rptChxrefOffset, 0); }
  public static void addRptArchived(FlatBufferBuilder builder, boolean rptArchived) { builder.addBoolean(52, rptArchived, false); }
  public static void addSelfReport(FlatBufferBuilder builder, boolean selfReport) { builder.addBoolean(53, selfReport, false); }
  public static void addMil2525Bstr(FlatBufferBuilder builder, int mil2525BstrOffset) { builder.addOffset(54, mil2525BstrOffset, 0); }
  public static void addTrnspdrId(FlatBufferBuilder builder, int trnspdrIdOffset) { builder.addOffset(55, trnspdrIdOffset, 0); }
  public static void addTrnspdrType(FlatBufferBuilder builder, int trnspdrTypeOffset) { builder.addOffset(56, trnspdrTypeOffset, 0); }
  public static void addEmitterName(FlatBufferBuilder builder, int emitterNameOffset) { builder.addOffset(57, emitterNameOffset, 0); }
  public static void addInfoSource(FlatBufferBuilder builder, int infoSourceOffset) { builder.addOffset(58, infoSourceOffset, 0); }
  public static void addBoosting(FlatBufferBuilder builder, boolean boosting) { builder.addBoolean(59, boosting, false); }
  public static void addFreq(FlatBufferBuilder builder, double freq) { builder.addDouble(60, freq, 0.0); }
  public static void addMaxFreq(FlatBufferBuilder builder, double maxFreq) { builder.addDouble(61, maxFreq, 0.0); }
  public static void addHarmonics(FlatBufferBuilder builder, int harmonicsOffset) { builder.addOffset(62, harmonicsOffset, 0); }
  public static void addPri(FlatBufferBuilder builder, double pri) { builder.addDouble(63, pri, 0.0); }
  public static void addPrf(FlatBufferBuilder builder, double prf) { builder.addDouble(64, prf, 0.0); }
  public static void addPw(FlatBufferBuilder builder, double pw) { builder.addDouble(65, pw, 0.0); }
  public static void addScanType(FlatBufferBuilder builder, int scanTypeOffset) { builder.addOffset(66, scanTypeOffset, 0); }
  public static void addScanRate(FlatBufferBuilder builder, double scanRate) { builder.addDouble(67, scanRate, 0.0); }
  public static void addScn(FlatBufferBuilder builder, int scn) { builder.addInt(68, scn, 0); }
  public static void addCI(FlatBufferBuilder builder, int cIOffset) { builder.addOffset(69, cIOffset, 0); }
  public static void addAngElev(FlatBufferBuilder builder, double angElev) { builder.addDouble(70, angElev, 0.0); }
  public static void addLat(FlatBufferBuilder builder, double lat) { builder.addDouble(71, lat, 0.0); }
  public static void addLon(FlatBufferBuilder builder, double lon) { builder.addDouble(72, lon, 0.0); }
  public static void addLaunchLat(FlatBufferBuilder builder, double launchLat) { builder.addDouble(73, launchLat, 0.0); }
  public static void addLaunchLon(FlatBufferBuilder builder, double launchLon) { builder.addDouble(74, launchLon, 0.0); }
  public static void addImpactLat(FlatBufferBuilder builder, double impactLat) { builder.addDouble(75, impactLat, 0.0); }
  public static void addImpactLon(FlatBufferBuilder builder, double impactLon) { builder.addDouble(76, impactLon, 0.0); }
  public static void addPolarSingLocLat(FlatBufferBuilder builder, double polarSingLocLat) { builder.addDouble(77, polarSingLocLat, 0.0); }
  public static void addPolarSingLocLon(FlatBufferBuilder builder, double polarSingLocLon) { builder.addDouble(78, polarSingLocLon, 0.0); }
  public static void addAzCorrCenterLine(FlatBufferBuilder builder, double azCorrCenterLine) { builder.addDouble(79, azCorrCenterLine, 0.0); }
  public static void addAzCorrArcWidth(FlatBufferBuilder builder, double azCorrArcWidth) { builder.addDouble(80, azCorrArcWidth, 0.0); }
  public static void addErrSemiIntAxis(FlatBufferBuilder builder, double errSemiIntAxis) { builder.addDouble(81, errSemiIntAxis, 0.0); }
  public static void addErrAreaOrient(FlatBufferBuilder builder, double errAreaOrient) { builder.addDouble(82, errAreaOrient, 0.0); }
  public static void addErrSemiMajElev(FlatBufferBuilder builder, double errSemiMajElev) { builder.addDouble(83, errSemiMajElev, 0.0); }
  public static void addErrGeoAreaSwitch(FlatBufferBuilder builder, int errGeoAreaSwitchOffset) { builder.addOffset(84, errGeoAreaSwitchOffset, 0); }
  public static void addBurnoutAlt(FlatBufferBuilder builder, double burnoutAlt) { builder.addDouble(85, burnoutAlt, 0.0); }
  public static void addTesEventId(FlatBufferBuilder builder, int tesEventIdOffset) { builder.addOffset(86, tesEventIdOffset, 0); }
  public static void addSpd(FlatBufferBuilder builder, double spd) { builder.addDouble(87, spd, 0.0); }
  public static void addAvgSpd(FlatBufferBuilder builder, double avgSpd) { builder.addDouble(88, avgSpd, 0.0); }
  public static void addTol(FlatBufferBuilder builder, double tol) { builder.addDouble(89, tol, 0.0); }
  public static void addAlt(FlatBufferBuilder builder, double alt) { builder.addDouble(90, alt, 0.0); }
  public static void addHdng(FlatBufferBuilder builder, double hdng) { builder.addDouble(91, hdng, 0.0); }
  public static void addCourse(FlatBufferBuilder builder, double course) { builder.addDouble(92, course, 0.0); }
  public static void addPropRpm(FlatBufferBuilder builder, double propRpm) { builder.addDouble(93, propRpm, 0.0); }
  public static void addTpk(FlatBufferBuilder builder, double tpk) { builder.addDouble(94, tpk, 0.0); }
  public static void addCoopLocInd(FlatBufferBuilder builder, int coopLocIndOffset) { builder.addOffset(95, coopLocIndOffset, 0); }
  public static void addManeuverInd(FlatBufferBuilder builder, int maneuverIndOffset) { builder.addOffset(96, maneuverIndOffset, 0); }
  public static void addLaunchAouType(FlatBufferBuilder builder, int launchAouTypeOffset) { builder.addOffset(97, launchAouTypeOffset, 0); }
  public static void addLaunchAouData(FlatBufferBuilder builder, int launchAouDataOffset) { builder.addOffset(98, launchAouDataOffset, 0); }
  public static int createLaunchAouDataVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLaunchAouDataVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addImpactAouType(FlatBufferBuilder builder, int impactAouTypeOffset) { builder.addOffset(99, impactAouTypeOffset, 0); }
  public static void addImpactAouData(FlatBufferBuilder builder, int impactAouDataOffset) { builder.addOffset(100, impactAouDataOffset, 0); }
  public static int createImpactAouDataVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startImpactAouDataVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addAouRptType(FlatBufferBuilder builder, int aouRptTypeOffset) { builder.addOffset(101, aouRptTypeOffset, 0); }
  public static void addAouRptData(FlatBufferBuilder builder, int aouRptDataOffset) { builder.addOffset(102, aouRptDataOffset, 0); }
  public static int createAouRptDataVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAouRptDataVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addEcefPos(FlatBufferBuilder builder, int ecefPosOffset) { builder.addOffset(103, ecefPosOffset, 0); }
  public static int createEcefPosVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startEcefPosVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addEcefVel(FlatBufferBuilder builder, int ecefVelOffset) { builder.addOffset(104, ecefVelOffset, 0); }
  public static int createEcefVelVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startEcefVelVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addContainment(FlatBufferBuilder builder, double containment) { builder.addDouble(105, containment, 0.0); }
  public static void addCpa(FlatBufferBuilder builder, double cpa) { builder.addDouble(106, cpa, 0.0); }
  public static void addTcpa(FlatBufferBuilder builder, int tcpaOffset) { builder.addOffset(107, tcpaOffset, 0); }
  public static void addNavStatus(FlatBufferBuilder builder, int navStatusOffset) { builder.addOffset(108, navStatusOffset, 0); }
  public static void addPosDeviceType(FlatBufferBuilder builder, int posDeviceTypeOffset) { builder.addOffset(109, posDeviceTypeOffset, 0); }
  public static void addAton(FlatBufferBuilder builder, int atonOffset) { builder.addOffset(110, atonOffset, 0); }
  public static void addOffPosInd(FlatBufferBuilder builder, int offPosIndOffset) { builder.addOffset(111, offPosIndOffset, 0); }
  public static void addAntennaRefDimensions(FlatBufferBuilder builder, int antennaRefDimensionsOffset) { builder.addOffset(112, antennaRefDimensionsOffset, 0); }
  public static int createAntennaRefDimensionsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAntennaRefDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addShipClass(FlatBufferBuilder builder, int shipClassOffset) { builder.addOffset(113, shipClassOffset, 0); }
  public static void addImon(FlatBufferBuilder builder, int imon) { builder.addInt(114, imon, 0); }
  public static void addMmsi(FlatBufferBuilder builder, int mmsi) { builder.addInt(115, mmsi, 0); }
  public static void addDraught(FlatBufferBuilder builder, double draught) { builder.addDouble(116, draught, 0.0); }
  public static void addLength(FlatBufferBuilder builder, double length) { builder.addDouble(117, length, 0.0); }
  public static void addWidth(FlatBufferBuilder builder, double width) { builder.addDouble(118, width, 0.0); }
  public static void addCargoType(FlatBufferBuilder builder, int cargoTypeOffset) { builder.addOffset(119, cargoTypeOffset, 0); }
  public static void addAppGrp(FlatBufferBuilder builder, int appGrpOffset) { builder.addOffset(120, appGrpOffset, 0); }
  public static void addHullProf(FlatBufferBuilder builder, int hullProfOffset) { builder.addOffset(121, hullProfOffset, 0); }
  public static void addPropType(FlatBufferBuilder builder, int propTypeOffset) { builder.addOffset(122, propTypeOffset, 0); }
  public static void addNumBlades(FlatBufferBuilder builder, int numBlades) { builder.addInt(123, numBlades, 0); }
  public static void addNumShafts(FlatBufferBuilder builder, int numShafts) { builder.addInt(124, numShafts, 0); }
  public static void addSternType(FlatBufferBuilder builder, int sternTypeOffset) { builder.addOffset(125, sternTypeOffset, 0); }
  public static void addVslWt(FlatBufferBuilder builder, double vslWt) { builder.addDouble(126, vslWt, 0.0); }
  public static void addArrTime(FlatBufferBuilder builder, int arrTimeOffset) { builder.addOffset(127, arrTimeOffset, 0); }
  public static void addArrFlag(FlatBufferBuilder builder, int arrFlagOffset) { builder.addOffset(128, arrFlagOffset, 0); }
  public static void addArrCargo(FlatBufferBuilder builder, int arrCargoOffset) { builder.addOffset(129, arrCargoOffset, 0); }
  public static void addArrPort(FlatBufferBuilder builder, int arrPortOffset) { builder.addOffset(130, arrPortOffset, 0); }
  public static void addDepPort(FlatBufferBuilder builder, int depPortOffset) { builder.addOffset(131, depPortOffset, 0); }
  public static void addDepFlag(FlatBufferBuilder builder, int depFlagOffset) { builder.addOffset(132, depFlagOffset, 0); }
  public static void addDepCargo(FlatBufferBuilder builder, int depCargoOffset) { builder.addOffset(133, depCargoOffset, 0); }
  public static void addDesFlag(FlatBufferBuilder builder, int desFlagOffset) { builder.addOffset(134, desFlagOffset, 0); }
  public static void addDesCargo(FlatBufferBuilder builder, int desCargoOffset) { builder.addOffset(135, desCargoOffset, 0); }
  public static void addDestination(FlatBufferBuilder builder, int destinationOffset) { builder.addOffset(136, destinationOffset, 0); }
  public static void addEta(FlatBufferBuilder builder, int etaOffset) { builder.addOffset(137, etaOffset, 0); }
  public static void addEtd(FlatBufferBuilder builder, int etdOffset) { builder.addOffset(138, etdOffset, 0); }
  public static void addIff(FlatBufferBuilder builder, int iffOffset) { builder.addOffset(139, iffOffset, 0); }
  public static void addEmgInd(FlatBufferBuilder builder, boolean emgInd) { builder.addBoolean(140, emgInd, false); }
  public static void addDropPtInd(FlatBufferBuilder builder, boolean dropPtInd) { builder.addBoolean(141, dropPtInd, false); }
  public static void addReinforced(FlatBufferBuilder builder, boolean reinforced) { builder.addBoolean(142, reinforced, false); }
  public static void addReduced(FlatBufferBuilder builder, boolean reduced) { builder.addBoolean(143, reduced, false); }
  public static void addHq(FlatBufferBuilder builder, boolean hq) { builder.addBoolean(144, hq, false); }
  public static void addDummy(FlatBufferBuilder builder, boolean dummy) { builder.addBoolean(145, dummy, false); }
  public static void addTaskForce(FlatBufferBuilder builder, boolean taskForce) { builder.addBoolean(146, taskForce, false); }
  public static void addFeint(FlatBufferBuilder builder, boolean feint) { builder.addBoolean(147, feint, false); }
  public static void addInstallation(FlatBufferBuilder builder, boolean installation) { builder.addBoolean(148, installation, false); }
  public static void addStaffCmts(FlatBufferBuilder builder, int staffCmtsOffset) { builder.addOffset(149, staffCmtsOffset, 0); }
  public static void addAddInfo(FlatBufferBuilder builder, int addInfoOffset) { builder.addOffset(150, addInfoOffset, 0); }
  public static void addEvalRating(FlatBufferBuilder builder, int evalRatingOffset) { builder.addOffset(151, evalRatingOffset, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(152, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(153, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(154, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(155, originOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(156, dataMode, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(157, origNetworkOffset, 0); }
  public static int endTrackDetails_Abridged(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishTrackDetails_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "TRAC"); }
  public static void finishSizePrefixedTrackDetails_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "TRAC"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public TrackDetails_Abridged get(int j) { return get(new TrackDetails_Abridged(), j); }
    public TrackDetails_Abridged get(TrackDetails_Abridged obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

