// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// Collect Requests support several types of individual requests, or planned/scheduled tasks on sensors and/or orbital objects. Options are provided to accomodate most common sensor contact and collection applications, including single sensor-object tasking, search operations, and TT&C support. Multiple requests originating from a plan or schedule may be associated to a sensor plan if desired.
 */
@SuppressWarnings("unused")
public final class CollectRequest_Ingest extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static CollectRequest_Ingest getRootAsCollectRequest_Ingest(ByteBuffer _bb) { return getRootAsCollectRequest_Ingest(_bb, new CollectRequest_Ingest()); }
  public static CollectRequest_Ingest getRootAsCollectRequest_Ingest(ByteBuffer _bb, CollectRequest_Ingest obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean CollectRequest_IngestBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "COLL"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public CollectRequest_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: COLLECTREQUEST-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * The unique ID of the collect request record from which this request originated. This may be used for cases of sensor-to-sensor tasking, such as tip/cue operations.
   * Example: /// Example: da98671b-34db-47bf-8c8d-7c668b92c800
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idParentReq() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idParentReqAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer idParentReqInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * The type of external message from which this request originated.
   * Example: /// Example: SU67
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String msgType() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgTypeAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer msgTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
   * Example: /// Example: 2024-04-25T08:17:01.346Z
   * Constraints: No constraints specified.
   */
  public String msgCreateDate() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgCreateDateAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer msgCreateDateInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The type of this collect or contact request (DIRECTED SEARCH, DWELL, OBJECT, POL, RATE TRACK, SEARCH, SOI, STARE, TTC, VOLUME SEARCH, etc.).
   * Example: /// Example: DWELL
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String type() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer typeAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer typeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Unique identifier of the parent plan or schedule associated with this request.  If null, this request is assumed not associated with a plan or schedule.
   * Example: /// Example: REF-PLAN-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idPlan() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idPlanAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer idPlanInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Index number (integer) for records within a collection plan or schedule.
   * Example: /// Example: 8
   * Constraints: No constraints specified.
   */
  public int planIndex() { int o = __offset(18); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Task ID associated with this request.  A task ID may be associated with a single collect request or may be used to tie together the sub-requests of a full collect, for example a DWELL consisting of many dwell points.
   * Example: /// Example: TASK-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String taskId() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer taskIdAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer taskIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * The dwell ID associated with this request.  A dwell ID is dwell point specific and a DWELL request consist of many dwell point requests.
   * Example: /// Example: DWELL-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String dwellId() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer dwellIdAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer dwellIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * Optional ID from external systems.  This field has no meaning within UDL and is provided as a convenience for systems that require tracking of an internal system generated ID.
   * Example: /// Example: EXTERNAL-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String externalId() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer externalIdAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer externalIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * Unique identifier of the requested/scheduled/planned sensor associated with this request.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
   * Example: /// Example: REF-SENSOR-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idSensor() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idSensorAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer idSensorInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * Optional identifier provided by the source to indicate the sensor identifier requested/scheduled/planned for this request. This may be an internal identifier and not necessarily a valid sensor ID.  If both idSensor and origSensorId are null then the request is assumed to be a general request for observations or contact on an object, if specified, or an area/volume.  In this case, the requester may specify a desired obType.
   * Example: /// Example: ORIGSENSOR-ID
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origSensorId() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origSensorIdAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer origSensorIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * Optional type of observation (EO, IR, RADAR, RF-ACTIVE, RF-PASSIVE, OTHER) requested.  This field may correspond to a request of a specific sensor, or to a general non sensor specific request.
   * Example: /// Example: RADAR
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String obType() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer obTypeAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer obTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * The priority of the collect request  (EMERGENCY, FLASH, IMMEDIATE, PRIORITY, ROUTINE).
   * Example: /// Example: EMERGENCY
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String priority() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer priorityAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer priorityInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * The (SSN) tasking category (1-5) associated with this request.  The tasking category defines the priority of gathering and transmitting the requested observational data.  Note that category definitions are sensor type specific.
   * Example: /// Example: 4
   * Constraints: No constraints specified.
   */
  public int taskCategory() { int o = __offset(34); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The (SSN) tasking suffix (A-Z) associated with this request.  The suffix defines the amount of observational data and the frequency of collection.  Note that suffix definitions are sensor type specific.
   * Example: /// Example: T
   * Constraints: Minimum length = 0, Maximum length = 1
   */
  public String suffix() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer suffixAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer suffixInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Boolean indicating that this collect request is UCT follow-up.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean uctFollowUp() { int o = __offset(38); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The start time or earliest time of the collect or contact request window, in ISO 8601 UTC format.
   * Example: /// Example: 2018-01-01T16:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String startTime() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer startTimeAsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer startTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * The end time of the collect or contact request window, in ISO 8601 UTC format.  If no endTime or duration is provided it is assumed the request is either ongoing or that the request is for a specified number of tracks (numTracks).  If both duration and endTime are provided, the endTime is assumed to take precedence.
   * Example: /// Example: 2018-01-01T18:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String endTime() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer endTimeAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer endTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * Unique identifier of the target on-orbit object for this request.
   * Example: /// Example: REF-ONORBIT-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idOnOrbit() { int o = __offset(44); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idOnOrbitAsByteBuffer() { return __vector_as_bytebuffer(44, 1); }
  public ByteBuffer idOnOrbitInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 44, 1); }
  /**
   * Satellite/catalog number of the target on-orbit object for this request.
   * Example: /// Example: 101
   * Constraints: No constraints specified.
   */
  public int satNo() { int o = __offset(46); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Optional identifier provided by the data source to indicate the target object of this request. This may be an internal identifier and not necessarily map to a valid satellite number.
   * Example: /// Example: ORIGOBJECT-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String origObjectId() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origObjectIdAsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer origObjectIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * The tasking group to which the target object is assigned.
   * Example: /// Example: 729
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String taskGroup() { int o = __offset(50); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer taskGroupAsByteBuffer() { return __vector_as_bytebuffer(50, 1); }
  public ByteBuffer taskGroupInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 50, 1); }
  /**
   * Inter-Range Operations Number.  Four-digit identifier used to schedule and identify AFSCN contact support for booster, launch, and on-orbit operations.
   * Example: /// Example: 3
   * Constraints: No constraints specified.
   */
  public int iron() { int o = __offset(52); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The orbit regime of the target (GEO, HEO, LAUNCH, LEO, MEO, OTHER).
   * Example: /// Example: GEO
   * Constraints: Minimum length = 0, Maximum length = 12
   */
  public String orbitRegime() { int o = __offset(54); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer orbitRegimeAsByteBuffer() { return __vector_as_bytebuffer(54, 1); }
  public ByteBuffer orbitRegimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 54, 1); }
  /**
   * The minimum object (diameter) size, in meters, to be reported.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double targetSize() { int o = __offset(56); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The minimum Radar Cross-Section of the target, in m^2.  If only minimum RCS is provided it is assumed to be minimum reportable RCS.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double rcsMin() { int o = __offset(58); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Radar Cross-Section of the target, in m^2.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double rcs() { int o = __offset(60); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum Radar Cross-Section of the target, in m^2.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double rcsMax() { int o = __offset(62); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The minimum frequency of interest, in MHz.  If only minimum frequency is provided it is assumed to be minimum reportable frequency.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double freqMin() { int o = __offset(64); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The estimated or expected emission frequency of the target, in MHz.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double freq() { int o = __offset(66); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum frequency of interest, in MHz.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double freqMax() { int o = __offset(68); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The RF polarization (H, LHC, RHC, V).
   * Example: /// Example: H
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String polarization() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer polarizationAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer polarizationInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * The minimum estimated or expected visual magnitude of the target, in Magnitudes (M).  If only minimum vismag is provided it is assumed to be minimum reportable vismag.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double visMagMin() { int o = __offset(72); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The estimated or expected visual magnitude of the target, in Magnitudes (M).
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double visMag() { int o = __offset(74); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum estimated or expected visual magnitude of the target, in Magnitudes (M).
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double visMagMax() { int o = __offset(76); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The spectral model used for the irradiance calculation.
   * Example: /// Example: Example Model
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String spectralModel() { int o = __offset(78); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer spectralModelAsByteBuffer() { return __vector_as_bytebuffer(78, 1); }
  public ByteBuffer spectralModelInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 78, 1); }
  /**
   * The fraction of solar energy reflected from target.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double reflectance() { int o = __offset(80); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The target object irradiance value.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double irradiance() { int o = __offset(82); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * For optical sensors, the requested number of frames to capture at each sensor step.
   * Example: /// Example: 6
   * Constraints: No constraints specified.
   */
  public int numFrames() { int o = __offset(84); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * For optical sensors, the frame rate of the camera, in Hz.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double frameRate() { int o = __offset(86); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * For optical sensors, the integration time per camera frame, in milliseconds.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double integrationTime() { int o = __offset(88); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The number of requested tracks on the target.  If numTracks is not provided it is assumed to indicate all possible observations every pass over the request duration or within the request start/end window.
   * Example: /// Example: 3
   * Constraints: No constraints specified.
   */
  public int numTracks() { int o = __offset(90); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of requested observations on the target.
   * Example: /// Example: 9
   * Constraints: No constraints specified.
   */
  public int numObs() { int o = __offset(92); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The duration of the collect request, in seconds.  If both duration and endTime are provided, the endTime is assumed to take precedence.
   * Example: /// Example: 11
   * Constraints: No constraints specified.
   */
  public int duration() { int o = __offset(94); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The search pattern to be executed for this request (e.g. PICKET-FENCE, SCAN, etc.).
   * Example: /// Example: SCAN
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String srchPattern() { int o = __offset(96); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer srchPatternAsByteBuffer() { return __vector_as_bytebuffer(96, 1); }
  public ByteBuffer srchPatternInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 96, 1); }
  /**
   * Pre-coordinated code, direction, or configuration to be executed by the sensor or site for this collect or contact.
   * Example: /// Example: Example direction
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String scenario() { int o = __offset(98); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer scenarioAsByteBuffer() { return __vector_as_bytebuffer(98, 1); }
  public ByteBuffer scenarioInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 98, 1); }
  /**
   * ID of the UDL Elset of the object associated with this request.
   * Example: /// Example: REF-ELSET-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idElset() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idElsetAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer idElsetInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * ID of the UDL Manifold Elset of the object associated with this request.  A Manifold Elset provides theoretical Keplerian orbital elements belonging to an object of interest's manifold describing a possible/theoretical orbit for an object of interest for tasking purposes.
   * Example: /// Example: REF-MANIFOLD-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idManifold() { int o = __offset(102); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idManifoldAsByteBuffer() { return __vector_as_bytebuffer(102, 1); }
  public ByteBuffer idManifoldInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 102, 1); }
  /**
   * ID of the UDL State Vector of the object or central vector associated with this request.
   * Example: /// Example: STATEVECTOR-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idStateVector() { int o = __offset(104); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idStateVectorAsByteBuffer() { return __vector_as_bytebuffer(104, 1); }
  public ByteBuffer idStateVectorInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 104, 1); }
  /**
   * ID of the UDL Ephemeris Set of the object associated with this request.
   * Example: /// Example: ES-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String esId() { int o = __offset(106); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer esIdAsByteBuffer() { return __vector_as_bytebuffer(106, 1); }
  public ByteBuffer esIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 106, 1); }
  /**
   * Epoch time, in ISO 8601 UTC format, of the orbital elements.
   * Example: /// Example: 2018-01-01T16:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String epoch() { int o = __offset(108); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer epochAsByteBuffer() { return __vector_as_bytebuffer(108, 1); }
  public ByteBuffer epochInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 108, 1); }
  /**
   * The average of the periapsis and apoapsis distances, in kilometers. For circular orbits, the semimajor axis is the distance between the centers of the bodies.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double semiMajorAxis() { int o = __offset(110); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The orbital eccentricity of an astronomical object is a parameter that determines the amount by which its orbit around another body deviates from a perfect circle.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double eccentricity() { int o = __offset(112); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The angle, in degrees, between the equator and the orbit plane when looking from the center of the Earth. Inclination ranges from 0-180 degrees, with 0-90 representing posigrade orbits and 90-180 representing retrograde orbits.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double inclination() { int o = __offset(114); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Right ascension of the ascending node, or RAAN is the angle as measured in degrees eastwards (or, as seen from the north, counterclockwise) from the First Point of Aries to the ascending node.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double raan() { int o = __offset(116); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The argument of perigee is the angle, in degrees, formed between the perigee and the ascending node.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double argOfPerigee() { int o = __offset(118); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The true anomaly defines the angular position, in degrees, of the object on it's orbital path as measured from the orbit focal point at epoch.  The true anomaly is referenced from perigee.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double trueAnomoly() { int o = __offset(120); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed right ascension angle, in degrees, for search or target acquisition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double ra() { int o = __offset(122); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed declination angle, in degrees, for search or target acquisition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double dec() { int o = __offset(124); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed azimuth angle, in degrees, for search or target acquisition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double az() { int o = __offset(126); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected or directed elevation angle, in degrees, for search or target acquisition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double el() { int o = __offset(128); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The expected acquisition range or defined center range, in km.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double range() { int o = __offset(130); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The extent of the azimuth angle, in degrees, from center azimuth to define a spatial volume.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double extentAz() { int o = __offset(132); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The extent of the elevation angle, in degrees, from center elevation to define a spatial volume.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double extentEl() { int o = __offset(134); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The extent of the range, in km, from center range to define a spatial volume.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double extentRange() { int o = __offset(136); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 latitude, in degrees. -90 to 90 degrees (negative values south of equator).  If an accompanying stopLat is provided, then the lat value can be assumed to be the starting latitude of a volume definition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double lat() { int o = __offset(138); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).  If an accompanying stopLon is provided, then lon value can be assumed to be the starting longitude of a volume definition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double lon() { int o = __offset(140); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Height above WGS-84 ellipsoid (HAE), in kilometers.  If an accompanying stopAlt is provided, then alt value can be assumed to be the starting altitude of a volume definition.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double alt() { int o = __offset(142); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The stopping WGS-84 latitude of a volume definition, in degrees.  -90 to 90 degrees (negative values south of equator).  The stopLat value is only meaningful if a (starting) lat value is provided.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double stopLat() { int o = __offset(144); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The stopping WGS-84 longitude of a volume definition, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).  The stopLon value is only meaningful if a (starting) lon value is provided.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double stopLon() { int o = __offset(146); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The stopping HAE WGS-84 height above ellipsoid (HAE), of a volume definition, in kilometers.  The stopAlt value is only meaningful if a (starting) alt value is provided.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double stopAlt() { int o = __offset(148); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum inclination, in degrees, to be used in search operations.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double srchInc() { int o = __offset(150); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The angular distance, in degrees, in the sensor-x direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double xAngle() { int o = __offset(152); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The angular distance, in degrees, in the sensor-y direction from scan center defined by the central vector.  The specification of xAngle and yAngle defines a rectangle of width 2*xAngle and height 2*yAngle centered about the central vector.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double yAngle() { int o = __offset(154); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The magnitude of rotation, in degrees, between the xAngle direction and locally defined equinoctial plane.  A positive value indicates clockwise rotation about the sensor boresight vector.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double orientAngle() { int o = __offset(156); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The customer for this request.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String customer() { int o = __offset(158); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer customerAsByteBuffer() { return __vector_as_bytebuffer(158, 1); }
  public ByteBuffer customerInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 158, 1); }
  /**
   * Notes or comments associated with this request.
   * Example: /// Example: Example notes
   * Constraints: Minimum length = 0, Maximum length = 512
   */
  public String notes() { int o = __offset(160); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer notesAsByteBuffer() { return __vector_as_bytebuffer(160, 1); }
  public ByteBuffer notesInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 160, 1); }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(162); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(162, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 162, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(164); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(164, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 164, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String source() { int o = __offset(166); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(166, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 166, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: Example source
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(168); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(168, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 168, 1); }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: ORIG
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(170); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(170, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 170, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(172); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * No description provided.
   * Example: /// Example: No example provided.
   * Constraints: No constraints specified.
   */
  public String stateVector() { int o = __offset(174); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer stateVectorAsByteBuffer() { return __vector_as_bytebuffer(174, 1); }
  public ByteBuffer stateVectorInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 174, 1); }
  /**
   * No description provided.
   * Example: /// Example: No example provided.
   * Constraints: No constraints specified.
   */
  public String elset() { int o = __offset(176); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer elsetAsByteBuffer() { return __vector_as_bytebuffer(176, 1); }
  public ByteBuffer elsetInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 176, 1); }
  /**
   * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
   * Example: /// Example: ['PROVIDER_TAG1', 'PROVIDER_TAG2']
   * Constraints: No constraints specified.
   */
  public String tags(int j) { int o = __offset(178); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int tagsLength() { int o = __offset(178); return o != 0 ? __vector_len(o) : 0; }
  public StringVector tagsVector() { return tagsVector(new StringVector()); }
  public StringVector tagsVector(StringVector obj) { int o = __offset(178); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }

  public static int createCollectRequest_Ingest(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int idParentReqOffset,
      int msgTypeOffset,
      int msgCreateDateOffset,
      int typeOffset,
      int idPlanOffset,
      int planIndex,
      int taskIdOffset,
      int dwellIdOffset,
      int externalIdOffset,
      int idSensorOffset,
      int origSensorIdOffset,
      int obTypeOffset,
      int priorityOffset,
      int taskCategory,
      int suffixOffset,
      boolean uctFollowUp,
      int startTimeOffset,
      int endTimeOffset,
      int idOnOrbitOffset,
      int satNo,
      int origObjectIdOffset,
      int taskGroupOffset,
      int iron,
      int orbitRegimeOffset,
      double targetSize,
      double rcsMin,
      double rcs,
      double rcsMax,
      double freqMin,
      double freq,
      double freqMax,
      int polarizationOffset,
      double visMagMin,
      double visMag,
      double visMagMax,
      int spectralModelOffset,
      double reflectance,
      double irradiance,
      int numFrames,
      double frameRate,
      double integrationTime,
      int numTracks,
      int numObs,
      int duration,
      int srchPatternOffset,
      int scenarioOffset,
      int idElsetOffset,
      int idManifoldOffset,
      int idStateVectorOffset,
      int esIdOffset,
      int epochOffset,
      double semiMajorAxis,
      double eccentricity,
      double inclination,
      double raan,
      double argOfPerigee,
      double trueAnomoly,
      double ra,
      double dec,
      double az,
      double el,
      double range,
      double extentAz,
      double extentEl,
      double extentRange,
      double lat,
      double lon,
      double alt,
      double stopLat,
      double stopLon,
      double stopAlt,
      double srchInc,
      double xAngle,
      double yAngle,
      double orientAngle,
      int customerOffset,
      int notesOffset,
      int createdAtOffset,
      int createdByOffset,
      int sourceOffset,
      int originOffset,
      int origNetworkOffset,
      byte dataMode,
      int stateVectorOffset,
      int elsetOffset,
      int tagsOffset) {
    builder.startTable(88);
    CollectRequest_Ingest.addOrientAngle(builder, orientAngle);
    CollectRequest_Ingest.addYAngle(builder, yAngle);
    CollectRequest_Ingest.addXAngle(builder, xAngle);
    CollectRequest_Ingest.addSrchInc(builder, srchInc);
    CollectRequest_Ingest.addStopAlt(builder, stopAlt);
    CollectRequest_Ingest.addStopLon(builder, stopLon);
    CollectRequest_Ingest.addStopLat(builder, stopLat);
    CollectRequest_Ingest.addAlt(builder, alt);
    CollectRequest_Ingest.addLon(builder, lon);
    CollectRequest_Ingest.addLat(builder, lat);
    CollectRequest_Ingest.addExtentRange(builder, extentRange);
    CollectRequest_Ingest.addExtentEl(builder, extentEl);
    CollectRequest_Ingest.addExtentAz(builder, extentAz);
    CollectRequest_Ingest.addRange(builder, range);
    CollectRequest_Ingest.addEl(builder, el);
    CollectRequest_Ingest.addAz(builder, az);
    CollectRequest_Ingest.addDec(builder, dec);
    CollectRequest_Ingest.addRa(builder, ra);
    CollectRequest_Ingest.addTrueAnomoly(builder, trueAnomoly);
    CollectRequest_Ingest.addArgOfPerigee(builder, argOfPerigee);
    CollectRequest_Ingest.addRaan(builder, raan);
    CollectRequest_Ingest.addInclination(builder, inclination);
    CollectRequest_Ingest.addEccentricity(builder, eccentricity);
    CollectRequest_Ingest.addSemiMajorAxis(builder, semiMajorAxis);
    CollectRequest_Ingest.addIntegrationTime(builder, integrationTime);
    CollectRequest_Ingest.addFrameRate(builder, frameRate);
    CollectRequest_Ingest.addIrradiance(builder, irradiance);
    CollectRequest_Ingest.addReflectance(builder, reflectance);
    CollectRequest_Ingest.addVisMagMax(builder, visMagMax);
    CollectRequest_Ingest.addVisMag(builder, visMag);
    CollectRequest_Ingest.addVisMagMin(builder, visMagMin);
    CollectRequest_Ingest.addFreqMax(builder, freqMax);
    CollectRequest_Ingest.addFreq(builder, freq);
    CollectRequest_Ingest.addFreqMin(builder, freqMin);
    CollectRequest_Ingest.addRcsMax(builder, rcsMax);
    CollectRequest_Ingest.addRcs(builder, rcs);
    CollectRequest_Ingest.addRcsMin(builder, rcsMin);
    CollectRequest_Ingest.addTargetSize(builder, targetSize);
    CollectRequest_Ingest.addTags(builder, tagsOffset);
    CollectRequest_Ingest.addElset(builder, elsetOffset);
    CollectRequest_Ingest.addStateVector(builder, stateVectorOffset);
    CollectRequest_Ingest.addOrigNetwork(builder, origNetworkOffset);
    CollectRequest_Ingest.addOrigin(builder, originOffset);
    CollectRequest_Ingest.addSource(builder, sourceOffset);
    CollectRequest_Ingest.addCreatedBy(builder, createdByOffset);
    CollectRequest_Ingest.addCreatedAt(builder, createdAtOffset);
    CollectRequest_Ingest.addNotes(builder, notesOffset);
    CollectRequest_Ingest.addCustomer(builder, customerOffset);
    CollectRequest_Ingest.addEpoch(builder, epochOffset);
    CollectRequest_Ingest.addEsId(builder, esIdOffset);
    CollectRequest_Ingest.addIdStateVector(builder, idStateVectorOffset);
    CollectRequest_Ingest.addIdManifold(builder, idManifoldOffset);
    CollectRequest_Ingest.addIdElset(builder, idElsetOffset);
    CollectRequest_Ingest.addScenario(builder, scenarioOffset);
    CollectRequest_Ingest.addSrchPattern(builder, srchPatternOffset);
    CollectRequest_Ingest.addDuration(builder, duration);
    CollectRequest_Ingest.addNumObs(builder, numObs);
    CollectRequest_Ingest.addNumTracks(builder, numTracks);
    CollectRequest_Ingest.addNumFrames(builder, numFrames);
    CollectRequest_Ingest.addSpectralModel(builder, spectralModelOffset);
    CollectRequest_Ingest.addPolarization(builder, polarizationOffset);
    CollectRequest_Ingest.addOrbitRegime(builder, orbitRegimeOffset);
    CollectRequest_Ingest.addIron(builder, iron);
    CollectRequest_Ingest.addTaskGroup(builder, taskGroupOffset);
    CollectRequest_Ingest.addOrigObjectId(builder, origObjectIdOffset);
    CollectRequest_Ingest.addSatNo(builder, satNo);
    CollectRequest_Ingest.addIdOnOrbit(builder, idOnOrbitOffset);
    CollectRequest_Ingest.addEndTime(builder, endTimeOffset);
    CollectRequest_Ingest.addStartTime(builder, startTimeOffset);
    CollectRequest_Ingest.addSuffix(builder, suffixOffset);
    CollectRequest_Ingest.addTaskCategory(builder, taskCategory);
    CollectRequest_Ingest.addPriority(builder, priorityOffset);
    CollectRequest_Ingest.addObType(builder, obTypeOffset);
    CollectRequest_Ingest.addOrigSensorId(builder, origSensorIdOffset);
    CollectRequest_Ingest.addIdSensor(builder, idSensorOffset);
    CollectRequest_Ingest.addExternalId(builder, externalIdOffset);
    CollectRequest_Ingest.addDwellId(builder, dwellIdOffset);
    CollectRequest_Ingest.addTaskId(builder, taskIdOffset);
    CollectRequest_Ingest.addPlanIndex(builder, planIndex);
    CollectRequest_Ingest.addIdPlan(builder, idPlanOffset);
    CollectRequest_Ingest.addType(builder, typeOffset);
    CollectRequest_Ingest.addMsgCreateDate(builder, msgCreateDateOffset);
    CollectRequest_Ingest.addMsgType(builder, msgTypeOffset);
    CollectRequest_Ingest.addIdParentReq(builder, idParentReqOffset);
    CollectRequest_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
    CollectRequest_Ingest.addId(builder, idOffset);
    CollectRequest_Ingest.addDataMode(builder, dataMode);
    CollectRequest_Ingest.addUctFollowUp(builder, uctFollowUp);
    return CollectRequest_Ingest.endCollectRequest_Ingest(builder);
  }

  public static void startCollectRequest_Ingest(FlatBufferBuilder builder) { builder.startTable(88); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addIdParentReq(FlatBufferBuilder builder, int idParentReqOffset) { builder.addOffset(2, idParentReqOffset, 0); }
  public static void addMsgType(FlatBufferBuilder builder, int msgTypeOffset) { builder.addOffset(3, msgTypeOffset, 0); }
  public static void addMsgCreateDate(FlatBufferBuilder builder, int msgCreateDateOffset) { builder.addOffset(4, msgCreateDateOffset, 0); }
  public static void addType(FlatBufferBuilder builder, int typeOffset) { builder.addOffset(5, typeOffset, 0); }
  public static void addIdPlan(FlatBufferBuilder builder, int idPlanOffset) { builder.addOffset(6, idPlanOffset, 0); }
  public static void addPlanIndex(FlatBufferBuilder builder, int planIndex) { builder.addInt(7, planIndex, 0); }
  public static void addTaskId(FlatBufferBuilder builder, int taskIdOffset) { builder.addOffset(8, taskIdOffset, 0); }
  public static void addDwellId(FlatBufferBuilder builder, int dwellIdOffset) { builder.addOffset(9, dwellIdOffset, 0); }
  public static void addExternalId(FlatBufferBuilder builder, int externalIdOffset) { builder.addOffset(10, externalIdOffset, 0); }
  public static void addIdSensor(FlatBufferBuilder builder, int idSensorOffset) { builder.addOffset(11, idSensorOffset, 0); }
  public static void addOrigSensorId(FlatBufferBuilder builder, int origSensorIdOffset) { builder.addOffset(12, origSensorIdOffset, 0); }
  public static void addObType(FlatBufferBuilder builder, int obTypeOffset) { builder.addOffset(13, obTypeOffset, 0); }
  public static void addPriority(FlatBufferBuilder builder, int priorityOffset) { builder.addOffset(14, priorityOffset, 0); }
  public static void addTaskCategory(FlatBufferBuilder builder, int taskCategory) { builder.addInt(15, taskCategory, 0); }
  public static void addSuffix(FlatBufferBuilder builder, int suffixOffset) { builder.addOffset(16, suffixOffset, 0); }
  public static void addUctFollowUp(FlatBufferBuilder builder, boolean uctFollowUp) { builder.addBoolean(17, uctFollowUp, false); }
  public static void addStartTime(FlatBufferBuilder builder, int startTimeOffset) { builder.addOffset(18, startTimeOffset, 0); }
  public static void addEndTime(FlatBufferBuilder builder, int endTimeOffset) { builder.addOffset(19, endTimeOffset, 0); }
  public static void addIdOnOrbit(FlatBufferBuilder builder, int idOnOrbitOffset) { builder.addOffset(20, idOnOrbitOffset, 0); }
  public static void addSatNo(FlatBufferBuilder builder, int satNo) { builder.addInt(21, satNo, 0); }
  public static void addOrigObjectId(FlatBufferBuilder builder, int origObjectIdOffset) { builder.addOffset(22, origObjectIdOffset, 0); }
  public static void addTaskGroup(FlatBufferBuilder builder, int taskGroupOffset) { builder.addOffset(23, taskGroupOffset, 0); }
  public static void addIron(FlatBufferBuilder builder, int iron) { builder.addInt(24, iron, 0); }
  public static void addOrbitRegime(FlatBufferBuilder builder, int orbitRegimeOffset) { builder.addOffset(25, orbitRegimeOffset, 0); }
  public static void addTargetSize(FlatBufferBuilder builder, double targetSize) { builder.addDouble(26, targetSize, 0.0); }
  public static void addRcsMin(FlatBufferBuilder builder, double rcsMin) { builder.addDouble(27, rcsMin, 0.0); }
  public static void addRcs(FlatBufferBuilder builder, double rcs) { builder.addDouble(28, rcs, 0.0); }
  public static void addRcsMax(FlatBufferBuilder builder, double rcsMax) { builder.addDouble(29, rcsMax, 0.0); }
  public static void addFreqMin(FlatBufferBuilder builder, double freqMin) { builder.addDouble(30, freqMin, 0.0); }
  public static void addFreq(FlatBufferBuilder builder, double freq) { builder.addDouble(31, freq, 0.0); }
  public static void addFreqMax(FlatBufferBuilder builder, double freqMax) { builder.addDouble(32, freqMax, 0.0); }
  public static void addPolarization(FlatBufferBuilder builder, int polarizationOffset) { builder.addOffset(33, polarizationOffset, 0); }
  public static void addVisMagMin(FlatBufferBuilder builder, double visMagMin) { builder.addDouble(34, visMagMin, 0.0); }
  public static void addVisMag(FlatBufferBuilder builder, double visMag) { builder.addDouble(35, visMag, 0.0); }
  public static void addVisMagMax(FlatBufferBuilder builder, double visMagMax) { builder.addDouble(36, visMagMax, 0.0); }
  public static void addSpectralModel(FlatBufferBuilder builder, int spectralModelOffset) { builder.addOffset(37, spectralModelOffset, 0); }
  public static void addReflectance(FlatBufferBuilder builder, double reflectance) { builder.addDouble(38, reflectance, 0.0); }
  public static void addIrradiance(FlatBufferBuilder builder, double irradiance) { builder.addDouble(39, irradiance, 0.0); }
  public static void addNumFrames(FlatBufferBuilder builder, int numFrames) { builder.addInt(40, numFrames, 0); }
  public static void addFrameRate(FlatBufferBuilder builder, double frameRate) { builder.addDouble(41, frameRate, 0.0); }
  public static void addIntegrationTime(FlatBufferBuilder builder, double integrationTime) { builder.addDouble(42, integrationTime, 0.0); }
  public static void addNumTracks(FlatBufferBuilder builder, int numTracks) { builder.addInt(43, numTracks, 0); }
  public static void addNumObs(FlatBufferBuilder builder, int numObs) { builder.addInt(44, numObs, 0); }
  public static void addDuration(FlatBufferBuilder builder, int duration) { builder.addInt(45, duration, 0); }
  public static void addSrchPattern(FlatBufferBuilder builder, int srchPatternOffset) { builder.addOffset(46, srchPatternOffset, 0); }
  public static void addScenario(FlatBufferBuilder builder, int scenarioOffset) { builder.addOffset(47, scenarioOffset, 0); }
  public static void addIdElset(FlatBufferBuilder builder, int idElsetOffset) { builder.addOffset(48, idElsetOffset, 0); }
  public static void addIdManifold(FlatBufferBuilder builder, int idManifoldOffset) { builder.addOffset(49, idManifoldOffset, 0); }
  public static void addIdStateVector(FlatBufferBuilder builder, int idStateVectorOffset) { builder.addOffset(50, idStateVectorOffset, 0); }
  public static void addEsId(FlatBufferBuilder builder, int esIdOffset) { builder.addOffset(51, esIdOffset, 0); }
  public static void addEpoch(FlatBufferBuilder builder, int epochOffset) { builder.addOffset(52, epochOffset, 0); }
  public static void addSemiMajorAxis(FlatBufferBuilder builder, double semiMajorAxis) { builder.addDouble(53, semiMajorAxis, 0.0); }
  public static void addEccentricity(FlatBufferBuilder builder, double eccentricity) { builder.addDouble(54, eccentricity, 0.0); }
  public static void addInclination(FlatBufferBuilder builder, double inclination) { builder.addDouble(55, inclination, 0.0); }
  public static void addRaan(FlatBufferBuilder builder, double raan) { builder.addDouble(56, raan, 0.0); }
  public static void addArgOfPerigee(FlatBufferBuilder builder, double argOfPerigee) { builder.addDouble(57, argOfPerigee, 0.0); }
  public static void addTrueAnomoly(FlatBufferBuilder builder, double trueAnomoly) { builder.addDouble(58, trueAnomoly, 0.0); }
  public static void addRa(FlatBufferBuilder builder, double ra) { builder.addDouble(59, ra, 0.0); }
  public static void addDec(FlatBufferBuilder builder, double dec) { builder.addDouble(60, dec, 0.0); }
  public static void addAz(FlatBufferBuilder builder, double az) { builder.addDouble(61, az, 0.0); }
  public static void addEl(FlatBufferBuilder builder, double el) { builder.addDouble(62, el, 0.0); }
  public static void addRange(FlatBufferBuilder builder, double range) { builder.addDouble(63, range, 0.0); }
  public static void addExtentAz(FlatBufferBuilder builder, double extentAz) { builder.addDouble(64, extentAz, 0.0); }
  public static void addExtentEl(FlatBufferBuilder builder, double extentEl) { builder.addDouble(65, extentEl, 0.0); }
  public static void addExtentRange(FlatBufferBuilder builder, double extentRange) { builder.addDouble(66, extentRange, 0.0); }
  public static void addLat(FlatBufferBuilder builder, double lat) { builder.addDouble(67, lat, 0.0); }
  public static void addLon(FlatBufferBuilder builder, double lon) { builder.addDouble(68, lon, 0.0); }
  public static void addAlt(FlatBufferBuilder builder, double alt) { builder.addDouble(69, alt, 0.0); }
  public static void addStopLat(FlatBufferBuilder builder, double stopLat) { builder.addDouble(70, stopLat, 0.0); }
  public static void addStopLon(FlatBufferBuilder builder, double stopLon) { builder.addDouble(71, stopLon, 0.0); }
  public static void addStopAlt(FlatBufferBuilder builder, double stopAlt) { builder.addDouble(72, stopAlt, 0.0); }
  public static void addSrchInc(FlatBufferBuilder builder, double srchInc) { builder.addDouble(73, srchInc, 0.0); }
  public static void addXAngle(FlatBufferBuilder builder, double xAngle) { builder.addDouble(74, xAngle, 0.0); }
  public static void addYAngle(FlatBufferBuilder builder, double yAngle) { builder.addDouble(75, yAngle, 0.0); }
  public static void addOrientAngle(FlatBufferBuilder builder, double orientAngle) { builder.addDouble(76, orientAngle, 0.0); }
  public static void addCustomer(FlatBufferBuilder builder, int customerOffset) { builder.addOffset(77, customerOffset, 0); }
  public static void addNotes(FlatBufferBuilder builder, int notesOffset) { builder.addOffset(78, notesOffset, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(79, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(80, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(81, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(82, originOffset, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(83, origNetworkOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(84, dataMode, 0); }
  public static void addStateVector(FlatBufferBuilder builder, int stateVectorOffset) { builder.addOffset(85, stateVectorOffset, 0); }
  public static void addElset(FlatBufferBuilder builder, int elsetOffset) { builder.addOffset(86, elsetOffset, 0); }
  public static void addTags(FlatBufferBuilder builder, int tagsOffset) { builder.addOffset(87, tagsOffset, 0); }
  public static int createTagsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startTagsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static int endCollectRequest_Ingest(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishCollectRequest_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "COLL"); }
  public static void finishSizePrefixedCollectRequest_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "COLL"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public CollectRequest_Ingest get(int j) { return get(new CollectRequest_Ingest(), j); }
    public CollectRequest_Ingest get(CollectRequest_Ingest obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

