// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// A track is a position and optionally a heading/velocity of an object such as an aircraft at a particular timestamp. It also includes optional information regarding the identity/type of the target object, if known.
 */
@SuppressWarnings("unused")
public final class Track_Abridged extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static Track_Abridged getRootAsTrack_Abridged(ByteBuffer _bb) { return getRootAsTrack_Abridged(_bb, new Track_Abridged()); }
  public static Track_Abridged getRootAsTrack_Abridged(ByteBuffer _bb, Track_Abridged obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean Track_AbridgedBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "TRAC"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public Track_Abridged __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: TRACK-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Contact information for assets reporting PPLI (Precise Participant Location and Identification). PPLI is a Link 16 message that is used by units to transmit complete location, identification, and limited status information.
   * Example: /// Example: Contact Info
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String cntct() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer cntctAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer cntctInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * Message Timestamp.
   * Example: /// Example: 2021-01-01T01:01:01.123456Z
   * Constraints: No constraints specified.
   */
  public String msgTs() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgTsAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer msgTsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Mission ID related to the track.
   * Example: /// Example: msnId
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String msnId() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msnIdAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer msnIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Nationality or organization of the tracking/reporting system or platform (e.g. FR, NATO, US, etc.).
   * Example: /// Example: US
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String assetNat() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer assetNatAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer assetNatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * Id/name of the platform providing the track data (i.e., tail number for air platform, tower ID for tower based sensor, site id for fixed radar).
   * Example: /// Example: asset
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String asset() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer assetAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer assetInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * Id/name of sensor providing the track data.
   * Example: /// Example: sen
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String sen() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer senAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer senInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * Sensor quality.
   * Example: /// Example: senQual
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String senQual() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer senQualAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer senQualInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * UUID identifying the track, which should remain the same on subsequent tracks of the same object.
   * Example: /// Example: trkId
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String trkId() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkIdAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer trkIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * The track number (TN) of a surveillance entity. Intended as, but not constrained to, the J-series track number encoded as five character alpha-numeric characters. Users should refer to J-series documentation for specific TN definitions.
   * Example: /// Example: trkNum
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String trkNum() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkNumAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer trkNumInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * Status of the track (e.g., INITIATING, MAINTAINING, DROPPING, TERMINATED, etc.).
   * Example: /// Example: INITIATING
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String trkStat() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkStatAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer trkStatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * Nationality or organization of the track object (e.g. FR, NATO, US, etc.).
   * Example: /// Example: NATO
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String objNat() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objNatAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer objNatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * The UID or designation of the tracked object.
   * Example: /// Example: objId
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String objId() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objIdAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer objIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * The generic classification of the track object/group (e.g., HELICOPTER, TRACKED, WATERCRAFT, WHEELED, etc.). Referenced, but not constrained to, NATO STANAG 4676 object type classifications.
   * Example: /// Example: WATERCRAFT
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objType() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objTypeAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer objTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * The object specific type. Intended as, but not constrained to, MIL-STD-6016 environment dependent specific type designations. The specific type can be reported as either a combination of the code and environment (e.g. 155/SURFACE) or as the descriptive representation (e.g. AUDACE DDG), which are equivalent.
   * Example: /// Example: LIGHT_TANK
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objSpec() { int o = __offset(38); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objSpecAsByteBuffer() { return __vector_as_bytebuffer(38, 1); }
  public ByteBuffer objSpecInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 38, 1); }
  /**
   * The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
   * Example: /// Example: COMBAT_VEHICLE
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objPlat() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objPlatAsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer objPlatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
   * Example: /// Example: HOLDING
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objAct() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objActAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer objActInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * The type of source information from which the track was derived. Intended as, but not constrained to, NATO STANAG 4676 modality types (AIS, BFT, BIOMETRIC, COMINT, DOPPLER, ELINT, HRR, HUMINT, IMAGE, MASINT, MIXED, OSINT, OTHER):
   * AIS: Derived from an automated identification system source.
   * BFT: Derived from a blue force tracking source.
   * BIOMETRICS: Derived from a biometrics source.
   * COMINT: Derived from a communications intelligence source.
   * DOPPLER: Derived from a radar doppler source.
   * ELINT: Derived from an electronics intelligence source.
   * HRR: Derived from a radar high range resolution source.
   * HUMINT: Derived from a human intelligence source.
   * IMAGE: Derived from a still or motion imagery source.
   * MASINT: Derived from a measurement and signals intelligence source.
   * MIXED: Derived from a combination of two or more sources.
   * OSINT: Derived from an open source intelligence source.
   * OTHER: Derived from other types of unspecified sources.
   * Example: /// Example: MASINT
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String modType() { int o = __offset(44); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer modTypeAsByteBuffer() { return __vector_as_bytebuffer(44, 1); }
  public ByteBuffer modTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 44, 1); }
  /**
   * UUID of the track item object, applies to STANAG-4676 messages.
   * Example: /// Example: trkItmId
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String trkItmId() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkItmIdAsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer trkItmIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * Track timestamp in ISO8601 UTC format.
   * Example: /// Example: 2021-06-07T14:17:39.653Z
   * Constraints: No constraints specified.
   */
  public String ts() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tsAsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer tsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * Value indicating track quality (not standardized).
   * Example: /// Example: 0
   * Constraints: No constraints specified.
   */
  public int trkQual() { int o = __offset(50); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Means by which the track data was created (e.g., MEASURED, AUTOMATIC PREDICTED, etc.).
   * Example: /// Example: MEASURED
   * Constraints: No constraints specified.
   */
  public String trkPtType() { int o = __offset(52); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trkPtTypeAsByteBuffer() { return __vector_as_bytebuffer(52, 1); }
  public ByteBuffer trkPtTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 52, 1); }
  /**
   * The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
   * ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
   * FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
   * HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
   * NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
   * PENDING: Track object which has not been evaluated.
   * SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
   * UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
   * Example: /// Example: FRIEND
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objIdent() { int o = __offset(54); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objIdentAsByteBuffer() { return __vector_as_bytebuffer(54, 1); }
  public ByteBuffer objIdentInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 54, 1); }
  /**
   * Track object identity credibility.
   * Example: /// Example: 0
   * Constraints: No constraints specified.
   */
  public int identCred() { int o = __offset(56); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Track object identity reliability.
   * Example: /// Example: 0
   * Constraints: No constraints specified.
   */
  public int identRel() { int o = __offset(58); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Additional track object identity/status information, typically used for EXERCISE identity amplification (FAKER, JOKER, KILO, TRAVELLER, ZOMBIE):
   * FAKER: Friendly track, object, or entity acting as an exercise hostile.
   * JOKER: Friendly track, object, or entity acting as an exercise suspect.
   * KILO: Friendly high-value object.
   * TRAVELLER: Suspect land or surface track following a recognized traffic route.
   * ZOMBIE: Suspect track, object, or entity of special interest.
   * Example: /// Example: ZOMBIE
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String identAmp() { int o = __offset(60); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer identAmpAsByteBuffer() { return __vector_as_bytebuffer(60, 1); }
  public ByteBuffer identAmpInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 60, 1); }
  /**
   * The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
   * AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
   * LAND: On the surface of dry land.
   * SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
   * SURFACE: On the surface of a body of water.
   * SUBSURFACE: Below the surface of a body of water.
   * UNKNOWN: Environment is not known.
   * Example: /// Example: LAND
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String env() { int o = __offset(62); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer envAsByteBuffer() { return __vector_as_bytebuffer(62, 1); }
  public ByteBuffer envInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 62, 1); }
  /**
   * Track environment confidence estimate (not standardized).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double envConf() { int o = __offset(64); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double trkConf() { int o = __offset(66); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track object location in ECEF [x, y, z], meters.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String ecefPos(int j) { int o = __offset(68); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int ecefPosLength() { int o = __offset(68); return o != 0 ? __vector_len(o) : 0; }
  public StringVector ecefPosVector() { return ecefPosVector(new StringVector()); }
  public StringVector ecefPosVector(StringVector obj) { int o = __offset(68); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Track object velocity in ECEF [x', y', z'], meters/sec.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String ecefVel(int j) { int o = __offset(70); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int ecefVelLength() { int o = __offset(70); return o != 0 ? __vector_len(o) : 0; }
  public StringVector ecefVelVector() { return ecefVelVector(new StringVector()); }
  public StringVector ecefVelVector(StringVector obj) { int o = __offset(70); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Track object acceleration in ECEF [x'', y'', z''], meters/sec^2.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String ecefAcc(int j) { int o = __offset(72); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int ecefAccLength() { int o = __offset(72); return o != 0 ? __vector_len(o) : 0; }
  public StringVector ecefAccVector() { return ecefAccVector(new StringVector()); }
  public StringVector ecefAccVector(StringVector obj) { int o = __offset(72); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * WGS-84 latitude of the track object, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double lat() { int o = __offset(74); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the track object, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double lon() { int o = __offset(76); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track point altitude relative to WGS-84 ellipsoid, in meters. Positive values indicate a track object height above ellipsoid, and negative values indicate a track object below ellipsoid, applicable to the depth estimate for a subsurface track.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double alt() { int o = __offset(78); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track object spd, in meters/sec.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double spd() { int o = __offset(80); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The track object heading, in degrees clockwise from true North at the object location.
   * Example: /// Example: 19.7
   * Constraints: No constraints specified.
   */
  public double hdng() { int o = __offset(82); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The track object course-over-ground, in degrees clockwise from true North at the object location (0-360 degrees).
   * Example: /// Example: 88.37
   * Constraints: No constraints specified.
   */
  public double course() { int o = __offset(84); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Origin of a local coordinate system [lat, lon, altitude].  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String lco(int j) { int o = __offset(86); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int lcoLength() { int o = __offset(86); return o != 0 ? __vector_len(o) : 0; }
  public StringVector lcoVector() { return lcoVector(new StringVector()); }
  public StringVector lcoVector(StringVector obj) { int o = __offset(86); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * x, y, and z-axis rotations about ECEF that define a local cartesian system.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String lcs(int j) { int o = __offset(88); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int lcsLength() { int o = __offset(88); return o != 0 ? __vector_len(o) : 0; }
  public StringVector lcsVector() { return lcsVector(new StringVector()); }
  public StringVector lcsVector(StringVector obj) { int o = __offset(88); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Estimate of the position, [x, y, z], of the track object in the defined cartesian system, in meters.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String lcPos(int j) { int o = __offset(90); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int lcPosLength() { int o = __offset(90); return o != 0 ? __vector_len(o) : 0; }
  public StringVector lcPosVector() { return lcPosVector(new StringVector()); }
  public StringVector lcPosVector(StringVector obj) { int o = __offset(90); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Estimate of the velocity, [x', y', z'], of the track object in the defined cartesian system, in meters/sec.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String lcVel(int j) { int o = __offset(92); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int lcVelLength() { int o = __offset(92); return o != 0 ? __vector_len(o) : 0; }
  public StringVector lcVelVector() { return lcVelVector(new StringVector()); }
  public StringVector lcVelVector(StringVector obj) { int o = __offset(92); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Estimate of the acceleration, [x'', y'', z''], of the track object in the defined cartesian system, in meters/sec^2.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String lcAcc(int j) { int o = __offset(94); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int lcAccLength() { int o = __offset(94); return o != 0 ? __vector_len(o) : 0; }
  public StringVector lcAccVector() { return lcAccVector(new StringVector()); }
  public StringVector lcAccVector(StringVector obj) { int o = __offset(94); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * East, North, Up velocity components, in meters/sec.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String eNuvel(int j) { int o = __offset(96); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int eNuvelLength() { int o = __offset(96); return o != 0 ? __vector_len(o) : 0; }
  public StringVector eNuvelVector() { return eNuvelVector(new StringVector()); }
  public StringVector eNuvelVector(StringVector obj) { int o = __offset(96); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * East, North, Up position components, in meters.  When provided, array must always contain 3 values.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String eNupos(int j) { int o = __offset(98); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int eNuposLength() { int o = __offset(98); return o != 0 ? __vector_len(o) : 0; }
  public StringVector eNuposVector() { return eNuposVector(new StringVector()); }
  public StringVector eNuposVector(StringVector obj) { int o = __offset(98); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Covariance matrix, in meter and second based units, for the defined cartesian system.
   * The array values represent the lower triangular half of the position-velocity covariance matrix.  The size of the covariance matrix is dynamic.  The values are output as an array of values corresponding to the position-velocity covariance element positions, ordered as follows:
   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
   * x&nbsp;&nbsp;&nbsp;&nbsp;1
   * y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
   * z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
   * x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
   * y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
   * z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
   * The covariance matrix will be as large as the last element needed, and with unused values zero-filled to maintain proper element positioning in the array.  For example, for a 2D (x, y) position-only covariance, the covariance matrix will be 2x2 and the array would contain the 3 elements corresponding to the x, and y position.  Another example, now for a 2D (x, y) position-velocity covariance, the covariance matrix will be 5x5 and the array would contain the 15 elements corresponding to the relevant x, y, x', and y' values (with the z-row and z-column being all zeros). The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
   * Example: /// Example: [1.1, 2.2, 3.3]
   * Constraints: No constraints specified.
   */
  public String cov(int j) { int o = __offset(100); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int covLength() { int o = __offset(100); return o != 0 ? __vector_len(o) : 0; }
  public StringVector covVector() { return covVector(new StringVector()); }
  public StringVector covVector(StringVector obj) { int o = __offset(100); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Uncertainty ellipsoid [semi-major axis (m), semi-minor axis (m), orientation (deg)].
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String errEllp(int j) { int o = __offset(102); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int errEllpLength() { int o = __offset(102); return o != 0 ? __vector_len(o) : 0; }
  public StringVector errEllpVector() { return errEllpVector(new StringVector()); }
  public StringVector errEllpVector(StringVector obj) { int o = __offset(102); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array of UDL record types (POI, MTI, TRACK, GROUNDIMAGE) that contributed to the generation of this fused track.  See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array, used in the track fusion. The 'srcTyps' and 'srcIds' arrays must match in size.
   * Example: /// Example: ['MTI', 'POI']
   * Constraints: No constraints specified.
   */
  public String srcTyps(int j) { int o = __offset(104); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int srcTypsLength() { int o = __offset(104); return o != 0 ? __vector_len(o) : 0; }
  public StringVector srcTypsVector() { return srcTypsVector(new StringVector()); }
  public StringVector srcTypsVector(StringVector obj) { int o = __offset(104); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array of UUIDs of the UDL data records that contributed to the generation of this fused track. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array, used in the track fusion.  The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object (e.g. /udl/poi/{uuid}).
   * Example: /// Example: ['f7c70cc8-f9b7-4467-b4ad-3904e360e842', '1da3fab000014e3133709830937387405']
   * Constraints: No constraints specified.
   */
  public String srcIds(int j) { int o = __offset(106); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int srcIdsLength() { int o = __offset(106); return o != 0 ? __vector_len(o) : 0; }
  public StringVector srcIdsVector() { return srcIdsVector(new StringVector()); }
  public StringVector srcIdsVector(StringVector obj) { int o = __offset(106); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The call sign currently assigned to this track object.
   * Example: /// Example: callSign
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String callSign() { int o = __offset(108); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer callSignAsByteBuffer() { return __vector_as_bytebuffer(108, 1); }
  public ByteBuffer callSignInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 108, 1); }
  /**
   * Flag indicating that this track is fused from multiple sensor sources.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean multiSource() { int o = __offset(110); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The J-series message type, if this track is derived from a J-series message.
   * Example: /// Example: J12.5
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String jSeries() { int o = __offset(112); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer jSeriesAsByteBuffer() { return __vector_as_bytebuffer(112, 1); }
  public ByteBuffer jSeriesInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 112, 1); }
  /**
   * The number of objects or units moving as a group and represented as a single entity in this track message. If null, the track is assumed to represent a single object. Note that if this track derives from a J-series message then special definitions apply for the following values: 13 indicates an estimated 2-7 units, 14 indicates an estimated more than 7 units, and 15 indicates an estimated more than 12 units.
   * Example: /// Example: 14
   * Constraints: No constraints specified.
   */
  public int strength() { int o = __offset(114); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Mode-1 interrogation response (mission code), indicating mission or aircraft type.
   * Example: /// Example: 1234
   * Constraints: No constraints specified.
   */
  public int m1() { int o = __offset(116); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Mode-1 validity status.
   * Example: /// Example: 1
   * Constraints: No constraints specified.
   */
  public int m1v() { int o = __offset(118); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Mode-2 interrogation response (military identification code).
   * Example: /// Example: 1234
   * Constraints: No constraints specified.
   */
  public int m2() { int o = __offset(120); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Mode-2 validity status.
   * Example: /// Example: 1
   * Constraints: No constraints specified.
   */
  public int m2v() { int o = __offset(122); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Mode-3/A interrogation response (aircraft identification), provides a 4-digit octal identification code for the aircraft, assigned by the air traffic controller. Mode-3/A is shared military/civilian use.
   * Example: /// Example: 2636
   * Constraints: No constraints specified.
   */
  public int m3a() { int o = __offset(124); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Mode-3/A validity status.
   * Example: /// Example: 1
   * Constraints: No constraints specified.
   */
  public int m3av() { int o = __offset(126); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
   * Example: /// Example: ['TAG1', 'TAG2']
   * Constraints: No constraints specified.
   */
  public String tags(int j) { int o = __offset(128); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int tagsLength() { int o = __offset(128); return o != 0 ? __vector_len(o) : 0; }
  public StringVector tagsVector() { return tagsVector(new StringVector()); }
  public StringVector tagsVector(StringVector obj) { int o = __offset(128); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
   * Example: /// Example: AXE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String sourceDl() { int o = __offset(130); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceDlAsByteBuffer() { return __vector_as_bytebuffer(130, 1); }
  public ByteBuffer sourceDlInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 130, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String source() { int o = __offset(132); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(132, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 132, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(134); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(134, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 134, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(136); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: ORIG
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(138); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(138, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 138, 1); }

  public static int createTrack_Abridged(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int cntctOffset,
      int createdAtOffset,
      int createdByOffset,
      int msgTsOffset,
      int msnIdOffset,
      int assetNatOffset,
      int assetOffset,
      int senOffset,
      int senQualOffset,
      int trkIdOffset,
      int trkNumOffset,
      int trkStatOffset,
      int objNatOffset,
      int objIdOffset,
      int objTypeOffset,
      int objSpecOffset,
      int objPlatOffset,
      int objActOffset,
      int modTypeOffset,
      int trkItmIdOffset,
      int tsOffset,
      int trkQual,
      int trkPtTypeOffset,
      int objIdentOffset,
      int identCred,
      int identRel,
      int identAmpOffset,
      int envOffset,
      double envConf,
      double trkConf,
      int ecefPosOffset,
      int ecefVelOffset,
      int ecefAccOffset,
      double lat,
      double lon,
      double alt,
      double spd,
      double hdng,
      double course,
      int lcoOffset,
      int lcsOffset,
      int lcPosOffset,
      int lcVelOffset,
      int lcAccOffset,
      int eNuvelOffset,
      int eNuposOffset,
      int covOffset,
      int errEllpOffset,
      int srcTypsOffset,
      int srcIdsOffset,
      int callSignOffset,
      boolean multiSource,
      int jSeriesOffset,
      int strength,
      int m1,
      int m1v,
      int m2,
      int m2v,
      int m3a,
      int m3av,
      int tagsOffset,
      int sourceDlOffset,
      int sourceOffset,
      int originOffset,
      byte dataMode,
      int origNetworkOffset) {
    builder.startTable(68);
    Track_Abridged.addCourse(builder, course);
    Track_Abridged.addHdng(builder, hdng);
    Track_Abridged.addSpd(builder, spd);
    Track_Abridged.addAlt(builder, alt);
    Track_Abridged.addLon(builder, lon);
    Track_Abridged.addLat(builder, lat);
    Track_Abridged.addTrkConf(builder, trkConf);
    Track_Abridged.addEnvConf(builder, envConf);
    Track_Abridged.addOrigNetwork(builder, origNetworkOffset);
    Track_Abridged.addOrigin(builder, originOffset);
    Track_Abridged.addSource(builder, sourceOffset);
    Track_Abridged.addSourceDl(builder, sourceDlOffset);
    Track_Abridged.addTags(builder, tagsOffset);
    Track_Abridged.addM3av(builder, m3av);
    Track_Abridged.addM3a(builder, m3a);
    Track_Abridged.addM2v(builder, m2v);
    Track_Abridged.addM2(builder, m2);
    Track_Abridged.addM1v(builder, m1v);
    Track_Abridged.addM1(builder, m1);
    Track_Abridged.addStrength(builder, strength);
    Track_Abridged.addJSeries(builder, jSeriesOffset);
    Track_Abridged.addCallSign(builder, callSignOffset);
    Track_Abridged.addSrcIds(builder, srcIdsOffset);
    Track_Abridged.addSrcTyps(builder, srcTypsOffset);
    Track_Abridged.addErrEllp(builder, errEllpOffset);
    Track_Abridged.addCov(builder, covOffset);
    Track_Abridged.addENupos(builder, eNuposOffset);
    Track_Abridged.addENuvel(builder, eNuvelOffset);
    Track_Abridged.addLcAcc(builder, lcAccOffset);
    Track_Abridged.addLcVel(builder, lcVelOffset);
    Track_Abridged.addLcPos(builder, lcPosOffset);
    Track_Abridged.addLcs(builder, lcsOffset);
    Track_Abridged.addLco(builder, lcoOffset);
    Track_Abridged.addEcefAcc(builder, ecefAccOffset);
    Track_Abridged.addEcefVel(builder, ecefVelOffset);
    Track_Abridged.addEcefPos(builder, ecefPosOffset);
    Track_Abridged.addEnv(builder, envOffset);
    Track_Abridged.addIdentAmp(builder, identAmpOffset);
    Track_Abridged.addIdentRel(builder, identRel);
    Track_Abridged.addIdentCred(builder, identCred);
    Track_Abridged.addObjIdent(builder, objIdentOffset);
    Track_Abridged.addTrkPtType(builder, trkPtTypeOffset);
    Track_Abridged.addTrkQual(builder, trkQual);
    Track_Abridged.addTs(builder, tsOffset);
    Track_Abridged.addTrkItmId(builder, trkItmIdOffset);
    Track_Abridged.addModType(builder, modTypeOffset);
    Track_Abridged.addObjAct(builder, objActOffset);
    Track_Abridged.addObjPlat(builder, objPlatOffset);
    Track_Abridged.addObjSpec(builder, objSpecOffset);
    Track_Abridged.addObjType(builder, objTypeOffset);
    Track_Abridged.addObjId(builder, objIdOffset);
    Track_Abridged.addObjNat(builder, objNatOffset);
    Track_Abridged.addTrkStat(builder, trkStatOffset);
    Track_Abridged.addTrkNum(builder, trkNumOffset);
    Track_Abridged.addTrkId(builder, trkIdOffset);
    Track_Abridged.addSenQual(builder, senQualOffset);
    Track_Abridged.addSen(builder, senOffset);
    Track_Abridged.addAsset(builder, assetOffset);
    Track_Abridged.addAssetNat(builder, assetNatOffset);
    Track_Abridged.addMsnId(builder, msnIdOffset);
    Track_Abridged.addMsgTs(builder, msgTsOffset);
    Track_Abridged.addCreatedBy(builder, createdByOffset);
    Track_Abridged.addCreatedAt(builder, createdAtOffset);
    Track_Abridged.addCntct(builder, cntctOffset);
    Track_Abridged.addClassificationMarking(builder, classificationMarkingOffset);
    Track_Abridged.addId(builder, idOffset);
    Track_Abridged.addDataMode(builder, dataMode);
    Track_Abridged.addMultiSource(builder, multiSource);
    return Track_Abridged.endTrack_Abridged(builder);
  }

  public static void startTrack_Abridged(FlatBufferBuilder builder) { builder.startTable(68); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addCntct(FlatBufferBuilder builder, int cntctOffset) { builder.addOffset(2, cntctOffset, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(3, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(4, createdByOffset, 0); }
  public static void addMsgTs(FlatBufferBuilder builder, int msgTsOffset) { builder.addOffset(5, msgTsOffset, 0); }
  public static void addMsnId(FlatBufferBuilder builder, int msnIdOffset) { builder.addOffset(6, msnIdOffset, 0); }
  public static void addAssetNat(FlatBufferBuilder builder, int assetNatOffset) { builder.addOffset(7, assetNatOffset, 0); }
  public static void addAsset(FlatBufferBuilder builder, int assetOffset) { builder.addOffset(8, assetOffset, 0); }
  public static void addSen(FlatBufferBuilder builder, int senOffset) { builder.addOffset(9, senOffset, 0); }
  public static void addSenQual(FlatBufferBuilder builder, int senQualOffset) { builder.addOffset(10, senQualOffset, 0); }
  public static void addTrkId(FlatBufferBuilder builder, int trkIdOffset) { builder.addOffset(11, trkIdOffset, 0); }
  public static void addTrkNum(FlatBufferBuilder builder, int trkNumOffset) { builder.addOffset(12, trkNumOffset, 0); }
  public static void addTrkStat(FlatBufferBuilder builder, int trkStatOffset) { builder.addOffset(13, trkStatOffset, 0); }
  public static void addObjNat(FlatBufferBuilder builder, int objNatOffset) { builder.addOffset(14, objNatOffset, 0); }
  public static void addObjId(FlatBufferBuilder builder, int objIdOffset) { builder.addOffset(15, objIdOffset, 0); }
  public static void addObjType(FlatBufferBuilder builder, int objTypeOffset) { builder.addOffset(16, objTypeOffset, 0); }
  public static void addObjSpec(FlatBufferBuilder builder, int objSpecOffset) { builder.addOffset(17, objSpecOffset, 0); }
  public static void addObjPlat(FlatBufferBuilder builder, int objPlatOffset) { builder.addOffset(18, objPlatOffset, 0); }
  public static void addObjAct(FlatBufferBuilder builder, int objActOffset) { builder.addOffset(19, objActOffset, 0); }
  public static void addModType(FlatBufferBuilder builder, int modTypeOffset) { builder.addOffset(20, modTypeOffset, 0); }
  public static void addTrkItmId(FlatBufferBuilder builder, int trkItmIdOffset) { builder.addOffset(21, trkItmIdOffset, 0); }
  public static void addTs(FlatBufferBuilder builder, int tsOffset) { builder.addOffset(22, tsOffset, 0); }
  public static void addTrkQual(FlatBufferBuilder builder, int trkQual) { builder.addInt(23, trkQual, 0); }
  public static void addTrkPtType(FlatBufferBuilder builder, int trkPtTypeOffset) { builder.addOffset(24, trkPtTypeOffset, 0); }
  public static void addObjIdent(FlatBufferBuilder builder, int objIdentOffset) { builder.addOffset(25, objIdentOffset, 0); }
  public static void addIdentCred(FlatBufferBuilder builder, int identCred) { builder.addInt(26, identCred, 0); }
  public static void addIdentRel(FlatBufferBuilder builder, int identRel) { builder.addInt(27, identRel, 0); }
  public static void addIdentAmp(FlatBufferBuilder builder, int identAmpOffset) { builder.addOffset(28, identAmpOffset, 0); }
  public static void addEnv(FlatBufferBuilder builder, int envOffset) { builder.addOffset(29, envOffset, 0); }
  public static void addEnvConf(FlatBufferBuilder builder, double envConf) { builder.addDouble(30, envConf, 0.0); }
  public static void addTrkConf(FlatBufferBuilder builder, double trkConf) { builder.addDouble(31, trkConf, 0.0); }
  public static void addEcefPos(FlatBufferBuilder builder, int ecefPosOffset) { builder.addOffset(32, ecefPosOffset, 0); }
  public static int createEcefPosVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startEcefPosVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addEcefVel(FlatBufferBuilder builder, int ecefVelOffset) { builder.addOffset(33, ecefVelOffset, 0); }
  public static int createEcefVelVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startEcefVelVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addEcefAcc(FlatBufferBuilder builder, int ecefAccOffset) { builder.addOffset(34, ecefAccOffset, 0); }
  public static int createEcefAccVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startEcefAccVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addLat(FlatBufferBuilder builder, double lat) { builder.addDouble(35, lat, 0.0); }
  public static void addLon(FlatBufferBuilder builder, double lon) { builder.addDouble(36, lon, 0.0); }
  public static void addAlt(FlatBufferBuilder builder, double alt) { builder.addDouble(37, alt, 0.0); }
  public static void addSpd(FlatBufferBuilder builder, double spd) { builder.addDouble(38, spd, 0.0); }
  public static void addHdng(FlatBufferBuilder builder, double hdng) { builder.addDouble(39, hdng, 0.0); }
  public static void addCourse(FlatBufferBuilder builder, double course) { builder.addDouble(40, course, 0.0); }
  public static void addLco(FlatBufferBuilder builder, int lcoOffset) { builder.addOffset(41, lcoOffset, 0); }
  public static int createLcoVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLcoVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addLcs(FlatBufferBuilder builder, int lcsOffset) { builder.addOffset(42, lcsOffset, 0); }
  public static int createLcsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLcsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addLcPos(FlatBufferBuilder builder, int lcPosOffset) { builder.addOffset(43, lcPosOffset, 0); }
  public static int createLcPosVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLcPosVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addLcVel(FlatBufferBuilder builder, int lcVelOffset) { builder.addOffset(44, lcVelOffset, 0); }
  public static int createLcVelVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLcVelVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addLcAcc(FlatBufferBuilder builder, int lcAccOffset) { builder.addOffset(45, lcAccOffset, 0); }
  public static int createLcAccVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLcAccVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addENuvel(FlatBufferBuilder builder, int eNuvelOffset) { builder.addOffset(46, eNuvelOffset, 0); }
  public static int createENuvelVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startENuvelVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addENupos(FlatBufferBuilder builder, int eNuposOffset) { builder.addOffset(47, eNuposOffset, 0); }
  public static int createENuposVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startENuposVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addCov(FlatBufferBuilder builder, int covOffset) { builder.addOffset(48, covOffset, 0); }
  public static int createCovVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startCovVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addErrEllp(FlatBufferBuilder builder, int errEllpOffset) { builder.addOffset(49, errEllpOffset, 0); }
  public static int createErrEllpVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startErrEllpVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSrcTyps(FlatBufferBuilder builder, int srcTypsOffset) { builder.addOffset(50, srcTypsOffset, 0); }
  public static int createSrcTypsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSrcTypsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSrcIds(FlatBufferBuilder builder, int srcIdsOffset) { builder.addOffset(51, srcIdsOffset, 0); }
  public static int createSrcIdsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSrcIdsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addCallSign(FlatBufferBuilder builder, int callSignOffset) { builder.addOffset(52, callSignOffset, 0); }
  public static void addMultiSource(FlatBufferBuilder builder, boolean multiSource) { builder.addBoolean(53, multiSource, false); }
  public static void addJSeries(FlatBufferBuilder builder, int jSeriesOffset) { builder.addOffset(54, jSeriesOffset, 0); }
  public static void addStrength(FlatBufferBuilder builder, int strength) { builder.addInt(55, strength, 0); }
  public static void addM1(FlatBufferBuilder builder, int m1) { builder.addInt(56, m1, 0); }
  public static void addM1v(FlatBufferBuilder builder, int m1v) { builder.addInt(57, m1v, 0); }
  public static void addM2(FlatBufferBuilder builder, int m2) { builder.addInt(58, m2, 0); }
  public static void addM2v(FlatBufferBuilder builder, int m2v) { builder.addInt(59, m2v, 0); }
  public static void addM3a(FlatBufferBuilder builder, int m3a) { builder.addInt(60, m3a, 0); }
  public static void addM3av(FlatBufferBuilder builder, int m3av) { builder.addInt(61, m3av, 0); }
  public static void addTags(FlatBufferBuilder builder, int tagsOffset) { builder.addOffset(62, tagsOffset, 0); }
  public static int createTagsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startTagsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSourceDl(FlatBufferBuilder builder, int sourceDlOffset) { builder.addOffset(63, sourceDlOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(64, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(65, originOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(66, dataMode, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(67, origNetworkOffset, 0); }
  public static int endTrack_Abridged(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishTrack_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "TRAC"); }
  public static void finishSizePrefixedTrack_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "TRAC"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public Track_Abridged get(int j) { return get(new Track_Abridged(), j); }
    public Track_Abridged get(Track_Abridged obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

