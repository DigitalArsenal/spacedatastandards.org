// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// Points identified within the route.
 */
@SuppressWarnings("unused")
public final class RoutePoints_Full extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static RoutePoints_Full getRootAsRoutePoints_Full(ByteBuffer _bb) { return getRootAsRoutePoints_Full(_bb, new RoutePoints_Full()); }
  public static RoutePoints_Full getRootAsRoutePoints_Full(ByteBuffer _bb, RoutePoints_Full obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean RoutePoints_FullBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "ROUT"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public RoutePoints_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Sequencing field for the track route. This is the identifier representing the sequence of waypoints associated to the track route.
   * Example: /// Example: 1
   * Constraints: No constraints specified.
   */
  public int ptSequenceId() { int o = __offset(4); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Code representation of the point within the track route (ex. EP, EX, CP, IP, etc.).
   * Example: /// Example: EP
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String ptTypeCode() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ptTypeCodeAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer ptTypeCodeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * The name that represents the point within the track route (ex. ENTRY POINT, EXIT POINT, CONTROL POINT, INITIAL POINT, etc.).
   * Example: /// Example: ENTRY POINT
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String ptTypeName() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ptTypeNameAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer ptTypeNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Name of a waypoint which identifies the location of the point.
   * Example: /// Example: KCHS
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String waypointName() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer waypointNameAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer waypointNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Flag indicating this is a Digital Aeronautical Flight Information File (DAFIF) point.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean dafifPt() { int o = __offset(12); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * WGS84 latitude of the point location, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 45.23
   * Constraints: No constraints specified.
   */
  public double ptLat() { int o = __offset(14); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS84 longitude of the point location, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 179.1
   * Constraints: No constraints specified.
   */
  public double ptLon() { int o = __offset(16); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The magnetic declination/variation of the route point location from true north, in degrees. Positive values east of true north and negative values west of true north.
   * Example: /// Example: 7.35
   * Constraints: No constraints specified.
   */
  public double magDec() { int o = __offset(18); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The length of the course from the Navigational Aid (NAVAID) in nautical miles.
   * Example: /// Example: 100.2
   * Constraints: No constraints specified.
   */
  public double navaidLength() { int o = __offset(20); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Navigational Aid (NAVAID) identification code.
   * Example: /// Example: HTO
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String navaid() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer navaidAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer navaidInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * The DoD Standard Country Code designator for the country where the route point resides. This field should be set to "OTHR" if the source value does not match a UDL country code value (ISO-3166-ALPHA-2).
   * Example: /// Example: NL
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String countryCode() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer countryCodeAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer countryCodeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * Specifies an alternate country code if the data provider code is not part of an official NAVAID Country Code standard such as ISO-3166 or FIPS. This field will be set to the value provided by the source and should be used for all Queries specifying a Country Code.
   * Example: /// Example: IZ
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String altCountryCode() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer altCountryCodeAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer altCountryCodeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * The NAVAID type of this route point (ex. VOR, VORTAC, TACAN, etc.).
   * Example: /// Example: VORTAC
   * Constraints: Minimum length = 0, Maximum length = 12
   */
  public String navaidType() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer navaidTypeAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer navaidTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }

  public static int createRoutePoints_Full(FlatBufferBuilder builder,
      int ptSequenceId,
      int ptTypeCodeOffset,
      int ptTypeNameOffset,
      int waypointNameOffset,
      boolean dafifPt,
      double ptLat,
      double ptLon,
      double magDec,
      double navaidLength,
      int navaidOffset,
      int countryCodeOffset,
      int altCountryCodeOffset,
      int navaidTypeOffset) {
    builder.startTable(13);
    RoutePoints_Full.addNavaidLength(builder, navaidLength);
    RoutePoints_Full.addMagDec(builder, magDec);
    RoutePoints_Full.addPtLon(builder, ptLon);
    RoutePoints_Full.addPtLat(builder, ptLat);
    RoutePoints_Full.addNavaidType(builder, navaidTypeOffset);
    RoutePoints_Full.addAltCountryCode(builder, altCountryCodeOffset);
    RoutePoints_Full.addCountryCode(builder, countryCodeOffset);
    RoutePoints_Full.addNavaid(builder, navaidOffset);
    RoutePoints_Full.addWaypointName(builder, waypointNameOffset);
    RoutePoints_Full.addPtTypeName(builder, ptTypeNameOffset);
    RoutePoints_Full.addPtTypeCode(builder, ptTypeCodeOffset);
    RoutePoints_Full.addPtSequenceId(builder, ptSequenceId);
    RoutePoints_Full.addDafifPt(builder, dafifPt);
    return RoutePoints_Full.endRoutePoints_Full(builder);
  }

  public static void startRoutePoints_Full(FlatBufferBuilder builder) { builder.startTable(13); }
  public static void addPtSequenceId(FlatBufferBuilder builder, int ptSequenceId) { builder.addInt(0, ptSequenceId, 0); }
  public static void addPtTypeCode(FlatBufferBuilder builder, int ptTypeCodeOffset) { builder.addOffset(1, ptTypeCodeOffset, 0); }
  public static void addPtTypeName(FlatBufferBuilder builder, int ptTypeNameOffset) { builder.addOffset(2, ptTypeNameOffset, 0); }
  public static void addWaypointName(FlatBufferBuilder builder, int waypointNameOffset) { builder.addOffset(3, waypointNameOffset, 0); }
  public static void addDafifPt(FlatBufferBuilder builder, boolean dafifPt) { builder.addBoolean(4, dafifPt, false); }
  public static void addPtLat(FlatBufferBuilder builder, double ptLat) { builder.addDouble(5, ptLat, 0.0); }
  public static void addPtLon(FlatBufferBuilder builder, double ptLon) { builder.addDouble(6, ptLon, 0.0); }
  public static void addMagDec(FlatBufferBuilder builder, double magDec) { builder.addDouble(7, magDec, 0.0); }
  public static void addNavaidLength(FlatBufferBuilder builder, double navaidLength) { builder.addDouble(8, navaidLength, 0.0); }
  public static void addNavaid(FlatBufferBuilder builder, int navaidOffset) { builder.addOffset(9, navaidOffset, 0); }
  public static void addCountryCode(FlatBufferBuilder builder, int countryCodeOffset) { builder.addOffset(10, countryCodeOffset, 0); }
  public static void addAltCountryCode(FlatBufferBuilder builder, int altCountryCodeOffset) { builder.addOffset(11, altCountryCodeOffset, 0); }
  public static void addNavaidType(FlatBufferBuilder builder, int navaidTypeOffset) { builder.addOffset(12, navaidTypeOffset, 0); }
  public static int endRoutePoints_Full(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishRoutePoints_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "ROUT"); }
  public static void finishSizePrefixedRoutePoints_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "ROUT"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public RoutePoints_Full get(int j) { return get(new RoutePoints_Full(), j); }
    public RoutePoints_Full get(RoutePoints_Full obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

