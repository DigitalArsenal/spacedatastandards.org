// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// An ephemeris record is a position and velocity vector identifying the location and trajectory of an on-orbit object at a specified time. Ephemeris points, including covariance, are in kilometer and second based units in a user specified reference frame, with ECI J2K being preferred. The EphemerisSet ID (esId) links all points associated with an ephemeris set. The 'EphemerisSet' record contains details of the underlying data and propagation models used in the generation of the ephemeris. Ephemeris points must be retrieved by specifying the parent EphemerisSet ID (esId).
 */
@SuppressWarnings("unused")
public final class Ephemeris_Full extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static Ephemeris_Full getRootAsEphemeris_Full(ByteBuffer _bb) { return getRootAsEphemeris_Full(_bb, new Ephemeris_Full()); }
  public static Ephemeris_Full getRootAsEphemeris_Full(ByteBuffer _bb, Ephemeris_Full obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean Ephemeris_FullBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "EPHE"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public Ephemeris_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: EPHEMERIS-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Unique identifier of the parent EphemerisSet, auto-generated by the system. The esId (ephemerisSet id) is used to identify all individual ephemeris states associated with a parent ephemerisSet.
   * Example: /// Example: ES-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String esId() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer esIdAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer esIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Time associated with the Ephemeris Point, in ISO8601 UTC format.
   * Example: /// Example: 2018-01-01T16:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String ts() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tsAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer tsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Cartesian X position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double xpos() { int o = __offset(12); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y position of target, in km, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double ypos() { int o = __offset(14); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z position of target, in km, in the specified EphemerisSet referenceFrame. If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double zpos() { int o = __offset(16); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian X velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double xvel() { int o = __offset(18); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double yvel() { int o = __offset(20); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z velocity of target, in km/sec, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double zvel() { int o = __offset(22); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian X acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double xaccel() { int o = __offset(24); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double yaccel() { int o = __offset(26); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z acceleration of target, in km/sec^2, in the specified EphemerisSet referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 1.1
   * Constraints: No constraints specified.
   */
  public double zaccel() { int o = __offset(28); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Covariance matrix, in kilometer and second based units, in the specified Ephemeris Set covReferenceFrame.  If the covReferenceFrame from the EphemerisSet table is null it is assumed to be J2000.
   * The array values represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;y&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;y'&nbsp;z'&nbsp;&nbsp;
   * x&nbsp;&nbsp;&nbsp;&nbsp;1
   * y&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3
   * z&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;6
   * x'&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;10
   * y'&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
   * z'&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp; 21
   * The array containing the covariance matrix elements will be of length 6 for position only covariance, or length 21 for position-velocity covariance.  The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
   * Example: /// Example: No example provided.
   * Constraints: No constraints specified.
   */
  public String cov(int j) { int o = __offset(30); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int covLength() { int o = __offset(30); return o != 0 ? __vector_len(o) : 0; }
  public StringVector covVector() { return covVector(new StringVector()); }
  public StringVector covVector(StringVector obj) { int o = __offset(30); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String source() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(38); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Unique identifier of the on-orbit satellite object.
   * Example: /// Example: ONORBIT-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idOnOrbit() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idOnOrbitAsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer idOnOrbitInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * Optional identifier provided by ephemeris source to indicate the target object of this ephemeris. This may be an internal identifier and not necessarily map to a valid satellite number.
   * Example: /// Example: ORIGOBJECT-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String origObjectId() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origObjectIdAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer origObjectIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(44); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(44, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 44, 1); }

  public static int createEphemeris_Full(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int esIdOffset,
      int tsOffset,
      double xpos,
      double ypos,
      double zpos,
      double xvel,
      double yvel,
      double zvel,
      double xaccel,
      double yaccel,
      double zaccel,
      int covOffset,
      int createdAtOffset,
      int createdByOffset,
      int sourceOffset,
      byte dataMode,
      int idOnOrbitOffset,
      int origObjectIdOffset,
      int originOffset) {
    builder.startTable(21);
    Ephemeris_Full.addZaccel(builder, zaccel);
    Ephemeris_Full.addYaccel(builder, yaccel);
    Ephemeris_Full.addXaccel(builder, xaccel);
    Ephemeris_Full.addZvel(builder, zvel);
    Ephemeris_Full.addYvel(builder, yvel);
    Ephemeris_Full.addXvel(builder, xvel);
    Ephemeris_Full.addZpos(builder, zpos);
    Ephemeris_Full.addYpos(builder, ypos);
    Ephemeris_Full.addXpos(builder, xpos);
    Ephemeris_Full.addOrigin(builder, originOffset);
    Ephemeris_Full.addOrigObjectId(builder, origObjectIdOffset);
    Ephemeris_Full.addIdOnOrbit(builder, idOnOrbitOffset);
    Ephemeris_Full.addSource(builder, sourceOffset);
    Ephemeris_Full.addCreatedBy(builder, createdByOffset);
    Ephemeris_Full.addCreatedAt(builder, createdAtOffset);
    Ephemeris_Full.addCov(builder, covOffset);
    Ephemeris_Full.addTs(builder, tsOffset);
    Ephemeris_Full.addEsId(builder, esIdOffset);
    Ephemeris_Full.addClassificationMarking(builder, classificationMarkingOffset);
    Ephemeris_Full.addId(builder, idOffset);
    Ephemeris_Full.addDataMode(builder, dataMode);
    return Ephemeris_Full.endEphemeris_Full(builder);
  }

  public static void startEphemeris_Full(FlatBufferBuilder builder) { builder.startTable(21); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addEsId(FlatBufferBuilder builder, int esIdOffset) { builder.addOffset(2, esIdOffset, 0); }
  public static void addTs(FlatBufferBuilder builder, int tsOffset) { builder.addOffset(3, tsOffset, 0); }
  public static void addXpos(FlatBufferBuilder builder, double xpos) { builder.addDouble(4, xpos, 0.0); }
  public static void addYpos(FlatBufferBuilder builder, double ypos) { builder.addDouble(5, ypos, 0.0); }
  public static void addZpos(FlatBufferBuilder builder, double zpos) { builder.addDouble(6, zpos, 0.0); }
  public static void addXvel(FlatBufferBuilder builder, double xvel) { builder.addDouble(7, xvel, 0.0); }
  public static void addYvel(FlatBufferBuilder builder, double yvel) { builder.addDouble(8, yvel, 0.0); }
  public static void addZvel(FlatBufferBuilder builder, double zvel) { builder.addDouble(9, zvel, 0.0); }
  public static void addXaccel(FlatBufferBuilder builder, double xaccel) { builder.addDouble(10, xaccel, 0.0); }
  public static void addYaccel(FlatBufferBuilder builder, double yaccel) { builder.addDouble(11, yaccel, 0.0); }
  public static void addZaccel(FlatBufferBuilder builder, double zaccel) { builder.addDouble(12, zaccel, 0.0); }
  public static void addCov(FlatBufferBuilder builder, int covOffset) { builder.addOffset(13, covOffset, 0); }
  public static int createCovVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startCovVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(14, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(15, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(16, sourceOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(17, dataMode, 0); }
  public static void addIdOnOrbit(FlatBufferBuilder builder, int idOnOrbitOffset) { builder.addOffset(18, idOnOrbitOffset, 0); }
  public static void addOrigObjectId(FlatBufferBuilder builder, int origObjectIdOffset) { builder.addOffset(19, origObjectIdOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(20, originOffset, 0); }
  public static int endEphemeris_Full(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishEphemeris_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "EPHE"); }
  public static void finishSizePrefixedEphemeris_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "EPHE"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public Ephemeris_Full get(int j) { return get(new Ephemeris_Full(), j); }
    public Ephemeris_Full get(Ephemeris_Full obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

