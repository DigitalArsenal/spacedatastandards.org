// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// Self-reported information obtained from Automatic Identification System (AIS) equipment. This contains information such as unique identification, status, position, course, and speed. The AIS is an automatic tracking system that uses transceivers on ships and is used by vessel traffic services. Although technically and operationally distinct, the AIS system is analogous to ADS-B that performs a similar function for aircraft. AIS is intended to assist a vessel's watchstanding officers and allow maritime authorities to track and monitor vessel movements. AIS integrates a standardized VHF transceiver with a positioning system such as Global Positioning System receiver, with other electronic navigation sensors, such as gyrocompass or rate of turn indicator. Vessels fitted with AIS transceivers can be tracked by AIS base stations located along coast lines or, when out of range of terrestrial networks, through a growing number of satellites that are fitted with special AIS receivers which are capable of deconflicting a large number of signatures.
 */
@SuppressWarnings("unused")
public final class AIS_Ingest extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static AIS_Ingest getRootAsAIS_Ingest(ByteBuffer _bb) { return getRootAsAIS_Ingest(_bb, new AIS_Ingest()); }
  public static AIS_Ingest getRootAsAIS_Ingest(ByteBuffer _bb, AIS_Ingest obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean AIS_IngestBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "AISI"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public AIS_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: AIS-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Unique identifier of the Track.
   * Example: /// Example: TRACK-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idTrack() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idTrackAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer idTrackInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Unique identifier of the vessel.
   * Example: /// Example: VESSEL-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idVessel() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idVesselAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer idVesselInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * The Maritime Mobile Service Identity of the vessel.  MMSI is a nine-digit number that identifies the transmitter station of the vessel.
   * Example: /// Example: 304010417
   * Constraints: No constraints specified.
   */
  public long mmsi() { int o = __offset(12); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * The International Maritime Organization Number of the vessel.  IMON is a seven-digit number that uniquely identifies the vessel.
   * Example: /// Example: 9015462
   * Constraints: No constraints specified.
   */
  public long imon() { int o = __offset(14); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * The timestamp that the vessel position was recorded, in ISO 8601 UTC format.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String ts() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tsAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer tsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * The name of the vessel.  Vessel names that exceed the AIS 20 character are shortened (not truncated) to 15 character-spaces, followed by an underscore and the last 4 characters-spaces of the vessel full name.
   * Example: /// Example: DORNUM
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String shipName() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer shipNameAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer shipNameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * The reported ship type (e.g. Passenger, Tanker, Cargo, Other, etc.).  See the engagedIn and specialCraft entries for additional information on certain types of vessels.
   * Example: /// Example: Passenger
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String shipType() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer shipTypeAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer shipTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * The activity that the vessel is engaged in.  This entry applies only when the shipType = Other.
   * Example: /// Example: Cargo
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String engagedIn() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer engagedInAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer engagedInInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * The type of special craft designation of the vessel.  This entry applies only when the shipType = Special Craft.
   * Example: /// Example: Tug
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String specialCraft() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer specialCraftAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer specialCraftInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * The reported cargo type. Intended as, but not constrained to, the USCG NAVCEN AIS cargo definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with ship and cargo types. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Freight
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String cargoType() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer cargoTypeAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer cargoTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * A uniquely designated identifier for the vessel's transmitter station.
   * Example: /// Example: V2OZ
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String callSign() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer callSignAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer callSignInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * The flag of the subject vessel according to AIS transmission.
   * Example: /// Example: United States
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String vesselFlag() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer vesselFlagAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer vesselFlagInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * WGS-84 latitude of the vessel position, in degrees.  -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 47.758499
   * Constraints: No constraints specified.
   */
  public double lat() { int o = __offset(32); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the vessel position, in degrees.  -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: -5.154223
   * Constraints: No constraints specified.
   */
  public double lon() { int o = __offset(34); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Flag indicating high reported position accuracy (less than or equal to 10 meters).  A value of 0/false indicates low accuracy (greater than 10 meters).
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean posHiAccuracy() { int o = __offset(36); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating high reported position latency (greater than 5 seconds).  A value of 0/false indicates low latency (less than 5 seconds).
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean posHiLatency() { int o = __offset(38); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The speed-over-ground reported by the vessel, in kilometers/hour.
   * Example: /// Example: 10.5
   * Constraints: No constraints specified.
   */
  public double speed() { int o = __offset(40); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The true heading reported by the vessel, in degrees.
   * Example: /// Example: 329.1
   * Constraints: No constraints specified.
   */
  public double trueHeading() { int o = __offset(42); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The course-over-ground reported by the vessel, in degrees.
   * Example: /// Example: 157.1
   * Constraints: No constraints specified.
   */
  public double course() { int o = __offset(44); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Rate-of-Turn for the vessel, in degrees/minute.  Positive value indicates that the vessel is turning right.
   * Example: /// Example: 22.1
   * Constraints: No constraints specified.
   */
  public double rateOfTurn() { int o = __offset(46); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Flag indicating that the vessel is engaged in a special maneuver (e.g. Waterway Navigation).
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean specialManeuver() { int o = __offset(48); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The AIS Navigational Status of the vessel (e.g. Underway Using Engine, Moored, Aground, etc.). Intended as, but not constrained to, the USCG NAVCEN navigation status definitions. Users should refer to USCG Navigation Center documentation for specific definitions associated with navigation status. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: Underway Using Engine
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String navStatus() { int o = __offset(50); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer navStatusAsByteBuffer() { return __vector_as_bytebuffer(50, 1); }
  public ByteBuffer navStatusInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 50, 1); }
  /**
   * The type of electronic position fixing device (e.g. GPS, GLONASS, etc.). Intended as, but not constrained to, the USCG NAVCEN electronic position fixing device definitions. Users should refer to USCG Navigation Center documentation for specific device type information. USCG NAVCEN documentation may be found at https://www.navcen.uscg.gov.
   * Example: /// Example: GPS
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String posDeviceType() { int o = __offset(52); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer posDeviceTypeAsByteBuffer() { return __vector_as_bytebuffer(52, 1); }
  public ByteBuffer posDeviceTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 52, 1); }
  /**
   * The reference dimensions of the vessel, reported as [A, B, C, D], in meters.  Where the array values represent the distance fore (A), aft (B), to port (C), and to starboard (D) of the navigation antenna.  Array with values A = C = 0 and B, D > 0 indicate the length (B) and width (D) of the vessel without antenna position reference.
   * Example: /// Example: [50.1, 50.1, 20.1, 20.1]
   * Constraints: No constraints specified.
   */
  public String antennaRefDimensions(int j) { int o = __offset(54); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int antennaRefDimensionsLength() { int o = __offset(54); return o != 0 ? __vector_len(o) : 0; }
  public StringVector antennaRefDimensionsVector() { return antennaRefDimensionsVector(new StringVector()); }
  public StringVector antennaRefDimensionsVector(StringVector obj) { int o = __offset(54); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The overall length of the vessel, in meters.  A value of 511 indicates a vessel length of 511 meters or greater.
   * Example: /// Example: 511.1
   * Constraints: No constraints specified.
   */
  public double length() { int o = __offset(56); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The breadth of the vessel, in meters.  A value of 63 indicates a vessel breadth of 63 meters or greater.
   * Example: /// Example: 24.1
   * Constraints: No constraints specified.
   */
  public double width() { int o = __offset(58); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum static draught, in meters, of the vessel according to the AIS transmission.
   * Example: /// Example: 21.1
   * Constraints: No constraints specified.
   */
  public double draught() { int o = __offset(60); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Further description or explanation of the vessel or type.
   * Example: /// Example: Search and rescue vessels
   * Constraints: Minimum length = 0, Maximum length = 100
   */
  public String shipDescription() { int o = __offset(62); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer shipDescriptionAsByteBuffer() { return __vector_as_bytebuffer(62, 1); }
  public ByteBuffer shipDescriptionInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 62, 1); }
  /**
   * The destination of the vessel according to the AIS transmission.
   * Example: /// Example: USCLE
   * Constraints: Minimum length = 0, Maximum length = 20
   */
  public String destination() { int o = __offset(64); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer destinationAsByteBuffer() { return __vector_as_bytebuffer(64, 1); }
  public ByteBuffer destinationInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 64, 1); }
  /**
   * The Estimated Time of Arrival of the vessel at the destination, in ISO 8601 UTC format.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String destinationEta() { int o = __offset(66); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer destinationEtaAsByteBuffer() { return __vector_as_bytebuffer(66, 1); }
  public ByteBuffer destinationEtaInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 66, 1); }
  /**
   * The US Geographic Unique Identifier of the current port hosting the vessel.
   * Example: /// Example: 0ABC
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String currentPortGuid() { int o = __offset(68); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer currentPortGuidAsByteBuffer() { return __vector_as_bytebuffer(68, 1); }
  public ByteBuffer currentPortGuidInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 68, 1); }
  /**
   * The UN Location Code of the current port hosting the vessel.
   * Example: /// Example: XF013
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String currentPortLocode() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer currentPortLocodeAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer currentPortLocodeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * The US Geographic Unique Identifier of the last port visited by the vessel.
   * Example: /// Example: 0VAX
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String lastPortGuid() { int o = __offset(72); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer lastPortGuidAsByteBuffer() { return __vector_as_bytebuffer(72, 1); }
  public ByteBuffer lastPortGuidInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 72, 1); }
  /**
   * The UN Location Code of the last port visited by the vessel.
   * Example: /// Example: USSKY
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String lastPortLocode() { int o = __offset(74); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer lastPortLocodeAsByteBuffer() { return __vector_as_bytebuffer(74, 1); }
  public ByteBuffer lastPortLocodeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 74, 1); }
  /**
   * The US Geographic Unique Identifier of the next destination port of the vessel.
   * Example: /// Example: 0Z8Q
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String nextPortGuid() { int o = __offset(76); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer nextPortGuidAsByteBuffer() { return __vector_as_bytebuffer(76, 1); }
  public ByteBuffer nextPortGuidInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 76, 1); }
  /**
   * The UN  Location Code of the next destination port of the vessel.
   * Example: /// Example: USCLE
   * Constraints: Minimum length = 0, Maximum length = 5
   */
  public String nextPortLocode() { int o = __offset(78); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer nextPortLocodeAsByteBuffer() { return __vector_as_bytebuffer(78, 1); }
  public ByteBuffer nextPortLocodeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 78, 1); }
  /**
   * The Estimated Time of Arrival of the vessel at the destination port, according to MarineTraffic calculations, in ISO 8601 UTC format.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String etaCalculated() { int o = __offset(80); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer etaCalculatedAsByteBuffer() { return __vector_as_bytebuffer(80, 1); }
  public ByteBuffer etaCalculatedInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 80, 1); }
  /**
   * The date and time that the ETA was calculated by MarineTraffic, in ISO 8601 UTC format.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String etaUpdated() { int o = __offset(82); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer etaUpdatedAsByteBuffer() { return __vector_as_bytebuffer(82, 1); }
  public ByteBuffer etaUpdatedInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 82, 1); }
  /**
   * The remaining distance, in kilometers, for the vessel to reach the reported destination.
   * Example: /// Example: 150.5
   * Constraints: No constraints specified.
   */
  public double distanceToGo() { int o = __offset(84); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The distance, in kilometers, that the vessel has travelled since departing the last port.
   * Example: /// Example: 200.3
   * Constraints: No constraints specified.
   */
  public double distanceTravelled() { int o = __offset(86); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The average speed, in kilometers/hour, calculated for the subject vessel during the latest voyage (port to port).
   * Example: /// Example: 12.1
   * Constraints: No constraints specified.
   */
  public double avgSpeed() { int o = __offset(88); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The maximum speed, in kilometers/hour, reported by the subject vessel during the latest voyage (port to port).
   * Example: /// Example: 13.3
   * Constraints: No constraints specified.
   */
  public double maxSpeed() { int o = __offset(90); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(92); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(92, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 92, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(94); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(94, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 94, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String source() { int o = __offset(96); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(96, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 96, 1); }
  /**
   * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
   * Example: /// Example: AXE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String sourceDl() { int o = __offset(98); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceDlAsByteBuffer() { return __vector_as_bytebuffer(98, 1); }
  public ByteBuffer sourceDlInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 98, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(102); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: ORIG
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(104); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(104, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 104, 1); }

  public static int createAIS_Ingest(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int idTrackOffset,
      int idVesselOffset,
      long mmsi,
      long imon,
      int tsOffset,
      int shipNameOffset,
      int shipTypeOffset,
      int engagedInOffset,
      int specialCraftOffset,
      int cargoTypeOffset,
      int callSignOffset,
      int vesselFlagOffset,
      double lat,
      double lon,
      boolean posHiAccuracy,
      boolean posHiLatency,
      double speed,
      double trueHeading,
      double course,
      double rateOfTurn,
      boolean specialManeuver,
      int navStatusOffset,
      int posDeviceTypeOffset,
      int antennaRefDimensionsOffset,
      double length,
      double width,
      double draught,
      int shipDescriptionOffset,
      int destinationOffset,
      int destinationEtaOffset,
      int currentPortGuidOffset,
      int currentPortLocodeOffset,
      int lastPortGuidOffset,
      int lastPortLocodeOffset,
      int nextPortGuidOffset,
      int nextPortLocodeOffset,
      int etaCalculatedOffset,
      int etaUpdatedOffset,
      double distanceToGo,
      double distanceTravelled,
      double avgSpeed,
      double maxSpeed,
      int createdAtOffset,
      int createdByOffset,
      int sourceOffset,
      int sourceDlOffset,
      int originOffset,
      byte dataMode,
      int origNetworkOffset) {
    builder.startTable(51);
    AIS_Ingest.addMaxSpeed(builder, maxSpeed);
    AIS_Ingest.addAvgSpeed(builder, avgSpeed);
    AIS_Ingest.addDistanceTravelled(builder, distanceTravelled);
    AIS_Ingest.addDistanceToGo(builder, distanceToGo);
    AIS_Ingest.addDraught(builder, draught);
    AIS_Ingest.addWidth(builder, width);
    AIS_Ingest.addLength(builder, length);
    AIS_Ingest.addRateOfTurn(builder, rateOfTurn);
    AIS_Ingest.addCourse(builder, course);
    AIS_Ingest.addTrueHeading(builder, trueHeading);
    AIS_Ingest.addSpeed(builder, speed);
    AIS_Ingest.addLon(builder, lon);
    AIS_Ingest.addLat(builder, lat);
    AIS_Ingest.addImon(builder, imon);
    AIS_Ingest.addMmsi(builder, mmsi);
    AIS_Ingest.addOrigNetwork(builder, origNetworkOffset);
    AIS_Ingest.addOrigin(builder, originOffset);
    AIS_Ingest.addSourceDl(builder, sourceDlOffset);
    AIS_Ingest.addSource(builder, sourceOffset);
    AIS_Ingest.addCreatedBy(builder, createdByOffset);
    AIS_Ingest.addCreatedAt(builder, createdAtOffset);
    AIS_Ingest.addEtaUpdated(builder, etaUpdatedOffset);
    AIS_Ingest.addEtaCalculated(builder, etaCalculatedOffset);
    AIS_Ingest.addNextPortLocode(builder, nextPortLocodeOffset);
    AIS_Ingest.addNextPortGuid(builder, nextPortGuidOffset);
    AIS_Ingest.addLastPortLocode(builder, lastPortLocodeOffset);
    AIS_Ingest.addLastPortGuid(builder, lastPortGuidOffset);
    AIS_Ingest.addCurrentPortLocode(builder, currentPortLocodeOffset);
    AIS_Ingest.addCurrentPortGuid(builder, currentPortGuidOffset);
    AIS_Ingest.addDestinationEta(builder, destinationEtaOffset);
    AIS_Ingest.addDestination(builder, destinationOffset);
    AIS_Ingest.addShipDescription(builder, shipDescriptionOffset);
    AIS_Ingest.addAntennaRefDimensions(builder, antennaRefDimensionsOffset);
    AIS_Ingest.addPosDeviceType(builder, posDeviceTypeOffset);
    AIS_Ingest.addNavStatus(builder, navStatusOffset);
    AIS_Ingest.addVesselFlag(builder, vesselFlagOffset);
    AIS_Ingest.addCallSign(builder, callSignOffset);
    AIS_Ingest.addCargoType(builder, cargoTypeOffset);
    AIS_Ingest.addSpecialCraft(builder, specialCraftOffset);
    AIS_Ingest.addEngagedIn(builder, engagedInOffset);
    AIS_Ingest.addShipType(builder, shipTypeOffset);
    AIS_Ingest.addShipName(builder, shipNameOffset);
    AIS_Ingest.addTs(builder, tsOffset);
    AIS_Ingest.addIdVessel(builder, idVesselOffset);
    AIS_Ingest.addIdTrack(builder, idTrackOffset);
    AIS_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
    AIS_Ingest.addId(builder, idOffset);
    AIS_Ingest.addDataMode(builder, dataMode);
    AIS_Ingest.addSpecialManeuver(builder, specialManeuver);
    AIS_Ingest.addPosHiLatency(builder, posHiLatency);
    AIS_Ingest.addPosHiAccuracy(builder, posHiAccuracy);
    return AIS_Ingest.endAIS_Ingest(builder);
  }

  public static void startAIS_Ingest(FlatBufferBuilder builder) { builder.startTable(51); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addIdTrack(FlatBufferBuilder builder, int idTrackOffset) { builder.addOffset(2, idTrackOffset, 0); }
  public static void addIdVessel(FlatBufferBuilder builder, int idVesselOffset) { builder.addOffset(3, idVesselOffset, 0); }
  public static void addMmsi(FlatBufferBuilder builder, long mmsi) { builder.addLong(4, mmsi, 0L); }
  public static void addImon(FlatBufferBuilder builder, long imon) { builder.addLong(5, imon, 0L); }
  public static void addTs(FlatBufferBuilder builder, int tsOffset) { builder.addOffset(6, tsOffset, 0); }
  public static void addShipName(FlatBufferBuilder builder, int shipNameOffset) { builder.addOffset(7, shipNameOffset, 0); }
  public static void addShipType(FlatBufferBuilder builder, int shipTypeOffset) { builder.addOffset(8, shipTypeOffset, 0); }
  public static void addEngagedIn(FlatBufferBuilder builder, int engagedInOffset) { builder.addOffset(9, engagedInOffset, 0); }
  public static void addSpecialCraft(FlatBufferBuilder builder, int specialCraftOffset) { builder.addOffset(10, specialCraftOffset, 0); }
  public static void addCargoType(FlatBufferBuilder builder, int cargoTypeOffset) { builder.addOffset(11, cargoTypeOffset, 0); }
  public static void addCallSign(FlatBufferBuilder builder, int callSignOffset) { builder.addOffset(12, callSignOffset, 0); }
  public static void addVesselFlag(FlatBufferBuilder builder, int vesselFlagOffset) { builder.addOffset(13, vesselFlagOffset, 0); }
  public static void addLat(FlatBufferBuilder builder, double lat) { builder.addDouble(14, lat, 0.0); }
  public static void addLon(FlatBufferBuilder builder, double lon) { builder.addDouble(15, lon, 0.0); }
  public static void addPosHiAccuracy(FlatBufferBuilder builder, boolean posHiAccuracy) { builder.addBoolean(16, posHiAccuracy, false); }
  public static void addPosHiLatency(FlatBufferBuilder builder, boolean posHiLatency) { builder.addBoolean(17, posHiLatency, false); }
  public static void addSpeed(FlatBufferBuilder builder, double speed) { builder.addDouble(18, speed, 0.0); }
  public static void addTrueHeading(FlatBufferBuilder builder, double trueHeading) { builder.addDouble(19, trueHeading, 0.0); }
  public static void addCourse(FlatBufferBuilder builder, double course) { builder.addDouble(20, course, 0.0); }
  public static void addRateOfTurn(FlatBufferBuilder builder, double rateOfTurn) { builder.addDouble(21, rateOfTurn, 0.0); }
  public static void addSpecialManeuver(FlatBufferBuilder builder, boolean specialManeuver) { builder.addBoolean(22, specialManeuver, false); }
  public static void addNavStatus(FlatBufferBuilder builder, int navStatusOffset) { builder.addOffset(23, navStatusOffset, 0); }
  public static void addPosDeviceType(FlatBufferBuilder builder, int posDeviceTypeOffset) { builder.addOffset(24, posDeviceTypeOffset, 0); }
  public static void addAntennaRefDimensions(FlatBufferBuilder builder, int antennaRefDimensionsOffset) { builder.addOffset(25, antennaRefDimensionsOffset, 0); }
  public static int createAntennaRefDimensionsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAntennaRefDimensionsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addLength(FlatBufferBuilder builder, double length) { builder.addDouble(26, length, 0.0); }
  public static void addWidth(FlatBufferBuilder builder, double width) { builder.addDouble(27, width, 0.0); }
  public static void addDraught(FlatBufferBuilder builder, double draught) { builder.addDouble(28, draught, 0.0); }
  public static void addShipDescription(FlatBufferBuilder builder, int shipDescriptionOffset) { builder.addOffset(29, shipDescriptionOffset, 0); }
  public static void addDestination(FlatBufferBuilder builder, int destinationOffset) { builder.addOffset(30, destinationOffset, 0); }
  public static void addDestinationEta(FlatBufferBuilder builder, int destinationEtaOffset) { builder.addOffset(31, destinationEtaOffset, 0); }
  public static void addCurrentPortGuid(FlatBufferBuilder builder, int currentPortGuidOffset) { builder.addOffset(32, currentPortGuidOffset, 0); }
  public static void addCurrentPortLocode(FlatBufferBuilder builder, int currentPortLocodeOffset) { builder.addOffset(33, currentPortLocodeOffset, 0); }
  public static void addLastPortGuid(FlatBufferBuilder builder, int lastPortGuidOffset) { builder.addOffset(34, lastPortGuidOffset, 0); }
  public static void addLastPortLocode(FlatBufferBuilder builder, int lastPortLocodeOffset) { builder.addOffset(35, lastPortLocodeOffset, 0); }
  public static void addNextPortGuid(FlatBufferBuilder builder, int nextPortGuidOffset) { builder.addOffset(36, nextPortGuidOffset, 0); }
  public static void addNextPortLocode(FlatBufferBuilder builder, int nextPortLocodeOffset) { builder.addOffset(37, nextPortLocodeOffset, 0); }
  public static void addEtaCalculated(FlatBufferBuilder builder, int etaCalculatedOffset) { builder.addOffset(38, etaCalculatedOffset, 0); }
  public static void addEtaUpdated(FlatBufferBuilder builder, int etaUpdatedOffset) { builder.addOffset(39, etaUpdatedOffset, 0); }
  public static void addDistanceToGo(FlatBufferBuilder builder, double distanceToGo) { builder.addDouble(40, distanceToGo, 0.0); }
  public static void addDistanceTravelled(FlatBufferBuilder builder, double distanceTravelled) { builder.addDouble(41, distanceTravelled, 0.0); }
  public static void addAvgSpeed(FlatBufferBuilder builder, double avgSpeed) { builder.addDouble(42, avgSpeed, 0.0); }
  public static void addMaxSpeed(FlatBufferBuilder builder, double maxSpeed) { builder.addDouble(43, maxSpeed, 0.0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(44, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(45, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(46, sourceOffset, 0); }
  public static void addSourceDl(FlatBufferBuilder builder, int sourceDlOffset) { builder.addOffset(47, sourceDlOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(48, originOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(49, dataMode, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(50, origNetworkOffset, 0); }
  public static int endAIS_Ingest(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishAIS_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "AISI"); }
  public static void finishSizePrefixedAIS_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "AISI"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public AIS_Ingest get(int j) { return get(new AIS_Ingest(), j); }
    public AIS_Ingest get(AIS_Ingest obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

