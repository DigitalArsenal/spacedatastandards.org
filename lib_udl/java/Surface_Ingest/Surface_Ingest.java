// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// Surface information contains properties related to an airfield's runway, taxiway, and parking. The surface types and characteristics can dictate the airfield's capability of hosting a specific aircraft.
 */
@SuppressWarnings("unused")
public final class Surface_Ingest extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static Surface_Ingest getRootAsSurface_Ingest(ByteBuffer _bb) { return getRootAsSurface_Ingest(_bb, new Surface_Ingest()); }
  public static Surface_Ingest getRootAsSurface_Ingest(ByteBuffer _bb, Surface_Ingest obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean Surface_IngestBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "SURF"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public Surface_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: be831d39-1822-da9f-7ace-6cc5643397dc
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * The surface name or identifier.
   * Example: /// Example: West lot
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String name() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer nameAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer nameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * The surface type of this record (e.g. RUNWAY, TAXIWAY, PARKING).
   * Example: /// Example: PARKING
   * Constraints: Minimum length = 1, Maximum length = 7
   */
  public String type() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer typeAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer typeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * The ID of the site where this surface is located.
   * Example: /// Example: SITE-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idSite() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idSiteAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer idSiteInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * Alternate site identifier provided by the source.
   * Example: /// Example: ORIG-SITE-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String altSiteId() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer altSiteIdAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer altSiteIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Flag indicating this is the primary runway.  Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean primary() { int o = __offset(16); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The length of the surface type, in feet.  Applicable for runway and parking surface types.
   * Example: /// Example: 1500
   * Constraints: No constraints specified.
   */
  public int lengthFt() { int o = __offset(18); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The landing distance available for the runway, in feet.  Applicable for runway surface types only.
   * Example: /// Example: 475
   * Constraints: No constraints specified.
   */
  public int ldaFt() { int o = __offset(20); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The width of the surface type, in feet.
   * Example: /// Example: 220
   * Constraints: No constraints specified.
   */
  public int widthFt() { int o = __offset(22); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The length of the surface type, in meters.  Applicable for runway and parking surface types.
   * Example: /// Example: 457
   * Constraints: No constraints specified.
   */
  public int lengthM() { int o = __offset(24); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The landing distance available for the runway, in meters.  Applicable for runway surface types only.
   * Example: /// Example: 145
   * Constraints: No constraints specified.
   */
  public int ldaM() { int o = __offset(26); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The width of the surface type, in meters.
   * Example: /// Example: 67
   * Constraints: No constraints specified.
   */
  public int widthM() { int o = __offset(28); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The surface material (e.g. Asphalt, Concrete, Dirt).
   * Example: /// Example: Concrete
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String material() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer materialAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer materialInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * The surface condition (e.g. GOOD, FAIR, POOR, SERIOUS, FAILED, CLOSED, UNKNOWN).
   * Example: /// Example: GOOD
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String condition() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer conditionAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer conditionInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * Raw weight bearing capacity value or pavement strength.
   * Example: /// Example: LCN 42
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String rawWbc() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer rawWbcAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer rawWbcInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Pavement classification number (PCN) and tire pressure code.
   * Example: /// Example: 73RBWT
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String pcn() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer pcnAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer pcnInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * Load classification number or pavement rating which ranks aircraft on a scale of 1 to 120.
   * Example: /// Example: 50
   * Constraints: No constraints specified.
   */
  public int lcn() { int o = __offset(38); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilopounds (kip). Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 143
   * Constraints: No constraints specified.
   */
  public int sWtKip() { int o = __offset(40); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 188
   * Constraints: No constraints specified.
   */
  public int tWtKip() { int o = __offset(42); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 195
   * Constraints: No constraints specified.
   */
  public int stWtKip() { int o = __offset(44); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 414
   * Constraints: No constraints specified.
   */
  public int ttWtKip() { int o = __offset(46); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 416
   * Constraints: No constraints specified.
   */
  public int ddWtKip() { int o = __offset(48); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 603
   * Constraints: No constraints specified.
   */
  public int sbttWtKip() { int o = __offset(50); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 870
   * Constraints: No constraints specified.
   */
  public int tdtWtkip() { int o = __offset(52); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 622
   * Constraints: No constraints specified.
   */
  public int trtWtKip() { int o = __offset(54); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilopounds (kip).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 833
   * Constraints: No constraints specified.
   */
  public int ddtWtKip() { int o = __offset(56); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an S-type (single) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 636
   * Constraints: No constraints specified.
   */
  public int sWtKn() { int o = __offset(58); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a T-type (twin (dual)) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 836
   * Constraints: No constraints specified.
   */
  public int tWtKn() { int o = __offset(60); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an ST-type (single tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 867
   * Constraints: No constraints specified.
   */
  public int stWtKn() { int o = __offset(62); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a GDSS TT-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 1842
   * Constraints: No constraints specified.
   */
  public int ttWtKn() { int o = __offset(64); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an FAA 2D-type (twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 1850
   * Constraints: No constraints specified.
   */
  public int ddWtKn() { int o = __offset(66); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for an SBTT-type (single belly twin tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 2682
   * Constraints: No constraints specified.
   */
  public int sbttWtKn() { int o = __offset(68); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a TDT-type (twin delta tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 3870
   * Constraints: No constraints specified.
   */
  public int tdtWtKn() { int o = __offset(70); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a TRT-type (triple tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 2767
   * Constraints: No constraints specified.
   */
  public int trtWtKn() { int o = __offset(72); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The max weight allowable on this surface type for a DDT-type (double dual tandem) landing gear configuration, in kilonewtons (kN).Note: The corresponding equivalent field is not converted by the UDL and may or may not be supplied by the provider. The provider/consumer is responsible for all unit conversions.
   * Example: /// Example: 3705
   * Constraints: No constraints specified.
   */
  public int ddtWtKn() { int o = __offset(74); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Flag indicating the surface has lighting.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lighting() { int o = __offset(76); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway lighting is unknown. Applicable for runway surface types only.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean lightsUnkn() { int o = __offset(78); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has approach lights. Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsAprch() { int o = __offset(80); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has Visual Approach Slope Indicator (VASI) lights. Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsVasi() { int o = __offset(82); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has Precision Approach Path Indicator (PAPI) lights. Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsPapi() { int o = __offset(84); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has Optical Landing System (OLS) lights. Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsOls() { int o = __offset(86); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has Runway End Identifier Lights (REIL). Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsReil() { int o = __offset(88); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has Touchdown Zone lights. Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsTdzl() { int o = __offset(90); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the runway has centerline lights. Applicable for runway surface types only.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lightsCl() { int o = __offset(92); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Flag indicating the surface type has an obstacle. Applicable for taxiway and parking surface types.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean obstacle() { int o = __offset(94); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2022-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(96); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(96, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 96, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(98); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(98, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 98, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String source() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(102); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(102, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 102, 1); }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: OPS1
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(104); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(104, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 104, 1); }
  /**
   * Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(106); return o != 0 ? bb.get(o + bb_pos) : 0; }

  public static int createSurface_Ingest(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int nameOffset,
      int typeOffset,
      int idSiteOffset,
      int altSiteIdOffset,
      boolean primary,
      int lengthFt,
      int ldaFt,
      int widthFt,
      int lengthM,
      int ldaM,
      int widthM,
      int materialOffset,
      int conditionOffset,
      int rawWbcOffset,
      int pcnOffset,
      int lcn,
      int sWtKip,
      int tWtKip,
      int stWtKip,
      int ttWtKip,
      int ddWtKip,
      int sbttWtKip,
      int tdtWtkip,
      int trtWtKip,
      int ddtWtKip,
      int sWtKn,
      int tWtKn,
      int stWtKn,
      int ttWtKn,
      int ddWtKn,
      int sbttWtKn,
      int tdtWtKn,
      int trtWtKn,
      int ddtWtKn,
      boolean lighting,
      boolean lightsUnkn,
      boolean lightsAprch,
      boolean lightsVasi,
      boolean lightsPapi,
      boolean lightsOls,
      boolean lightsReil,
      boolean lightsTdzl,
      boolean lightsCl,
      boolean obstacle,
      int createdAtOffset,
      int createdByOffset,
      int sourceOffset,
      int originOffset,
      int origNetworkOffset,
      byte dataMode) {
    builder.startTable(52);
    Surface_Ingest.addOrigNetwork(builder, origNetworkOffset);
    Surface_Ingest.addOrigin(builder, originOffset);
    Surface_Ingest.addSource(builder, sourceOffset);
    Surface_Ingest.addCreatedBy(builder, createdByOffset);
    Surface_Ingest.addCreatedAt(builder, createdAtOffset);
    Surface_Ingest.addDdtWtKn(builder, ddtWtKn);
    Surface_Ingest.addTrtWtKn(builder, trtWtKn);
    Surface_Ingest.addTdtWtKn(builder, tdtWtKn);
    Surface_Ingest.addSbttWtKn(builder, sbttWtKn);
    Surface_Ingest.addDdWtKn(builder, ddWtKn);
    Surface_Ingest.addTtWtKn(builder, ttWtKn);
    Surface_Ingest.addStWtKn(builder, stWtKn);
    Surface_Ingest.addTWtKn(builder, tWtKn);
    Surface_Ingest.addSWtKn(builder, sWtKn);
    Surface_Ingest.addDdtWtKip(builder, ddtWtKip);
    Surface_Ingest.addTrtWtKip(builder, trtWtKip);
    Surface_Ingest.addTdtWtkip(builder, tdtWtkip);
    Surface_Ingest.addSbttWtKip(builder, sbttWtKip);
    Surface_Ingest.addDdWtKip(builder, ddWtKip);
    Surface_Ingest.addTtWtKip(builder, ttWtKip);
    Surface_Ingest.addStWtKip(builder, stWtKip);
    Surface_Ingest.addTWtKip(builder, tWtKip);
    Surface_Ingest.addSWtKip(builder, sWtKip);
    Surface_Ingest.addLcn(builder, lcn);
    Surface_Ingest.addPcn(builder, pcnOffset);
    Surface_Ingest.addRawWbc(builder, rawWbcOffset);
    Surface_Ingest.addCondition(builder, conditionOffset);
    Surface_Ingest.addMaterial(builder, materialOffset);
    Surface_Ingest.addWidthM(builder, widthM);
    Surface_Ingest.addLdaM(builder, ldaM);
    Surface_Ingest.addLengthM(builder, lengthM);
    Surface_Ingest.addWidthFt(builder, widthFt);
    Surface_Ingest.addLdaFt(builder, ldaFt);
    Surface_Ingest.addLengthFt(builder, lengthFt);
    Surface_Ingest.addAltSiteId(builder, altSiteIdOffset);
    Surface_Ingest.addIdSite(builder, idSiteOffset);
    Surface_Ingest.addType(builder, typeOffset);
    Surface_Ingest.addName(builder, nameOffset);
    Surface_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
    Surface_Ingest.addId(builder, idOffset);
    Surface_Ingest.addDataMode(builder, dataMode);
    Surface_Ingest.addObstacle(builder, obstacle);
    Surface_Ingest.addLightsCl(builder, lightsCl);
    Surface_Ingest.addLightsTdzl(builder, lightsTdzl);
    Surface_Ingest.addLightsReil(builder, lightsReil);
    Surface_Ingest.addLightsOls(builder, lightsOls);
    Surface_Ingest.addLightsPapi(builder, lightsPapi);
    Surface_Ingest.addLightsVasi(builder, lightsVasi);
    Surface_Ingest.addLightsAprch(builder, lightsAprch);
    Surface_Ingest.addLightsUnkn(builder, lightsUnkn);
    Surface_Ingest.addLighting(builder, lighting);
    Surface_Ingest.addPrimary(builder, primary);
    return Surface_Ingest.endSurface_Ingest(builder);
  }

  public static void startSurface_Ingest(FlatBufferBuilder builder) { builder.startTable(52); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addName(FlatBufferBuilder builder, int nameOffset) { builder.addOffset(2, nameOffset, 0); }
  public static void addType(FlatBufferBuilder builder, int typeOffset) { builder.addOffset(3, typeOffset, 0); }
  public static void addIdSite(FlatBufferBuilder builder, int idSiteOffset) { builder.addOffset(4, idSiteOffset, 0); }
  public static void addAltSiteId(FlatBufferBuilder builder, int altSiteIdOffset) { builder.addOffset(5, altSiteIdOffset, 0); }
  public static void addPrimary(FlatBufferBuilder builder, boolean primary) { builder.addBoolean(6, primary, false); }
  public static void addLengthFt(FlatBufferBuilder builder, int lengthFt) { builder.addInt(7, lengthFt, 0); }
  public static void addLdaFt(FlatBufferBuilder builder, int ldaFt) { builder.addInt(8, ldaFt, 0); }
  public static void addWidthFt(FlatBufferBuilder builder, int widthFt) { builder.addInt(9, widthFt, 0); }
  public static void addLengthM(FlatBufferBuilder builder, int lengthM) { builder.addInt(10, lengthM, 0); }
  public static void addLdaM(FlatBufferBuilder builder, int ldaM) { builder.addInt(11, ldaM, 0); }
  public static void addWidthM(FlatBufferBuilder builder, int widthM) { builder.addInt(12, widthM, 0); }
  public static void addMaterial(FlatBufferBuilder builder, int materialOffset) { builder.addOffset(13, materialOffset, 0); }
  public static void addCondition(FlatBufferBuilder builder, int conditionOffset) { builder.addOffset(14, conditionOffset, 0); }
  public static void addRawWbc(FlatBufferBuilder builder, int rawWbcOffset) { builder.addOffset(15, rawWbcOffset, 0); }
  public static void addPcn(FlatBufferBuilder builder, int pcnOffset) { builder.addOffset(16, pcnOffset, 0); }
  public static void addLcn(FlatBufferBuilder builder, int lcn) { builder.addInt(17, lcn, 0); }
  public static void addSWtKip(FlatBufferBuilder builder, int sWtKip) { builder.addInt(18, sWtKip, 0); }
  public static void addTWtKip(FlatBufferBuilder builder, int tWtKip) { builder.addInt(19, tWtKip, 0); }
  public static void addStWtKip(FlatBufferBuilder builder, int stWtKip) { builder.addInt(20, stWtKip, 0); }
  public static void addTtWtKip(FlatBufferBuilder builder, int ttWtKip) { builder.addInt(21, ttWtKip, 0); }
  public static void addDdWtKip(FlatBufferBuilder builder, int ddWtKip) { builder.addInt(22, ddWtKip, 0); }
  public static void addSbttWtKip(FlatBufferBuilder builder, int sbttWtKip) { builder.addInt(23, sbttWtKip, 0); }
  public static void addTdtWtkip(FlatBufferBuilder builder, int tdtWtkip) { builder.addInt(24, tdtWtkip, 0); }
  public static void addTrtWtKip(FlatBufferBuilder builder, int trtWtKip) { builder.addInt(25, trtWtKip, 0); }
  public static void addDdtWtKip(FlatBufferBuilder builder, int ddtWtKip) { builder.addInt(26, ddtWtKip, 0); }
  public static void addSWtKn(FlatBufferBuilder builder, int sWtKn) { builder.addInt(27, sWtKn, 0); }
  public static void addTWtKn(FlatBufferBuilder builder, int tWtKn) { builder.addInt(28, tWtKn, 0); }
  public static void addStWtKn(FlatBufferBuilder builder, int stWtKn) { builder.addInt(29, stWtKn, 0); }
  public static void addTtWtKn(FlatBufferBuilder builder, int ttWtKn) { builder.addInt(30, ttWtKn, 0); }
  public static void addDdWtKn(FlatBufferBuilder builder, int ddWtKn) { builder.addInt(31, ddWtKn, 0); }
  public static void addSbttWtKn(FlatBufferBuilder builder, int sbttWtKn) { builder.addInt(32, sbttWtKn, 0); }
  public static void addTdtWtKn(FlatBufferBuilder builder, int tdtWtKn) { builder.addInt(33, tdtWtKn, 0); }
  public static void addTrtWtKn(FlatBufferBuilder builder, int trtWtKn) { builder.addInt(34, trtWtKn, 0); }
  public static void addDdtWtKn(FlatBufferBuilder builder, int ddtWtKn) { builder.addInt(35, ddtWtKn, 0); }
  public static void addLighting(FlatBufferBuilder builder, boolean lighting) { builder.addBoolean(36, lighting, false); }
  public static void addLightsUnkn(FlatBufferBuilder builder, boolean lightsUnkn) { builder.addBoolean(37, lightsUnkn, false); }
  public static void addLightsAprch(FlatBufferBuilder builder, boolean lightsAprch) { builder.addBoolean(38, lightsAprch, false); }
  public static void addLightsVasi(FlatBufferBuilder builder, boolean lightsVasi) { builder.addBoolean(39, lightsVasi, false); }
  public static void addLightsPapi(FlatBufferBuilder builder, boolean lightsPapi) { builder.addBoolean(40, lightsPapi, false); }
  public static void addLightsOls(FlatBufferBuilder builder, boolean lightsOls) { builder.addBoolean(41, lightsOls, false); }
  public static void addLightsReil(FlatBufferBuilder builder, boolean lightsReil) { builder.addBoolean(42, lightsReil, false); }
  public static void addLightsTdzl(FlatBufferBuilder builder, boolean lightsTdzl) { builder.addBoolean(43, lightsTdzl, false); }
  public static void addLightsCl(FlatBufferBuilder builder, boolean lightsCl) { builder.addBoolean(44, lightsCl, false); }
  public static void addObstacle(FlatBufferBuilder builder, boolean obstacle) { builder.addBoolean(45, obstacle, false); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(46, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(47, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(48, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(49, originOffset, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(50, origNetworkOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(51, dataMode, 0); }
  public static int endSurface_Ingest(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishSurface_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "SURF"); }
  public static void finishSizePrefixedSurface_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "SURF"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public Surface_Ingest get(int j) { return get(new Surface_Ingest(), j); }
    public Surface_Ingest get(Surface_Ingest obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

