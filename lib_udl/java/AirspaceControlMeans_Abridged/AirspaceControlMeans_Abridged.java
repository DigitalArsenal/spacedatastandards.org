// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// A conditional nested segment to report multiple airspace control means within a particular airspace control means status.
 */
@SuppressWarnings("unused")
public final class AirspaceControlMeans_Abridged extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static AirspaceControlMeans_Abridged getRootAsAirspaceControlMeans_Abridged(ByteBuffer _bb) { return getRootAsAirspaceControlMeans_Abridged(_bb, new AirspaceControlMeans_Abridged()); }
  public static AirspaceControlMeans_Abridged getRootAsAirspaceControlMeans_Abridged(ByteBuffer _bb, AirspaceControlMeans_Abridged obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean AirspaceControlMeans_AbridgedBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "AIRS"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public AirspaceControlMeans_Abridged __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * The code for the type of airspace control means.
   * Example: /// Example: ACM:ADAREA
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String cmType() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer cmTypeAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer cmTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Airspace control means name or designator.
   * Example: /// Example: DESIG:C34
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String cmId() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer cmIdAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer cmIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Designates the geometric type that defines the airspace shape. One of CIRCLE, CORRIDOR, LINE, ORBIT, etc.
   * Example: /// Example: POLYARC
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public byte cmShape() { int o = __offset(8); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Designates the means by which a defined airspace control means is to be used.
   * Example: /// Example: USE:AIRCOR
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String usage() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer usageAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer usageInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Unique Link 16 identifier assigned to the airspace control means.
   * Example: /// Example: F3356
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String link16Id() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer link16IdAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer link16IdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The altitude at or below which the vertical position of an aircraft is controlled by reference to true altitude.
   * Example: /// Example: 18000FT
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String transAltitude() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer transAltitudeAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer transAltitudeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * Specifies the geodetic datum by which the spatial coordinates of the controlled airspace are calculated, if different from the top level ACO datum.
   * Example: /// Example: NAR
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String geoDatumAlt() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer geoDatumAltAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer geoDatumAltInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
   * Example: /// Example: 152345N0505657E
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String coord0() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer coord0AsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer coord0InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * A geospatial point coordinate specified in DMS (Degrees, Minutes, Seconds) format. The fields coord0 and coord1 should be used in the specification of any airspace control shape that requires exactly one (1) or two (2) reference points for construction. For shapes requiring one reference point, For instance, when shape is set to "APOINT," this field is required and singluarly defines the shape. Similarly, this field is required to define the center point of a "CIRCLE" shape, or the "origin of bearing" for arcs.
   * Example: /// Example: 1523N05057E
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String coord1() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer coord1AsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer coord1InByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "beginning" radial bearing parameter.
   * Example: /// Example: 330
   * Constraints: No constraints specified.
   */
  public double bearing0() { int o = __offset(22); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * A bearing measured from true North, in angular degrees. If cmShape is set to "POLYARC" or "RADARC," this field is required and is mapped to the "ending" radial bearing parameter.
   * Example: /// Example: 160
   * Constraints: No constraints specified.
   */
  public double bearing1() { int o = __offset(24); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "inner" radial magnitude arc limit. If provided, the field radMagUnit is required.
   * Example: /// Example: 30.04
   * Constraints: No constraints specified.
   */
  public double radMag0() { int o = __offset(26); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * A distance that represents a radial magnitude. If cmShape is set to "CIRCLE" or "POLYARC," one of either fields radMag0 or radMag1 is required. If cmShape is set to "RADARC," this field is required and maps to the "outer" radial magnitude arc limit. If provided, the field radMagUnit is required.
   * Example: /// Example: 50.12
   * Constraints: No constraints specified.
   */
  public double radMag1() { int o = __offset(28); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Specifies the unit of length in which radial magnitudes are given. Use M for meters, KM for kilometers, or NM for nautical miles.
   * Example: /// Example: NM
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String radMagUnit() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer radMagUnitAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer radMagUnitInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * A set of geospatial coordinates specified in DMS (Degrees, Minutes, Seconds) format which determine the vertices of a one or two dimensional geospatial shape. When shape is set to "POLYARC" or "POLYGON," this field is required as applied in the construction of the area boundary. If cmShape is set to "COORIDOR" or "GEOLINE," this field is required and can be interpreted as an ordered set of points along a path in space.
   * Example: /// Example: ['203632N0594256E', '155000N0594815E', '155000N0591343E']
   * Constraints: No constraints specified.
   */
  public String polyCoord(int j) { int o = __offset(32); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int polyCoordLength() { int o = __offset(32); return o != 0 ? __vector_len(o) : 0; }
  public StringVector polyCoordVector() { return polyCoordVector(new StringVector()); }
  public StringVector polyCoordVector(StringVector obj) { int o = __offset(32); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Index of a segment in an airtrack, which is defined by an ordered set of points.
   * Example: /// Example: 99
   * Constraints: No constraints specified.
   */
  public int trackLeg() { int o = __offset(34); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the LEFT half-plane realtive to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the left of the track segment line. If provided, the field widthUnit is required.
   * Example: /// Example: 5.2
   * Constraints: No constraints specified.
   */
  public double widthLeft() { int o = __offset(36); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Given an ordered pair of spatial coordinates (p0, p1), defines a distance extending into the RIGHT half-plane relative to the direction of the vector that maps p0 to p1. If cmShape is set to "1TRACK", this field is required to define the width of the airspace track as measured from the right of the track segment line. If provided, the field widthUnit is required.
   * Example: /// Example: 10.4
   * Constraints: No constraints specified.
   */
  public double widthRight() { int o = __offset(38); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Used to describe the "side to side" distance of a target, object or area. If cmShape is set to "CORRIDOR" or "AORBIT", this field is required and is mapped to the width parameter. If provided, the field widthUnit is required.
   * Example: /// Example: 15.6
   * Constraints: No constraints specified.
   */
  public double width() { int o = __offset(40); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Specifies the unit of length for which widths are given. Use M for meters, KM for kilometers, or NM for nautical miles.
   * Example: /// Example: KM
   * Constraints: Minimum length = 0, Maximum length = 8
   */
  public String widthUnit() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer widthUnitAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer widthUnitInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * An array of at least two alphanumeric symbols used to serially identify the corridor waypoints. If cmShape is set to "CORRIDOR," one of either corrWayPoints or polyCoord is required to specify the centerline of the corridor path.
   * Example: /// Example: ['POB', 'RDU', 'IAD']
   * Constraints: No constraints specified.
   */
  public String corrWayPoints(int j) { int o = __offset(44); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int corrWayPointsLength() { int o = __offset(44); return o != 0 ? __vector_len(o) : 0; }
  public StringVector corrWayPointsVector() { return corrWayPointsVector(new StringVector()); }
  public StringVector corrWayPointsVector(StringVector obj) { int o = __offset(44); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Orbit alignment look-up code. Can be C=Center, L=Left, R=Right.
   * Example: /// Example: C
   * Constraints: Minimum length = 0, Maximum length = 1
   */
  public String orbitAlignment() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer orbitAlignmentAsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer orbitAlignmentInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * Description of the airspace vertical dimension.
   * Example: /// Example: BRRA:GL-100AGL
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String effVdim() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer effVdimAsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer effVdimInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * The timePeriod set describes the effective datetime for a given airspace control means.
   * Example: /// Example: No example provided.
   * Constraints: No constraints specified.
   */
  public String airspaceTimePeriod(int j) { int o = __offset(50); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int airspaceTimePeriodLength() { int o = __offset(50); return o != 0 ? __vector_len(o) : 0; }
  public StringVector airspaceTimePeriodVector() { return airspaceTimePeriodVector(new StringVector()); }
  public StringVector airspaceTimePeriodVector(StringVector obj) { int o = __offset(50); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The controlPoint set describes any reference/controlling/rendevous point for a given airspace control means.
   * Example: /// Example: No example provided.
   * Constraints: No constraints specified.
   */
  public String airspaceControlPoint(int j) { int o = __offset(52); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int airspaceControlPointLength() { int o = __offset(52); return o != 0 ? __vector_len(o) : 0; }
  public StringVector airspaceControlPointVector() { return airspaceControlPointVector(new StringVector()); }
  public StringVector airspaceControlPointVector(StringVector obj) { int o = __offset(52); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The commander responsible within a specified geographical area for the airspace control operation assigned to him.
   * Example: /// Example: RHEIN MAIN CP
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String ctrlAuth() { int o = __offset(54); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer ctrlAuthAsByteBuffer() { return __vector_as_bytebuffer(54, 1); }
  public ByteBuffer ctrlAuthInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 54, 1); }
  /**
   * The frequency for the airspace control authority. Can specify HZ, KHZ, MHZ, GHZ or a DESIG frequency designator code.
   * Example: /// Example: ['125.25MHZ']
   * Constraints: No constraints specified.
   */
  public String ctrlAuthFreqs(int j) { int o = __offset(56); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int ctrlAuthFreqsLength() { int o = __offset(56); return o != 0 ? __vector_len(o) : 0; }
  public StringVector ctrlAuthFreqsVector() { return ctrlAuthFreqsVector(new StringVector()); }
  public StringVector ctrlAuthFreqsVector(StringVector obj) { int o = __offset(56); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Used to provide transit intstructions for the airspace control means.
   * Example: /// Example: SITUATION
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String genTextInd() { int o = __offset(58); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer genTextIndAsByteBuffer() { return __vector_as_bytebuffer(58, 1); }
  public ByteBuffer genTextIndInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 58, 1); }
  /**
   * General informat detailing the transit instruction for the airspace control means.
   * Example: /// Example: 1. CAPACITY: MDM TK, 50 VEHICLE CONVOY. 2. CHOKE POINTS: EXIT 5
   * Constraints: Minimum length = 0, Maximum length = 128
   */
  public String freeText() { int o = __offset(60); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer freeTextAsByteBuffer() { return __vector_as_bytebuffer(60, 1); }
  public ByteBuffer freeTextInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 60, 1); }

  public static int createAirspaceControlMeans_Abridged(FlatBufferBuilder builder,
      int cmTypeOffset,
      int cmIdOffset,
      byte cmShape,
      int usageOffset,
      int link16IdOffset,
      int transAltitudeOffset,
      int geoDatumAltOffset,
      int coord0Offset,
      int coord1Offset,
      double bearing0,
      double bearing1,
      double radMag0,
      double radMag1,
      int radMagUnitOffset,
      int polyCoordOffset,
      int trackLeg,
      double widthLeft,
      double widthRight,
      double width,
      int widthUnitOffset,
      int corrWayPointsOffset,
      int orbitAlignmentOffset,
      int effVdimOffset,
      int airspaceTimePeriodOffset,
      int airspaceControlPointOffset,
      int ctrlAuthOffset,
      int ctrlAuthFreqsOffset,
      int genTextIndOffset,
      int freeTextOffset) {
    builder.startTable(29);
    AirspaceControlMeans_Abridged.addWidth(builder, width);
    AirspaceControlMeans_Abridged.addWidthRight(builder, widthRight);
    AirspaceControlMeans_Abridged.addWidthLeft(builder, widthLeft);
    AirspaceControlMeans_Abridged.addRadMag1(builder, radMag1);
    AirspaceControlMeans_Abridged.addRadMag0(builder, radMag0);
    AirspaceControlMeans_Abridged.addBearing1(builder, bearing1);
    AirspaceControlMeans_Abridged.addBearing0(builder, bearing0);
    AirspaceControlMeans_Abridged.addFreeText(builder, freeTextOffset);
    AirspaceControlMeans_Abridged.addGenTextInd(builder, genTextIndOffset);
    AirspaceControlMeans_Abridged.addCtrlAuthFreqs(builder, ctrlAuthFreqsOffset);
    AirspaceControlMeans_Abridged.addCtrlAuth(builder, ctrlAuthOffset);
    AirspaceControlMeans_Abridged.addAirspaceControlPoint(builder, airspaceControlPointOffset);
    AirspaceControlMeans_Abridged.addAirspaceTimePeriod(builder, airspaceTimePeriodOffset);
    AirspaceControlMeans_Abridged.addEffVdim(builder, effVdimOffset);
    AirspaceControlMeans_Abridged.addOrbitAlignment(builder, orbitAlignmentOffset);
    AirspaceControlMeans_Abridged.addCorrWayPoints(builder, corrWayPointsOffset);
    AirspaceControlMeans_Abridged.addWidthUnit(builder, widthUnitOffset);
    AirspaceControlMeans_Abridged.addTrackLeg(builder, trackLeg);
    AirspaceControlMeans_Abridged.addPolyCoord(builder, polyCoordOffset);
    AirspaceControlMeans_Abridged.addRadMagUnit(builder, radMagUnitOffset);
    AirspaceControlMeans_Abridged.addCoord1(builder, coord1Offset);
    AirspaceControlMeans_Abridged.addCoord0(builder, coord0Offset);
    AirspaceControlMeans_Abridged.addGeoDatumAlt(builder, geoDatumAltOffset);
    AirspaceControlMeans_Abridged.addTransAltitude(builder, transAltitudeOffset);
    AirspaceControlMeans_Abridged.addLink16Id(builder, link16IdOffset);
    AirspaceControlMeans_Abridged.addUsage(builder, usageOffset);
    AirspaceControlMeans_Abridged.addCmId(builder, cmIdOffset);
    AirspaceControlMeans_Abridged.addCmType(builder, cmTypeOffset);
    AirspaceControlMeans_Abridged.addCmShape(builder, cmShape);
    return AirspaceControlMeans_Abridged.endAirspaceControlMeans_Abridged(builder);
  }

  public static void startAirspaceControlMeans_Abridged(FlatBufferBuilder builder) { builder.startTable(29); }
  public static void addCmType(FlatBufferBuilder builder, int cmTypeOffset) { builder.addOffset(0, cmTypeOffset, 0); }
  public static void addCmId(FlatBufferBuilder builder, int cmIdOffset) { builder.addOffset(1, cmIdOffset, 0); }
  public static void addCmShape(FlatBufferBuilder builder, byte cmShape) { builder.addByte(2, cmShape, 0); }
  public static void addUsage(FlatBufferBuilder builder, int usageOffset) { builder.addOffset(3, usageOffset, 0); }
  public static void addLink16Id(FlatBufferBuilder builder, int link16IdOffset) { builder.addOffset(4, link16IdOffset, 0); }
  public static void addTransAltitude(FlatBufferBuilder builder, int transAltitudeOffset) { builder.addOffset(5, transAltitudeOffset, 0); }
  public static void addGeoDatumAlt(FlatBufferBuilder builder, int geoDatumAltOffset) { builder.addOffset(6, geoDatumAltOffset, 0); }
  public static void addCoord0(FlatBufferBuilder builder, int coord0Offset) { builder.addOffset(7, coord0Offset, 0); }
  public static void addCoord1(FlatBufferBuilder builder, int coord1Offset) { builder.addOffset(8, coord1Offset, 0); }
  public static void addBearing0(FlatBufferBuilder builder, double bearing0) { builder.addDouble(9, bearing0, 0.0); }
  public static void addBearing1(FlatBufferBuilder builder, double bearing1) { builder.addDouble(10, bearing1, 0.0); }
  public static void addRadMag0(FlatBufferBuilder builder, double radMag0) { builder.addDouble(11, radMag0, 0.0); }
  public static void addRadMag1(FlatBufferBuilder builder, double radMag1) { builder.addDouble(12, radMag1, 0.0); }
  public static void addRadMagUnit(FlatBufferBuilder builder, int radMagUnitOffset) { builder.addOffset(13, radMagUnitOffset, 0); }
  public static void addPolyCoord(FlatBufferBuilder builder, int polyCoordOffset) { builder.addOffset(14, polyCoordOffset, 0); }
  public static int createPolyCoordVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startPolyCoordVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addTrackLeg(FlatBufferBuilder builder, int trackLeg) { builder.addInt(15, trackLeg, 0); }
  public static void addWidthLeft(FlatBufferBuilder builder, double widthLeft) { builder.addDouble(16, widthLeft, 0.0); }
  public static void addWidthRight(FlatBufferBuilder builder, double widthRight) { builder.addDouble(17, widthRight, 0.0); }
  public static void addWidth(FlatBufferBuilder builder, double width) { builder.addDouble(18, width, 0.0); }
  public static void addWidthUnit(FlatBufferBuilder builder, int widthUnitOffset) { builder.addOffset(19, widthUnitOffset, 0); }
  public static void addCorrWayPoints(FlatBufferBuilder builder, int corrWayPointsOffset) { builder.addOffset(20, corrWayPointsOffset, 0); }
  public static int createCorrWayPointsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startCorrWayPointsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addOrbitAlignment(FlatBufferBuilder builder, int orbitAlignmentOffset) { builder.addOffset(21, orbitAlignmentOffset, 0); }
  public static void addEffVdim(FlatBufferBuilder builder, int effVdimOffset) { builder.addOffset(22, effVdimOffset, 0); }
  public static void addAirspaceTimePeriod(FlatBufferBuilder builder, int airspaceTimePeriodOffset) { builder.addOffset(23, airspaceTimePeriodOffset, 0); }
  public static int createAirspaceTimePeriodVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAirspaceTimePeriodVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addAirspaceControlPoint(FlatBufferBuilder builder, int airspaceControlPointOffset) { builder.addOffset(24, airspaceControlPointOffset, 0); }
  public static int createAirspaceControlPointVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAirspaceControlPointVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addCtrlAuth(FlatBufferBuilder builder, int ctrlAuthOffset) { builder.addOffset(25, ctrlAuthOffset, 0); }
  public static void addCtrlAuthFreqs(FlatBufferBuilder builder, int ctrlAuthFreqsOffset) { builder.addOffset(26, ctrlAuthFreqsOffset, 0); }
  public static int createCtrlAuthFreqsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startCtrlAuthFreqsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addGenTextInd(FlatBufferBuilder builder, int genTextIndOffset) { builder.addOffset(27, genTextIndOffset, 0); }
  public static void addFreeText(FlatBufferBuilder builder, int freeTextOffset) { builder.addOffset(28, freeTextOffset, 0); }
  public static int endAirspaceControlMeans_Abridged(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishAirspaceControlMeans_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "AIRS"); }
  public static void finishSizePrefixedAirspaceControlMeans_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "AIRS"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public AirspaceControlMeans_Abridged get(int j) { return get(new AirspaceControlMeans_Abridged(), j); }
    public AirspaceControlMeans_Abridged get(AirspaceControlMeans_Abridged obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

