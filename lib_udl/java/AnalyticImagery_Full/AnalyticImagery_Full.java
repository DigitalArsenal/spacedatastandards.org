// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// The analytic imagery schema supports data plots and graphics of various types. The records contain general file information, allows for annotations to user-defined areas of interest on the graphics, and supports keyword searching.
 */
@SuppressWarnings("unused")
public final class AnalyticImagery_Full extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static AnalyticImagery_Full getRootAsAnalyticImagery_Full(ByteBuffer _bb) { return getRootAsAnalyticImagery_Full(_bb, new AnalyticImagery_Full()); }
  public static AnalyticImagery_Full getRootAsAnalyticImagery_Full(ByteBuffer _bb, AnalyticImagery_Full obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean AnalyticImagery_FullBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "ANAL"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public AnalyticImagery_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: ANALYTIC-IMAGERY-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * General type of content of this image (CONTOUR, DIAGRAM, HEATMAP, HISTOGRAM, PLOT, SCREENSHOT).
   * Example: /// Example: CONTOUR
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String content() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer contentAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer contentInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * The message time of this image record, in ISO8601 UTC format with millisecond precision.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String msgTime() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgTimeAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer msgTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * The type of image associated with this record (GIF, JPG, PNG, TIF).
   * Example: /// Example: JPG
   * Constraints: Minimum length = 1, Maximum length = 16
   */
  public String imageType() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer imageTypeAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer imageTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The image file name.
   * Example: /// Example: IMAGE-NAME
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String filename() { int o = __offset(14); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer filenameAsByteBuffer() { return __vector_as_bytebuffer(14, 1); }
  public ByteBuffer filenameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 14, 1); }
  /**
   * The image file size, in bytes.  The maximum file size for this service is 40,000,000 bytes (40MB). Files exceeding the maximum size will be rejected.
   * Example: /// Example: 7654321
   * Constraints: No constraints specified.
   */
  public long filesize() { int o = __offset(16); return o != 0 ? bb.getLong(o + bb_pos) : 0L; }
  /**
   * The image width (horizontal), in pixels.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int imgWidth() { int o = __offset(18); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The image height (vertical), in pixels.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int imgHeight() { int o = __offset(20); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Optional field indicating the units that apply to the x-axis of the attached image, when applicable.
   * Example: /// Example: pixels
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String xUnits() { int o = __offset(22); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer xUnitsAsByteBuffer() { return __vector_as_bytebuffer(22, 1); }
  public ByteBuffer xUnitsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 22, 1); }
  /**
   * Optional field indicating the units that apply to the y-axis of the attached image, when applicable.
   * Example: /// Example: pixels
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String yUnits() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer yUnitsAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer yUnitsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * Optional field indicating the units that apply to the z-axis of the attached image, when applicable.
   * Example: /// Example: pixels
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String zUnits() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer zUnitsAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer zUnitsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * User-defined set ID of a sequence of images.  Used to associate related analytic image records.
   * Example: /// Example: IMAGE-IDS
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String imageSetId() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer imageSetIdAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer imageSetIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * The number of images in an image set.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int imageSetLength() { int o = __offset(30); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The sequence number of an image within an image set.  If null, then it is assumed that the order of images in an imageSet is not relevant.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int sequenceId() { int o = __offset(32); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Description of the image content and utility.
   * Example: /// Example: Image description
   * Constraints: Minimum length = 1, Maximum length = 512
   */
  public String description() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer descriptionAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer descriptionInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * The start time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String dataStart() { int o = __offset(36); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer dataStartAsByteBuffer() { return __vector_as_bytebuffer(36, 1); }
  public ByteBuffer dataStartInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 36, 1); }
  /**
   * The stop time, in ISO8601 UTC format with millisecond precision, of the data used in the analysis or composition of the image content, when applicable.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String dataStop() { int o = __offset(38); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer dataStopAsByteBuffer() { return __vector_as_bytebuffer(38, 1); }
  public ByteBuffer dataStopInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 38, 1); }
  /**
   * Rectangular annotation limits, specified in pixels, as an array of arrays of the coordinates [ [UL1x, UL1y], [UR1x, UR1y], [LR1x, LR1y], [LL1x, LL1y] ], indicating the corners of a rectangle beginning with the Upper Left (UL) and moving clockwise. Allows the image provider to highlight one or more rectangular area(s) of interest. The array must contain Nx4 two-element arrays, where N is the number of rectangles of interest.  The associated annotation(s) should be included in the annText array.
   * Example: /// Example: [[1, 1], [1, 2], [1, 3], [1, 4]]
   * Constraints: No constraints specified.
   */
  public String annLims(int j) { int o = __offset(40); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int annLimsLength() { int o = __offset(40); return o != 0 ? __vector_len(o) : 0; }
  public StringVector annLimsVector() { return annLimsVector(new StringVector()); }
  public StringVector annLimsVector(StringVector obj) { int o = __offset(40); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Annotation text, a string array of annotation(s) corresponding to the rectangular areas specified in annLims.  This array contains the annotation text associated with the areas of interest indicated in annLims, in order.  This array should contain one annotation per four values of the area (annLims) array.
   * Example: /// Example: ['rec1', 'rec2']
   * Constraints: No constraints specified.
   */
  public String annText(int j) { int o = __offset(42); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int annTextLength() { int o = __offset(42); return o != 0 ? __vector_len(o) : 0; }
  public StringVector annTextVector() { return annTextVector(new StringVector()); }
  public StringVector annTextVector(StringVector obj) { int o = __offset(42); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array of searchable keywords for this analytic imagery record.
   * Example: /// Example: ['Key1', 'Key2']
   * Constraints: No constraints specified.
   */
  public String keywords(int j) { int o = __offset(44); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int keywordsLength() { int o = __offset(44); return o != 0 ? __vector_len(o) : 0; }
  public StringVector keywordsVector() { return keywordsVector(new StringVector()); }
  public StringVector keywordsVector(StringVector obj) { int o = __offset(44); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Optional geographical region or polygon (lat/lon pairs) of the area surrounding the point of interest as projected on the ground.
   * Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
   * Constraints: No constraints specified.
   */
  public String area() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer areaAsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer areaInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * Geographical region or polygon (lon/lat pairs), as depicted by the Well-Known Text representation of the geometry/geography, of the image as projected on the ground. WKT reference: https://www.opengeospatial.org/standards/wkt-crs. Ignored if included with a POST or PUT request that also specifies a valid 'area' field.
   * Example: /// Example: POLYGON((67.3291113966927 26.156175339112,67.2580009640721 26.091022064271,67.1795862381682 26.6637992964562,67.2501237475598 26.730115808233,67.3291113966927 26.156175339112))
   * Constraints: No constraints specified.
   */
  public String atext() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer atextAsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer atextInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * Geographical region or polygon (lat/lon pairs), as depicted by the GeoJSON representation of the geometry/geography, of the image as projected on the ground. GeoJSON Reference: https://geojson.org/. Ignored if included with a POST or PUT request that also specifies a valid 'area' or 'atext' field.
   * Example: /// Example: {"type":"Polygon","coordinates":[[[67.3291113966927,26.156175339112],[67.2580009640721,26.091022064271],[67.1795862381682,26.6637992964562],[67.2501237475598,26.730115808233],[67.3291113966927,26.156175339112]]]}
   * Constraints: No constraints specified.
   */
  public String agjson() { int o = __offset(50); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer agjsonAsByteBuffer() { return __vector_as_bytebuffer(50, 1); }
  public ByteBuffer agjsonInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 50, 1); }
  /**
   * Type of region as projected on the ground.
   * Example: /// Example: POLYGON
   * Constraints: Minimum length = 0, Maximum length = 128
   */
  public String atype() { int o = __offset(52); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer atypeAsByteBuffer() { return __vector_as_bytebuffer(52, 1); }
  public ByteBuffer atypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 52, 1); }
  /**
   * Number of dimensions of the geometry depicted by region.
   * Example: /// Example: 2
   * Constraints: No constraints specified.
   */
  public int andims() { int o = __offset(54); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Geographical spatial_ref_sys for region.
   * Example: /// Example: 4326
   * Constraints: No constraints specified.
   */
  public int asrid() { int o = __offset(56); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Assessed satellite ID (NORAD RSO object number).  The 'satId' and 'satIdConf' arrays must match in size.
   * Example: /// Example: [12004, 12005]
   * Constraints: No constraints specified.
   */
  public String satId(int j) { int o = __offset(58); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int satIdLength() { int o = __offset(58); return o != 0 ? __vector_len(o) : 0; }
  public StringVector satIdVector() { return satIdVector(new StringVector()); }
  public StringVector satIdVector(StringVector obj) { int o = __offset(58); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Assessed satellite confidence corresponding to an assessment ID.  Values are between 0.0 and 1.0.  The 'satId' and 'satIdConf' arrays must match in size.
   * Example: /// Example: [0.98, 0.22]
   * Constraints: No constraints specified.
   */
  public String satIdConf(int j) { int o = __offset(60); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int satIdConfLength() { int o = __offset(60); return o != 0 ? __vector_len(o) : 0; }
  public StringVector satIdConfVector() { return satIdConfVector(new StringVector()); }
  public StringVector satIdConfVector(StringVector obj) { int o = __offset(60); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array of UDL record types (AIS, CONJUNCTION, DOA, ELSET, EO, ESID, GROUNDIMAGE, POI, MANEUVER, MTI, NOTIFICATION, RADAR, RF, SIGACT, SKYIMAGE, SV, TRACK) that are related to this image. See the associated 'srcIds' array for the record UUIDs, positionally corresponding to the record types in this array. The 'srcTyps' and 'srcIds' arrays must match in size.
   * Example: /// Example: ['MTI', 'POI']
   * Constraints: No constraints specified.
   */
  public String srcTyps(int j) { int o = __offset(62); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int srcTypsLength() { int o = __offset(62); return o != 0 ? __vector_len(o) : 0; }
  public StringVector srcTypsVector() { return srcTypsVector(new StringVector()); }
  public StringVector srcTypsVector(StringVector obj) { int o = __offset(62); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array of UUIDs of the UDL data records that are related to this image. See the associated 'srcTyps' array for the specific types of data, positionally corresponding to the UUIDs in this array. The 'srcTyps' and 'srcIds' arrays must match in size. See the corresponding srcTyps array element for the data type of the UUID and use the appropriate API operation to retrieve that object.
   * Example: /// Example: ['DOA_ID', 'DWELL_ID']
   * Constraints: No constraints specified.
   */
  public String srcIds(int j) { int o = __offset(64); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int srcIdsLength() { int o = __offset(64); return o != 0 ? __vector_len(o) : 0; }
  public StringVector srcIdsVector() { return srcIdsVector(new StringVector()); }
  public StringVector srcIdsVector(StringVector obj) { int o = __offset(64); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Optional array of provider/source specific tags for this data, where each element is no longer than 32 characters, used for implementing data owner conditional access controls to restrict access to the data. Should be left null by data providers unless conditional access controls are coordinated with the UDL team.
   * Example: /// Example: ['TAG1', 'TAG2']
   * Constraints: No constraints specified.
   */
  public String tags(int j) { int o = __offset(66); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int tagsLength() { int o = __offset(66); return o != 0 ? __vector_len(o) : 0; }
  public StringVector tagsVector() { return tagsVector(new StringVector()); }
  public StringVector tagsVector(StringVector obj) { int o = __offset(66); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * MD5 checksum value of the file. The ingest/create operation will automatically generate the value.
   * Example: /// Example: 123
   * Constraints: Minimum length = 0, Maximum length = 256
   */
  public String checksumValue() { int o = __offset(68); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer checksumValueAsByteBuffer() { return __vector_as_bytebuffer(68, 1); }
  public ByteBuffer checksumValueInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 68, 1); }
  /**
   * Optional identifier to track a commercial or marketplace transaction executed to produce this data.
   * Example: /// Example: a7bdef1f-5a4f-4716-bee4-7a1e0ec7d35a
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String transactionId() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer transactionIdAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer transactionIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(72); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(72, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 72, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(74); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(74, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 74, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String source() { int o = __offset(76); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(76, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 76, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: ORIGIN
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(78); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(78, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 78, 1); }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: TST1
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(80); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(80, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 80, 1); }
  /**
   * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
   * Example: /// Example: AXE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String sourceDl() { int o = __offset(82); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceDlAsByteBuffer() { return __vector_as_bytebuffer(82, 1); }
  public ByteBuffer sourceDlInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 82, 1); }
  /**
   * Indicator of whether the data is REAL, TEST, SIMULATED, or EXERCISE data.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(84); return o != 0 ? bb.get(o + bb_pos) : 0; }

  public static int createAnalyticImagery_Full(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int contentOffset,
      int msgTimeOffset,
      int imageTypeOffset,
      int filenameOffset,
      long filesize,
      int imgWidth,
      int imgHeight,
      int xUnitsOffset,
      int yUnitsOffset,
      int zUnitsOffset,
      int imageSetIdOffset,
      int imageSetLength,
      int sequenceId,
      int descriptionOffset,
      int dataStartOffset,
      int dataStopOffset,
      int annLimsOffset,
      int annTextOffset,
      int keywordsOffset,
      int areaOffset,
      int atextOffset,
      int agjsonOffset,
      int atypeOffset,
      int andims,
      int asrid,
      int satIdOffset,
      int satIdConfOffset,
      int srcTypsOffset,
      int srcIdsOffset,
      int tagsOffset,
      int checksumValueOffset,
      int transactionIdOffset,
      int createdAtOffset,
      int createdByOffset,
      int sourceOffset,
      int originOffset,
      int origNetworkOffset,
      int sourceDlOffset,
      byte dataMode) {
    builder.startTable(41);
    AnalyticImagery_Full.addFilesize(builder, filesize);
    AnalyticImagery_Full.addSourceDl(builder, sourceDlOffset);
    AnalyticImagery_Full.addOrigNetwork(builder, origNetworkOffset);
    AnalyticImagery_Full.addOrigin(builder, originOffset);
    AnalyticImagery_Full.addSource(builder, sourceOffset);
    AnalyticImagery_Full.addCreatedBy(builder, createdByOffset);
    AnalyticImagery_Full.addCreatedAt(builder, createdAtOffset);
    AnalyticImagery_Full.addTransactionId(builder, transactionIdOffset);
    AnalyticImagery_Full.addChecksumValue(builder, checksumValueOffset);
    AnalyticImagery_Full.addTags(builder, tagsOffset);
    AnalyticImagery_Full.addSrcIds(builder, srcIdsOffset);
    AnalyticImagery_Full.addSrcTyps(builder, srcTypsOffset);
    AnalyticImagery_Full.addSatIdConf(builder, satIdConfOffset);
    AnalyticImagery_Full.addSatId(builder, satIdOffset);
    AnalyticImagery_Full.addAsrid(builder, asrid);
    AnalyticImagery_Full.addAndims(builder, andims);
    AnalyticImagery_Full.addAtype(builder, atypeOffset);
    AnalyticImagery_Full.addAgjson(builder, agjsonOffset);
    AnalyticImagery_Full.addAtext(builder, atextOffset);
    AnalyticImagery_Full.addArea(builder, areaOffset);
    AnalyticImagery_Full.addKeywords(builder, keywordsOffset);
    AnalyticImagery_Full.addAnnText(builder, annTextOffset);
    AnalyticImagery_Full.addAnnLims(builder, annLimsOffset);
    AnalyticImagery_Full.addDataStop(builder, dataStopOffset);
    AnalyticImagery_Full.addDataStart(builder, dataStartOffset);
    AnalyticImagery_Full.addDescription(builder, descriptionOffset);
    AnalyticImagery_Full.addSequenceId(builder, sequenceId);
    AnalyticImagery_Full.addImageSetLength(builder, imageSetLength);
    AnalyticImagery_Full.addImageSetId(builder, imageSetIdOffset);
    AnalyticImagery_Full.addZUnits(builder, zUnitsOffset);
    AnalyticImagery_Full.addYUnits(builder, yUnitsOffset);
    AnalyticImagery_Full.addXUnits(builder, xUnitsOffset);
    AnalyticImagery_Full.addImgHeight(builder, imgHeight);
    AnalyticImagery_Full.addImgWidth(builder, imgWidth);
    AnalyticImagery_Full.addFilename(builder, filenameOffset);
    AnalyticImagery_Full.addImageType(builder, imageTypeOffset);
    AnalyticImagery_Full.addMsgTime(builder, msgTimeOffset);
    AnalyticImagery_Full.addContent(builder, contentOffset);
    AnalyticImagery_Full.addClassificationMarking(builder, classificationMarkingOffset);
    AnalyticImagery_Full.addId(builder, idOffset);
    AnalyticImagery_Full.addDataMode(builder, dataMode);
    return AnalyticImagery_Full.endAnalyticImagery_Full(builder);
  }

  public static void startAnalyticImagery_Full(FlatBufferBuilder builder) { builder.startTable(41); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addContent(FlatBufferBuilder builder, int contentOffset) { builder.addOffset(2, contentOffset, 0); }
  public static void addMsgTime(FlatBufferBuilder builder, int msgTimeOffset) { builder.addOffset(3, msgTimeOffset, 0); }
  public static void addImageType(FlatBufferBuilder builder, int imageTypeOffset) { builder.addOffset(4, imageTypeOffset, 0); }
  public static void addFilename(FlatBufferBuilder builder, int filenameOffset) { builder.addOffset(5, filenameOffset, 0); }
  public static void addFilesize(FlatBufferBuilder builder, long filesize) { builder.addLong(6, filesize, 0L); }
  public static void addImgWidth(FlatBufferBuilder builder, int imgWidth) { builder.addInt(7, imgWidth, 0); }
  public static void addImgHeight(FlatBufferBuilder builder, int imgHeight) { builder.addInt(8, imgHeight, 0); }
  public static void addXUnits(FlatBufferBuilder builder, int xUnitsOffset) { builder.addOffset(9, xUnitsOffset, 0); }
  public static void addYUnits(FlatBufferBuilder builder, int yUnitsOffset) { builder.addOffset(10, yUnitsOffset, 0); }
  public static void addZUnits(FlatBufferBuilder builder, int zUnitsOffset) { builder.addOffset(11, zUnitsOffset, 0); }
  public static void addImageSetId(FlatBufferBuilder builder, int imageSetIdOffset) { builder.addOffset(12, imageSetIdOffset, 0); }
  public static void addImageSetLength(FlatBufferBuilder builder, int imageSetLength) { builder.addInt(13, imageSetLength, 0); }
  public static void addSequenceId(FlatBufferBuilder builder, int sequenceId) { builder.addInt(14, sequenceId, 0); }
  public static void addDescription(FlatBufferBuilder builder, int descriptionOffset) { builder.addOffset(15, descriptionOffset, 0); }
  public static void addDataStart(FlatBufferBuilder builder, int dataStartOffset) { builder.addOffset(16, dataStartOffset, 0); }
  public static void addDataStop(FlatBufferBuilder builder, int dataStopOffset) { builder.addOffset(17, dataStopOffset, 0); }
  public static void addAnnLims(FlatBufferBuilder builder, int annLimsOffset) { builder.addOffset(18, annLimsOffset, 0); }
  public static int createAnnLimsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAnnLimsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addAnnText(FlatBufferBuilder builder, int annTextOffset) { builder.addOffset(19, annTextOffset, 0); }
  public static int createAnnTextVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAnnTextVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addKeywords(FlatBufferBuilder builder, int keywordsOffset) { builder.addOffset(20, keywordsOffset, 0); }
  public static int createKeywordsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startKeywordsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addArea(FlatBufferBuilder builder, int areaOffset) { builder.addOffset(21, areaOffset, 0); }
  public static void addAtext(FlatBufferBuilder builder, int atextOffset) { builder.addOffset(22, atextOffset, 0); }
  public static void addAgjson(FlatBufferBuilder builder, int agjsonOffset) { builder.addOffset(23, agjsonOffset, 0); }
  public static void addAtype(FlatBufferBuilder builder, int atypeOffset) { builder.addOffset(24, atypeOffset, 0); }
  public static void addAndims(FlatBufferBuilder builder, int andims) { builder.addInt(25, andims, 0); }
  public static void addAsrid(FlatBufferBuilder builder, int asrid) { builder.addInt(26, asrid, 0); }
  public static void addSatId(FlatBufferBuilder builder, int satIdOffset) { builder.addOffset(27, satIdOffset, 0); }
  public static int createSatIdVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSatIdVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSatIdConf(FlatBufferBuilder builder, int satIdConfOffset) { builder.addOffset(28, satIdConfOffset, 0); }
  public static int createSatIdConfVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSatIdConfVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSrcTyps(FlatBufferBuilder builder, int srcTypsOffset) { builder.addOffset(29, srcTypsOffset, 0); }
  public static int createSrcTypsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSrcTypsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSrcIds(FlatBufferBuilder builder, int srcIdsOffset) { builder.addOffset(30, srcIdsOffset, 0); }
  public static int createSrcIdsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSrcIdsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addTags(FlatBufferBuilder builder, int tagsOffset) { builder.addOffset(31, tagsOffset, 0); }
  public static int createTagsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startTagsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addChecksumValue(FlatBufferBuilder builder, int checksumValueOffset) { builder.addOffset(32, checksumValueOffset, 0); }
  public static void addTransactionId(FlatBufferBuilder builder, int transactionIdOffset) { builder.addOffset(33, transactionIdOffset, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(34, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(35, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(36, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(37, originOffset, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(38, origNetworkOffset, 0); }
  public static void addSourceDl(FlatBufferBuilder builder, int sourceDlOffset) { builder.addOffset(39, sourceDlOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(40, dataMode, 0); }
  public static int endAnalyticImagery_Full(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishAnalyticImagery_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "ANAL"); }
  public static void finishSizePrefixedAnalyticImagery_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "ANAL"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public AnalyticImagery_Full get(int j) { return get(new AnalyticImagery_Full(), j); }
    public AnalyticImagery_Full get(AnalyticImagery_Full obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

