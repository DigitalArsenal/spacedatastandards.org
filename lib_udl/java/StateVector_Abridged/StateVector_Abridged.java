// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// This service provides operations for querying and manipulation of state vectors for OnOrbit objects. State vectors are cartesian vectors of position (r) and velocity (v) that, together with their time (epoch) (t), uniquely determine the trajectory of the orbiting body in space. J2000 is the preferred coordinate frame for all state vector positions/velocities in UDL, but in some cases data may be in another frame depending on the provider and/or datatype. Please see the 'Discover' tab in the storefront to confirm coordinate frames by data provider.
 */
@SuppressWarnings("unused")
public final class StateVector_Abridged extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static StateVector_Abridged getRootAsStateVector_Abridged(ByteBuffer _bb) { return getRootAsStateVector_Abridged(_bb, new StateVector_Abridged()); }
  public static StateVector_Abridged getRootAsStateVector_Abridged(ByteBuffer _bb, StateVector_Abridged obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean StateVector_AbridgedBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "STAT"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public StateVector_Abridged __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system.
   * Example: /// Example: STATEVECTOR-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String idStateVector() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idStateVectorAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idStateVectorInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Time of validity for state vector in ISO 8601 UTC datetime format, with microsecond precision.
   * Example: /// Example: 2018-01-01T16:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String epoch() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer epochAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer epochInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * The pedigree of state vector, or methods used for its generation to include state update/orbit determination, propagation from another state, or a state from a calibration satellite (e.g. ORBIT_UPDATE, PROPAGATION, CALIBRATION, CONJUNCTION, FLIGHT_PLAN).
   * Example: /// Example: CONJUNCTION
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String pedigree() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer pedigreeAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer pedigreeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * Unique identifier of the satellite on-orbit object, if correlated. For the public catalog, the idOnOrbit is typically the satellite number as a string, but may be a UUID for analyst or other unknown or untracked satellites.
   * Example: /// Example: ONORBIT-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idOnOrbit() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idOnOrbitAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer idOnOrbitInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * Satellite/Catalog number of the target OnOrbit object.
   * Example: /// Example: 12
   * Constraints: No constraints specified.
   */
  public int satNo() { int o = __offset(14); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Optional identifier provided by state vector source to indicate the target onorbit object of this state vector. This may be an internal identifier and not necessarily map to a valid satellite number.
   * Example: /// Example: ORIGOBJECT-ID
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origObjectId() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origObjectIdAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer origObjectIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Unique identifier of the OD solution record that produced this state vector. This ID can be used to obtain additional information on an OrbitDetermination object using the 'get by ID' operation (e.g. /udl/orbitdetermination/{id}). For example, the OrbitDetermination with idOrbitDetermination = abc would be queries as /udl/orbitdetermination/abc.
   * Example: /// Example: 026dd511-8ba5-47d3-9909-836149f87686
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String idOrbitDetermination() { int o = __offset(18); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idOrbitDeterminationAsByteBuffer() { return __vector_as_bytebuffer(18, 1); }
  public ByteBuffer idOrbitDeterminationInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 18, 1); }
  /**
   * Boolean indicating this state vector was unable to be correlated to a known object. This flag should only be set to true by data providers after an attempt to correlate to an OnOrbit object was made and failed. If unable to correlate, the 'origObjectId' field may be populated with an internal data provider specific identifier.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean uct() { int o = __offset(20); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Cartesian X position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: -1118.577381
   * Constraints: No constraints specified.
   */
  public double xpos() { int o = __offset(22); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 3026.231084
   * Constraints: No constraints specified.
   */
  public double ypos() { int o = __offset(24); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z position of the target, in kilometers, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 6167.831808
   * Constraints: No constraints specified.
   */
  public double zpos() { int o = __offset(26); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian X velocity of target, in kilometers/second, in the specified referenceFrame. If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: -4.25242784
   * Constraints: No constraints specified.
   */
  public double xvel() { int o = __offset(28); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: 5.291107434
   * Constraints: No constraints specified.
   */
  public double yvel() { int o = __offset(30); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z velocity of target, in kilometers/second, in the specified referenceFrame.  If referenceFrame is null then J2K should be assumed.
   * Example: /// Example: -3.356493869
   * Constraints: No constraints specified.
   */
  public double zvel() { int o = __offset(32); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The reference frame of the cartesian orbital states. If the referenceFrame is null it is assumed to be J2000.
   * Example: /// Example: J2000
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public byte referenceFrame() { int o = __offset(34); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Covariance matrix, in kilometer and second based units, in the specified covReferenceFrame.  If the covReferenceFrame is null it is assumed to be J2000.
   * The array values (1-21) represent the lower triangular half of the position-velocity covariance matrix. The size of the covariance matrix is dynamic, depending on whether the covariance for position only or position & velocity. The covariance elements are position dependent within the array with values ordered as follows:
   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR&nbsp;&nbsp;
   * x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1
   * y&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3
   * z&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;6
   * x'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;10
   * y'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11&nbsp;&nbsp;12&nbsp;&nbsp;13&nbsp;&nbsp;14&nbsp;&nbsp;15
   * z'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;&nbsp;17&nbsp;&nbsp;18&nbsp;&nbsp;19&nbsp;&nbsp;20&nbsp;&nbsp;&nbsp;21&nbsp;
   * The cov array should contain only the lower left triangle values from top left down to bottom right, in order.
   * If additional covariance terms are included for DRAG, SRP, and/or THRUST, the matrix can be extended with the following order of elements:
   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;z&nbsp;&nbsp;&nbsp;&nbsp;x'&nbsp;&nbsp;&nbsp;&nbsp;y'&nbsp;&nbsp;&nbsp;&nbsp;z'&nbsp;&nbsp;&nbsp;&nbsp;DRG&nbsp;&nbsp;&nbsp;&nbsp;SRP&nbsp;&nbsp;&nbsp;&nbsp;THR
   * DRG&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;23&nbsp;&nbsp;24&nbsp;&nbsp;25&nbsp;&nbsp;26&nbsp;&nbsp;&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;28&nbsp;&nbsp;
   * SRP&nbsp;&nbsp;&nbsp;29&nbsp;&nbsp;30&nbsp;&nbsp;31&nbsp;&nbsp;32&nbsp;&nbsp;33&nbsp;&nbsp;&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;36&nbsp;&nbsp;
   * THR&nbsp;&nbsp;&nbsp;37&nbsp;&nbsp;38&nbsp;&nbsp;39&nbsp;&nbsp;40&nbsp;&nbsp;41&nbsp;&nbsp;&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;
   * Example: /// Example: [1.1, 2.2]
   * Constraints: No constraints specified.
   */
  public String cov(int j) { int o = __offset(36); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int covLength() { int o = __offset(36); return o != 0 ? __vector_len(o) : 0; }
  public StringVector covVector() { return covVector(new StringVector()); }
  public StringVector covVector(StringVector obj) { int o = __offset(36); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The reference frame of the covariance matrix elements. If the covReferenceFrame is null it is assumed to be J2000.
   * Example: /// Example: J2000
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public byte covReferenceFrame() { int o = __offset(38); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * The method used to generate the covariance during the orbit determination (OD) that produced the state vector, or whether an arbitrary, non-calculated default value was used (CALCULATED, DEFAULT).
   * Example: /// Example: CALCULATED
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String covMethod() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer covMethodAsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer covMethodInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * The covariance matrix values represent the lower triangular half of the covariance matrix in terms of equinoctial elements.&nbsp; The size of the covariance matrix is dynamic.&nbsp; The values are outputted in order across each row, i.e.:
   * 1&nbsp;&nbsp; 2&nbsp;&nbsp; 3&nbsp;&nbsp; 4&nbsp;&nbsp; 5
   * 6&nbsp;&nbsp; 7&nbsp;&nbsp; 8&nbsp;&nbsp; 9&nbsp; 10
   * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
   * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
   * 51&nbsp; 52&nbsp; 53&nbsp; 54&nbsp; 55
   * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
   * :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :&nbsp;&nbsp; :
   * The ordering of values is as follows:
   * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Af&nbsp;&nbsp; Ag&nbsp;&nbsp; L&nbsp;&nbsp;&nbsp; N&nbsp;&nbsp; Chi&nbsp; Psi&nbsp;&nbsp; B&nbsp;&nbsp; BDOT AGOM&nbsp; T&nbsp;&nbsp; C1&nbsp;&nbsp; C2&nbsp; ...
   * Af&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
   * Ag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3
   * L&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp; 6
   * N&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp; 10
   * Chi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp; 12&nbsp;&nbsp; 13&nbsp;&nbsp; 14&nbsp;&nbsp; 15
   * Psi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp; 17&nbsp;&nbsp; 18&nbsp;&nbsp; 19&nbsp;&nbsp; 20&nbsp;&nbsp; 21
   * B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp; 23&nbsp;&nbsp; 24 &nbsp;&nbsp;25&nbsp;&nbsp; 26&nbsp;&nbsp; 27&nbsp;&nbsp; 28
   * BDOT&nbsp;&nbsp; 29&nbsp;&nbsp; 30&nbsp;&nbsp; 31&nbsp;&nbsp; 32&nbsp;&nbsp; 33&nbsp;&nbsp; 34&nbsp;&nbsp; 35&nbsp;&nbsp; 36
   * AGOM&nbsp; 37&nbsp;&nbsp; 38&nbsp;&nbsp; 39&nbsp;&nbsp; 40&nbsp;&nbsp; 41&nbsp;&nbsp; 42&nbsp;&nbsp; 43&nbsp;&nbsp; 44&nbsp;&nbsp; 45
   * T&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 46&nbsp;&nbsp; 47&nbsp;&nbsp; 48&nbsp;&nbsp; 49&nbsp;&nbsp; 50&nbsp;&nbsp; 51&nbsp;&nbsp; 52&nbsp;&nbsp; 53&nbsp;&nbsp; 54&nbsp;&nbsp; 55
   * C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 56&nbsp;&nbsp; 57&nbsp;&nbsp; 58&nbsp;&nbsp; 59&nbsp;&nbsp; 60&nbsp;&nbsp; 61&nbsp;&nbsp; 62&nbsp;&nbsp; 63&nbsp;&nbsp; 64&nbsp;&nbsp; 65&nbsp;&nbsp; 66
   * C2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67&nbsp;&nbsp; 68&nbsp;&nbsp; 69&nbsp;&nbsp; 70&nbsp;&nbsp; 71&nbsp; &nbsp;72&nbsp;&nbsp; 73&nbsp;&nbsp; 74&nbsp;&nbsp; 75&nbsp;&nbsp; 76&nbsp;&nbsp; 77&nbsp;&nbsp; 78
   * :
   * :
   * where C1, C2, etc, are the "consider parameters" that may be added to the covariance matrix.&nbsp; The covariance matrix will be as large as the last element/model parameter needed.&nbsp; In other words, if the DC solved for all 6 elements plus AGOM, the covariance matrix will be 9x9 (and the rows for B and BDOT will be all zeros).&nbsp; If the covariance matrix is unavailable, the size will be set to 0x0, and no data will follow.&nbsp; The cov field should contain only the lower left triangle values from top left down to bottom right, in order.
   * Example: /// Example: [1.1, 2.2]
   * Constraints: No constraints specified.
   */
  public String eqCov(int j) { int o = __offset(42); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int eqCovLength() { int o = __offset(42); return o != 0 ? __vector_len(o) : 0; }
  public StringVector eqCovVector() { return eqCovVector(new StringVector()); }
  public StringVector eqCovVector(StringVector obj) { int o = __offset(42); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Cartesian X position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -1145.688502
   * Constraints: No constraints specified.
   */
  public double xposAlt1() { int o = __offset(44); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: 3020.729572
   * Constraints: No constraints specified.
   */
  public double yposAlt1() { int o = __offset(46); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z position of the target, in kilometers, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: 6165.55187
   * Constraints: No constraints specified.
   */
  public double zposAlt1() { int o = __offset(48); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian X velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -4.270832252
   * Constraints: No constraints specified.
   */
  public double xvelAlt1() { int o = __offset(50); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: 5.27074276
   * Constraints: No constraints specified.
   */
  public double yvelAlt1() { int o = __offset(52); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z velocity of the target, in kilometers/second, in the specified alt1ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -3.365155181
   * Constraints: No constraints specified.
   */
  public double zvelAlt1() { int o = __offset(54); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The reference frame of the alternate1 (Alt1) cartesian orbital state.
   * Example: /// Example: TEME
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String alt1ReferenceFrame() { int o = __offset(56); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer alt1ReferenceFrameAsByteBuffer() { return __vector_as_bytebuffer(56, 1); }
  public ByteBuffer alt1ReferenceFrameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 56, 1); }
  /**
   * Cartesian X position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -1456.915926
   * Constraints: No constraints specified.
   */
  public double xposAlt2() { int o = __offset(58); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -2883.540406
   * Constraints: No constraints specified.
   */
  public double yposAlt2() { int o = __offset(60); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z position of the target, in kilometers, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: 6165.55187
   * Constraints: No constraints specified.
   */
  public double zposAlt2() { int o = __offset(62); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian X velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -1.219814294
   * Constraints: No constraints specified.
   */
  public double xvelAlt2() { int o = __offset(64); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Y velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -6.602080212
   * Constraints: No constraints specified.
   */
  public double yvelAlt2() { int o = __offset(66); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Cartesian Z velocity of the target, in kilometers/second, in the specified alt2ReferenceFrame. Alternate reference frames are optional and are intended to allow a data source to provide an equivalent vector in a different cartesian frame than the primary vector.
   * Example: /// Example: -3.365155181
   * Constraints: No constraints specified.
   */
  public double zvelAlt2() { int o = __offset(68); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The reference frame of the alternate2 (Alt2) cartesian orbital state.
   * Example: /// Example: EFG/TDR
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String alt2ReferenceFrame() { int o = __offset(70); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer alt2ReferenceFrameAsByteBuffer() { return __vector_as_bytebuffer(70, 1); }
  public ByteBuffer alt2ReferenceFrameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 70, 1); }
  /**
   * One sigma position uncertainty, in kilometers.
   * Example: /// Example: 0.333399744452
   * Constraints: No constraints specified.
   */
  public double posUnc() { int o = __offset(72); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * One sigma velocity uncertainty, in kilometers/second.
   * Example: /// Example: 4e-06
   * Constraints: No constraints specified.
   */
  public double velUnc() { int o = __offset(74); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The mass of the object, in kilograms.
   * Example: /// Example: 164.5
   * Constraints: No constraints specified.
   */
  public double mass() { int o = __offset(76); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The actual area of the object at it's largest cross-section, expressed in meters^2.
   * Example: /// Example: 5.065
   * Constraints: No constraints specified.
   */
  public double area() { int o = __offset(78); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Area-to-mass ratio coefficient for solar radiation pressure.
   * Example: /// Example: 0.0244394
   * Constraints: No constraints specified.
   */
  public double solarRadPressCoeff() { int o = __offset(80); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Area-to-mass ratio coefficient for atmospheric ballistic drag (m2/kg).
   * Example: /// Example: 0.0224391269775
   * Constraints: No constraints specified.
   */
  public double dragCoeff() { int o = __offset(82); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The effective area of the object exposed to atmospheric drag, expressed in meters^2.
   * Example: /// Example: 4.739
   * Constraints: No constraints specified.
   */
  public double dragArea() { int o = __offset(84); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Epoch revolution number.
   * Example: /// Example: 7205
   * Constraints: No constraints specified.
   */
  public int revNo() { int o = __offset(86); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Geopotential model used for this vector (e.g. EGM-96, WGS-84, WGS-72, JGM-2, or GEM-T3), including mm degree zonals, nn degree/order tesserals. E.g. EGM-96 24Z,24T.
   * Example: /// Example: EGM-96
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String geopotentialModel() { int o = __offset(88); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer geopotentialModelAsByteBuffer() { return __vector_as_bytebuffer(88, 1); }
  public ByteBuffer geopotentialModelInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 88, 1); }
  /**
   * The Drag Model used for this vector (e.g. HARRIS-PRIESTER, JAC70, JBH09, MSIS90, NONE, etc.).
   * Example: /// Example: JAC70
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String dragModel() { int o = __offset(90); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer dragModelAsByteBuffer() { return __vector_as_bytebuffer(90, 1); }
  public ByteBuffer dragModelInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 90, 1); }
  /**
   * Boolean indicating use of lunar/solar perturbations for this vector.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean lunarSolar() { int o = __offset(92); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Boolean indicating use of solar radiation pressure perturbations for this vector.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean solarRadPress() { int o = __offset(94); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The effective area of the object exposed to solar radiation pressure, expressed in meters^2.
   * Example: /// Example: 4.311
   * Constraints: No constraints specified.
   */
  public double srpArea() { int o = __offset(96); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Boolean indicating use of solid earth tide perturbations for this vector.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean solidEarthTides() { int o = __offset(98); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Boolean indicating use of in-track thrust perturbations for this vector.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean inTrackThrust() { int o = __offset(100); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * First derivative of drag/ballistic coefficient (m2/kg-s).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double bDot() { int o = __offset(102); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Model parameter value for energy dissipation rate (EDR) (w/kg).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double edr() { int o = __offset(104); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Model parameter value for thrust acceleration (m/s2).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double thrustAccel() { int o = __offset(106); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Model parameter value for center of mass offset (m).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double cmOffset() { int o = __offset(108); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The start of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
   * Example: /// Example: 2022-11-09T11:20:21.247192Z
   * Constraints: No constraints specified.
   */
  public String lastObStart() { int o = __offset(110); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer lastObStartAsByteBuffer() { return __vector_as_bytebuffer(110, 1); }
  public ByteBuffer lastObStartInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 110, 1); }
  /**
   * The end of the time interval containing the time of the last accepted observation, in ISO 8601 UTC format with microsecond precision.  For an exact observation time, the firstObTime and lastObTime are the same.
   * Example: /// Example: 2022-11-09T11:20:21.247192Z
   * Constraints: No constraints specified.
   */
  public String lastObEnd() { int o = __offset(112); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer lastObEndAsByteBuffer() { return __vector_as_bytebuffer(112, 1); }
  public ByteBuffer lastObEndInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 112, 1); }
  /**
   * The number of observations available for the OD of the object.
   * Example: /// Example: 376
   * Constraints: No constraints specified.
   */
  public int obsAvailable() { int o = __offset(114); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of observations accepted for the OD of the object.
   * Example: /// Example: 374
   * Constraints: No constraints specified.
   */
  public int obsUsed() { int o = __offset(116); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of sensor tracks available for the OD of the object.
   * Example: /// Example: 163
   * Constraints: No constraints specified.
   */
  public int tracksAvail() { int o = __offset(118); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of sensor tracks accepted for the OD of the object.
   * Example: /// Example: 163
   * Constraints: No constraints specified.
   */
  public int tracksUsed() { int o = __offset(120); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The recommended OD time span calculated for the object, expressed in days.
   * Example: /// Example: 3.5
   * Constraints: No constraints specified.
   */
  public double recOdspan() { int o = __offset(122); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The actual time span used for the OD of the object, expressed in days.
   * Example: /// Example: 3.5
   * Constraints: No constraints specified.
   */
  public double actualOdspan() { int o = __offset(124); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The percentage of residuals accepted in the OD of the object.
   * Example: /// Example: 99.5
   * Constraints: No constraints specified.
   */
  public double residualsAcc() { int o = __offset(126); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * F10 (10.7 cm) solar flux value.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double solarFluxF10() { int o = __offset(128); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * F10 (10.7 cm) solar flux 81-day average value.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double solarFluxF10Avg() { int o = __offset(130); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Average solar flux geomagnetic index.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double solarFluxApavg() { int o = __offset(132); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * TAI (Temps Atomique International) minus UTC (Universal Time Coordinates) offset in seconds.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double taiUtc() { int o = __offset(134); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Universal Time-1 (UT1) minus UTC offset, in seconds.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double ut1Utc() { int o = __offset(136); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Rate of change of UT1 (milliseconds/day) - first derivative of ut1Utc.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double ut1Rate() { int o = __offset(138); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Polar Wander Motion X (arc seconds).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double polarMotionX() { int o = __offset(140); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Polar Wander Motion Y (arc seconds).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double polarMotionY() { int o = __offset(142); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Number of terms used in the IAU 1980 nutation model (4, 50, or 106).
   * Example: /// Example: 4
   * Constraints: No constraints specified.
   */
  public int iau1980Terms() { int o = __offset(144); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Time of the next leap second after epoch in ISO 8601 UTC time. If the next leap second is not known, the time of the previous leap second is used.
   * Example: /// Example: 2021-01-01T01:01:01.123Z
   * Constraints: No constraints specified.
   */
  public String leapSecondTime() { int o = __offset(146); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer leapSecondTimeAsByteBuffer() { return __vector_as_bytebuffer(146, 1); }
  public ByteBuffer leapSecondTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 146, 1); }
  /**
   * Integrator Mode.
   * Example: /// Example: integratorMode
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String integratorMode() { int o = __offset(148); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer integratorModeAsByteBuffer() { return __vector_as_bytebuffer(148, 1); }
  public ByteBuffer integratorModeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 148, 1); }
  /**
   * Type of partial derivatives used (ANALYTIC, FULL NUM, or FAST NUM).
   * Example: /// Example: ANALYTIC
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String partials() { int o = __offset(150); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer partialsAsByteBuffer() { return __vector_as_bytebuffer(150, 1); }
  public ByteBuffer partialsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 150, 1); }
  /**
   * Integrator step mode (AUTO, TIME, or S).
   * Example: /// Example: AUTO
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String stepMode() { int o = __offset(152); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer stepModeAsByteBuffer() { return __vector_as_bytebuffer(152, 1); }
  public ByteBuffer stepModeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 152, 1); }
  /**
   * Boolean indicating use of fixed step size for this vector.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean fixedStep() { int o = __offset(154); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Initial step size selection (AUTO or MANUAL).
   * Example: /// Example: AUTO
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String stepSizeSelection() { int o = __offset(156); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer stepSizeSelectionAsByteBuffer() { return __vector_as_bytebuffer(156, 1); }
  public ByteBuffer stepSizeSelectionInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 156, 1); }
  /**
   * Initial integration step size (seconds).
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double stepSize() { int o = __offset(158); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Integrator error control.
   * Example: /// Example: 1.23
   * Constraints: No constraints specified.
   */
  public double errorControl() { int o = __offset(160); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Array containing the standard deviation of error in target object position, U, V and W direction respectively (km).
   * Example: /// Example: [1.23, 4.56]
   * Constraints: No constraints specified.
   */
  public String sigmaPosUvw(int j) { int o = __offset(162); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int sigmaPosUvwLength() { int o = __offset(162); return o != 0 ? __vector_len(o) : 0; }
  public StringVector sigmaPosUvwVector() { return sigmaPosUvwVector(new StringVector()); }
  public StringVector sigmaPosUvwVector(StringVector obj) { int o = __offset(162); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array containing the standard deviation of error in target object velocity, U, V and W direction respectively (km/sec).
   * Example: /// Example: [1.23, 4.56]
   * Constraints: No constraints specified.
   */
  public String sigmaVelUvw(int j) { int o = __offset(164); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int sigmaVelUvwLength() { int o = __offset(164); return o != 0 ? __vector_len(o) : 0; }
  public StringVector sigmaVelUvwVector() { return sigmaVelUvwVector(new StringVector()); }
  public StringVector sigmaVelUvwVector(StringVector obj) { int o = __offset(164); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The Weighted Root Mean Squared (RMS) of the differential correction on the target object that produced this vector.  WRMS is a quality indicator of the state vector update, with a value of 1.00 being optimal.  WRMS applies to Batch Least Squares (BLS) processes.
   * Example: /// Example: 0.991
   * Constraints: No constraints specified.
   */
  public double rms() { int o = __offset(166); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String source() { int o = __offset(168); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(168, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 168, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(170); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(170, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 170, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(172); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Optional algorithm used to produce this record.
   * Example: /// Example: SAMPLE_ALGORITHM
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String algorithm() { int o = __offset(174); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer algorithmAsByteBuffer() { return __vector_as_bytebuffer(174, 1); }
  public ByteBuffer algorithmInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 174, 1); }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(176); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(176, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 176, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(178); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(178, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 178, 1); }
  /**
   * Optional source-provided and searchable metadata or descriptor of the data.
   * Example: /// Example: descriptor
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String descriptor() { int o = __offset(180); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer descriptorAsByteBuffer() { return __vector_as_bytebuffer(180, 1); }
  public ByteBuffer descriptorInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 180, 1); }
  /**
   * Optional identifier to track a commercial or marketplace transaction executed to produce this data.
   * Example: /// Example: transactionId
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String transactionId() { int o = __offset(182); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer transactionIdAsByteBuffer() { return __vector_as_bytebuffer(182, 1); }
  public ByteBuffer transactionIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 182, 1); }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: ORIG
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(184); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(184, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 184, 1); }
  /**
   * The source data library from which this record was received. This could be a remote or tactical UDL or another data library. If null, the record should be assumed to have originated from the primary Enterprise UDL.
   * Example: /// Example: AXE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String sourceDl() { int o = __offset(186); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceDlAsByteBuffer() { return __vector_as_bytebuffer(186, 1); }
  public ByteBuffer sourceDlInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 186, 1); }

  public static int createStateVector_Abridged(FlatBufferBuilder builder,
      int idStateVectorOffset,
      int classificationMarkingOffset,
      int epochOffset,
      int pedigreeOffset,
      int idOnOrbitOffset,
      int satNo,
      int origObjectIdOffset,
      int idOrbitDeterminationOffset,
      boolean uct,
      double xpos,
      double ypos,
      double zpos,
      double xvel,
      double yvel,
      double zvel,
      byte referenceFrame,
      int covOffset,
      byte covReferenceFrame,
      int covMethodOffset,
      int eqCovOffset,
      double xposAlt1,
      double yposAlt1,
      double zposAlt1,
      double xvelAlt1,
      double yvelAlt1,
      double zvelAlt1,
      int alt1ReferenceFrameOffset,
      double xposAlt2,
      double yposAlt2,
      double zposAlt2,
      double xvelAlt2,
      double yvelAlt2,
      double zvelAlt2,
      int alt2ReferenceFrameOffset,
      double posUnc,
      double velUnc,
      double mass,
      double area,
      double solarRadPressCoeff,
      double dragCoeff,
      double dragArea,
      int revNo,
      int geopotentialModelOffset,
      int dragModelOffset,
      boolean lunarSolar,
      boolean solarRadPress,
      double srpArea,
      boolean solidEarthTides,
      boolean inTrackThrust,
      double bDot,
      double edr,
      double thrustAccel,
      double cmOffset,
      int lastObStartOffset,
      int lastObEndOffset,
      int obsAvailable,
      int obsUsed,
      int tracksAvail,
      int tracksUsed,
      double recOdspan,
      double actualOdspan,
      double residualsAcc,
      double solarFluxF10,
      double solarFluxF10Avg,
      double solarFluxApavg,
      double taiUtc,
      double ut1Utc,
      double ut1Rate,
      double polarMotionX,
      double polarMotionY,
      int iau1980Terms,
      int leapSecondTimeOffset,
      int integratorModeOffset,
      int partialsOffset,
      int stepModeOffset,
      boolean fixedStep,
      int stepSizeSelectionOffset,
      double stepSize,
      double errorControl,
      int sigmaPosUvwOffset,
      int sigmaVelUvwOffset,
      double rms,
      int sourceOffset,
      int originOffset,
      byte dataMode,
      int algorithmOffset,
      int createdAtOffset,
      int createdByOffset,
      int descriptorOffset,
      int transactionIdOffset,
      int origNetworkOffset,
      int sourceDlOffset) {
    builder.startTable(92);
    StateVector_Abridged.addRms(builder, rms);
    StateVector_Abridged.addErrorControl(builder, errorControl);
    StateVector_Abridged.addStepSize(builder, stepSize);
    StateVector_Abridged.addPolarMotionY(builder, polarMotionY);
    StateVector_Abridged.addPolarMotionX(builder, polarMotionX);
    StateVector_Abridged.addUt1Rate(builder, ut1Rate);
    StateVector_Abridged.addUt1Utc(builder, ut1Utc);
    StateVector_Abridged.addTaiUtc(builder, taiUtc);
    StateVector_Abridged.addSolarFluxApavg(builder, solarFluxApavg);
    StateVector_Abridged.addSolarFluxF10Avg(builder, solarFluxF10Avg);
    StateVector_Abridged.addSolarFluxF10(builder, solarFluxF10);
    StateVector_Abridged.addResidualsAcc(builder, residualsAcc);
    StateVector_Abridged.addActualOdspan(builder, actualOdspan);
    StateVector_Abridged.addRecOdspan(builder, recOdspan);
    StateVector_Abridged.addCmOffset(builder, cmOffset);
    StateVector_Abridged.addThrustAccel(builder, thrustAccel);
    StateVector_Abridged.addEdr(builder, edr);
    StateVector_Abridged.addBDot(builder, bDot);
    StateVector_Abridged.addSrpArea(builder, srpArea);
    StateVector_Abridged.addDragArea(builder, dragArea);
    StateVector_Abridged.addDragCoeff(builder, dragCoeff);
    StateVector_Abridged.addSolarRadPressCoeff(builder, solarRadPressCoeff);
    StateVector_Abridged.addArea(builder, area);
    StateVector_Abridged.addMass(builder, mass);
    StateVector_Abridged.addVelUnc(builder, velUnc);
    StateVector_Abridged.addPosUnc(builder, posUnc);
    StateVector_Abridged.addZvelAlt2(builder, zvelAlt2);
    StateVector_Abridged.addYvelAlt2(builder, yvelAlt2);
    StateVector_Abridged.addXvelAlt2(builder, xvelAlt2);
    StateVector_Abridged.addZposAlt2(builder, zposAlt2);
    StateVector_Abridged.addYposAlt2(builder, yposAlt2);
    StateVector_Abridged.addXposAlt2(builder, xposAlt2);
    StateVector_Abridged.addZvelAlt1(builder, zvelAlt1);
    StateVector_Abridged.addYvelAlt1(builder, yvelAlt1);
    StateVector_Abridged.addXvelAlt1(builder, xvelAlt1);
    StateVector_Abridged.addZposAlt1(builder, zposAlt1);
    StateVector_Abridged.addYposAlt1(builder, yposAlt1);
    StateVector_Abridged.addXposAlt1(builder, xposAlt1);
    StateVector_Abridged.addZvel(builder, zvel);
    StateVector_Abridged.addYvel(builder, yvel);
    StateVector_Abridged.addXvel(builder, xvel);
    StateVector_Abridged.addZpos(builder, zpos);
    StateVector_Abridged.addYpos(builder, ypos);
    StateVector_Abridged.addXpos(builder, xpos);
    StateVector_Abridged.addSourceDl(builder, sourceDlOffset);
    StateVector_Abridged.addOrigNetwork(builder, origNetworkOffset);
    StateVector_Abridged.addTransactionId(builder, transactionIdOffset);
    StateVector_Abridged.addDescriptor(builder, descriptorOffset);
    StateVector_Abridged.addCreatedBy(builder, createdByOffset);
    StateVector_Abridged.addCreatedAt(builder, createdAtOffset);
    StateVector_Abridged.addAlgorithm(builder, algorithmOffset);
    StateVector_Abridged.addOrigin(builder, originOffset);
    StateVector_Abridged.addSource(builder, sourceOffset);
    StateVector_Abridged.addSigmaVelUvw(builder, sigmaVelUvwOffset);
    StateVector_Abridged.addSigmaPosUvw(builder, sigmaPosUvwOffset);
    StateVector_Abridged.addStepSizeSelection(builder, stepSizeSelectionOffset);
    StateVector_Abridged.addStepMode(builder, stepModeOffset);
    StateVector_Abridged.addPartials(builder, partialsOffset);
    StateVector_Abridged.addIntegratorMode(builder, integratorModeOffset);
    StateVector_Abridged.addLeapSecondTime(builder, leapSecondTimeOffset);
    StateVector_Abridged.addIau1980Terms(builder, iau1980Terms);
    StateVector_Abridged.addTracksUsed(builder, tracksUsed);
    StateVector_Abridged.addTracksAvail(builder, tracksAvail);
    StateVector_Abridged.addObsUsed(builder, obsUsed);
    StateVector_Abridged.addObsAvailable(builder, obsAvailable);
    StateVector_Abridged.addLastObEnd(builder, lastObEndOffset);
    StateVector_Abridged.addLastObStart(builder, lastObStartOffset);
    StateVector_Abridged.addDragModel(builder, dragModelOffset);
    StateVector_Abridged.addGeopotentialModel(builder, geopotentialModelOffset);
    StateVector_Abridged.addRevNo(builder, revNo);
    StateVector_Abridged.addAlt2ReferenceFrame(builder, alt2ReferenceFrameOffset);
    StateVector_Abridged.addAlt1ReferenceFrame(builder, alt1ReferenceFrameOffset);
    StateVector_Abridged.addEqCov(builder, eqCovOffset);
    StateVector_Abridged.addCovMethod(builder, covMethodOffset);
    StateVector_Abridged.addCov(builder, covOffset);
    StateVector_Abridged.addIdOrbitDetermination(builder, idOrbitDeterminationOffset);
    StateVector_Abridged.addOrigObjectId(builder, origObjectIdOffset);
    StateVector_Abridged.addSatNo(builder, satNo);
    StateVector_Abridged.addIdOnOrbit(builder, idOnOrbitOffset);
    StateVector_Abridged.addPedigree(builder, pedigreeOffset);
    StateVector_Abridged.addEpoch(builder, epochOffset);
    StateVector_Abridged.addClassificationMarking(builder, classificationMarkingOffset);
    StateVector_Abridged.addIdStateVector(builder, idStateVectorOffset);
    StateVector_Abridged.addDataMode(builder, dataMode);
    StateVector_Abridged.addFixedStep(builder, fixedStep);
    StateVector_Abridged.addInTrackThrust(builder, inTrackThrust);
    StateVector_Abridged.addSolidEarthTides(builder, solidEarthTides);
    StateVector_Abridged.addSolarRadPress(builder, solarRadPress);
    StateVector_Abridged.addLunarSolar(builder, lunarSolar);
    StateVector_Abridged.addCovReferenceFrame(builder, covReferenceFrame);
    StateVector_Abridged.addReferenceFrame(builder, referenceFrame);
    StateVector_Abridged.addUct(builder, uct);
    return StateVector_Abridged.endStateVector_Abridged(builder);
  }

  public static void startStateVector_Abridged(FlatBufferBuilder builder) { builder.startTable(92); }
  public static void addIdStateVector(FlatBufferBuilder builder, int idStateVectorOffset) { builder.addOffset(0, idStateVectorOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addEpoch(FlatBufferBuilder builder, int epochOffset) { builder.addOffset(2, epochOffset, 0); }
  public static void addPedigree(FlatBufferBuilder builder, int pedigreeOffset) { builder.addOffset(3, pedigreeOffset, 0); }
  public static void addIdOnOrbit(FlatBufferBuilder builder, int idOnOrbitOffset) { builder.addOffset(4, idOnOrbitOffset, 0); }
  public static void addSatNo(FlatBufferBuilder builder, int satNo) { builder.addInt(5, satNo, 0); }
  public static void addOrigObjectId(FlatBufferBuilder builder, int origObjectIdOffset) { builder.addOffset(6, origObjectIdOffset, 0); }
  public static void addIdOrbitDetermination(FlatBufferBuilder builder, int idOrbitDeterminationOffset) { builder.addOffset(7, idOrbitDeterminationOffset, 0); }
  public static void addUct(FlatBufferBuilder builder, boolean uct) { builder.addBoolean(8, uct, false); }
  public static void addXpos(FlatBufferBuilder builder, double xpos) { builder.addDouble(9, xpos, 0.0); }
  public static void addYpos(FlatBufferBuilder builder, double ypos) { builder.addDouble(10, ypos, 0.0); }
  public static void addZpos(FlatBufferBuilder builder, double zpos) { builder.addDouble(11, zpos, 0.0); }
  public static void addXvel(FlatBufferBuilder builder, double xvel) { builder.addDouble(12, xvel, 0.0); }
  public static void addYvel(FlatBufferBuilder builder, double yvel) { builder.addDouble(13, yvel, 0.0); }
  public static void addZvel(FlatBufferBuilder builder, double zvel) { builder.addDouble(14, zvel, 0.0); }
  public static void addReferenceFrame(FlatBufferBuilder builder, byte referenceFrame) { builder.addByte(15, referenceFrame, 0); }
  public static void addCov(FlatBufferBuilder builder, int covOffset) { builder.addOffset(16, covOffset, 0); }
  public static int createCovVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startCovVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addCovReferenceFrame(FlatBufferBuilder builder, byte covReferenceFrame) { builder.addByte(17, covReferenceFrame, 0); }
  public static void addCovMethod(FlatBufferBuilder builder, int covMethodOffset) { builder.addOffset(18, covMethodOffset, 0); }
  public static void addEqCov(FlatBufferBuilder builder, int eqCovOffset) { builder.addOffset(19, eqCovOffset, 0); }
  public static int createEqCovVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startEqCovVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addXposAlt1(FlatBufferBuilder builder, double xposAlt1) { builder.addDouble(20, xposAlt1, 0.0); }
  public static void addYposAlt1(FlatBufferBuilder builder, double yposAlt1) { builder.addDouble(21, yposAlt1, 0.0); }
  public static void addZposAlt1(FlatBufferBuilder builder, double zposAlt1) { builder.addDouble(22, zposAlt1, 0.0); }
  public static void addXvelAlt1(FlatBufferBuilder builder, double xvelAlt1) { builder.addDouble(23, xvelAlt1, 0.0); }
  public static void addYvelAlt1(FlatBufferBuilder builder, double yvelAlt1) { builder.addDouble(24, yvelAlt1, 0.0); }
  public static void addZvelAlt1(FlatBufferBuilder builder, double zvelAlt1) { builder.addDouble(25, zvelAlt1, 0.0); }
  public static void addAlt1ReferenceFrame(FlatBufferBuilder builder, int alt1ReferenceFrameOffset) { builder.addOffset(26, alt1ReferenceFrameOffset, 0); }
  public static void addXposAlt2(FlatBufferBuilder builder, double xposAlt2) { builder.addDouble(27, xposAlt2, 0.0); }
  public static void addYposAlt2(FlatBufferBuilder builder, double yposAlt2) { builder.addDouble(28, yposAlt2, 0.0); }
  public static void addZposAlt2(FlatBufferBuilder builder, double zposAlt2) { builder.addDouble(29, zposAlt2, 0.0); }
  public static void addXvelAlt2(FlatBufferBuilder builder, double xvelAlt2) { builder.addDouble(30, xvelAlt2, 0.0); }
  public static void addYvelAlt2(FlatBufferBuilder builder, double yvelAlt2) { builder.addDouble(31, yvelAlt2, 0.0); }
  public static void addZvelAlt2(FlatBufferBuilder builder, double zvelAlt2) { builder.addDouble(32, zvelAlt2, 0.0); }
  public static void addAlt2ReferenceFrame(FlatBufferBuilder builder, int alt2ReferenceFrameOffset) { builder.addOffset(33, alt2ReferenceFrameOffset, 0); }
  public static void addPosUnc(FlatBufferBuilder builder, double posUnc) { builder.addDouble(34, posUnc, 0.0); }
  public static void addVelUnc(FlatBufferBuilder builder, double velUnc) { builder.addDouble(35, velUnc, 0.0); }
  public static void addMass(FlatBufferBuilder builder, double mass) { builder.addDouble(36, mass, 0.0); }
  public static void addArea(FlatBufferBuilder builder, double area) { builder.addDouble(37, area, 0.0); }
  public static void addSolarRadPressCoeff(FlatBufferBuilder builder, double solarRadPressCoeff) { builder.addDouble(38, solarRadPressCoeff, 0.0); }
  public static void addDragCoeff(FlatBufferBuilder builder, double dragCoeff) { builder.addDouble(39, dragCoeff, 0.0); }
  public static void addDragArea(FlatBufferBuilder builder, double dragArea) { builder.addDouble(40, dragArea, 0.0); }
  public static void addRevNo(FlatBufferBuilder builder, int revNo) { builder.addInt(41, revNo, 0); }
  public static void addGeopotentialModel(FlatBufferBuilder builder, int geopotentialModelOffset) { builder.addOffset(42, geopotentialModelOffset, 0); }
  public static void addDragModel(FlatBufferBuilder builder, int dragModelOffset) { builder.addOffset(43, dragModelOffset, 0); }
  public static void addLunarSolar(FlatBufferBuilder builder, boolean lunarSolar) { builder.addBoolean(44, lunarSolar, false); }
  public static void addSolarRadPress(FlatBufferBuilder builder, boolean solarRadPress) { builder.addBoolean(45, solarRadPress, false); }
  public static void addSrpArea(FlatBufferBuilder builder, double srpArea) { builder.addDouble(46, srpArea, 0.0); }
  public static void addSolidEarthTides(FlatBufferBuilder builder, boolean solidEarthTides) { builder.addBoolean(47, solidEarthTides, false); }
  public static void addInTrackThrust(FlatBufferBuilder builder, boolean inTrackThrust) { builder.addBoolean(48, inTrackThrust, false); }
  public static void addBDot(FlatBufferBuilder builder, double bDot) { builder.addDouble(49, bDot, 0.0); }
  public static void addEdr(FlatBufferBuilder builder, double edr) { builder.addDouble(50, edr, 0.0); }
  public static void addThrustAccel(FlatBufferBuilder builder, double thrustAccel) { builder.addDouble(51, thrustAccel, 0.0); }
  public static void addCmOffset(FlatBufferBuilder builder, double cmOffset) { builder.addDouble(52, cmOffset, 0.0); }
  public static void addLastObStart(FlatBufferBuilder builder, int lastObStartOffset) { builder.addOffset(53, lastObStartOffset, 0); }
  public static void addLastObEnd(FlatBufferBuilder builder, int lastObEndOffset) { builder.addOffset(54, lastObEndOffset, 0); }
  public static void addObsAvailable(FlatBufferBuilder builder, int obsAvailable) { builder.addInt(55, obsAvailable, 0); }
  public static void addObsUsed(FlatBufferBuilder builder, int obsUsed) { builder.addInt(56, obsUsed, 0); }
  public static void addTracksAvail(FlatBufferBuilder builder, int tracksAvail) { builder.addInt(57, tracksAvail, 0); }
  public static void addTracksUsed(FlatBufferBuilder builder, int tracksUsed) { builder.addInt(58, tracksUsed, 0); }
  public static void addRecOdspan(FlatBufferBuilder builder, double recOdspan) { builder.addDouble(59, recOdspan, 0.0); }
  public static void addActualOdspan(FlatBufferBuilder builder, double actualOdspan) { builder.addDouble(60, actualOdspan, 0.0); }
  public static void addResidualsAcc(FlatBufferBuilder builder, double residualsAcc) { builder.addDouble(61, residualsAcc, 0.0); }
  public static void addSolarFluxF10(FlatBufferBuilder builder, double solarFluxF10) { builder.addDouble(62, solarFluxF10, 0.0); }
  public static void addSolarFluxF10Avg(FlatBufferBuilder builder, double solarFluxF10Avg) { builder.addDouble(63, solarFluxF10Avg, 0.0); }
  public static void addSolarFluxApavg(FlatBufferBuilder builder, double solarFluxApavg) { builder.addDouble(64, solarFluxApavg, 0.0); }
  public static void addTaiUtc(FlatBufferBuilder builder, double taiUtc) { builder.addDouble(65, taiUtc, 0.0); }
  public static void addUt1Utc(FlatBufferBuilder builder, double ut1Utc) { builder.addDouble(66, ut1Utc, 0.0); }
  public static void addUt1Rate(FlatBufferBuilder builder, double ut1Rate) { builder.addDouble(67, ut1Rate, 0.0); }
  public static void addPolarMotionX(FlatBufferBuilder builder, double polarMotionX) { builder.addDouble(68, polarMotionX, 0.0); }
  public static void addPolarMotionY(FlatBufferBuilder builder, double polarMotionY) { builder.addDouble(69, polarMotionY, 0.0); }
  public static void addIau1980Terms(FlatBufferBuilder builder, int iau1980Terms) { builder.addInt(70, iau1980Terms, 0); }
  public static void addLeapSecondTime(FlatBufferBuilder builder, int leapSecondTimeOffset) { builder.addOffset(71, leapSecondTimeOffset, 0); }
  public static void addIntegratorMode(FlatBufferBuilder builder, int integratorModeOffset) { builder.addOffset(72, integratorModeOffset, 0); }
  public static void addPartials(FlatBufferBuilder builder, int partialsOffset) { builder.addOffset(73, partialsOffset, 0); }
  public static void addStepMode(FlatBufferBuilder builder, int stepModeOffset) { builder.addOffset(74, stepModeOffset, 0); }
  public static void addFixedStep(FlatBufferBuilder builder, boolean fixedStep) { builder.addBoolean(75, fixedStep, false); }
  public static void addStepSizeSelection(FlatBufferBuilder builder, int stepSizeSelectionOffset) { builder.addOffset(76, stepSizeSelectionOffset, 0); }
  public static void addStepSize(FlatBufferBuilder builder, double stepSize) { builder.addDouble(77, stepSize, 0.0); }
  public static void addErrorControl(FlatBufferBuilder builder, double errorControl) { builder.addDouble(78, errorControl, 0.0); }
  public static void addSigmaPosUvw(FlatBufferBuilder builder, int sigmaPosUvwOffset) { builder.addOffset(79, sigmaPosUvwOffset, 0); }
  public static int createSigmaPosUvwVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSigmaPosUvwVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSigmaVelUvw(FlatBufferBuilder builder, int sigmaVelUvwOffset) { builder.addOffset(80, sigmaVelUvwOffset, 0); }
  public static int createSigmaVelUvwVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSigmaVelUvwVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addRms(FlatBufferBuilder builder, double rms) { builder.addDouble(81, rms, 0.0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(82, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(83, originOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(84, dataMode, 0); }
  public static void addAlgorithm(FlatBufferBuilder builder, int algorithmOffset) { builder.addOffset(85, algorithmOffset, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(86, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(87, createdByOffset, 0); }
  public static void addDescriptor(FlatBufferBuilder builder, int descriptorOffset) { builder.addOffset(88, descriptorOffset, 0); }
  public static void addTransactionId(FlatBufferBuilder builder, int transactionIdOffset) { builder.addOffset(89, transactionIdOffset, 0); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(90, origNetworkOffset, 0); }
  public static void addSourceDl(FlatBufferBuilder builder, int sourceDlOffset) { builder.addOffset(91, sourceDlOffset, 0); }
  public static int endStateVector_Abridged(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishStateVector_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "STAT"); }
  public static void finishSizePrefixedStateVector_AbridgedBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "STAT"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public StateVector_Abridged get(int j) { return get(new StateVector_Abridged(), j); }
    public StateVector_Abridged get(StateVector_Abridged obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

