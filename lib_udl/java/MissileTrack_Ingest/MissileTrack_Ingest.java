// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// These services provide operations for querying of all available missile track details and amplifying missile data. A missile track is a position and optionally a heading/velocity of an object across all environments at a particular timestamp. It also includes optional information regarding the identity/type of missile, impact location, launch location and other amplifying object data, if known.
 */
@SuppressWarnings("unused")
public final class MissileTrack_Ingest extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static MissileTrack_Ingest getRootAsMissileTrack_Ingest(ByteBuffer _bb) { return getRootAsMissileTrack_Ingest(_bb, new MissileTrack_Ingest()); }
  public static MissileTrack_Ingest getRootAsMissileTrack_Ingest(ByteBuffer _bb, MissileTrack_Ingest obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean MissileTrack_IngestBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "MISS"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public MissileTrack_Ingest __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the record, auto-generated by the system if not provided on create operations.
   * Example: /// Example: MissileTrack_ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String id() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * The type of external message from which this request originated.
   * Example: /// Example: MSG-TYPE
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String msgType() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgTypeAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer msgTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * The message subtype is a finer grain categorization of message types as many messages can contain a variety of data content within the same structure.  Examples include but are not limited to Initial, Final, Launch, Update, etc.  Users should consult the appropriate documentation, based on the message type, for the definitions of the subtypes that apply to that message.
   * Example: /// Example: Update
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String msgSubType() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgSubTypeAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer msgSubTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }
  /**
   * The timestamp of the external message from which this request originated, if applicable, in ISO8601 UTC format with millisecond precision.
   * Example: /// Example: 2024-04-25T08:17:01.346Z
   * Constraints: No constraints specified.
   */
  public String msgCreateDate() { int o = __offset(12); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer msgCreateDateAsByteBuffer() { return __vector_as_bytebuffer(12, 1); }
  public ByteBuffer msgCreateDateInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 12, 1); }
  /**
   * The track environment type (AIR, LAND, SPACE, SUBSURFACE, SURFACE, UNKNOWN):
   *  AIR: Between sea level and the Kármán line, which has an altitude of 100 kilometers (62 miles).
   *  LAND: On the surface of dry land.
   *  SPACE: Above the Kármán line, which has an altitude of 100 kilometers (62 miles).
   *  SURFACE: On the surface of a body of water.
   *  SUBSURFACE: Below the surface of a body of water.
   *  UNKNOWN: Environment is not known.
   * Example: /// Example: AIR
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public byte env() { int o = __offset(14); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * The type of object to which this record refers. The object type may be updated in later records based on assessment of additional data.
   * Example: /// Example: Ballistic
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objType() { int o = __offset(16); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objTypeAsByteBuffer() { return __vector_as_bytebuffer(16, 1); }
  public ByteBuffer objTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 16, 1); }
  /**
   * Confidence of the object type, 0-100.
   * Example: /// Example: 90
   * Constraints: No constraints specified.
   */
  public int objTypeConf() { int o = __offset(18); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Space Platform field along with the Space Activity field further defines the identity of a Space track (examples: SATELLITE, WEAPON, PATROL). The object platform type. Intended as, but not constrained to, MIL-STD-6016 environment dependent platform type designations. The platform type can be reported as either a combination of the code and environment (e.g. 14/LAND) or as the descriptive representations (e.g. COMBAT VEHICLE), which are equivalent.
   * Example: /// Example: WEAPON
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objPlat() { int o = __offset(20); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objPlatAsByteBuffer() { return __vector_as_bytebuffer(20, 1); }
  public ByteBuffer objPlatInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 20, 1); }
  /**
   * The estimated identity of the track object (ASSUMED FRIEND, FRIEND, HOSTILE, NEUTRAL, PENDING, SUSPECT, UNKNOWN):
   *  ASSUMED FRIEND: Track assumed to be a friend due to the object characteristics, behavior, and/or origin.
   *  FRIEND: Track object supporting friendly forces and belonging to a declared friendly nation or entity.
   *  HOSTILE: Track object belonging to an opposing nation, party, group, or entity deemed to contribute to a threat to friendly forces or their mission due to its behavior, characteristics, nationality, or origin.
   *  NEUTRAL: Track object whose characteristics, behavior, nationality, and/or origin indicate that it is neither supporting nor opposing friendly forces or their mission.
   *  PENDING: Track object which has not been evaluated.
   *  SUSPECT: Track object deemed potentially hostile due to the object characteristics, behavior, nationality, and/or origin.
   *  UNKNOWN: Track object which has been evaluated and does not meet criteria for any standard identity.
   * Example: /// Example: FRIEND
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public byte objIdent() { int o = __offset(22); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Space amplification indicates additional information on the space environment being reported (examples: NUCLEAR WARHEAD, FUEL-AIR EXPLOSIVE WARHEAD, DEBRIS).
   * Example: /// Example: NUCLEAR WARHEAD
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String spaceAmp() { int o = __offset(24); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer spaceAmpAsByteBuffer() { return __vector_as_bytebuffer(24, 1); }
  public ByteBuffer spaceAmpInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 24, 1); }
  /**
   * Space activity (examples: RECONNAISSANCE, ANTISPACE WARFARE, TELEVISION). The activity in which the track object is engaged. Intended as, but not constrained to, MIL-STD-6016 environment dependent activity designations. The activity can be reported as either a combination of the code and environment (e.g. 65/AIR) or as the descriptive enumeration (e.g. DIVERTING), which are equivalent.
   * Example: /// Example: HOLDING
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String objAct() { int o = __offset(26); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer objActAsByteBuffer() { return __vector_as_bytebuffer(26, 1); }
  public ByteBuffer objActInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 26, 1); }
  /**
   * Specific type of point or track with an environment of space.
   * Example: /// Example: SS-21_MOD_2_CRBM
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String spaceSpecType() { int o = __offset(28); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer spaceSpecTypeAsByteBuffer() { return __vector_as_bytebuffer(28, 1); }
  public ByteBuffer spaceSpecTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 28, 1); }
  /**
   * Subtype is a finer grain categorization of missile types. Examples include but are not limited to SRBM, MRBM, IRBM, LRBM, ICBM, SLBM. 
   * &nbsp;SRBM - Short-Range Ballistic Missile
   * &nbsp;MRBM - Medium-Range Ballistic Missile
   * &nbsp;IRBM - Intermediate-Range Ballistic Missile
   * &nbsp;LRBM - Long-Range Ballistic Missile
   * &nbsp;ICBM - Intercontinental Ballistic Missile
   * &nbsp;SLBM - Submarine-Launched Ballistic Missile.
   * Example: /// Example: SLBM
   * Constraints: Minimum length = 0, Maximum length = 16
   */
  public String acftSubType() { int o = __offset(30); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer acftSubTypeAsByteBuffer() { return __vector_as_bytebuffer(30, 1); }
  public ByteBuffer acftSubTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 30, 1); }
  /**
   * Track name.
   * Example: /// Example: TRACK-NAME
   * Constraints: Minimum length = 0, Maximum length = 48
   */
  public String name() { int o = __offset(32); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer nameAsByteBuffer() { return __vector_as_bytebuffer(32, 1); }
  public ByteBuffer nameInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 32, 1); }
  /**
   * The call sign currently assigned to the track object.
   * Example: /// Example: Charlie
   * Constraints: Minimum length = 0, Maximum length = 24
   */
  public String callSign() { int o = __offset(34); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer callSignAsByteBuffer() { return __vector_as_bytebuffer(34, 1); }
  public ByteBuffer callSignInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 34, 1); }
  /**
   * Indicates whether or not the missile is considered lost.
   * Example: /// Example: False
   * Constraints: No constraints specified.
   */
  public boolean lostTrkInd() { int o = __offset(36); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Track ID within the originating system.
   * Example: /// Example: 102288
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String trackId() { int o = __offset(38); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer trackIdAsByteBuffer() { return __vector_as_bytebuffer(38, 1); }
  public ByteBuffer trackIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 38, 1); }
  /**
   * Track ID of the parent track, within the originating system, from which the track was developed.
   * Example: /// Example: 102288
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String parentTrackId() { int o = __offset(40); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer parentTrackIdAsByteBuffer() { return __vector_as_bytebuffer(40, 1); }
  public ByteBuffer parentTrackIdInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 40, 1); }
  /**
   * Track ID for the source of the missile-unique identifier.
   * Example: /// Example: MUID-SRC-ID
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String muidSrcTrk() { int o = __offset(42); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer muidSrcTrkAsByteBuffer() { return __vector_as_bytebuffer(42, 1); }
  public ByteBuffer muidSrcTrkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 42, 1); }
  /**
   * Source of the missile-unique identifier (MUID).
   * Example: /// Example: MUID-SRC
   * Constraints: Minimum length = 0, Maximum length = 36
   */
  public String muidSrc() { int o = __offset(44); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer muidSrcAsByteBuffer() { return __vector_as_bytebuffer(44, 1); }
  public ByteBuffer muidSrcInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 44, 1); }
  /**
   * A track may be designated as a non-alert track or an alert track.
   * Examples include but are not limited to:
   * &nbsp;Non-alert tracks – choose None (Blank).
   * &nbsp;Alert tracks – enter the proper alert classification:
   * &nbsp;HIT - High Interest Track
   * &nbsp;TGT - Target
   * &nbsp;SUS - Suspect Carrier
   * &nbsp;NSP - Cleared Suspect.
   * Example: /// Example: HIT
   * Constraints: Minimum length = 0, Maximum length = 4
   */
  public String alert() { int o = __offset(46); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer alertAsByteBuffer() { return __vector_as_bytebuffer(46, 1); }
  public ByteBuffer alertInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 46, 1); }
  /**
   * Missile status enumeration examples include but are not limited to:
   * &nbsp;AT LAUNCH 
   * &nbsp;AT OBSERVATION 
   * &nbsp;FLYING 
   * &nbsp;IMPACTED 
   * &nbsp;LOST 
   * &nbsp;STALE
   * &nbsp;DEBRIS.
   * Example: /// Example: AT LAUNCH
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String mslStatus() { int o = __offset(48); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer mslStatusAsByteBuffer() { return __vector_as_bytebuffer(48, 1); }
  public ByteBuffer mslStatusInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 48, 1); }
  /**
   * The receipt time of the data by the processing system, in ISO8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String ts() { int o = __offset(50); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer tsAsByteBuffer() { return __vector_as_bytebuffer(50, 1); }
  public ByteBuffer tsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 50, 1); }
  /**
   * The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
   * Example: /// Example: ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 40
   */
  public String aouRptType() { int o = __offset(52); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer aouRptTypeAsByteBuffer() { return __vector_as_bytebuffer(52, 1); }
  public ByteBuffer aouRptTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 52, 1); }
  /**
   * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
   * &nbsp;ELLIPSE:
   * &nbsp;&nbsp;brg - orientation in degrees of the ellipse
   * &nbsp;&nbsp;a1 - semi-major axis in kilometers
   * &nbsp;&nbsp;a2 - semi-minor axis in kilometers
   * &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
   * &nbsp;&nbsp;brg - orientation in degrees of the bearing box
   * &nbsp;&nbsp;a1 - length of bearing box in kilometers
   * &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
   * &nbsp;OTHER (All other type values):
   * &nbsp;&nbsp;brg - line of bearing in degrees true
   * &nbsp;&nbsp;a1 - bearing error in degrees
   * &nbsp;&nbsp;a2 - estimated range in kilometers.
   * Example: /// Example: [34.3, 26.5, 1.2]
   * Constraints: No constraints specified.
   */
  public String aouRptData(int j) { int o = __offset(54); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int aouRptDataLength() { int o = __offset(54); return o != 0 ? __vector_len(o) : 0; }
  public StringVector aouRptDataVector() { return aouRptDataVector(new StringVector()); }
  public StringVector aouRptDataVector(StringVector obj) { int o = __offset(54); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The percentage of time that the estimated AoU will "cover" the true position of the track.
   * Example: /// Example: 90.64
   * Constraints: No constraints specified.
   */
  public double containment() { int o = __offset(56); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Overall track confidence estimate (not standardized, but typically a value between 0 and 1, with 0 indicating lowest confidence).
   * Example: /// Example: 0.95
   * Constraints: No constraints specified.
   */
  public double trkConf() { int o = __offset(58); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track Quality is reported as an integer from 0-15. Track Quality specifies the reliability of the positional information of a reported track, with higher values indicating higher track quality; i.e., lower errors in reported position.
   * Example: /// Example: 1
   * Constraints: No constraints specified.
   */
  public int trkQual() { int o = __offset(60); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Angle of elevation/depression between observer and missile in degrees.
   * Example: /// Example: 15.2
   * Constraints: No constraints specified.
   */
  public double angElev() { int o = __offset(62); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Last report type received from the sensor (for example, OBSBO = observation burnout).
   * Example: /// Example: OBSBO
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String senMode() { int o = __offset(64); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer senModeAsByteBuffer() { return __vector_as_bytebuffer(64, 1); }
  public ByteBuffer senModeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 64, 1); }
  /**
   * Source code for source of information used to detect track.
   * Example: /// Example: S1
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String infoSource() { int o = __offset(66); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer infoSourceAsByteBuffer() { return __vector_as_bytebuffer(66, 1); }
  public ByteBuffer infoSourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 66, 1); }
  /**
   * Indicates whether or not the missile is currently in a state of boosting.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean boosting() { int o = __offset(68); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Azimuth corridor reference point latitude.
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double polarSingLocLat() { int o = __offset(70); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Azimuth corridor reference point longitude.
   * Example: /// Example: 46.74596844
   * Constraints: No constraints specified.
   */
  public double polarSingLocLon() { int o = __offset(72); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Indicates whether or not a track has an emergency.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean emgInd() { int o = __offset(74); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * The drop-point indicator setting.
   * Example: /// Example: True
   * Constraints: No constraints specified.
   */
  public boolean dropPtInd() { int o = __offset(76); return o != 0 ? 0!=bb.get(o + bb_pos) : false; }
  /**
   * Confidence level of the amplifying characteristics. Values range from 0 to 6.
   * Example: /// Example: 6
   * Constraints: No constraints specified.
   */
  public int spaceAmpConf() { int o = __offset(78); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Missile launch timestamp in ISO8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String launchTime() { int o = __offset(80); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer launchTimeAsByteBuffer() { return __vector_as_bytebuffer(80, 1); }
  public ByteBuffer launchTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 80, 1); }
  /**
   * WGS-84 latitude of the missile launch point, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double launchLat() { int o = __offset(82); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the missile launch point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 46.74596844
   * Constraints: No constraints specified.
   */
  public double launchLon() { int o = __offset(84); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Missile azimuth corridor data.
   * Example: /// Example: 12.876
   * Constraints: No constraints specified.
   */
  public double azCorr() { int o = __offset(86); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Track point burnout altitude relative to WGS-84 ellipsoid, in kilometers.
   * Example: /// Example: 30567.452
   * Constraints: No constraints specified.
   */
  public double burnoutAlt() { int o = __offset(88); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
   * Example: /// Example: ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 40
   */
  public String launchAouType() { int o = __offset(90); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer launchAouTypeAsByteBuffer() { return __vector_as_bytebuffer(90, 1); }
  public ByteBuffer launchAouTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 90, 1); }
  /**
   * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
   * &nbsp;ELLIPSE:
   * &nbsp;&nbsp;brg - orientation in degrees of the ellipse
   * &nbsp;&nbsp;a1 - semi-major axis in kilometers
   * &nbsp;&nbsp;a2 - semi-minor axis in kilometers
   * &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
   * &nbsp;&nbsp;brg - orientation in degrees of the bearing box
   * &nbsp;&nbsp;a1 - length of bearing box in kilometers
   * &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
   * &nbsp;OTHER (All other type values):
   * &nbsp;&nbsp;brg - line of bearing in degrees true
   * &nbsp;&nbsp;a1 - bearing error in degrees
   * &nbsp;&nbsp;a2 - estimated range in kilometers.
   * Example: /// Example: [1.23, 2.34, 3.45]
   * Constraints: No constraints specified.
   */
  public String launchAouData(int j) { int o = __offset(92); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int launchAouDataLength() { int o = __offset(92); return o != 0 ? __vector_len(o) : 0; }
  public StringVector launchAouDataVector() { return launchAouDataVector(new StringVector()); }
  public StringVector launchAouDataVector(StringVector obj) { int o = __offset(92); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Estimated time of impact timestamp in ISO8601 UTC format with microsecond precision.
   * Example: /// Example: 2021-02-25T12:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String impactTime() { int o = __offset(94); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer impactTimeAsByteBuffer() { return __vector_as_bytebuffer(94, 1); }
  public ByteBuffer impactTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 94, 1); }
  /**
   * WGS-84 latitude of the missile object impact point, in degrees. -90 to 90 degrees (negative values south of equator).
   * Example: /// Example: 19.88550102
   * Constraints: No constraints specified.
   */
  public double impactLat() { int o = __offset(96); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * WGS-84 longitude of the missile object impact point, in degrees. -180 to 180 degrees (negative values west of Prime Meridian).
   * Example: /// Example: 46.74596844
   * Constraints: No constraints specified.
   */
  public double impactLon() { int o = __offset(98); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The Area of Uncertainty (AoU) type (BEARING, ELLIPSE, OTHER) definition. This type defines the elements of the aouEllp array and is required if aouEllp is not null. See the aouEllp field definition for specific information.
   * Example: /// Example: ELLIPSE
   * Constraints: Minimum length = 0, Maximum length = 40
   */
  public String impactAouType() { int o = __offset(100); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer impactAouTypeAsByteBuffer() { return __vector_as_bytebuffer(100, 1); }
  public ByteBuffer impactAouTypeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 100, 1); }
  /**
   * Three element array representing an Area of Uncertainty (AoU). The array element definitions and units are type specific depending on the aouType specified in this record:
   * &nbsp;ELLIPSE:
   * &nbsp;&nbsp;brg - orientation in degrees of the ellipse
   * &nbsp;&nbsp;a1 - semi-major axis in kilometers
   * &nbsp;&nbsp;a2 - semi-minor axis in kilometers
   * &nbsp;BEARING (BEARING BOX or MTST BEARING BOX):
   * &nbsp;&nbsp;brg - orientation in degrees of the bearing box
   * &nbsp;&nbsp;a1 - length of bearing box in kilometers
   * &nbsp;&nbsp;a2 - half-width of bearing box in kilometers
   * &nbsp;OTHER (All other type values):
   * &nbsp;&nbsp;brg - line of bearing in degrees true
   * &nbsp;&nbsp;a1 - bearing error in degrees
   * &nbsp;&nbsp;a2 - estimated range in kilometers.
   * Example: /// Example: [34.3, 26.5, 1.2]
   * Constraints: No constraints specified.
   */
  public String impactAouData(int j) { int o = __offset(102); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int impactAouDataLength() { int o = __offset(102); return o != 0 ? __vector_len(o) : 0; }
  public StringVector impactAouDataVector() { return impactAouDataVector(new StringVector()); }
  public StringVector impactAouDataVector(StringVector obj) { int o = __offset(102); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Array of MissileTrackVector objects. Missile track vectors are cartesian vectors of position, velocity, and acceleration that, together with their time, 'epoch', uniquely determine the trajectory of the missile. ECEF is the preferred coordinate frame but in some cases data may be in another frame as specified by 'referenceFrame', depending on the provider.
   * Example: /// Example: No example provided.
   * Constraints: No constraints specified.
   */
  public String vectors(int j) { int o = __offset(104); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int vectorsLength() { int o = __offset(104); return o != 0 ? __vector_len(o) : 0; }
  public StringVector vectorsVector() { return vectorsVector(new StringVector()); }
  public StringVector vectorsVector(StringVector obj) { int o = __offset(104); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The originating source network on which this record was created, auto-populated by the system.
   * Example: /// Example: ORIG
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String origNetwork() { int o = __offset(106); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer origNetworkAsByteBuffer() { return __vector_as_bytebuffer(106, 1); }
  public ByteBuffer origNetworkInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 106, 1); }
  /**
   * Time the row was created in the database.
   * Example: /// Example: 2021-02-25T12:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(108); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(108, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 108, 1); }
  /**
   * Application user who created the row in the database.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(110); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(110, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 110, 1); }
  /**
   * Source of the data.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String source() { int o = __offset(112); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(112, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 112, 1); }
  /**
   * Originating system or organization which produced the data, if different from the source. The origin may be different than the source if the source was a mediating system which forwarded the data on behalf of the origin system. If null, the source may be assumed to be the origin.
   * Example: /// Example: THIRD_PARTY_DATASOURCE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String origin() { int o = __offset(114); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer originAsByteBuffer() { return __vector_as_bytebuffer(114, 1); }
  public ByteBuffer originInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 114, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(116); return o != 0 ? bb.get(o + bb_pos) : 0; }

  public static int createMissileTrack_Ingest(FlatBufferBuilder builder,
      int idOffset,
      int classificationMarkingOffset,
      int msgTypeOffset,
      int msgSubTypeOffset,
      int msgCreateDateOffset,
      byte env,
      int objTypeOffset,
      int objTypeConf,
      int objPlatOffset,
      byte objIdent,
      int spaceAmpOffset,
      int objActOffset,
      int spaceSpecTypeOffset,
      int acftSubTypeOffset,
      int nameOffset,
      int callSignOffset,
      boolean lostTrkInd,
      int trackIdOffset,
      int parentTrackIdOffset,
      int muidSrcTrkOffset,
      int muidSrcOffset,
      int alertOffset,
      int mslStatusOffset,
      int tsOffset,
      int aouRptTypeOffset,
      int aouRptDataOffset,
      double containment,
      double trkConf,
      int trkQual,
      double angElev,
      int senModeOffset,
      int infoSourceOffset,
      boolean boosting,
      double polarSingLocLat,
      double polarSingLocLon,
      boolean emgInd,
      boolean dropPtInd,
      int spaceAmpConf,
      int launchTimeOffset,
      double launchLat,
      double launchLon,
      double azCorr,
      double burnoutAlt,
      int launchAouTypeOffset,
      int launchAouDataOffset,
      int impactTimeOffset,
      double impactLat,
      double impactLon,
      int impactAouTypeOffset,
      int impactAouDataOffset,
      int vectorsOffset,
      int origNetworkOffset,
      int createdAtOffset,
      int createdByOffset,
      int sourceOffset,
      int originOffset,
      byte dataMode) {
    builder.startTable(57);
    MissileTrack_Ingest.addImpactLon(builder, impactLon);
    MissileTrack_Ingest.addImpactLat(builder, impactLat);
    MissileTrack_Ingest.addBurnoutAlt(builder, burnoutAlt);
    MissileTrack_Ingest.addAzCorr(builder, azCorr);
    MissileTrack_Ingest.addLaunchLon(builder, launchLon);
    MissileTrack_Ingest.addLaunchLat(builder, launchLat);
    MissileTrack_Ingest.addPolarSingLocLon(builder, polarSingLocLon);
    MissileTrack_Ingest.addPolarSingLocLat(builder, polarSingLocLat);
    MissileTrack_Ingest.addAngElev(builder, angElev);
    MissileTrack_Ingest.addTrkConf(builder, trkConf);
    MissileTrack_Ingest.addContainment(builder, containment);
    MissileTrack_Ingest.addOrigin(builder, originOffset);
    MissileTrack_Ingest.addSource(builder, sourceOffset);
    MissileTrack_Ingest.addCreatedBy(builder, createdByOffset);
    MissileTrack_Ingest.addCreatedAt(builder, createdAtOffset);
    MissileTrack_Ingest.addOrigNetwork(builder, origNetworkOffset);
    MissileTrack_Ingest.addVectors(builder, vectorsOffset);
    MissileTrack_Ingest.addImpactAouData(builder, impactAouDataOffset);
    MissileTrack_Ingest.addImpactAouType(builder, impactAouTypeOffset);
    MissileTrack_Ingest.addImpactTime(builder, impactTimeOffset);
    MissileTrack_Ingest.addLaunchAouData(builder, launchAouDataOffset);
    MissileTrack_Ingest.addLaunchAouType(builder, launchAouTypeOffset);
    MissileTrack_Ingest.addLaunchTime(builder, launchTimeOffset);
    MissileTrack_Ingest.addSpaceAmpConf(builder, spaceAmpConf);
    MissileTrack_Ingest.addInfoSource(builder, infoSourceOffset);
    MissileTrack_Ingest.addSenMode(builder, senModeOffset);
    MissileTrack_Ingest.addTrkQual(builder, trkQual);
    MissileTrack_Ingest.addAouRptData(builder, aouRptDataOffset);
    MissileTrack_Ingest.addAouRptType(builder, aouRptTypeOffset);
    MissileTrack_Ingest.addTs(builder, tsOffset);
    MissileTrack_Ingest.addMslStatus(builder, mslStatusOffset);
    MissileTrack_Ingest.addAlert(builder, alertOffset);
    MissileTrack_Ingest.addMuidSrc(builder, muidSrcOffset);
    MissileTrack_Ingest.addMuidSrcTrk(builder, muidSrcTrkOffset);
    MissileTrack_Ingest.addParentTrackId(builder, parentTrackIdOffset);
    MissileTrack_Ingest.addTrackId(builder, trackIdOffset);
    MissileTrack_Ingest.addCallSign(builder, callSignOffset);
    MissileTrack_Ingest.addName(builder, nameOffset);
    MissileTrack_Ingest.addAcftSubType(builder, acftSubTypeOffset);
    MissileTrack_Ingest.addSpaceSpecType(builder, spaceSpecTypeOffset);
    MissileTrack_Ingest.addObjAct(builder, objActOffset);
    MissileTrack_Ingest.addSpaceAmp(builder, spaceAmpOffset);
    MissileTrack_Ingest.addObjPlat(builder, objPlatOffset);
    MissileTrack_Ingest.addObjTypeConf(builder, objTypeConf);
    MissileTrack_Ingest.addObjType(builder, objTypeOffset);
    MissileTrack_Ingest.addMsgCreateDate(builder, msgCreateDateOffset);
    MissileTrack_Ingest.addMsgSubType(builder, msgSubTypeOffset);
    MissileTrack_Ingest.addMsgType(builder, msgTypeOffset);
    MissileTrack_Ingest.addClassificationMarking(builder, classificationMarkingOffset);
    MissileTrack_Ingest.addId(builder, idOffset);
    MissileTrack_Ingest.addDataMode(builder, dataMode);
    MissileTrack_Ingest.addDropPtInd(builder, dropPtInd);
    MissileTrack_Ingest.addEmgInd(builder, emgInd);
    MissileTrack_Ingest.addBoosting(builder, boosting);
    MissileTrack_Ingest.addLostTrkInd(builder, lostTrkInd);
    MissileTrack_Ingest.addObjIdent(builder, objIdent);
    MissileTrack_Ingest.addEnv(builder, env);
    return MissileTrack_Ingest.endMissileTrack_Ingest(builder);
  }

  public static void startMissileTrack_Ingest(FlatBufferBuilder builder) { builder.startTable(57); }
  public static void addId(FlatBufferBuilder builder, int idOffset) { builder.addOffset(0, idOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addMsgType(FlatBufferBuilder builder, int msgTypeOffset) { builder.addOffset(2, msgTypeOffset, 0); }
  public static void addMsgSubType(FlatBufferBuilder builder, int msgSubTypeOffset) { builder.addOffset(3, msgSubTypeOffset, 0); }
  public static void addMsgCreateDate(FlatBufferBuilder builder, int msgCreateDateOffset) { builder.addOffset(4, msgCreateDateOffset, 0); }
  public static void addEnv(FlatBufferBuilder builder, byte env) { builder.addByte(5, env, 0); }
  public static void addObjType(FlatBufferBuilder builder, int objTypeOffset) { builder.addOffset(6, objTypeOffset, 0); }
  public static void addObjTypeConf(FlatBufferBuilder builder, int objTypeConf) { builder.addInt(7, objTypeConf, 0); }
  public static void addObjPlat(FlatBufferBuilder builder, int objPlatOffset) { builder.addOffset(8, objPlatOffset, 0); }
  public static void addObjIdent(FlatBufferBuilder builder, byte objIdent) { builder.addByte(9, objIdent, 0); }
  public static void addSpaceAmp(FlatBufferBuilder builder, int spaceAmpOffset) { builder.addOffset(10, spaceAmpOffset, 0); }
  public static void addObjAct(FlatBufferBuilder builder, int objActOffset) { builder.addOffset(11, objActOffset, 0); }
  public static void addSpaceSpecType(FlatBufferBuilder builder, int spaceSpecTypeOffset) { builder.addOffset(12, spaceSpecTypeOffset, 0); }
  public static void addAcftSubType(FlatBufferBuilder builder, int acftSubTypeOffset) { builder.addOffset(13, acftSubTypeOffset, 0); }
  public static void addName(FlatBufferBuilder builder, int nameOffset) { builder.addOffset(14, nameOffset, 0); }
  public static void addCallSign(FlatBufferBuilder builder, int callSignOffset) { builder.addOffset(15, callSignOffset, 0); }
  public static void addLostTrkInd(FlatBufferBuilder builder, boolean lostTrkInd) { builder.addBoolean(16, lostTrkInd, false); }
  public static void addTrackId(FlatBufferBuilder builder, int trackIdOffset) { builder.addOffset(17, trackIdOffset, 0); }
  public static void addParentTrackId(FlatBufferBuilder builder, int parentTrackIdOffset) { builder.addOffset(18, parentTrackIdOffset, 0); }
  public static void addMuidSrcTrk(FlatBufferBuilder builder, int muidSrcTrkOffset) { builder.addOffset(19, muidSrcTrkOffset, 0); }
  public static void addMuidSrc(FlatBufferBuilder builder, int muidSrcOffset) { builder.addOffset(20, muidSrcOffset, 0); }
  public static void addAlert(FlatBufferBuilder builder, int alertOffset) { builder.addOffset(21, alertOffset, 0); }
  public static void addMslStatus(FlatBufferBuilder builder, int mslStatusOffset) { builder.addOffset(22, mslStatusOffset, 0); }
  public static void addTs(FlatBufferBuilder builder, int tsOffset) { builder.addOffset(23, tsOffset, 0); }
  public static void addAouRptType(FlatBufferBuilder builder, int aouRptTypeOffset) { builder.addOffset(24, aouRptTypeOffset, 0); }
  public static void addAouRptData(FlatBufferBuilder builder, int aouRptDataOffset) { builder.addOffset(25, aouRptDataOffset, 0); }
  public static int createAouRptDataVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startAouRptDataVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addContainment(FlatBufferBuilder builder, double containment) { builder.addDouble(26, containment, 0.0); }
  public static void addTrkConf(FlatBufferBuilder builder, double trkConf) { builder.addDouble(27, trkConf, 0.0); }
  public static void addTrkQual(FlatBufferBuilder builder, int trkQual) { builder.addInt(28, trkQual, 0); }
  public static void addAngElev(FlatBufferBuilder builder, double angElev) { builder.addDouble(29, angElev, 0.0); }
  public static void addSenMode(FlatBufferBuilder builder, int senModeOffset) { builder.addOffset(30, senModeOffset, 0); }
  public static void addInfoSource(FlatBufferBuilder builder, int infoSourceOffset) { builder.addOffset(31, infoSourceOffset, 0); }
  public static void addBoosting(FlatBufferBuilder builder, boolean boosting) { builder.addBoolean(32, boosting, false); }
  public static void addPolarSingLocLat(FlatBufferBuilder builder, double polarSingLocLat) { builder.addDouble(33, polarSingLocLat, 0.0); }
  public static void addPolarSingLocLon(FlatBufferBuilder builder, double polarSingLocLon) { builder.addDouble(34, polarSingLocLon, 0.0); }
  public static void addEmgInd(FlatBufferBuilder builder, boolean emgInd) { builder.addBoolean(35, emgInd, false); }
  public static void addDropPtInd(FlatBufferBuilder builder, boolean dropPtInd) { builder.addBoolean(36, dropPtInd, false); }
  public static void addSpaceAmpConf(FlatBufferBuilder builder, int spaceAmpConf) { builder.addInt(37, spaceAmpConf, 0); }
  public static void addLaunchTime(FlatBufferBuilder builder, int launchTimeOffset) { builder.addOffset(38, launchTimeOffset, 0); }
  public static void addLaunchLat(FlatBufferBuilder builder, double launchLat) { builder.addDouble(39, launchLat, 0.0); }
  public static void addLaunchLon(FlatBufferBuilder builder, double launchLon) { builder.addDouble(40, launchLon, 0.0); }
  public static void addAzCorr(FlatBufferBuilder builder, double azCorr) { builder.addDouble(41, azCorr, 0.0); }
  public static void addBurnoutAlt(FlatBufferBuilder builder, double burnoutAlt) { builder.addDouble(42, burnoutAlt, 0.0); }
  public static void addLaunchAouType(FlatBufferBuilder builder, int launchAouTypeOffset) { builder.addOffset(43, launchAouTypeOffset, 0); }
  public static void addLaunchAouData(FlatBufferBuilder builder, int launchAouDataOffset) { builder.addOffset(44, launchAouDataOffset, 0); }
  public static int createLaunchAouDataVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startLaunchAouDataVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addImpactTime(FlatBufferBuilder builder, int impactTimeOffset) { builder.addOffset(45, impactTimeOffset, 0); }
  public static void addImpactLat(FlatBufferBuilder builder, double impactLat) { builder.addDouble(46, impactLat, 0.0); }
  public static void addImpactLon(FlatBufferBuilder builder, double impactLon) { builder.addDouble(47, impactLon, 0.0); }
  public static void addImpactAouType(FlatBufferBuilder builder, int impactAouTypeOffset) { builder.addOffset(48, impactAouTypeOffset, 0); }
  public static void addImpactAouData(FlatBufferBuilder builder, int impactAouDataOffset) { builder.addOffset(49, impactAouDataOffset, 0); }
  public static int createImpactAouDataVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startImpactAouDataVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addVectors(FlatBufferBuilder builder, int vectorsOffset) { builder.addOffset(50, vectorsOffset, 0); }
  public static int createVectorsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startVectorsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addOrigNetwork(FlatBufferBuilder builder, int origNetworkOffset) { builder.addOffset(51, origNetworkOffset, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(52, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(53, createdByOffset, 0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(54, sourceOffset, 0); }
  public static void addOrigin(FlatBufferBuilder builder, int originOffset) { builder.addOffset(55, originOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(56, dataMode, 0); }
  public static int endMissileTrack_Ingest(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishMissileTrack_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "MISS"); }
  public static void finishSizePrefixedMissileTrack_IngestBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "MISS"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public MissileTrack_Ingest get(int j) { return get(new MissileTrack_Ingest(), j); }
    public MissileTrack_Ingest get(MissileTrack_Ingest obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

