// automatically generated by the FlatBuffers compiler, do not modify

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * /// Model representation of additional detailed observation data for electro-optical based sensor phenomenologies.
 */
@SuppressWarnings("unused")
public final class EOObservationDetails_Full extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static EOObservationDetails_Full getRootAsEOObservationDetails_Full(ByteBuffer _bb) { return getRootAsEOObservationDetails_Full(_bb, new EOObservationDetails_Full()); }
  public static EOObservationDetails_Full getRootAsEOObservationDetails_Full(ByteBuffer _bb, EOObservationDetails_Full obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public static boolean EOObservationDetails_FullBufferHasIdentifier(ByteBuffer _bb) { return __has_identifier(_bb, "EOOB"); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public EOObservationDetails_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Unique identifier of the parent EOObservation.
   * Example: /// Example: EOOBSERVATION-ID
   * Constraints: Minimum length = 1, Maximum length = 36
   */
  public String idEoobservation() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer idEoobservationAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer idEoobservationInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Classification marking of the data in IC/CAPCO Portion-marked format, will be set to EOObservation classificationMarking if blank.
   * Example: /// Example: U
   * Constraints: Minimum length = 1, Maximum length = 128
   */
  public String classificationMarking() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer classificationMarkingAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer classificationMarkingInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Ob detection time in ISO 8601 UTC with microsecond precision, will be set to EOObservation obTime if blank.
   * Example: /// Example: 2018-01-01T16:00:00.123456Z
   * Constraints: No constraints specified.
   */
  public String obTime() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer obTimeAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer obTimeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Predicted Right Ascension of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
   * Example: /// Example: 10.1
   * Constraints: No constraints specified.
   */
  public double predictedRa() { int o = __offset(10); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Predicted Declination of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
   * Example: /// Example: 10.1
   * Constraints: No constraints specified.
   */
  public double predictedDeclination() { int o = __offset(12); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Predicted Azimuth angle of the target object from a ground -based sensor (no atmospheric refraction correction required). AZ_EL implies apparent topocentric place in true of date reference frame as seen from the observer with aberration due to the observer velocity and light travel time applied.
   * Example: /// Example: 10.1
   * Constraints: No constraints specified.
   */
  public double predictedAzimuth() { int o = __offset(14); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Predicted elevation angle of the target object from a ground -based sensor (no atmospheric refraction correction required). AZ_EL implies apparent topocentric place in true of date reference frame as seen from the observer with aberration due to the observer velocity and light travel time applied.
   * Example: /// Example: 10.1
   * Constraints: No constraints specified.
   */
  public double predictedElevation() { int o = __offset(16); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Azimuth angle of the sun from a ground-based telescope (no atmospheric refraction correction required) the observer with aberration due to the observer velocity and light travel time applied.
   * Example: /// Example: 10.1
   * Constraints: No constraints specified.
   */
  public double sunAzimuth() { int o = __offset(18); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Elevation angle of the sun from a ground-based telescope (no atmospheric refraction correction required).
   * Example: /// Example: 10.1
   * Constraints: No constraints specified.
   */
  public double sunElevation() { int o = __offset(20); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The value is the number of spectral filters used.
   * Example: /// Example: 10
   * Constraints: No constraints specified.
   */
  public int numSpectralFilters() { int o = __offset(22); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Array of the SpectralFilters keywords, must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: ['Keyword1', 'Keyword2']
   * Constraints: No constraints specified.
   */
  public String spectralFilters(int j) { int o = __offset(24); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int spectralFiltersLength() { int o = __offset(24); return o != 0 ? __vector_len(o) : 0; }
  public StringVector spectralFiltersVector() { return spectralFiltersVector(new StringVector()); }
  public StringVector spectralFiltersVector(StringVector obj) { int o = __offset(24); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * This is the in-band average irradiance of a 0th mag source. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.  Units = W/m2/nm.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String spectralZmfl(int j) { int o = __offset(26); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int spectralZmflLength() { int o = __offset(26); return o != 0 ? __vector_len(o) : 0; }
  public StringVector spectralZmflVector() { return spectralZmflVector(new StringVector()); }
  public StringVector spectralZmflVector(StringVector obj) { int o = __offset(26); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * This is the in-band solar magnitude at 1 A.U. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.  Units = mag.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String spectralFilterSolarMag(int j) { int o = __offset(28); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int spectralFilterSolarMagLength() { int o = __offset(28); return o != 0 ? __vector_len(o) : 0; }
  public StringVector spectralFilterSolarMagVector() { return spectralFilterSolarMagVector(new StringVector()); }
  public StringVector spectralFilterSolarMagVector(StringVector obj) { int o = __offset(28); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * This is the value for the zero-point calculated for each filter denoted in spectralFilters. It is the difference between the catalog mag and instrumental mag for a set of standard stars. For use with All Sky photometry. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String zeroPoints(int j) { int o = __offset(30); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int zeroPointsLength() { int o = __offset(30); return o != 0 ? __vector_len(o) : 0; }
  public StringVector zeroPointsVector() { return zeroPointsVector(new StringVector()); }
  public StringVector zeroPointsVector(StringVector obj) { int o = __offset(30); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * This is the uncertainty in the zero point for the filter denoted in spectralFilters. For use with All Sky photometry. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String zeroPointsUnc(int j) { int o = __offset(32); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int zeroPointsUncLength() { int o = __offset(32); return o != 0 ? __vector_len(o) : 0; }
  public StringVector zeroPointsUncVector() { return zeroPointsUncVector(new StringVector()); }
  public StringVector zeroPointsUncVector(StringVector obj) { int o = __offset(32); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The extinction coefficient computed for the nth filter. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n. Units = mag/airmass.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String extinctionCoeffs(int j) { int o = __offset(34); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int extinctionCoeffsLength() { int o = __offset(34); return o != 0 ? __vector_len(o) : 0; }
  public StringVector extinctionCoeffsVector() { return extinctionCoeffsVector(new StringVector()); }
  public StringVector extinctionCoeffsVector(StringVector obj) { int o = __offset(34); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * This is the uncertainty in the extinction coefficient for the nth filter. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n. -9999 for space-based sensors. Units = mag/airmass.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String extinctionCoeffsUnc(int j) { int o = __offset(36); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int extinctionCoeffsUncLength() { int o = __offset(36); return o != 0 ? __vector_len(o) : 0; }
  public StringVector extinctionCoeffsUncVector() { return extinctionCoeffsUncVector(new StringVector()); }
  public StringVector extinctionCoeffsUncVector(StringVector obj) { int o = __offset(36); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Color coefficient for filter n for a space-based sensor where there is no atmospheric extinction. Must be present for all values n=1 to numSpectralFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String colorCoeffs(int j) { int o = __offset(38); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int colorCoeffsLength() { int o = __offset(38); return o != 0 ? __vector_len(o) : 0; }
  public StringVector colorCoeffsVector() { return colorCoeffsVector(new StringVector()); }
  public StringVector colorCoeffsVector(StringVector obj) { int o = __offset(38); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The value is the number of neutral density filters used.
   * Example: /// Example: 12
   * Constraints: No constraints specified.
   */
  public int numNeutralDensityFilters() { int o = __offset(40); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Must be present for all values n=1 to numNeutralDensityFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: ['numNeutralDensityFilters1', 'numNeutralDensityFilters2']
   * Constraints: No constraints specified.
   */
  public String neutralDensityFilterNames(int j) { int o = __offset(42); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int neutralDensityFilterNamesLength() { int o = __offset(42); return o != 0 ? __vector_len(o) : 0; }
  public StringVector neutralDensityFilterNamesVector() { return neutralDensityFilterNamesVector(new StringVector()); }
  public StringVector neutralDensityFilterNamesVector(StringVector obj) { int o = __offset(42); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * The transmission of the nth neutral density filter. Must be present for all values n=1 to numNeutralDensityFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String neutralDensityFilterTransmissions(int j) { int o = __offset(44); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int neutralDensityFilterTransmissionsLength() { int o = __offset(44); return o != 0 ? __vector_len(o) : 0; }
  public StringVector neutralDensityFilterTransmissionsVector() { return neutralDensityFilterTransmissionsVector(new StringVector()); }
  public StringVector neutralDensityFilterTransmissionsVector(StringVector obj) { int o = __offset(44); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * This is the uncertainty in the transmission for the nth filter. Must be present for all values n=1 to numNeutralDensityFilters, in incrementing order of n, and for no other values of n.
   * Example: /// Example: [1.1, 2.1, 3.1]
   * Constraints: No constraints specified.
   */
  public String neutralDensityFilterTransmissionsUnc(int j) { int o = __offset(46); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int neutralDensityFilterTransmissionsUncLength() { int o = __offset(46); return o != 0 ? __vector_len(o) : 0; }
  public StringVector neutralDensityFilterTransmissionsUncVector() { return neutralDensityFilterTransmissionsUncVector(new StringVector()); }
  public StringVector neutralDensityFilterTransmissionsUncVector(StringVector obj) { int o = __offset(46); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Some sensors have gain settings. This value is the gain used during the observation in units e-/ADU. If no gain is used, the value = 1.
   * Example: /// Example: 234.2
   * Constraints: No constraints specified.
   */
  public double gain() { int o = __offset(48); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sensor instantaneous field of view (ratio of pixel pitch to focal length).
   * Example: /// Example: 0.2
   * Constraints: No constraints specified.
   */
  public double ifov() { int o = __offset(50); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Pixel array size (width) in pixels.
   * Example: /// Example: 12
   * Constraints: No constraints specified.
   */
  public int pixelArrayWidth() { int o = __offset(52); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Pixel array size (height) in pixels.
   * Example: /// Example: 23
   * Constraints: No constraints specified.
   */
  public int pixelArrayHeight() { int o = __offset(54); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Minimum valid pixel value, this is typically 0.
   * Example: /// Example: 12
   * Constraints: No constraints specified.
   */
  public int pixelMin() { int o = __offset(56); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Maximum valid pixel value, this is defined as 2^(number of bits per pixel). For example, a CCD with 8-bitpixels, would have a maximum valid pixel value of 2^8 = 256. This can represent the saturation value of the detector, but some sensors will saturate at a value significantly lower than full well depth. This is the analog-to-digital conversion (ADC) saturation value.
   * Example: /// Example: 256
   * Constraints: No constraints specified.
   */
  public int pixelMax() { int o = __offset(58); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Observed centroid row number on the focal plane in pixels (0 is top edge, 0.5 is center of pixels along top of image).
   * Example: /// Example: 0.1
   * Constraints: No constraints specified.
   */
  public double centroidRow() { int o = __offset(60); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Observed centroid column number on the focal plane in pixels (0 is left edge, 0.5 is center of pixels along left of image).
   * Example: /// Example: 0.5
   * Constraints: No constraints specified.
   */
  public double centroidColumn() { int o = __offset(62); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Spatial variance of image distribution in vertical direction measured in pixels squared.
   * Example: /// Example: 0.1
   * Constraints: No constraints specified.
   */
  public double rowVariance() { int o = __offset(64); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Spatial variance of image distribution in horizontal direction measured in pixels squared.
   * Example: /// Example: 0.1
   * Constraints: No constraints specified.
   */
  public double columnVariance() { int o = __offset(66); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Spatial covariance of image distribution across horizontal and vertical directions measured in pixels squared.
   * Example: /// Example: 0.01
   * Constraints: No constraints specified.
   */
  public double rowColCov() { int o = __offset(68); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * An array of measurements that correspond to the distance from the streak center measured from the optical image in pixels that show change over an interval of time. The array length is dependent on the length of the streak. The distFromStreakCenter, surfBrightness, and surfBrightnessUnc arrays will match in size.
   * Example: /// Example: [-127.153, -126.153, -125.153]
   * Constraints: No constraints specified.
   */
  public String distFromStreakCenter(int j) { int o = __offset(70); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int distFromStreakCenterLength() { int o = __offset(70); return o != 0 ? __vector_len(o) : 0; }
  public StringVector distFromStreakCenterVector() { return distFromStreakCenterVector(new StringVector()); }
  public StringVector distFromStreakCenterVector(StringVector obj) { int o = __offset(70); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * An array of surface brightness measurements in magnitudes per square arcsecond from the optical image that show change over an interval of time. The array length is dependent on the length of the streak. The distFromStreakCenter, surfBrightness, and surfBrightnessUnc arrays will match in size.
   * Example: /// Example: [21.01, 21.382, 21.725]
   * Constraints: No constraints specified.
   */
  public String surfBrightness(int j) { int o = __offset(72); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int surfBrightnessLength() { int o = __offset(72); return o != 0 ? __vector_len(o) : 0; }
  public StringVector surfBrightnessVector() { return surfBrightnessVector(new StringVector()); }
  public StringVector surfBrightnessVector(StringVector obj) { int o = __offset(72); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * An array of surface brightness uncertainty measurements in magnitudes per square arcsecond from the optical image that show change over an interval of time. The array length is dependent on the length of the streak. The distFromStreakCenter, surfBrightness, and surfBrightnessUnc arrays will match in size.
   * Example: /// Example: [0.165, 0.165, 0.165]
   * Constraints: No constraints specified.
   */
  public String surfBrightnessUnc(int j) { int o = __offset(74); return o != 0 ? __string(__vector(o) + j * 4) : null; }
  public int surfBrightnessUncLength() { int o = __offset(74); return o != 0 ? __vector_len(o) : 0; }
  public StringVector surfBrightnessUncVector() { return surfBrightnessUncVector(new StringVector()); }
  public StringVector surfBrightnessUncVector(StringVector obj) { int o = __offset(74); return o != 0 ? obj.__assign(__vector(o), 4, bb) : null; }
  /**
   * Uncertainty in the times reported in UTC in seconds.
   * Example: /// Example: 13.1
   * Constraints: No constraints specified.
   */
  public double timesUnc() { int o = __offset(76); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Operating temperature of CCD recorded during exposure or measured during calibrations in K.
   * Example: /// Example: 123.4
   * Constraints: No constraints specified.
   */
  public double ccdTemp() { int o = __offset(78); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The reference number, x, where x ranges from 1 to n, where n is the number specified in spectralFilters that corresponds to the spectral filter given in the corresponding spectralFilterNames.
   * Example: /// Example: 23
   * Constraints: No constraints specified.
   */
  public int currentSpectralFilterNum() { int o = __offset(80); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The reference number n, in neutralDensityFilters for the currently used neutral density filter.
   * Example: /// Example: 3
   * Constraints: No constraints specified.
   */
  public int currentNeutralDensityFilterNum() { int o = __offset(82); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of pixels binned horizontally.
   * Example: /// Example: 12
   * Constraints: No constraints specified.
   */
  public int binningHoriz() { int o = __offset(84); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The number of pixels binned vertically.
   * Example: /// Example: 14
   * Constraints: No constraints specified.
   */
  public int binningVert() { int o = __offset(86); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Number of stars used in photometric fit count.
   * Example: /// Example: 23
   * Constraints: No constraints specified.
   */
  public int pcalNumStars() { int o = __offset(88); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * The x centroid position on the CCD of the target object in pixels.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double ccdObjPosX() { int o = __offset(90); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * The y centroid position on the CCD of the target object in pixels.
   * Example: /// Example: 321.4
   * Constraints: No constraints specified.
   */
  public double ccdObjPosY() { int o = __offset(92); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * This is the pixel width of the target. This is either a frame-by-frame measurement or a constant point spread function or synthetic aperture used in the extraction.
   * Example: /// Example: 133.2
   * Constraints: No constraints specified.
   */
  public double ccdObjWidth() { int o = __offset(94); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * This is the background signal at or in the vicinity of the radiometric source position. Specifically, this is the average background count level (DN/pixel) divided by the exposure time in seconds of the background pixels used in the photometric extraction. DN/pixel/sec.
   * Example: /// Example: 4134.1
   * Constraints: No constraints specified.
   */
  public double backgroundSignal() { int o = __offset(96); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Estimated 1-sigma uncertainty in the background signal at or in the vicinity of the radiometric source position. DN/pixel/sec.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double backgroundSignalUnc() { int o = __offset(98); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Peak Aperture Raw Counts is the value of the peak pixel in the real or synthetic aperture containing the target signal.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double peakApertureCount() { int o = __offset(100); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Peak Background Raw Counts is the largest pixel value used in background signal.
   * Example: /// Example: 321
   * Constraints: No constraints specified.
   */
  public int peakBackgroundCount() { int o = __offset(102); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Estimated signal-to-noise ratio (SNR) for the total radiometric signal. Under some algorithms, this can be a constant per target (not per observation). Note: this SNR applies to the total signal of the radiometric source (i.e., Net_Obj_Sig with units DN/sec), not to be confused with the SNR of the signal in the peak pixel (i.e., DN/pixel/sec).
   * Example: /// Example: 13.4
   * Constraints: No constraints specified.
   */
  public double snrEst() { int o = __offset(104); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Instrumental magnitude of a sensor before corrections are applied for atmosphere or to transform to standard magnitude scale.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double magInstrumental() { int o = __offset(106); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Uncertainty in the instrumental magnitude.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double magInstrumentalUnc() { int o = __offset(108); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Optical Cross Section computed in units m(2)/ster.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double opticalCrossSection() { int o = __offset(110); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Uncertainty in Optical Cross Section computed in units m(2)/ster.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double opticalCrossSectionUnc() { int o = __offset(112); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sun state vector in ECI J2000 coordinate frame in km.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double sunStatePosX() { int o = __offset(114); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sun state vector in ECI J2000 coordinate frame in km.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double sunStatePosY() { int o = __offset(116); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sun state vector in ECI J2000 coordinate frame in km.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double sunStatePosZ() { int o = __offset(118); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sun state vector in ECI J2000 coordinate frame in km/sec.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double sunStateVelX() { int o = __offset(120); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sun state vector in ECI J2000 coordinate frame in km/sec.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double sunStateVelY() { int o = __offset(122); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Sun state vector in ECI J2000 coordinate frame in km/sec.
   * Example: /// Example: 123.3
   * Constraints: No constraints specified.
   */
  public double sunStateVelZ() { int o = __offset(124); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Number of catalog stars in the detector field of view (FOV) with the target object. Can be 0 for narrow FOV sensors.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int numCatalogStars() { int o = __offset(126); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Number of detected stars in the FOV with the target object. Helps identify frames with clouds.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int numDetectedStars() { int o = __offset(128); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Number of correlated stars in the FOV with the target object. Can be 0 for narrow FOV sensors.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int numCorrelatedStars() { int o = __offset(130); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Uncertainty of predicted Right Ascension of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double predictedRaUnc() { int o = __offset(132); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Uncertainty of Predicted Declination of the Target object from the frame of reference of the sensor (J2000, geocentric velocity aberration). SGP4 and VCMs produce geocentric origin and velocity aberration and subtracting the sensor geocentric position of the sensor places in its reference frame.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double predictedDeclinationUnc() { int o = __offset(134); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Covariance (x^2) in measured Right Ascension (X) in deg^2.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double raCov() { int o = __offset(136); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Covariance (Y^2) in measured declination (Y) in deg^2.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double declinationCov() { int o = __offset(138); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Covariance (XY) in measured ra/declination (XY) in deg^2.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double raDeclinationCov() { int o = __offset(140); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * World Coordinate System (WCS) X pixel origin in astrometric fit.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double acalCrPixX() { int o = __offset(142); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * World Coordinate System (WCS) Y pixel origin in astrometric fit.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double acalCrPixY() { int o = __offset(144); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * World Coordinate System (WCS) equatorial coordinate X origin corresponding to CRPIX in astrometric fit in degrees.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double acalCrValX() { int o = __offset(146); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * World Coordinate System (WCS) equatorial coordinate Y origin corresponding to CRPIX in astrometric fit in degrees.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double acalCrValY() { int o = __offset(148); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Number of stars used in astrometric fit.
   * Example: /// Example: 123
   * Constraints: No constraints specified.
   */
  public int acalNumStars() { int o = __offset(150); return o != 0 ? bb.getInt(o + bb_pos) : 0; }
  /**
   * Distance from the target object to the sun during the observation in meters.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double objSunRange() { int o = __offset(152); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Solar phase angle bisector vector. The vector that bisects the solar phase angle. The phase angle bisector is the angle that is << of the value in #48. Then calculate the point on the RA/DEC (ECI J2000.0) sphere that a vector at this angle would intersect.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double phaseAngBisect() { int o = __offset(154); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Fraction of the sun that is illuminating the target object. This indicates if the target is in the Earthâ€™s penumbra or umbra. (It is 0 when object is in umbra and 1 when object is fully illuminated.).
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double solarDiskFrac() { int o = __offset(156); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Time off element set.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double toes() { int o = __offset(158); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Degrees Off Element Set.
   * Example: /// Example: 123.2
   * Constraints: No constraints specified.
   */
  public double does() { int o = __offset(160); return o != 0 ? bb.getDouble(o + bb_pos) : 0.0; }
  /**
   * Source of the data, will be set to EOObservation source if blank.
   * Example: /// Example: Bluestaq
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String source() { int o = __offset(162); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer sourceAsByteBuffer() { return __vector_as_bytebuffer(162, 1); }
  public ByteBuffer sourceInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 162, 1); }
  /**
   * Indicator of whether the data is EXERCISE, REAL, SIMULATED, or TEST data:
   * EXERCISE:&nbsp;Data pertaining to a government or military exercise. The data may include both real and simulated data.
   * REAL:&nbsp;Data collected or produced that pertains to real-world objects, events, and analysis.
   * SIMULATED:&nbsp;Synthetic data generated by a model to mimic real-world datasets.
   * TEST:&nbsp;Specific datasets used to evaluate compliance with specifications and requirements, and for validating technical, functional, and performance characteristics.
   * , will be set to EOObservation dataMode if blank.
   * Example: /// Example: TEST
   * Constraints: Minimum length = 1, Maximum length = 32
   */
  public byte dataMode() { int o = __offset(164); return o != 0 ? bb.get(o + bb_pos) : 0; }
  /**
   * Time the row was created in the database, auto-populated by the system.
   * Example: /// Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String createdAt() { int o = __offset(166); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdAtAsByteBuffer() { return __vector_as_bytebuffer(166, 1); }
  public ByteBuffer createdAtInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 166, 1); }
  /**
   * Application user who created the row in the database, auto-populated by the system.
   * Example: /// Example: some.user
   * Constraints: Minimum length = 1, Maximum length = 64
   */
  public String createdBy() { int o = __offset(168); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer createdByAsByteBuffer() { return __vector_as_bytebuffer(168, 1); }
  public ByteBuffer createdByInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 168, 1); }

  public static int createEOObservationDetails_Full(FlatBufferBuilder builder,
      int idEoobservationOffset,
      int classificationMarkingOffset,
      int obTimeOffset,
      double predictedRa,
      double predictedDeclination,
      double predictedAzimuth,
      double predictedElevation,
      double sunAzimuth,
      double sunElevation,
      int numSpectralFilters,
      int spectralFiltersOffset,
      int spectralZmflOffset,
      int spectralFilterSolarMagOffset,
      int zeroPointsOffset,
      int zeroPointsUncOffset,
      int extinctionCoeffsOffset,
      int extinctionCoeffsUncOffset,
      int colorCoeffsOffset,
      int numNeutralDensityFilters,
      int neutralDensityFilterNamesOffset,
      int neutralDensityFilterTransmissionsOffset,
      int neutralDensityFilterTransmissionsUncOffset,
      double gain,
      double ifov,
      int pixelArrayWidth,
      int pixelArrayHeight,
      int pixelMin,
      int pixelMax,
      double centroidRow,
      double centroidColumn,
      double rowVariance,
      double columnVariance,
      double rowColCov,
      int distFromStreakCenterOffset,
      int surfBrightnessOffset,
      int surfBrightnessUncOffset,
      double timesUnc,
      double ccdTemp,
      int currentSpectralFilterNum,
      int currentNeutralDensityFilterNum,
      int binningHoriz,
      int binningVert,
      int pcalNumStars,
      double ccdObjPosX,
      double ccdObjPosY,
      double ccdObjWidth,
      double backgroundSignal,
      double backgroundSignalUnc,
      double peakApertureCount,
      int peakBackgroundCount,
      double snrEst,
      double magInstrumental,
      double magInstrumentalUnc,
      double opticalCrossSection,
      double opticalCrossSectionUnc,
      double sunStatePosX,
      double sunStatePosY,
      double sunStatePosZ,
      double sunStateVelX,
      double sunStateVelY,
      double sunStateVelZ,
      int numCatalogStars,
      int numDetectedStars,
      int numCorrelatedStars,
      double predictedRaUnc,
      double predictedDeclinationUnc,
      double raCov,
      double declinationCov,
      double raDeclinationCov,
      double acalCrPixX,
      double acalCrPixY,
      double acalCrValX,
      double acalCrValY,
      int acalNumStars,
      double objSunRange,
      double phaseAngBisect,
      double solarDiskFrac,
      double toes,
      double does,
      int sourceOffset,
      byte dataMode,
      int createdAtOffset,
      int createdByOffset) {
    builder.startTable(83);
    EOObservationDetails_Full.addDoes(builder, does);
    EOObservationDetails_Full.addToes(builder, toes);
    EOObservationDetails_Full.addSolarDiskFrac(builder, solarDiskFrac);
    EOObservationDetails_Full.addPhaseAngBisect(builder, phaseAngBisect);
    EOObservationDetails_Full.addObjSunRange(builder, objSunRange);
    EOObservationDetails_Full.addAcalCrValY(builder, acalCrValY);
    EOObservationDetails_Full.addAcalCrValX(builder, acalCrValX);
    EOObservationDetails_Full.addAcalCrPixY(builder, acalCrPixY);
    EOObservationDetails_Full.addAcalCrPixX(builder, acalCrPixX);
    EOObservationDetails_Full.addRaDeclinationCov(builder, raDeclinationCov);
    EOObservationDetails_Full.addDeclinationCov(builder, declinationCov);
    EOObservationDetails_Full.addRaCov(builder, raCov);
    EOObservationDetails_Full.addPredictedDeclinationUnc(builder, predictedDeclinationUnc);
    EOObservationDetails_Full.addPredictedRaUnc(builder, predictedRaUnc);
    EOObservationDetails_Full.addSunStateVelZ(builder, sunStateVelZ);
    EOObservationDetails_Full.addSunStateVelY(builder, sunStateVelY);
    EOObservationDetails_Full.addSunStateVelX(builder, sunStateVelX);
    EOObservationDetails_Full.addSunStatePosZ(builder, sunStatePosZ);
    EOObservationDetails_Full.addSunStatePosY(builder, sunStatePosY);
    EOObservationDetails_Full.addSunStatePosX(builder, sunStatePosX);
    EOObservationDetails_Full.addOpticalCrossSectionUnc(builder, opticalCrossSectionUnc);
    EOObservationDetails_Full.addOpticalCrossSection(builder, opticalCrossSection);
    EOObservationDetails_Full.addMagInstrumentalUnc(builder, magInstrumentalUnc);
    EOObservationDetails_Full.addMagInstrumental(builder, magInstrumental);
    EOObservationDetails_Full.addSnrEst(builder, snrEst);
    EOObservationDetails_Full.addPeakApertureCount(builder, peakApertureCount);
    EOObservationDetails_Full.addBackgroundSignalUnc(builder, backgroundSignalUnc);
    EOObservationDetails_Full.addBackgroundSignal(builder, backgroundSignal);
    EOObservationDetails_Full.addCcdObjWidth(builder, ccdObjWidth);
    EOObservationDetails_Full.addCcdObjPosY(builder, ccdObjPosY);
    EOObservationDetails_Full.addCcdObjPosX(builder, ccdObjPosX);
    EOObservationDetails_Full.addCcdTemp(builder, ccdTemp);
    EOObservationDetails_Full.addTimesUnc(builder, timesUnc);
    EOObservationDetails_Full.addRowColCov(builder, rowColCov);
    EOObservationDetails_Full.addColumnVariance(builder, columnVariance);
    EOObservationDetails_Full.addRowVariance(builder, rowVariance);
    EOObservationDetails_Full.addCentroidColumn(builder, centroidColumn);
    EOObservationDetails_Full.addCentroidRow(builder, centroidRow);
    EOObservationDetails_Full.addIfov(builder, ifov);
    EOObservationDetails_Full.addGain(builder, gain);
    EOObservationDetails_Full.addSunElevation(builder, sunElevation);
    EOObservationDetails_Full.addSunAzimuth(builder, sunAzimuth);
    EOObservationDetails_Full.addPredictedElevation(builder, predictedElevation);
    EOObservationDetails_Full.addPredictedAzimuth(builder, predictedAzimuth);
    EOObservationDetails_Full.addPredictedDeclination(builder, predictedDeclination);
    EOObservationDetails_Full.addPredictedRa(builder, predictedRa);
    EOObservationDetails_Full.addCreatedBy(builder, createdByOffset);
    EOObservationDetails_Full.addCreatedAt(builder, createdAtOffset);
    EOObservationDetails_Full.addSource(builder, sourceOffset);
    EOObservationDetails_Full.addAcalNumStars(builder, acalNumStars);
    EOObservationDetails_Full.addNumCorrelatedStars(builder, numCorrelatedStars);
    EOObservationDetails_Full.addNumDetectedStars(builder, numDetectedStars);
    EOObservationDetails_Full.addNumCatalogStars(builder, numCatalogStars);
    EOObservationDetails_Full.addPeakBackgroundCount(builder, peakBackgroundCount);
    EOObservationDetails_Full.addPcalNumStars(builder, pcalNumStars);
    EOObservationDetails_Full.addBinningVert(builder, binningVert);
    EOObservationDetails_Full.addBinningHoriz(builder, binningHoriz);
    EOObservationDetails_Full.addCurrentNeutralDensityFilterNum(builder, currentNeutralDensityFilterNum);
    EOObservationDetails_Full.addCurrentSpectralFilterNum(builder, currentSpectralFilterNum);
    EOObservationDetails_Full.addSurfBrightnessUnc(builder, surfBrightnessUncOffset);
    EOObservationDetails_Full.addSurfBrightness(builder, surfBrightnessOffset);
    EOObservationDetails_Full.addDistFromStreakCenter(builder, distFromStreakCenterOffset);
    EOObservationDetails_Full.addPixelMax(builder, pixelMax);
    EOObservationDetails_Full.addPixelMin(builder, pixelMin);
    EOObservationDetails_Full.addPixelArrayHeight(builder, pixelArrayHeight);
    EOObservationDetails_Full.addPixelArrayWidth(builder, pixelArrayWidth);
    EOObservationDetails_Full.addNeutralDensityFilterTransmissionsUnc(builder, neutralDensityFilterTransmissionsUncOffset);
    EOObservationDetails_Full.addNeutralDensityFilterTransmissions(builder, neutralDensityFilterTransmissionsOffset);
    EOObservationDetails_Full.addNeutralDensityFilterNames(builder, neutralDensityFilterNamesOffset);
    EOObservationDetails_Full.addNumNeutralDensityFilters(builder, numNeutralDensityFilters);
    EOObservationDetails_Full.addColorCoeffs(builder, colorCoeffsOffset);
    EOObservationDetails_Full.addExtinctionCoeffsUnc(builder, extinctionCoeffsUncOffset);
    EOObservationDetails_Full.addExtinctionCoeffs(builder, extinctionCoeffsOffset);
    EOObservationDetails_Full.addZeroPointsUnc(builder, zeroPointsUncOffset);
    EOObservationDetails_Full.addZeroPoints(builder, zeroPointsOffset);
    EOObservationDetails_Full.addSpectralFilterSolarMag(builder, spectralFilterSolarMagOffset);
    EOObservationDetails_Full.addSpectralZmfl(builder, spectralZmflOffset);
    EOObservationDetails_Full.addSpectralFilters(builder, spectralFiltersOffset);
    EOObservationDetails_Full.addNumSpectralFilters(builder, numSpectralFilters);
    EOObservationDetails_Full.addObTime(builder, obTimeOffset);
    EOObservationDetails_Full.addClassificationMarking(builder, classificationMarkingOffset);
    EOObservationDetails_Full.addIdEoobservation(builder, idEoobservationOffset);
    EOObservationDetails_Full.addDataMode(builder, dataMode);
    return EOObservationDetails_Full.endEOObservationDetails_Full(builder);
  }

  public static void startEOObservationDetails_Full(FlatBufferBuilder builder) { builder.startTable(83); }
  public static void addIdEoobservation(FlatBufferBuilder builder, int idEoobservationOffset) { builder.addOffset(0, idEoobservationOffset, 0); }
  public static void addClassificationMarking(FlatBufferBuilder builder, int classificationMarkingOffset) { builder.addOffset(1, classificationMarkingOffset, 0); }
  public static void addObTime(FlatBufferBuilder builder, int obTimeOffset) { builder.addOffset(2, obTimeOffset, 0); }
  public static void addPredictedRa(FlatBufferBuilder builder, double predictedRa) { builder.addDouble(3, predictedRa, 0.0); }
  public static void addPredictedDeclination(FlatBufferBuilder builder, double predictedDeclination) { builder.addDouble(4, predictedDeclination, 0.0); }
  public static void addPredictedAzimuth(FlatBufferBuilder builder, double predictedAzimuth) { builder.addDouble(5, predictedAzimuth, 0.0); }
  public static void addPredictedElevation(FlatBufferBuilder builder, double predictedElevation) { builder.addDouble(6, predictedElevation, 0.0); }
  public static void addSunAzimuth(FlatBufferBuilder builder, double sunAzimuth) { builder.addDouble(7, sunAzimuth, 0.0); }
  public static void addSunElevation(FlatBufferBuilder builder, double sunElevation) { builder.addDouble(8, sunElevation, 0.0); }
  public static void addNumSpectralFilters(FlatBufferBuilder builder, int numSpectralFilters) { builder.addInt(9, numSpectralFilters, 0); }
  public static void addSpectralFilters(FlatBufferBuilder builder, int spectralFiltersOffset) { builder.addOffset(10, spectralFiltersOffset, 0); }
  public static int createSpectralFiltersVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSpectralFiltersVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSpectralZmfl(FlatBufferBuilder builder, int spectralZmflOffset) { builder.addOffset(11, spectralZmflOffset, 0); }
  public static int createSpectralZmflVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSpectralZmflVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSpectralFilterSolarMag(FlatBufferBuilder builder, int spectralFilterSolarMagOffset) { builder.addOffset(12, spectralFilterSolarMagOffset, 0); }
  public static int createSpectralFilterSolarMagVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSpectralFilterSolarMagVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addZeroPoints(FlatBufferBuilder builder, int zeroPointsOffset) { builder.addOffset(13, zeroPointsOffset, 0); }
  public static int createZeroPointsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startZeroPointsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addZeroPointsUnc(FlatBufferBuilder builder, int zeroPointsUncOffset) { builder.addOffset(14, zeroPointsUncOffset, 0); }
  public static int createZeroPointsUncVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startZeroPointsUncVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addExtinctionCoeffs(FlatBufferBuilder builder, int extinctionCoeffsOffset) { builder.addOffset(15, extinctionCoeffsOffset, 0); }
  public static int createExtinctionCoeffsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startExtinctionCoeffsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addExtinctionCoeffsUnc(FlatBufferBuilder builder, int extinctionCoeffsUncOffset) { builder.addOffset(16, extinctionCoeffsUncOffset, 0); }
  public static int createExtinctionCoeffsUncVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startExtinctionCoeffsUncVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addColorCoeffs(FlatBufferBuilder builder, int colorCoeffsOffset) { builder.addOffset(17, colorCoeffsOffset, 0); }
  public static int createColorCoeffsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startColorCoeffsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addNumNeutralDensityFilters(FlatBufferBuilder builder, int numNeutralDensityFilters) { builder.addInt(18, numNeutralDensityFilters, 0); }
  public static void addNeutralDensityFilterNames(FlatBufferBuilder builder, int neutralDensityFilterNamesOffset) { builder.addOffset(19, neutralDensityFilterNamesOffset, 0); }
  public static int createNeutralDensityFilterNamesVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startNeutralDensityFilterNamesVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addNeutralDensityFilterTransmissions(FlatBufferBuilder builder, int neutralDensityFilterTransmissionsOffset) { builder.addOffset(20, neutralDensityFilterTransmissionsOffset, 0); }
  public static int createNeutralDensityFilterTransmissionsVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startNeutralDensityFilterTransmissionsVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addNeutralDensityFilterTransmissionsUnc(FlatBufferBuilder builder, int neutralDensityFilterTransmissionsUncOffset) { builder.addOffset(21, neutralDensityFilterTransmissionsUncOffset, 0); }
  public static int createNeutralDensityFilterTransmissionsUncVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startNeutralDensityFilterTransmissionsUncVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addGain(FlatBufferBuilder builder, double gain) { builder.addDouble(22, gain, 0.0); }
  public static void addIfov(FlatBufferBuilder builder, double ifov) { builder.addDouble(23, ifov, 0.0); }
  public static void addPixelArrayWidth(FlatBufferBuilder builder, int pixelArrayWidth) { builder.addInt(24, pixelArrayWidth, 0); }
  public static void addPixelArrayHeight(FlatBufferBuilder builder, int pixelArrayHeight) { builder.addInt(25, pixelArrayHeight, 0); }
  public static void addPixelMin(FlatBufferBuilder builder, int pixelMin) { builder.addInt(26, pixelMin, 0); }
  public static void addPixelMax(FlatBufferBuilder builder, int pixelMax) { builder.addInt(27, pixelMax, 0); }
  public static void addCentroidRow(FlatBufferBuilder builder, double centroidRow) { builder.addDouble(28, centroidRow, 0.0); }
  public static void addCentroidColumn(FlatBufferBuilder builder, double centroidColumn) { builder.addDouble(29, centroidColumn, 0.0); }
  public static void addRowVariance(FlatBufferBuilder builder, double rowVariance) { builder.addDouble(30, rowVariance, 0.0); }
  public static void addColumnVariance(FlatBufferBuilder builder, double columnVariance) { builder.addDouble(31, columnVariance, 0.0); }
  public static void addRowColCov(FlatBufferBuilder builder, double rowColCov) { builder.addDouble(32, rowColCov, 0.0); }
  public static void addDistFromStreakCenter(FlatBufferBuilder builder, int distFromStreakCenterOffset) { builder.addOffset(33, distFromStreakCenterOffset, 0); }
  public static int createDistFromStreakCenterVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startDistFromStreakCenterVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSurfBrightness(FlatBufferBuilder builder, int surfBrightnessOffset) { builder.addOffset(34, surfBrightnessOffset, 0); }
  public static int createSurfBrightnessVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSurfBrightnessVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addSurfBrightnessUnc(FlatBufferBuilder builder, int surfBrightnessUncOffset) { builder.addOffset(35, surfBrightnessUncOffset, 0); }
  public static int createSurfBrightnessUncVector(FlatBufferBuilder builder, int[] data) { builder.startVector(4, data.length, 4); for (int i = data.length - 1; i >= 0; i--) builder.addOffset(data[i]); return builder.endVector(); }
  public static void startSurfBrightnessUncVector(FlatBufferBuilder builder, int numElems) { builder.startVector(4, numElems, 4); }
  public static void addTimesUnc(FlatBufferBuilder builder, double timesUnc) { builder.addDouble(36, timesUnc, 0.0); }
  public static void addCcdTemp(FlatBufferBuilder builder, double ccdTemp) { builder.addDouble(37, ccdTemp, 0.0); }
  public static void addCurrentSpectralFilterNum(FlatBufferBuilder builder, int currentSpectralFilterNum) { builder.addInt(38, currentSpectralFilterNum, 0); }
  public static void addCurrentNeutralDensityFilterNum(FlatBufferBuilder builder, int currentNeutralDensityFilterNum) { builder.addInt(39, currentNeutralDensityFilterNum, 0); }
  public static void addBinningHoriz(FlatBufferBuilder builder, int binningHoriz) { builder.addInt(40, binningHoriz, 0); }
  public static void addBinningVert(FlatBufferBuilder builder, int binningVert) { builder.addInt(41, binningVert, 0); }
  public static void addPcalNumStars(FlatBufferBuilder builder, int pcalNumStars) { builder.addInt(42, pcalNumStars, 0); }
  public static void addCcdObjPosX(FlatBufferBuilder builder, double ccdObjPosX) { builder.addDouble(43, ccdObjPosX, 0.0); }
  public static void addCcdObjPosY(FlatBufferBuilder builder, double ccdObjPosY) { builder.addDouble(44, ccdObjPosY, 0.0); }
  public static void addCcdObjWidth(FlatBufferBuilder builder, double ccdObjWidth) { builder.addDouble(45, ccdObjWidth, 0.0); }
  public static void addBackgroundSignal(FlatBufferBuilder builder, double backgroundSignal) { builder.addDouble(46, backgroundSignal, 0.0); }
  public static void addBackgroundSignalUnc(FlatBufferBuilder builder, double backgroundSignalUnc) { builder.addDouble(47, backgroundSignalUnc, 0.0); }
  public static void addPeakApertureCount(FlatBufferBuilder builder, double peakApertureCount) { builder.addDouble(48, peakApertureCount, 0.0); }
  public static void addPeakBackgroundCount(FlatBufferBuilder builder, int peakBackgroundCount) { builder.addInt(49, peakBackgroundCount, 0); }
  public static void addSnrEst(FlatBufferBuilder builder, double snrEst) { builder.addDouble(50, snrEst, 0.0); }
  public static void addMagInstrumental(FlatBufferBuilder builder, double magInstrumental) { builder.addDouble(51, magInstrumental, 0.0); }
  public static void addMagInstrumentalUnc(FlatBufferBuilder builder, double magInstrumentalUnc) { builder.addDouble(52, magInstrumentalUnc, 0.0); }
  public static void addOpticalCrossSection(FlatBufferBuilder builder, double opticalCrossSection) { builder.addDouble(53, opticalCrossSection, 0.0); }
  public static void addOpticalCrossSectionUnc(FlatBufferBuilder builder, double opticalCrossSectionUnc) { builder.addDouble(54, opticalCrossSectionUnc, 0.0); }
  public static void addSunStatePosX(FlatBufferBuilder builder, double sunStatePosX) { builder.addDouble(55, sunStatePosX, 0.0); }
  public static void addSunStatePosY(FlatBufferBuilder builder, double sunStatePosY) { builder.addDouble(56, sunStatePosY, 0.0); }
  public static void addSunStatePosZ(FlatBufferBuilder builder, double sunStatePosZ) { builder.addDouble(57, sunStatePosZ, 0.0); }
  public static void addSunStateVelX(FlatBufferBuilder builder, double sunStateVelX) { builder.addDouble(58, sunStateVelX, 0.0); }
  public static void addSunStateVelY(FlatBufferBuilder builder, double sunStateVelY) { builder.addDouble(59, sunStateVelY, 0.0); }
  public static void addSunStateVelZ(FlatBufferBuilder builder, double sunStateVelZ) { builder.addDouble(60, sunStateVelZ, 0.0); }
  public static void addNumCatalogStars(FlatBufferBuilder builder, int numCatalogStars) { builder.addInt(61, numCatalogStars, 0); }
  public static void addNumDetectedStars(FlatBufferBuilder builder, int numDetectedStars) { builder.addInt(62, numDetectedStars, 0); }
  public static void addNumCorrelatedStars(FlatBufferBuilder builder, int numCorrelatedStars) { builder.addInt(63, numCorrelatedStars, 0); }
  public static void addPredictedRaUnc(FlatBufferBuilder builder, double predictedRaUnc) { builder.addDouble(64, predictedRaUnc, 0.0); }
  public static void addPredictedDeclinationUnc(FlatBufferBuilder builder, double predictedDeclinationUnc) { builder.addDouble(65, predictedDeclinationUnc, 0.0); }
  public static void addRaCov(FlatBufferBuilder builder, double raCov) { builder.addDouble(66, raCov, 0.0); }
  public static void addDeclinationCov(FlatBufferBuilder builder, double declinationCov) { builder.addDouble(67, declinationCov, 0.0); }
  public static void addRaDeclinationCov(FlatBufferBuilder builder, double raDeclinationCov) { builder.addDouble(68, raDeclinationCov, 0.0); }
  public static void addAcalCrPixX(FlatBufferBuilder builder, double acalCrPixX) { builder.addDouble(69, acalCrPixX, 0.0); }
  public static void addAcalCrPixY(FlatBufferBuilder builder, double acalCrPixY) { builder.addDouble(70, acalCrPixY, 0.0); }
  public static void addAcalCrValX(FlatBufferBuilder builder, double acalCrValX) { builder.addDouble(71, acalCrValX, 0.0); }
  public static void addAcalCrValY(FlatBufferBuilder builder, double acalCrValY) { builder.addDouble(72, acalCrValY, 0.0); }
  public static void addAcalNumStars(FlatBufferBuilder builder, int acalNumStars) { builder.addInt(73, acalNumStars, 0); }
  public static void addObjSunRange(FlatBufferBuilder builder, double objSunRange) { builder.addDouble(74, objSunRange, 0.0); }
  public static void addPhaseAngBisect(FlatBufferBuilder builder, double phaseAngBisect) { builder.addDouble(75, phaseAngBisect, 0.0); }
  public static void addSolarDiskFrac(FlatBufferBuilder builder, double solarDiskFrac) { builder.addDouble(76, solarDiskFrac, 0.0); }
  public static void addToes(FlatBufferBuilder builder, double toes) { builder.addDouble(77, toes, 0.0); }
  public static void addDoes(FlatBufferBuilder builder, double does) { builder.addDouble(78, does, 0.0); }
  public static void addSource(FlatBufferBuilder builder, int sourceOffset) { builder.addOffset(79, sourceOffset, 0); }
  public static void addDataMode(FlatBufferBuilder builder, byte dataMode) { builder.addByte(80, dataMode, 0); }
  public static void addCreatedAt(FlatBufferBuilder builder, int createdAtOffset) { builder.addOffset(81, createdAtOffset, 0); }
  public static void addCreatedBy(FlatBufferBuilder builder, int createdByOffset) { builder.addOffset(82, createdByOffset, 0); }
  public static int endEOObservationDetails_Full(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }
  public static void finishEOObservationDetails_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finish(offset, "EOOB"); }
  public static void finishSizePrefixedEOObservationDetails_FullBuffer(FlatBufferBuilder builder, int offset) { builder.finishSizePrefixed(offset, "EOOB"); }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public EOObservationDetails_Full get(int j) { return get(new EOObservationDetails_Full(), j); }
    public EOObservationDetails_Full get(EOObservationDetails_Full obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

