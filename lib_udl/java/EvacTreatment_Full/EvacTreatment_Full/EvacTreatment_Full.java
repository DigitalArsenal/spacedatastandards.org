// automatically generated by the FlatBuffers compiler, do not modify

package EvacTreatment_Full;

import com.google.flatbuffers.BaseVector;
import com.google.flatbuffers.BooleanVector;
import com.google.flatbuffers.ByteVector;
import com.google.flatbuffers.Constants;
import com.google.flatbuffers.DoubleVector;
import com.google.flatbuffers.FlatBufferBuilder;
import com.google.flatbuffers.FloatVector;
import com.google.flatbuffers.IntVector;
import com.google.flatbuffers.LongVector;
import com.google.flatbuffers.ShortVector;
import com.google.flatbuffers.StringVector;
import com.google.flatbuffers.Struct;
import com.google.flatbuffers.Table;
import com.google.flatbuffers.UnionVector;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;

/**
 * Treatment information.
 */
@SuppressWarnings("unused")
public final class EvacTreatment_Full extends Table {
  public static void ValidateVersion() { Constants.FLATBUFFERS_24_3_25(); }
  public static EvacTreatment_Full getRootAsEvacTreatment_Full(ByteBuffer _bb) { return getRootAsEvacTreatment_Full(_bb, new EvacTreatment_Full()); }
  public static EvacTreatment_Full getRootAsEvacTreatment_Full(ByteBuffer _bb, EvacTreatment_Full obj) { _bb.order(ByteOrder.LITTLE_ENDIAN); return (obj.__assign(_bb.getInt(_bb.position()) + _bb.position(), _bb)); }
  public void __init(int _i, ByteBuffer _bb) { __reset(_i, _bb); }
  public EvacTreatment_Full __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }

  /**
   * Type of treatment administered or to be administered.  Intended as, but not constrained to, K07.1 Treatment Type Enumeration (e.g. AIRWAY ADJUNCT, AIRWAY ASSISTED VENTILATION, AIRWAY COMBI TUBE USED, AIRWAY ET NT, AIRWAY INTUBATED, AIRWAY NPA OPA APPLIED, AIRWAY PATIENT, AIRWAY POSITIONAL, AIRWAY SURGICAL CRIC, BREATHING CHEST SEAL, BREATHING CHEST TUBE, etc.).
   * Example: BREATHING CHEST TUBE
   * Constraints: Minimum length = 0, Maximum length = 64
   */
  public String type() { int o = __offset(4); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer typeAsByteBuffer() { return __vector_as_bytebuffer(4, 1); }
  public ByteBuffer typeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 4, 1); }
  /**
   * Body part location or body part treated or to be treated.  Intended as, but not constrained to, K07.1 Body Location Enumeration (e.g. ANKLE LEFT BACK, ANKLE LEFT FRONT, ANKLE RIGHT BACK, ANKLE RIGHT FRONT, ARM LEFT BACK, ARM LEFT ELBOW BACK, ARM LEFT ELBOW FRONT, ARM LEFT FRONT, ARM LEFT LOWER BACK, etc.).
   * Example: CHEST
   * Constraints: Minimum length = 0, Maximum length = 32
   */
  public String bodyPart() { int o = __offset(6); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer bodyPartAsByteBuffer() { return __vector_as_bytebuffer(6, 1); }
  public ByteBuffer bodyPartInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 6, 1); }
  /**
   * Datetime of the treatment in ISO 8601 UTC format.
   * Example: 2018-01-01T16:00:00.123Z
   * Constraints: No constraints specified.
   */
  public String time() { int o = __offset(8); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer timeAsByteBuffer() { return __vector_as_bytebuffer(8, 1); }
  public ByteBuffer timeInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 8, 1); }
  /**
   * Additional comments on the patient's treatment information.
   * Example: Comments on the treatment info.
   * Constraints: Minimum length = 0, Maximum length = 1024
   */
  public String comments() { int o = __offset(10); return o != 0 ? __string(o + bb_pos) : null; }
  public ByteBuffer commentsAsByteBuffer() { return __vector_as_bytebuffer(10, 1); }
  public ByteBuffer commentsInByteBuffer(ByteBuffer _bb) { return __vector_in_bytebuffer(_bb, 10, 1); }

  public static int createEvacTreatment_Full(FlatBufferBuilder builder,
      int typeOffset,
      int bodyPartOffset,
      int timeOffset,
      int commentsOffset) {
    builder.startTable(4);
    EvacTreatment_Full.addComments(builder, commentsOffset);
    EvacTreatment_Full.addTime(builder, timeOffset);
    EvacTreatment_Full.addBodyPart(builder, bodyPartOffset);
    EvacTreatment_Full.addType(builder, typeOffset);
    return EvacTreatment_Full.endEvacTreatment_Full(builder);
  }

  public static void startEvacTreatment_Full(FlatBufferBuilder builder) { builder.startTable(4); }
  public static void addType(FlatBufferBuilder builder, int typeOffset) { builder.addOffset(0, typeOffset, 0); }
  public static void addBodyPart(FlatBufferBuilder builder, int bodyPartOffset) { builder.addOffset(1, bodyPartOffset, 0); }
  public static void addTime(FlatBufferBuilder builder, int timeOffset) { builder.addOffset(2, timeOffset, 0); }
  public static void addComments(FlatBufferBuilder builder, int commentsOffset) { builder.addOffset(3, commentsOffset, 0); }
  public static int endEvacTreatment_Full(FlatBufferBuilder builder) {
    int o = builder.endTable();
    return o;
  }

  public static final class Vector extends BaseVector {
    public Vector __assign(int _vector, int _element_size, ByteBuffer _bb) { __reset(_vector, _element_size, _bb); return this; }

    public EvacTreatment_Full get(int j) { return get(new EvacTreatment_Full(), j); }
    public EvacTreatment_Full get(EvacTreatment_Full obj, int j) {  return obj.__assign(__indirect(__element(j), bb), bb); }
  }
}

